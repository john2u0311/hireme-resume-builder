{"ast":null,"code":"import * as P from '@react-pdf/primitives';\nimport { isNil, matchPercent } from '@react-pdf/fns';\nimport absPath from 'abs-svg-path';\nimport parsePath from 'parse-svg-path';\nimport normalizePath from 'normalize-svg-path';\nimport colorString from 'color-string';\nconst renderPath = (ctx, node) => {\n  const d = node.props?.d;\n  if (d) ctx.path(node.props.d);\n};\nconst KAPPA$3 = 4.0 * ((Math.sqrt(2) - 1.0) / 3.0);\nconst renderRect = (ctx, node) => {\n  const x = node.props?.x || 0;\n  const y = node.props?.y || 0;\n  const rx = node.props?.rx || 0;\n  const ry = node.props?.ry || 0;\n  const width = node.props?.width || 0;\n  const height = node.props?.height || 0;\n  if (!width || !height) return;\n  if (rx && ry) {\n    const krx = rx * KAPPA$3;\n    const kry = ry * KAPPA$3;\n    ctx.moveTo(x + rx, y);\n    ctx.lineTo(x - rx + width, y);\n    ctx.bezierCurveTo(x - rx + width + krx, y, x + width, y + ry - kry, x + width, y + ry);\n    ctx.lineTo(x + width, y + height - ry);\n    ctx.bezierCurveTo(x + width, y + height - ry + kry, x - rx + width + krx, y + height, x - rx + width, y + height);\n    ctx.lineTo(x + rx, y + height);\n    ctx.bezierCurveTo(x + rx - krx, y + height, x, y + height - ry + kry, x, y + height - ry);\n    ctx.lineTo(x, y + ry);\n    ctx.bezierCurveTo(x, y + ry - kry, x + rx - krx, y, x + rx, y);\n  } else {\n    ctx.moveTo(x, y);\n    ctx.lineTo(x + width, y);\n    ctx.lineTo(x + width, y + height);\n    ctx.lineTo(x, y + height);\n  }\n  ctx.closePath();\n};\nconst renderLine$1 = (ctx, node) => {\n  const {\n    x1,\n    x2,\n    y1,\n    y2\n  } = node.props || {};\n  ctx.moveTo(x1, y1);\n  ctx.lineTo(x2, y2);\n};\nconst renderGroup = () => {\n  // noop\n};\nconst KAPPA$2 = 4.0 * ((Math.sqrt(2) - 1.0) / 3.0);\nconst drawEllipse = function (ctx, rx, ry) {\n  let cx = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;\n  let cy = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 0;\n  const x = cx - rx;\n  const y = cy - ry;\n  const ox = rx * KAPPA$2;\n  const oy = ry * KAPPA$2;\n  const xe = x + rx * 2;\n  const ye = y + ry * 2;\n  const xm = x + rx;\n  const ym = y + ry;\n  ctx.moveTo(x, ym);\n  ctx.bezierCurveTo(x, ym - oy, xm - ox, y, xm, y);\n  ctx.bezierCurveTo(xm + ox, y, xe, ym - oy, xe, ym);\n  ctx.bezierCurveTo(xe, ym + oy, xm + ox, ye, xm, ye);\n  ctx.bezierCurveTo(xm - ox, ye, x, ym + oy, x, ym);\n  ctx.closePath();\n};\nconst renderEllipse = (ctx, node) => {\n  const {\n    cx,\n    cy,\n    rx,\n    ry\n  } = node.props || {};\n  drawEllipse(ctx, rx, ry, cx, cy);\n};\nconst renderCircle = (ctx, node) => {\n  const cx = node.props?.cx;\n  const cy = node.props?.cy;\n  const r = node.props?.r;\n  drawEllipse(ctx, r, r, cx, cy);\n};\n\n/* eslint-disable no-return-assign */\nconst number = n => {\n  if (n > -1e21 && n < 1e21) {\n    return Math.round(n * 1e6) / 1e6;\n  }\n  throw new Error(`unsupported number: ${n}`);\n};\nconst _renderGlyphs = (ctx, encoded, positions, x, y) => {\n  const commands = [];\n  const scale = ctx._fontSize / 1000;\n  let i;\n  let last = 0;\n  let hadOffset = false;\n  ctx.save();\n  // flip coordinate system\n  ctx.transform(1, 0, 0, -1, 0, ctx.page.height);\n  y = ctx.page.height - y;\n  // add current font to page if necessary\n  if (ctx.page.fonts[ctx._font.id] == null) {\n    ctx.page.fonts[ctx._font.id] = ctx._font.ref();\n  }\n  // begin the text object\n  ctx.addContent('BT');\n  // text position\n  ctx.addContent(`1 0 0 1 ${number(x)} ${number(y)} Tm`);\n  // font and font size\n  ctx.addContent(`/${ctx._font.id} ${number(ctx._fontSize)} Tf`);\n  // Adds a segment of text to the TJ command buffer\n  const addSegment = cur => {\n    if (last < cur) {\n      const hex = encoded.slice(last, cur).join('');\n      const advance = positions[cur - 1].xAdvance - positions[cur - 1].advanceWidth;\n      commands.push(`<${hex}> ${number(-advance)}`);\n    }\n    return last = cur;\n  };\n  // Flushes the current TJ commands to the output stream\n  const flush = s => {\n    addSegment(s);\n    if (commands.length > 0) {\n      ctx.addContent(`[${commands.join(' ')}] TJ`);\n      return commands.length = 0;\n    }\n  };\n  for (i = 0; i < positions.length; i += 1) {\n    // If we have an x or y offset, we have to break out of the current TJ command\n    // so we can move the text position.\n    const pos = positions[i];\n    if (pos.xOffset || pos.yOffset) {\n      // Flush the current buffer\n      flush(i);\n      // Move the text position and flush just the current character\n      ctx.addContent(`1 0 0 1 ${number(x + pos.xOffset * scale)} ${number(y + pos.yOffset * scale)} Tm`);\n      flush(i + 1);\n      hadOffset = true;\n    } else {\n      // If the last character had an offset, reset the text position\n      if (hadOffset) {\n        ctx.addContent(`1 0 0 1 ${number(x)} ${number(y)} Tm`);\n        hadOffset = false;\n      }\n      // Group segments that don't have any advance adjustments\n      if (pos.xAdvance - pos.advanceWidth !== 0) {\n        addSegment(i + 1);\n      }\n    }\n    x += pos.xAdvance * scale;\n  }\n  // Flush any remaining commands\n  flush(i);\n  // end the text object\n  ctx.addContent('ET');\n  // restore flipped coordinate system\n  return ctx.restore();\n};\nconst renderGlyphs = (ctx, glyphs, positions, x, y) => {\n  const scale = 1000 / ctx._fontSize;\n  const unitsPerEm = ctx._font.font.unitsPerEm || 1000;\n  const advanceWidthScale = 1000 / unitsPerEm;\n  // Glyph encoding and positioning\n  const encodedGlyphs = ctx._font.encodeGlyphs(glyphs);\n  const encodedPositions = positions.map((pos, i) => ({\n    xAdvance: pos.xAdvance * scale,\n    yAdvance: pos.yAdvance * scale,\n    xOffset: pos.xOffset,\n    yOffset: pos.yOffset,\n    advanceWidth: glyphs[i].advanceWidth * advanceWidthScale\n  }));\n  return _renderGlyphs(ctx, encodedGlyphs, encodedPositions, x, y);\n};\nconst renderRun$1 = (ctx, run) => {\n  if (!run.glyphs) return;\n  if (!run.positions) return;\n  const runAdvanceWidth = run.xAdvance;\n  const font = run.attributes.font?.[0];\n  const {\n    fontSize,\n    color,\n    opacity\n  } = run.attributes;\n  if (color) ctx.fillColor(color);\n  ctx.fillOpacity(opacity);\n  if (font) {\n    ctx.font(font.type === 'STANDARD' ? font.fullName : font, fontSize);\n  }\n  try {\n    renderGlyphs(ctx, run.glyphs, run.positions, 0, 0);\n  } catch (error) {\n    console.log(error);\n  }\n  ctx.translate(runAdvanceWidth, 0);\n};\nconst renderSpan = (ctx, line, textAnchor, dominantBaseline) => {\n  ctx.save();\n  const x = line.box?.x || 0;\n  const y = line.box?.y || 0;\n  const font = line.runs[0]?.attributes.font?.[0];\n  const scale = line.runs[0]?.attributes?.scale || 1;\n  const width = line.xAdvance;\n  if (!font) return;\n  const ascent = font.ascent * scale;\n  const xHeight = font.xHeight * scale;\n  const descent = font.descent * scale;\n  const capHeight = font.capHeight * scale;\n  let xTranslate = x;\n  let yTranslate = y;\n  switch (textAnchor) {\n    case 'middle':\n      xTranslate = x - width / 2;\n      break;\n    case 'end':\n      xTranslate = x - width;\n      break;\n    default:\n      xTranslate = x;\n      break;\n  }\n  switch (dominantBaseline) {\n    case 'middle':\n    case 'central':\n      yTranslate = y + capHeight / 2;\n      break;\n    case 'hanging':\n      yTranslate = y + capHeight;\n      break;\n    case 'mathematical':\n      yTranslate = y + xHeight;\n      break;\n    case 'text-after-edge':\n      yTranslate = y + descent;\n      break;\n    case 'text-before-edge':\n      yTranslate = y + ascent;\n      break;\n    default:\n      yTranslate = y;\n      break;\n  }\n  ctx.translate(xTranslate, yTranslate);\n  line.runs.forEach(run => renderRun$1(ctx, run));\n  ctx.restore();\n};\nconst renderSvgText = (ctx, node) => {\n  const children = node.children;\n  children.forEach(span => renderSpan(ctx, span.lines[0], span.props.textAnchor, span.props.dominantBaseline));\n};\nconst pairs = values => {\n  const result = [];\n  for (let i = 0; i < values.length; i += 2) {\n    result.push([values[i], values[i + 1]]);\n  }\n  return result;\n};\n/**\n * Parse svg-like points into number arrays\n *\n * @param points string ex. \"20,30 50,60\"\n * @returns points array ex. [[20, 30], [50, 60]]\n */\nconst parsePoints = points => {\n  let values = (points || '').trim().replace(/,/g, ' ').replace(/(\\d)-(\\d)/g, '$1 -$2').split(/\\s+/);\n  if (values.length % 2 !== 0) {\n    values = values.slice(0, -1);\n  }\n  const mappedValues = values.map(parseFloat);\n  return pairs(mappedValues);\n};\nconst drawPolyline = (ctx, points) => {\n  if (points.length > 0) {\n    ctx.moveTo(points[0][0], points[0][1]);\n    points.slice(1).forEach(p => ctx.lineTo(p[0], p[1]));\n  }\n};\nconst renderPolyline = (ctx, node) => {\n  const points = parsePoints(node.props.points || '');\n  drawPolyline(ctx, points);\n};\nconst renderPolygon = (ctx, node) => {\n  const points = parsePoints(node.props.points || '');\n  drawPolyline(ctx, points);\n  ctx.closePath();\n};\nconst renderImage$1 = (ctx, node) => {\n  if (!node.box) return;\n  if (!node.image?.data) return;\n  const {\n    x = 0,\n    y = 0\n  } = node.props;\n  const {\n    width,\n    height,\n    opacity\n  } = node.style;\n  const paddingTop = node.box.paddingLeft || 0;\n  const paddingLeft = node.box.paddingLeft || 0;\n  if (width === 0 || height === 0) {\n    console.warn(`Image with src '${node.props.href}' skipped due to invalid dimensions`);\n    return;\n  }\n  if (typeof width === 'string' || typeof height === 'string') {\n    console.warn(`Image with src '${node.props.href}' skipped due to percentage width or height`);\n    return;\n  }\n  ctx.save();\n  ctx.fillOpacity(opacity || 1).image(node.image.data, x + paddingLeft, y + paddingTop, {\n    width,\n    height\n  });\n  ctx.restore();\n};\n\n// This constant is used to approximate a symmetrical arc using a cubic\n// Bezier curve.\nconst KAPPA$1 = 4.0 * ((Math.sqrt(2) - 1.0) / 3.0);\nconst clipNode = (ctx, node) => {\n  if (!node.box) return;\n  if (!node.style) return;\n  const {\n    top,\n    left,\n    width,\n    height\n  } = node.box;\n  const {\n    borderTopLeftRadius = 0,\n    borderTopRightRadius = 0,\n    borderBottomRightRadius = 0,\n    borderBottomLeftRadius = 0\n  } = node.style;\n  // Border top\n  // @ts-expect-error this is always a number due to resolve border radius step\n  const rtr = Math.min(borderTopRightRadius, 0.5 * width, 0.5 * height);\n  const ctr = rtr * (1.0 - KAPPA$1);\n  ctx.moveTo(left + rtr, top);\n  ctx.lineTo(left + width - rtr, top);\n  ctx.bezierCurveTo(left + width - ctr, top, left + width, top + ctr, left + width, top + rtr);\n  // Border right\n  // @ts-expect-error this is always a number due to resolve border radius step\n  const rbr = Math.min(borderBottomRightRadius, 0.5 * width, 0.5 * height);\n  const cbr = rbr * (1.0 - KAPPA$1);\n  ctx.lineTo(left + width, top + height - rbr);\n  ctx.bezierCurveTo(left + width, top + height - cbr, left + width - cbr, top + height, left + width - rbr, top + height);\n  // Border bottom\n  // @ts-expect-error this is always a number due to resolve border radius step\n  const rbl = Math.min(borderBottomLeftRadius, 0.5 * width, 0.5 * height);\n  const cbl = rbl * (1.0 - KAPPA$1);\n  ctx.lineTo(left + rbl, top + height);\n  ctx.bezierCurveTo(left + cbl, top + height, left, top + height - cbl, left, top + height - rbl);\n  // Border left\n  // @ts-expect-error this is always a number due to resolve border radius step\n  const rtl = Math.min(borderTopLeftRadius, 0.5 * width, 0.5 * height);\n  const ctl = rtl * (1.0 - KAPPA$1);\n  ctx.lineTo(left, top + rtl);\n  ctx.bezierCurveTo(left, top + ctl, left + ctl, top, left + rtl, top);\n  ctx.closePath();\n  ctx.clip();\n};\nconst applySingleTransformation = (ctx, transform, origin) => {\n  const {\n    operation,\n    value\n  } = transform;\n  switch (operation) {\n    case 'scale':\n      {\n        const [scaleX, scaleY] = value;\n        ctx.scale(scaleX, scaleY, {\n          origin\n        });\n        break;\n      }\n    case 'rotate':\n      {\n        const [angle] = value;\n        ctx.rotate(angle, {\n          origin\n        });\n        break;\n      }\n    case 'translate':\n      {\n        const [x, y = 0] = value;\n        ctx.translate(x, y, {\n          origin\n        });\n        break;\n      }\n    case 'skew':\n      {\n        const [xAngle = 0, yAngle = 0] = value;\n        const radx = xAngle * Math.PI / 180;\n        const rady = yAngle * Math.PI / 180;\n        const tanx = Math.tan(radx);\n        const tany = Math.tan(rady);\n        let x = 0;\n        let y = 0;\n        if (origin != null) {\n          [x, y] = Array.from(origin);\n          const x1 = x + tanx * y;\n          const y1 = y + tany * x;\n          x -= x1;\n          y -= y1;\n        }\n        ctx.transform(1, tany, tanx, 1, x, y);\n        break;\n      }\n    case 'matrix':\n      {\n        ctx.transform(...value);\n        break;\n      }\n    default:\n      {\n        console.error(`Transform operation: '${operation}' doesn't supported`);\n      }\n  }\n};\nconst applyTransformations = (ctx, node) => {\n  if (!node.origin) return;\n  const {\n    props,\n    style\n  } = node;\n  const origin = [node.origin.left, node.origin.top];\n  const propsTransform = 'transform' in props ? props.transform : undefined;\n  const operations = style?.transform || propsTransform || [];\n  operations.forEach(operation => {\n    applySingleTransformation(ctx, operation, origin);\n  });\n};\n\n// From https://github.com/dy/svg-path-bounds/blob/master/index.js\nconst getPathBoundingBox = node => {\n  const path = normalizePath(absPath(parsePath(node.props?.d || '')));\n  if (!path.length) return [0, 0, 0, 0];\n  const bounds = [Infinity, Infinity, -Infinity, -Infinity];\n  for (let i = 0, l = path.length; i < l; i += 1) {\n    const points = path[i].slice(1);\n    for (let j = 0; j < points.length; j += 2) {\n      if (points[j + 0] < bounds[0]) bounds[0] = points[j + 0];\n      if (points[j + 1] < bounds[1]) bounds[1] = points[j + 1];\n      if (points[j + 0] > bounds[2]) bounds[2] = points[j + 0];\n      if (points[j + 1] > bounds[3]) bounds[3] = points[j + 1];\n    }\n  }\n  return bounds;\n};\nconst getCircleBoundingBox = node => {\n  const r = node.props?.r || 0;\n  const cx = node.props?.cx || 0;\n  const cy = node.props?.cy || 0;\n  return [cx - r, cy - r, cx + r, cy + r];\n};\nconst getEllipseBoundingBox = node => {\n  const cx = node.props?.cx || 0;\n  const cy = node.props?.cy || 0;\n  const rx = node.props?.rx || 0;\n  const ry = node.props?.ry || 0;\n  return [cx - rx, cy - ry, cx + rx, cy + ry];\n};\nconst getLineBoundingBox = node => {\n  const x1 = node.props?.x1 || 0;\n  const y1 = node.props?.y1 || 0;\n  const x2 = node.props?.x2 || 0;\n  const y2 = node.props?.y2 || 0;\n  return [Math.min(x1, x2), Math.min(y1, y2), Math.max(x1, x2), Math.max(y1, y2)];\n};\nconst getRectBoundingBox = node => {\n  const x = node.props?.x || 0;\n  const y = node.props?.y || 0;\n  const width = node.props?.width || 0;\n  const height = node.props?.height || 0;\n  return [x, y, x + width, y + height];\n};\nconst max = values => Math.max(-Infinity, ...values);\nconst min = values => Math.min(Infinity, ...values);\nconst getPolylineBoundingBox = node => {\n  const points = parsePoints(node.props?.points);\n  const xValues = points.map(p => p[0]);\n  const yValues = points.map(p => p[1]);\n  return [min(xValues), min(yValues), max(xValues), max(yValues)];\n};\nconst boundingBoxFns = {\n  [P.Rect]: getRectBoundingBox,\n  [P.Line]: getLineBoundingBox,\n  [P.Path]: getPathBoundingBox,\n  [P.Circle]: getCircleBoundingBox,\n  [P.Ellipse]: getEllipseBoundingBox,\n  [P.Polygon]: getPolylineBoundingBox,\n  [P.Polyline]: getPolylineBoundingBox\n};\nconst getBoundingBox = node => {\n  const boundingBoxFn = boundingBoxFns[node.type];\n  return boundingBoxFn ? boundingBoxFn(node) : [0, 0, 0, 0];\n};\nconst setStrokeWidth = (ctx, node) => {\n  if (!node.props) return;\n  if (!('strokeWidth' in node.props)) return;\n  const lineWidth = node.props.strokeWidth;\n  if (lineWidth) ctx.lineWidth(lineWidth);\n};\nconst setStrokeColor = (ctx, node) => {\n  if (!node.props) return;\n  if (!('stroke' in node.props)) return;\n  const strokeColor = node.props.stroke;\n  if (strokeColor) ctx.strokeColor(strokeColor);\n};\nconst setOpacity = (ctx, node) => {\n  if (!node.props) return;\n  if (!('opacity' in node.props)) return;\n  const opacity = node.props.opacity;\n  if (!isNil(opacity)) ctx.opacity(opacity);\n};\nconst setFillOpacity = (ctx, node) => {\n  if (!node.props) return;\n  if (!('fillOpacity' in node.props)) return;\n  const fillOpacity = node.props.fillOpacity || null;\n  if (!isNil(fillOpacity)) ctx.fillOpacity(fillOpacity);\n};\nconst setStrokeOpacity = (ctx, node) => {\n  if (!node.props) return;\n  if (!('strokeOpacity' in node.props)) return;\n  const strokeOpacity = node.props?.strokeOpacity;\n  if (!isNil(strokeOpacity)) ctx.strokeOpacity(strokeOpacity);\n};\nconst setLineJoin = (ctx, node) => {\n  if (!node.props) return;\n  if (!('strokeLinejoin' in node.props)) return;\n  const lineJoin = node.props.strokeLinejoin;\n  if (lineJoin) ctx.lineJoin(lineJoin);\n};\nconst setLineCap = (ctx, node) => {\n  if (!node.props) return;\n  if (!('strokeLinecap' in node.props)) return;\n  const lineCap = node.props?.strokeLinecap;\n  if (lineCap) ctx.lineCap(lineCap);\n};\nconst setLineDash = (ctx, node) => {\n  if (!node.props) return;\n  if (!('strokeDasharray' in node.props)) return;\n  const value = node.props?.strokeDasharray || null;\n  // @ts-expect-error check this works as expected\n  if (value) ctx.dash(value.split(/[\\s,]+/).map(Number));\n};\nconst hasLinearGradientFill = node => {\n  if (!node.props) return false;\n  if (!('fill' in node.props)) return false;\n  if (typeof node.props.fill === 'string') return false;\n  return node.props.fill?.type === P.LinearGradient;\n};\nconst hasRadialGradientFill = node => {\n  if (!node.props) return false;\n  if (!('fill' in node.props)) return false;\n  if (typeof node.props.fill === 'string') return false;\n  return node.props.fill?.type === P.RadialGradient;\n};\nfunction multiplyMatrices(m1, m2) {\n  const a = m1[0] * m2[0] + m1[2] * m2[1];\n  const b = m1[1] * m2[0] + m1[3] * m2[1];\n  const c = m1[0] * m2[2] + m1[2] * m2[3];\n  const d = m1[1] * m2[2] + m1[3] * m2[3];\n  const e = m1[0] * m2[4] + m1[2] * m2[5] + m1[4];\n  const f = m1[1] * m2[4] + m1[3] * m2[5] + m1[5];\n  return [a, b, c, d, e, f];\n}\nconst transformGradient = (grad, transforms, bbox, units) => {\n  const matrices = transforms.map(transform => {\n    switch (transform.operation) {\n      case 'scale':\n        {\n          const value = transform.value;\n          return [value[0], 0, 0, value[1], 0, 0];\n        }\n      case 'translate':\n        {\n          const value = transform.value;\n          let x = value[0] || 0;\n          let y = value[1] || 0;\n          if (units === 'objectBoundingBox') {\n            x = (bbox[2] - bbox[0]) * x;\n            y = (bbox[3] - bbox[1]) * y;\n          }\n          return [1, 0, 0, 1, x, y];\n        }\n      case 'rotate':\n        {\n          const value = transform.value;\n          const cos = Math.cos(value[0]);\n          const sin = Math.sin(value[0]);\n          return [cos, sin, -sin, cos, 0, 0];\n        }\n      case 'skew':\n        {\n          const value = transform.value;\n          return [1, Math.tan(value[0]), Math.tan(value[1]), 1, 0, 0];\n        }\n      case 'matrix':\n        {\n          const value = transform.value;\n          let x = value[4] || 0;\n          let y = value[5] || 0;\n          if (units === 'objectBoundingBox') {\n            x = (bbox[2] - bbox[0]) * x;\n            y = (bbox[3] - bbox[1]) * y;\n          }\n          return [value[0], value[1], value[2], value[3], x, y];\n        }\n      default:\n        return [1, 0, 0, 1, 0, 0];\n    }\n  });\n  const matrix = matrices.reduce(multiplyMatrices, [1, 0, 0, 1, 0, 0]);\n  grad.setTransform(...matrix);\n};\n// Math simplified from https://github.com/devongovett/svgkit/blob/master/src/elements/SVGGradient.js#L104\nconst setLinearGradientFill = (ctx, node) => {\n  if (!node.props) return;\n  if (!('fill' in node.props)) return;\n  const bbox = getBoundingBox(node);\n  const gradient = node.props?.fill;\n  if (!gradient) return;\n  const units = gradient.props.gradientUnits || 'objectBoundingBox';\n  const transforms = gradient.props.gradientTransform || [];\n  let x1 = gradient.props.x1 || 0;\n  let y1 = gradient.props.y1 || 0;\n  let x2 = gradient.props.x2 || 1;\n  let y2 = gradient.props.y2 || 0;\n  if (units === 'objectBoundingBox') {\n    const m0 = bbox[2] - bbox[0];\n    const m3 = bbox[3] - bbox[1];\n    const m4 = bbox[0];\n    const m5 = bbox[1];\n    x1 = m0 * x1 + m4;\n    y1 = m3 * y1 + m5;\n    x2 = m0 * x2 + m4;\n    y2 = m3 * y2 + m5;\n  }\n  const grad = ctx.linearGradient(x1, y1, x2, y2);\n  transformGradient(grad, transforms, bbox, units);\n  gradient.children?.forEach(stop => {\n    grad.stop(stop.props.offset, stop.props.stopColor, stop.props.stopOpacity);\n  });\n  ctx.fill(grad);\n};\n// Math simplified from https://github.com/devongovett/svgkit/blob/master/src/elements/SVGGradient.js#L155\nconst setRadialGradientFill = (ctx, node) => {\n  if (!node.props) return;\n  if (!('fill' in node.props)) return;\n  const bbox = getBoundingBox(node);\n  const gradient = node.props?.fill;\n  if (!gradient) return;\n  const units = gradient.props.gradientUnits || 'objectBoundingBox';\n  const transforms = gradient.props.gradientTransform || [];\n  let r = gradient.props.r || 0.5;\n  let cx = gradient.props.cx || 0.5;\n  let cy = gradient.props.cy || 0.5;\n  let fx = gradient.props.fx || cx;\n  let fy = gradient.props.fy || cy;\n  if (units === 'objectBoundingBox') {\n    const m0 = bbox[2] - bbox[0];\n    const m3 = bbox[3] - bbox[1];\n    const m4 = bbox[0];\n    const m5 = bbox[1];\n    r = r * m0;\n    cx = m0 * cx + m4;\n    cy = m3 * cy + m5;\n    fx = m0 * fx + m4;\n    fy = m3 * fy + m5;\n  }\n  const grad = ctx.radialGradient(cx, cy, 0, fx, fy, r);\n  transformGradient(grad, transforms, bbox, units);\n  gradient.children?.forEach(stop => {\n    grad.stop(stop.props.offset, stop.props.stopColor, stop.props.stopOpacity);\n  });\n  ctx.fill(grad);\n};\nconst setFillColor = (ctx, node) => {\n  if (!node.props) return;\n  if (!('fill' in node.props)) return;\n  const fillColor = node.props?.fill;\n  if (fillColor) ctx.fillColor(fillColor);\n};\nconst setFill = (ctx, node) => {\n  if (hasLinearGradientFill(node)) return setLinearGradientFill(ctx, node);\n  if (hasRadialGradientFill(node)) return setRadialGradientFill(ctx, node);\n  return setFillColor(ctx, node);\n};\nconst draw = (ctx, node) => {\n  const props = node.props || {};\n  if ('fill' in props && 'stroke' in props && props.fill && props.stroke) {\n    ctx.fillAndStroke(props.fillRule);\n  } else if ('fill' in props && props.fill) {\n    ctx.fill(props.fillRule);\n  } else if ('stroke' in props && props.stroke) {\n    ctx.stroke();\n  } else {\n    ctx.save();\n    ctx.opacity(0);\n    ctx.fill(null);\n    ctx.restore();\n  }\n};\nconst noop = () => {};\nconst renderFns$1 = {\n  [P.Tspan]: noop,\n  [P.TextInstance]: noop,\n  [P.Path]: renderPath,\n  [P.Rect]: renderRect,\n  [P.Line]: renderLine$1,\n  [P.G]: renderGroup,\n  [P.Text]: renderSvgText,\n  [P.Circle]: renderCircle,\n  [P.Image]: renderImage$1,\n  [P.Ellipse]: renderEllipse,\n  [P.Polygon]: renderPolygon,\n  [P.Polyline]: renderPolyline\n};\nconst renderNode$1 = (ctx, node) => {\n  const renderFn = renderFns$1[node.type];\n  if (renderFn) {\n    renderFn(ctx, node);\n  } else {\n    console.warn(`SVG node of type ${node.type} is not currently supported`);\n  }\n};\nconst drawNode = (ctx, node) => {\n  setLineCap(ctx, node);\n  setLineDash(ctx, node);\n  setLineJoin(ctx, node);\n  setStrokeWidth(ctx, node);\n  setStrokeColor(ctx, node);\n  setFill(ctx, node);\n  setStrokeOpacity(ctx, node);\n  setFillOpacity(ctx, node);\n  setOpacity(ctx, node);\n  applyTransformations(ctx, node);\n  renderNode$1(ctx, node);\n  draw(ctx, node);\n};\nconst clipPath = (ctx, node) => {\n  if (!node.props) return;\n  if (!('clipPath' in node.props)) return;\n  const value = node.props.clipPath;\n  if (value) {\n    const children = value.children || [];\n    children.forEach(child => renderNode$1(ctx, child));\n    ctx.clip();\n  }\n};\nconst drawChildren = (ctx, node) => {\n  const children = node.children || [];\n  children.forEach(child => {\n    ctx.save();\n    clipPath(ctx, child);\n    drawNode(ctx, child);\n    drawChildren(ctx, child);\n    ctx.restore();\n  });\n};\nconst resolveAspectRatio = (ctx, node) => {\n  if (!node.box) return;\n  const {\n    width,\n    height\n  } = node.box;\n  const {\n    viewBox,\n    preserveAspectRatio\n  } = node.props;\n  const {\n    meetOrSlice = 'meet',\n    align = 'xMidYMid'\n  } = preserveAspectRatio || {};\n  if (viewBox == null || width == null || height == null) return;\n  const x = viewBox?.minX || 0;\n  const y = viewBox?.minY || 0;\n  const logicalWidth = viewBox?.maxX || width;\n  const logicalHeight = viewBox?.maxY || height;\n  const logicalRatio = logicalWidth / logicalHeight;\n  const physicalRatio = width / height;\n  const scaleX = width / logicalWidth;\n  const scaleY = height / logicalHeight;\n  if (align === 'none') {\n    ctx.scale(scaleX, scaleY);\n    ctx.translate(-x, -y);\n    return;\n  }\n  if (logicalRatio < physicalRatio && meetOrSlice === 'meet' || logicalRatio >= physicalRatio && meetOrSlice === 'slice') {\n    ctx.scale(scaleY, scaleY);\n    switch (align) {\n      case 'xMinYMin':\n      case 'xMinYMid':\n      case 'xMinYMax':\n        ctx.translate(-x, -y);\n        break;\n      case 'xMidYMin':\n      case 'xMidYMid':\n      case 'xMidYMax':\n        ctx.translate(-x - (logicalWidth - width * logicalHeight / height) / 2, -y);\n        break;\n      default:\n        ctx.translate(-x - (logicalWidth - width * logicalHeight / height), -y);\n    }\n  } else {\n    ctx.scale(scaleX, scaleX);\n    switch (align) {\n      case 'xMinYMin':\n      case 'xMidYMin':\n      case 'xMaxYMin':\n        ctx.translate(-x, -y);\n        break;\n      case 'xMinYMid':\n      case 'xMidYMid':\n      case 'xMaxYMid':\n        ctx.translate(-x, -y - (logicalHeight - height * logicalWidth / width) / 2);\n        break;\n      default:\n        ctx.translate(-x, -y - (logicalHeight - height * logicalWidth / width));\n    }\n  }\n};\nconst moveToOrigin = (ctx, node) => {\n  if (!node.box) return;\n  const {\n    top,\n    left\n  } = node.box;\n  const paddingLeft = node.box.paddingLeft || 0;\n  const paddingTop = node.box.paddingTop || 0;\n  ctx.translate(left + paddingLeft, top + paddingTop);\n};\nconst renderSvg = (ctx, node) => {\n  ctx.save();\n  clipNode(ctx, node);\n  moveToOrigin(ctx, node);\n  resolveAspectRatio(ctx, node);\n  drawChildren(ctx, node);\n  ctx.restore();\n};\nconst black = {\n  value: '#000',\n  opacity: 1\n};\n// TODO: parse to number[] in layout to avoid this step\nconst parseColor = hex => {\n  if (!hex) return black;\n  const parsed = colorString.get(hex);\n  if (!parsed) return black;\n  const value = colorString.to.hex(parsed.value.slice(0, 3));\n  const opacity = parsed.value[3];\n  return {\n    value,\n    opacity\n  };\n};\nconst DEST_REGEXP = /^#.+/;\nconst isSrcId$1 = src => src.match(DEST_REGEXP);\nconst renderAttachment = (ctx, attachment) => {\n  const {\n    xOffset = 0,\n    yOffset = 0,\n    width,\n    height,\n    image\n  } = attachment;\n  ctx.translate(-width + xOffset, -height + yOffset);\n  ctx.image(image, 0, 0, {\n    fit: [width, height],\n    align: 'center',\n    valign: 'bottom'\n  });\n};\nconst renderAttachments = (ctx, run) => {\n  if (!run.glyphs) return;\n  if (!run.positions) return;\n  const font = run.attributes.font?.[0];\n  if (!font) return;\n  ctx.save();\n  const space = font.glyphForCodePoint(0x20);\n  const objectReplacement = font.glyphForCodePoint(0xfffc);\n  let attachmentAdvance = 0;\n  for (let i = 0; i < run.glyphs.length; i += 1) {\n    const position = run.positions[i];\n    const glyph = run.glyphs[i];\n    attachmentAdvance += position.xAdvance || 0;\n    if (glyph.id === objectReplacement.id && run.attributes.attachment) {\n      ctx.translate(attachmentAdvance, position.yOffset || 0);\n      renderAttachment(ctx, run.attributes.attachment);\n      run.glyphs[i] = space;\n      attachmentAdvance = 0;\n    }\n  }\n  ctx.restore();\n};\nconst renderRun = (ctx, run) => {\n  if (!run.glyphs) return;\n  if (!run.positions) return;\n  const font = run.attributes.font?.[0];\n  if (!font) return;\n  const {\n    fontSize,\n    link\n  } = run.attributes;\n  const color = parseColor(run.attributes.color);\n  const opacity = isNil(run.attributes.opacity) ? color.opacity : run.attributes.opacity;\n  const {\n    height = 0,\n    descent = 0,\n    xAdvance = 0\n  } = run;\n  ctx.fillColor(color.value);\n  ctx.fillOpacity(opacity);\n  if (link) {\n    if (isSrcId$1(link)) {\n      ctx.goTo(0, -height - descent, xAdvance, height, link.slice(1));\n    } else {\n      ctx.link(0, -height - descent, xAdvance, height, link);\n    }\n  }\n  renderAttachments(ctx, run);\n  ctx.font(font.type === 'STANDARD' ? font.fullName : font, fontSize);\n  try {\n    renderGlyphs(ctx, run.glyphs, run.positions, 0, 0);\n  } catch (error) {\n    console.log(error);\n  }\n  ctx.translate(xAdvance, 0);\n};\nconst renderBackground$1 = (ctx, rect, backgroundColor) => {\n  const color = parseColor(backgroundColor);\n  ctx.save();\n  ctx.fillOpacity(color.opacity);\n  ctx.rect(rect.x, rect.y, rect.width, rect.height);\n  ctx.fill(color.value);\n  ctx.restore();\n};\nconst renderDecorationLine = (ctx, decorationLine) => {\n  ctx.save();\n  ctx.lineWidth(decorationLine.rect.height);\n  ctx.strokeOpacity(decorationLine.opacity);\n  if (/dashed/.test(decorationLine.style)) {\n    ctx.dash(3 * decorationLine.rect.height, {});\n  } else if (/dotted/.test(decorationLine.style)) {\n    ctx.dash(decorationLine.rect.height, {});\n  }\n  if (/wavy/.test(decorationLine.style)) {\n    const dist = Math.max(2, decorationLine.rect.height);\n    let step = 1.1 * dist;\n    const stepCount = Math.floor(decorationLine.rect.width / (2 * step));\n    // Adjust step to fill entire width\n    const remainingWidth = decorationLine.rect.width - stepCount * 2 * step;\n    const adjustment = remainingWidth / stepCount / 2;\n    step += adjustment;\n    const cp1y = decorationLine.rect.y + dist;\n    const cp2y = decorationLine.rect.y - dist;\n    let {\n      x\n    } = decorationLine.rect;\n    ctx.moveTo(decorationLine.rect.x, decorationLine.rect.y);\n    for (let i = 0; i < stepCount; i += 1) {\n      ctx.bezierCurveTo(x + step, cp1y, x + step, cp2y, x + 2 * step, decorationLine.rect.y);\n      x += 2 * step;\n    }\n  } else {\n    ctx.moveTo(decorationLine.rect.x, decorationLine.rect.y);\n    ctx.lineTo(decorationLine.rect.x + decorationLine.rect.width, decorationLine.rect.y);\n    if (/double/.test(decorationLine.style)) {\n      ctx.moveTo(decorationLine.rect.x, decorationLine.rect.y + decorationLine.rect.height * 2);\n      ctx.lineTo(decorationLine.rect.x + decorationLine.rect.width, decorationLine.rect.y + decorationLine.rect.height * 2);\n    }\n  }\n  ctx.stroke(decorationLine.color);\n  ctx.restore();\n};\nconst renderLine = (ctx, line) => {\n  if (!line.box) return;\n  const lineAscent = line.ascent || 0;\n  ctx.save();\n  ctx.translate(line.box.x, line.box.y + lineAscent);\n  for (let i = 0; i < line.runs.length; i += 1) {\n    const run = line.runs[i];\n    const isLastRun = i === line.runs.length - 1;\n    if (run.attributes.backgroundColor) {\n      const xAdvance = run.xAdvance ?? 0;\n      const overflowRight = isLastRun ? line.overflowRight ?? 0 : 0;\n      const backgroundRect = {\n        x: 0,\n        y: -lineAscent,\n        height: line.box.height,\n        width: xAdvance - overflowRight\n      };\n      renderBackground$1(ctx, backgroundRect, run.attributes.backgroundColor);\n    }\n    renderRun(ctx, run);\n  }\n  ctx.restore();\n  ctx.save();\n  ctx.translate(line.box.x, line.box.y);\n  if (line.decorationLines) {\n    for (let i = 0; i < line.decorationLines.length; i += 1) {\n      const decorationLine = line.decorationLines[i];\n      renderDecorationLine(ctx, decorationLine);\n    }\n  }\n  ctx.restore();\n};\nconst renderBlock = (ctx, block) => {\n  block.forEach(line => {\n    renderLine(ctx, line);\n  });\n};\nconst renderText = (ctx, node) => {\n  if (!node.box) return;\n  if (!node.lines) return;\n  const {\n    top,\n    left\n  } = node.box;\n  const blocks = [node.lines];\n  const paddingTop = node.box?.paddingTop || 0;\n  const paddingLeft = node.box?.paddingLeft || 0;\n  const initialY = node.lines[0] ? node.lines[0].box.y : 0;\n  const offsetX = node.alignOffset || 0;\n  ctx.save();\n  ctx.translate(left + paddingLeft - offsetX, top + paddingTop - initialY);\n  blocks.forEach(block => {\n    renderBlock(ctx, block);\n  });\n  ctx.restore();\n};\nconst renderPage = (ctx, node) => {\n  if (!node.box) return;\n  const {\n    width,\n    height\n  } = node.box;\n  const dpi = node.props?.dpi || 72;\n  const userUnit = dpi / 72;\n  ctx.addPage({\n    size: [width, height],\n    margin: 0,\n    userUnit\n  });\n};\nconst renderNote = (ctx, node) => {\n  if (!node.box) return;\n  const {\n    top,\n    left\n  } = node.box;\n  const value = node?.children?.[0].value || '';\n  const color = node.style?.backgroundColor;\n  ctx.note(left, top, 0, 0, value, {\n    color\n  });\n};\nconst embedImage = (ctx, node) => {\n  const src = node.image.data;\n  let image;\n  if (typeof src === 'string') {\n    image = ctx._imageRegistry[src];\n  }\n  if (!image) {\n    image = ctx.openImage(src);\n  }\n  if (!image.obj) {\n    image.embed(ctx);\n  }\n  return image;\n};\nconst isNumeric = n => {\n  return !Number.isNaN(parseFloat(n)) && Number.isFinite(n);\n};\nconst applyContainObjectFit = (cw, ch, iw, ih, px, py) => {\n  const cr = cw / ch;\n  const ir = iw / ih;\n  const pxp = matchPercent(px ?? null);\n  const pyp = matchPercent(py ?? null);\n  const pxv = pxp ? pxp.percent : 0.5;\n  const pyv = pyp ? pyp.percent : 0.5;\n  if (cr > ir) {\n    const height = ch;\n    const width = height * ir;\n    const yOffset = isNumeric(py) ? py : 0;\n    const xOffset = isNumeric(px) ? px : (cw - width) * pxv;\n    return {\n      width,\n      height,\n      xOffset,\n      yOffset\n    };\n  }\n  const width = cw;\n  const height = width / ir;\n  const xOffset = isNumeric(px) ? px : 0;\n  const yOffset = isNumeric(py) ? py : (ch - height) * pyv;\n  return {\n    width,\n    height,\n    yOffset,\n    xOffset\n  };\n};\nconst applyNoneObjectFit = (cw, ch, iw, ih, px, py) => {\n  const width = iw;\n  const height = ih;\n  const pxp = matchPercent(px ?? null);\n  const pyp = matchPercent(py ?? null);\n  const pxv = pxp ? pxp.percent : 0.5;\n  const pyv = pyp ? pyp.percent : 0.5;\n  const xOffset = isNumeric(px) ? px : (cw - width) * pxv;\n  const yOffset = isNumeric(py) ? py : (ch - height) * pyv;\n  return {\n    width,\n    height,\n    xOffset,\n    yOffset\n  };\n};\nconst applyCoverObjectFit = (cw, ch, iw, ih, px, py) => {\n  const ir = iw / ih;\n  const cr = cw / ch;\n  const pxp = matchPercent(px ?? null);\n  const pyp = matchPercent(py ?? null);\n  const pxv = pxp ? pxp.percent : 0.5;\n  const pyv = pyp ? pyp.percent : 0.5;\n  if (cr > ir) {\n    const width = cw;\n    const height = width / ir;\n    const xOffset = isNumeric(px) ? px : 0;\n    const yOffset = isNumeric(py) ? py : (ch - height) * pyv;\n    return {\n      width,\n      height,\n      yOffset,\n      xOffset\n    };\n  }\n  const height = ch;\n  const width = height * ir;\n  const xOffset = isNumeric(px) ? px : (cw - width) * pxv;\n  const yOffset = isNumeric(py) ? py : 0;\n  return {\n    width,\n    height,\n    xOffset,\n    yOffset\n  };\n};\nconst applyScaleDownObjectFit = (cw, ch, iw, ih, px, py) => {\n  const containDimension = applyContainObjectFit(cw, ch, iw, ih, px, py);\n  const noneDimension = applyNoneObjectFit(cw, ch, iw, ih, px, py);\n  return containDimension.width < noneDimension.width ? containDimension : noneDimension;\n};\nconst applyFillObjectFit = (cw, ch, px, py) => {\n  return {\n    width: cw,\n    height: ch,\n    xOffset: matchPercent(px ?? null) ? 0 : px || 0,\n    yOffset: matchPercent(py ?? null) ? 0 : py || 0\n  };\n};\nconst resolveObjectFit = function () {\n  let type = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'fill';\n  let cw = arguments.length > 1 ? arguments[1] : undefined;\n  let ch = arguments.length > 2 ? arguments[2] : undefined;\n  let iw = arguments.length > 3 ? arguments[3] : undefined;\n  let ih = arguments.length > 4 ? arguments[4] : undefined;\n  let px = arguments.length > 5 ? arguments[5] : undefined;\n  let py = arguments.length > 6 ? arguments[6] : undefined;\n  switch (type) {\n    case 'contain':\n      return applyContainObjectFit(cw, ch, iw, ih, px, py);\n    case 'cover':\n      return applyCoverObjectFit(cw, ch, iw, ih, px, py);\n    case 'none':\n      return applyNoneObjectFit(cw, ch, iw, ih, px, py);\n    case 'scale-down':\n      return applyScaleDownObjectFit(cw, ch, iw, ih, px, py);\n    default:\n      return applyFillObjectFit(cw, ch, px, py);\n  }\n};\nconst drawImage = (ctx, node, options) => {\n  if (!node.box) return;\n  if (!node.image) return;\n  const {\n    left,\n    top\n  } = node.box;\n  const opacity = node.style?.opacity;\n  const objectFit = node.style?.objectFit;\n  const objectPositionX = node.style?.objectPositionX;\n  const objectPositionY = node.style?.objectPositionY;\n  const paddingTop = node.box.paddingTop || 0;\n  const paddingRight = node.box.paddingRight || 0;\n  const paddingBottom = node.box.paddingBottom || 0;\n  const paddingLeft = node.box.paddingLeft || 0;\n  const imageCache = options.imageCache || new Map();\n  const {\n    width,\n    height,\n    xOffset,\n    yOffset\n  } = resolveObjectFit(objectFit, node.box.width - paddingLeft - paddingRight, node.box.height - paddingTop - paddingBottom, node.image.width, node.image.height, objectPositionX, objectPositionY);\n  if (node.image.data) {\n    if (width !== 0 && height !== 0) {\n      const cacheKey = node.image.key;\n      const image = imageCache.get(cacheKey) || embedImage(ctx, node);\n      if (cacheKey) imageCache.set(cacheKey, image);\n      const imageOpacity = isNil(opacity) ? 1 : opacity;\n      ctx.fillOpacity(imageOpacity).image(image, left + paddingLeft + xOffset, top + paddingTop + yOffset, {\n        width,\n        height\n      });\n    } else {\n      console.warn(`Image with src '${JSON.stringify(node.props.src || node.props.source)}' skipped due to invalid dimensions`);\n    }\n  }\n};\nconst renderImage = (ctx, node, options) => {\n  ctx.save();\n  clipNode(ctx, node);\n  drawImage(ctx, node, options);\n  ctx.restore();\n};\nconst CONTENT_COLOR = '#a1c6e7';\nconst PADDING_COLOR = '#c4deb9';\nconst MARGIN_COLOR = '#f8cca1';\n// TODO: Draw debug boxes using clipping to enhance quality\nconst debugContent = (ctx, node) => {\n  if (!node.box) return;\n  const {\n    left,\n    top,\n    width,\n    height,\n    paddingLeft = 0,\n    paddingTop = 0,\n    paddingRight = 0,\n    paddingBottom = 0,\n    borderLeftWidth = 0,\n    borderTopWidth = 0,\n    borderRightWidth = 0,\n    borderBottomWidth = 0\n  } = node.box;\n  ctx.fillColor(CONTENT_COLOR).opacity(0.5).rect(left + paddingLeft + borderLeftWidth, top + paddingTop + borderTopWidth, width - paddingLeft - paddingRight - borderRightWidth - borderLeftWidth, height - paddingTop - paddingBottom - borderTopWidth - borderBottomWidth).fill();\n};\nconst debugPadding = (ctx, node) => {\n  if (!node.box) return;\n  const {\n    left,\n    top,\n    width,\n    height,\n    paddingLeft = 0,\n    paddingTop = 0,\n    paddingRight = 0,\n    paddingBottom = 0,\n    borderLeftWidth = 0,\n    borderTopWidth = 0,\n    borderRightWidth = 0,\n    borderBottomWidth = 0\n  } = node.box;\n  ctx.fillColor(PADDING_COLOR).opacity(0.5);\n  // Padding top\n  ctx.rect(left + paddingLeft + borderLeftWidth, top + borderTopWidth, width - paddingRight - paddingLeft - borderLeftWidth - borderRightWidth, paddingTop).fill();\n  // Padding left\n  ctx.rect(left + borderLeftWidth, top + borderTopWidth, paddingLeft, height - borderTopWidth - borderBottomWidth).fill();\n  // Padding right\n  ctx.rect(left + width - paddingRight - borderRightWidth, top + borderTopWidth, paddingRight, height - borderTopWidth - borderBottomWidth).fill();\n  // Padding bottom\n  ctx.rect(left + paddingLeft + borderLeftWidth, top + height - paddingBottom - borderBottomWidth, width - paddingRight - paddingLeft - borderLeftWidth - borderRightWidth, paddingBottom).fill();\n};\nconst debugMargin = (ctx, node) => {\n  if (!node.box) return;\n  const {\n    left,\n    top,\n    width,\n    height\n  } = node.box;\n  const {\n    marginLeft = 0,\n    marginTop = 0,\n    marginRight = 0,\n    marginBottom = 0\n  } = node.box;\n  ctx.fillColor(MARGIN_COLOR).opacity(0.5);\n  // Margin top\n  ctx.rect(left, top - marginTop, width, marginTop).fill();\n  // Margin left\n  ctx.rect(left - marginLeft, top - marginTop, marginLeft, height + marginTop + marginBottom).fill();\n  // Margin right\n  ctx.rect(left + width, top - marginTop, marginRight, height + marginTop + marginBottom).fill();\n  // Margin bottom\n  ctx.rect(left, top + height, width, marginBottom).fill();\n};\nconst debugText = (ctx, node) => {\n  if (!node.box) return;\n  const {\n    left,\n    top,\n    width,\n    height\n  } = node.box;\n  const {\n    marginLeft = 0,\n    marginTop = 0,\n    marginRight = 0,\n    marginBottom = 0\n  } = node.box;\n  const roundedWidth = Math.round(width + marginLeft + marginRight);\n  const roundedHeight = Math.round(height + marginTop + marginBottom);\n  ctx.fontSize(6).opacity(1).fillColor('black').text(`${roundedWidth} x ${roundedHeight}`, left - marginLeft, Math.max(top - marginTop - 4, 1), {\n    width: Infinity\n  });\n};\nconst debugOrigin = (ctx, node) => {\n  if (node.origin) {\n    ctx.circle(node.origin.left, node.origin.top, 3).fill('red').circle(node.origin.left, node.origin.top, 5).stroke('red');\n  }\n};\nconst renderDebug = (ctx, node) => {\n  if (!node.props) return;\n  if (!('debug' in node.props) || !node.props.debug) return;\n  ctx.save();\n  debugContent(ctx, node);\n  debugPadding(ctx, node);\n  debugMargin(ctx, node);\n  debugText(ctx, node);\n  debugOrigin(ctx, node);\n  ctx.restore();\n};\nconst availableMethods = ['dash', 'clip', 'save', 'path', 'fill', 'font', 'text', 'rect', 'scale', 'moveTo', 'lineTo', 'stroke', 'rotate', 'circle', 'lineCap', 'opacity', 'ellipse', 'polygon', 'restore', 'lineJoin', 'fontSize', 'fillColor', 'lineWidth', 'translate', 'miterLimit', 'strokeColor', 'fillOpacity', 'roundedRect', 'fillAndStroke', 'strokeOpacity', 'bezierCurveTo', 'quadraticCurveTo', 'linearGradient', 'radialGradient'];\nconst painter = ctx => {\n  const p = availableMethods.reduce((acc, prop) => ({\n    ...acc,\n    [prop]: function () {\n      // @ts-expect-error ctx[prop] is a function\n      ctx[prop](...arguments);\n      return p;\n    }\n  }), {});\n  return p;\n};\nconst renderCanvas = (ctx, node) => {\n  if (!node.box) return;\n  const {\n    top,\n    left,\n    width,\n    height\n  } = node.box;\n  const paddingTop = node.box.paddingTop || 0;\n  const paddingLeft = node.box.paddingLeft || 0;\n  const paddingRight = node.box.paddingRight || 0;\n  const paddingBottom = node.box.paddingBottom || 0;\n  const availableWidth = width - paddingLeft - paddingRight;\n  const availableHeight = height - paddingTop - paddingBottom;\n  if (!availableWidth || !availableHeight) {\n    console.warn('Canvas element has null width or height. Please provide valid values via the `style` prop in order to correctly render it.');\n  }\n  ctx.save().translate(left + paddingLeft, top + paddingTop);\n  if (node.props.paint) {\n    node.props.paint(painter(ctx), availableWidth, availableHeight);\n  }\n  ctx.restore();\n};\n\n// Ref: https://www.w3.org/TR/css-backgrounds-3/#borders\n// This constant is used to approximate a symmetrical arc using a cubic Bezier curve.\nconst KAPPA = 4.0 * ((Math.sqrt(2) - 1.0) / 3.0);\nconst clipBorderTop = (ctx, layout, style, rtr, rtl) => {\n  const {\n    top,\n    left,\n    width,\n    height\n  } = layout;\n  const {\n    borderTopWidth,\n    borderRightWidth,\n    borderLeftWidth\n  } = style;\n  // Clip outer top border edge\n  ctx.moveTo(left + rtl, top);\n  ctx.lineTo(left + width - rtr, top);\n  // Ellipse coefficients outer top right cap\n  const c0 = rtr * (1.0 - KAPPA);\n  // Clip outer top right cap\n  ctx.bezierCurveTo(left + width - c0, top, left + width, top + c0, left + width, top + rtr);\n  // Move down in case the margin exceedes the radius\n  const topRightYCoord = top + Math.max(borderTopWidth, rtr);\n  ctx.lineTo(left + width, topRightYCoord);\n  // Clip inner top right cap\n  ctx.lineTo(left + width - borderRightWidth, topRightYCoord);\n  // Ellipse coefficients inner top right cap\n  const innerTopRightRadiusX = Math.max(rtr - borderRightWidth, 0);\n  const innerTopRightRadiusY = Math.max(rtr - borderTopWidth, 0);\n  const c1 = innerTopRightRadiusX * (1.0 - KAPPA);\n  const c2 = innerTopRightRadiusY * (1.0 - KAPPA);\n  // Clip inner top right cap\n  ctx.bezierCurveTo(left + width - borderRightWidth, top + borderTopWidth + c2, left + width - borderRightWidth - c1, top + borderTopWidth, left + width - borderRightWidth - innerTopRightRadiusX, top + borderTopWidth);\n  // Clip inner top border edge\n  ctx.lineTo(left + Math.max(rtl, borderLeftWidth), top + borderTopWidth);\n  // Ellipse coefficients inner top left cap\n  const innerTopLeftRadiusX = Math.max(rtl - borderLeftWidth, 0);\n  const innerTopLeftRadiusY = Math.max(rtl - borderTopWidth, 0);\n  const c3 = innerTopLeftRadiusX * (1.0 - KAPPA);\n  const c4 = innerTopLeftRadiusY * (1.0 - KAPPA);\n  const topLeftYCoord = top + Math.max(borderTopWidth, rtl);\n  // Clip inner top left cap\n  ctx.bezierCurveTo(left + borderLeftWidth + c3, top + borderTopWidth, left + borderLeftWidth, top + borderTopWidth + c4, left + borderLeftWidth, topLeftYCoord);\n  ctx.lineTo(left, topLeftYCoord);\n  // Move down in case the margin exceedes the radius\n  ctx.lineTo(left, top + rtl);\n  // Ellipse coefficients outer top left cap\n  const c5 = rtl * (1.0 - KAPPA);\n  // Clip outer top left cap\n  ctx.bezierCurveTo(left, top + c5, left + c5, top, left + rtl, top);\n  ctx.closePath();\n  ctx.clip();\n  // Clip border top cap joins\n  if (borderRightWidth) {\n    const trSlope = -borderTopWidth / borderRightWidth;\n    ctx.moveTo(left + width / 2, trSlope * (-width / 2) + top);\n    ctx.lineTo(left + width, top);\n    ctx.lineTo(left, top);\n    ctx.lineTo(left, top + height);\n    ctx.closePath();\n    ctx.clip();\n  }\n  if (borderLeftWidth) {\n    const trSlope = -borderTopWidth / borderLeftWidth;\n    ctx.moveTo(left + width / 2, trSlope * (-width / 2) + top);\n    ctx.lineTo(left, top);\n    ctx.lineTo(left + width, top);\n    ctx.lineTo(left + width, top + height);\n    ctx.closePath();\n    ctx.clip();\n  }\n};\nconst fillBorderTop = (ctx, layout, style, rtr, rtl) => {\n  const {\n    top,\n    left,\n    width\n  } = layout;\n  const {\n    borderTopColor,\n    borderTopWidth,\n    borderTopStyle,\n    borderRightWidth,\n    borderLeftWidth\n  } = style;\n  const c0 = rtl * (1.0 - KAPPA);\n  const c1 = rtr * (1.0 - KAPPA);\n  ctx.moveTo(left, top + Math.max(rtl, borderTopWidth));\n  ctx.bezierCurveTo(left, top + c0, left + c0, top, left + rtl, top);\n  ctx.lineTo(left + width - rtr, top);\n  ctx.bezierCurveTo(left + width - c1, top, left + width, top + c1, left + width, top + rtr);\n  ctx.strokeColor(borderTopColor);\n  ctx.lineWidth(Math.max(borderRightWidth, borderTopWidth, borderLeftWidth) * 2);\n  if (borderTopStyle === 'dashed') {\n    ctx.dash(borderTopWidth * 2, {\n      space: borderTopWidth * 1.2\n    });\n  } else if (borderTopStyle === 'dotted') {\n    ctx.dash(borderTopWidth, {\n      space: borderTopWidth * 1.2\n    });\n  }\n  ctx.stroke();\n  ctx.undash();\n};\nconst clipBorderRight = (ctx, layout, style, rtr, rbr) => {\n  const {\n    top,\n    left,\n    width,\n    height\n  } = layout;\n  const {\n    borderTopWidth,\n    borderRightWidth,\n    borderBottomWidth\n  } = style;\n  // Clip outer right border edge\n  ctx.moveTo(left + width, top + rtr);\n  ctx.lineTo(left + width, top + height - rbr);\n  // Ellipse coefficients outer bottom right cap\n  const c0 = rbr * (1.0 - KAPPA);\n  // Clip outer top right cap\n  ctx.bezierCurveTo(left + width, top + height - c0, left + width - c0, top + height, left + width - rbr, top + height);\n  // Move left in case the margin exceedes the radius\n  const topBottomXCoord = left + width - Math.max(borderRightWidth, rbr);\n  ctx.lineTo(topBottomXCoord, top + height);\n  // Clip inner bottom right cap\n  ctx.lineTo(topBottomXCoord, top + height - borderBottomWidth);\n  // Ellipse coefficients inner bottom right cap\n  const innerBottomRightRadiusX = Math.max(rbr - borderRightWidth, 0);\n  const innerBottomRightRadiusY = Math.max(rbr - borderBottomWidth, 0);\n  const c1 = innerBottomRightRadiusX * (1.0 - KAPPA);\n  const c2 = innerBottomRightRadiusY * (1.0 - KAPPA);\n  // Clip inner top right cap\n  ctx.bezierCurveTo(left + width - borderRightWidth - c1, top + height - borderBottomWidth, left + width - borderRightWidth, top + height - borderBottomWidth - c2, left + width - borderRightWidth, top + height - Math.max(rbr, borderBottomWidth));\n  // Clip inner right border edge\n  ctx.lineTo(left + width - borderRightWidth, top + Math.max(rtr, borderTopWidth));\n  // Ellipse coefficients inner top right cap\n  const innerTopRightRadiusX = Math.max(rtr - borderRightWidth, 0);\n  const innerTopRightRadiusY = Math.max(rtr - borderTopWidth, 0);\n  const c3 = innerTopRightRadiusX * (1.0 - KAPPA);\n  const c4 = innerTopRightRadiusY * (1.0 - KAPPA);\n  const topRightXCoord = left + width - Math.max(rtr, borderRightWidth);\n  // Clip inner top left cap\n  ctx.bezierCurveTo(left + width - borderRightWidth, top + borderTopWidth + c4, left + width - borderRightWidth - c3, top + borderTopWidth, topRightXCoord, top + borderTopWidth);\n  ctx.lineTo(topRightXCoord, top);\n  // Move right in case the margin exceedes the radius\n  ctx.lineTo(left + width - rtr, top);\n  // Ellipse coefficients outer top right cap\n  const c5 = rtr * (1.0 - KAPPA);\n  // Clip outer top right cap\n  ctx.bezierCurveTo(left + width - c5, top, left + width, top + c5, left + width, top + rtr);\n  ctx.closePath();\n  ctx.clip();\n  // Clip border right cap joins\n  if (borderTopWidth) {\n    const trSlope = -borderTopWidth / borderRightWidth;\n    ctx.moveTo(left + width / 2, trSlope * (-width / 2) + top);\n    ctx.lineTo(left + width, top);\n    ctx.lineTo(left + width, top + height);\n    ctx.lineTo(left, top + height);\n    ctx.closePath();\n    ctx.clip();\n  }\n  if (borderBottomWidth) {\n    const brSlope = borderBottomWidth / borderRightWidth;\n    ctx.moveTo(left + width / 2, brSlope * (-width / 2) + top + height);\n    ctx.lineTo(left + width, top + height);\n    ctx.lineTo(left + width, top);\n    ctx.lineTo(left, top);\n    ctx.closePath();\n    ctx.clip();\n  }\n};\nconst fillBorderRight = (ctx, layout, style, rtr, rbr) => {\n  const {\n    top,\n    left,\n    width,\n    height\n  } = layout;\n  const {\n    borderRightColor,\n    borderRightStyle,\n    borderRightWidth,\n    borderTopWidth,\n    borderBottomWidth\n  } = style;\n  const c0 = rbr * (1.0 - KAPPA);\n  const c1 = rtr * (1.0 - KAPPA);\n  ctx.moveTo(left + width - rtr, top);\n  ctx.bezierCurveTo(left + width - c1, top, left + width, top + c1, left + width, top + rtr);\n  ctx.lineTo(left + width, top + height - rbr);\n  ctx.bezierCurveTo(left + width, top + height - c0, left + width - c0, top + height, left + width - rbr, top + height);\n  ctx.strokeColor(borderRightColor);\n  ctx.lineWidth(Math.max(borderRightWidth, borderTopWidth, borderBottomWidth) * 2);\n  if (borderRightStyle === 'dashed') {\n    ctx.dash(borderRightWidth * 2, {\n      space: borderRightWidth * 1.2\n    });\n  } else if (borderRightStyle === 'dotted') {\n    ctx.dash(borderRightWidth, {\n      space: borderRightWidth * 1.2\n    });\n  }\n  ctx.stroke();\n  ctx.undash();\n};\nconst clipBorderBottom = (ctx, layout, style, rbl, rbr) => {\n  const {\n    top,\n    left,\n    width,\n    height\n  } = layout;\n  const {\n    borderBottomWidth,\n    borderRightWidth,\n    borderLeftWidth\n  } = style;\n  // Clip outer top border edge\n  ctx.moveTo(left + width - rbr, top + height);\n  ctx.lineTo(left + rbl, top + height);\n  // Ellipse coefficients outer top right cap\n  const c0 = rbl * (1.0 - KAPPA);\n  // Clip outer top right cap\n  ctx.bezierCurveTo(left + c0, top + height, left, top + height - c0, left, top + height - rbl);\n  // Move up in case the margin exceedes the radius\n  const bottomLeftYCoord = top + height - Math.max(borderBottomWidth, rbl);\n  ctx.lineTo(left, bottomLeftYCoord);\n  // Clip inner bottom left cap\n  ctx.lineTo(left + borderLeftWidth, bottomLeftYCoord);\n  // Ellipse coefficients inner top right cap\n  const innerBottomLeftRadiusX = Math.max(rbl - borderLeftWidth, 0);\n  const innerBottomLeftRadiusY = Math.max(rbl - borderBottomWidth, 0);\n  const c1 = innerBottomLeftRadiusX * (1.0 - KAPPA);\n  const c2 = innerBottomLeftRadiusY * (1.0 - KAPPA);\n  // Clip inner bottom left cap\n  ctx.bezierCurveTo(left + borderLeftWidth, top + height - borderBottomWidth - c2, left + borderLeftWidth + c1, top + height - borderBottomWidth, left + borderLeftWidth + innerBottomLeftRadiusX, top + height - borderBottomWidth);\n  // Clip inner bottom border edge\n  ctx.lineTo(left + width - Math.max(rbr, borderRightWidth), top + height - borderBottomWidth);\n  // Ellipse coefficients inner top left cap\n  const innerBottomRightRadiusX = Math.max(rbr - borderRightWidth, 0);\n  const innerBottomRightRadiusY = Math.max(rbr - borderBottomWidth, 0);\n  const c3 = innerBottomRightRadiusX * (1.0 - KAPPA);\n  const c4 = innerBottomRightRadiusY * (1.0 - KAPPA);\n  const bottomRightYCoord = top + height - Math.max(borderBottomWidth, rbr);\n  // Clip inner top left cap\n  ctx.bezierCurveTo(left + width - borderRightWidth - c3, top + height - borderBottomWidth, left + width - borderRightWidth, top + height - borderBottomWidth - c4, left + width - borderRightWidth, bottomRightYCoord);\n  ctx.lineTo(left + width, bottomRightYCoord);\n  // Move down in case the margin exceedes the radius\n  ctx.lineTo(left + width, top + height - rbr);\n  // Ellipse coefficients outer top left cap\n  const c5 = rbr * (1.0 - KAPPA);\n  // Clip outer top left cap\n  ctx.bezierCurveTo(left + width, top + height - c5, left + width - c5, top + height, left + width - rbr, top + height);\n  ctx.closePath();\n  ctx.clip();\n  // Clip border bottom cap joins\n  if (borderRightWidth) {\n    const brSlope = borderBottomWidth / borderRightWidth;\n    ctx.moveTo(left + width / 2, brSlope * (-width / 2) + top + height);\n    ctx.lineTo(left + width, top + height);\n    ctx.lineTo(left, top + height);\n    ctx.lineTo(left, top);\n    ctx.closePath();\n    ctx.clip();\n  }\n  if (borderLeftWidth) {\n    const trSlope = -borderBottomWidth / borderLeftWidth;\n    ctx.moveTo(left + width / 2, trSlope * (width / 2) + top + height);\n    ctx.lineTo(left, top + height);\n    ctx.lineTo(left + width, top + height);\n    ctx.lineTo(left + width, top);\n    ctx.closePath();\n    ctx.clip();\n  }\n};\nconst fillBorderBottom = (ctx, layout, style, rbl, rbr) => {\n  const {\n    top,\n    left,\n    width,\n    height\n  } = layout;\n  const {\n    borderBottomColor,\n    borderBottomStyle,\n    borderBottomWidth,\n    borderRightWidth,\n    borderLeftWidth\n  } = style;\n  const c0 = rbl * (1.0 - KAPPA);\n  const c1 = rbr * (1.0 - KAPPA);\n  ctx.moveTo(left + width, top + height - rbr);\n  ctx.bezierCurveTo(left + width, top + height - c1, left + width - c1, top + height, left + width - rbr, top + height);\n  ctx.lineTo(left + rbl, top + height);\n  ctx.bezierCurveTo(left + c0, top + height, left, top + height - c0, left, top + height - rbl);\n  ctx.strokeColor(borderBottomColor);\n  ctx.lineWidth(Math.max(borderBottomWidth, borderRightWidth, borderLeftWidth) * 2);\n  if (borderBottomStyle === 'dashed') {\n    ctx.dash(borderBottomWidth * 2, {\n      space: borderBottomWidth * 1.2\n    });\n  } else if (borderBottomStyle === 'dotted') {\n    ctx.dash(borderBottomWidth, {\n      space: borderBottomWidth * 1.2\n    });\n  }\n  ctx.stroke();\n  ctx.undash();\n};\nconst clipBorderLeft = (ctx, layout, style, rbl, rtl) => {\n  const {\n    top,\n    left,\n    width,\n    height\n  } = layout;\n  const {\n    borderTopWidth,\n    borderLeftWidth,\n    borderBottomWidth\n  } = style;\n  // Clip outer left border edge\n  ctx.moveTo(left, top + height - rbl);\n  ctx.lineTo(left, top + rtl);\n  // Ellipse coefficients outer top left cap\n  const c0 = rtl * (1.0 - KAPPA);\n  // Clip outer top left cap\n  ctx.bezierCurveTo(left, top + c0, left + c0, top, left + rtl, top);\n  // Move right in case the margin exceedes the radius\n  const topLeftCoordX = left + Math.max(borderLeftWidth, rtl);\n  ctx.lineTo(topLeftCoordX, top);\n  // Clip inner top left cap\n  ctx.lineTo(topLeftCoordX, top + borderTopWidth);\n  // Ellipse coefficients inner top left cap\n  const innerTopLeftRadiusX = Math.max(rtl - borderLeftWidth, 0);\n  const innerTopLeftRadiusY = Math.max(rtl - borderTopWidth, 0);\n  const c1 = innerTopLeftRadiusX * (1.0 - KAPPA);\n  const c2 = innerTopLeftRadiusY * (1.0 - KAPPA);\n  // Clip inner top right cap\n  ctx.bezierCurveTo(left + borderLeftWidth + c1, top + borderTopWidth, left + borderLeftWidth, top + borderTopWidth + c2, left + borderLeftWidth, top + Math.max(rtl, borderTopWidth));\n  // Clip inner left border edge\n  ctx.lineTo(left + borderLeftWidth, top + height - Math.max(rbl, borderBottomWidth));\n  // Ellipse coefficients inner bottom left cap\n  const innerBottomLeftRadiusX = Math.max(rbl - borderLeftWidth, 0);\n  const innerBottomLeftRadiusY = Math.max(rbl - borderBottomWidth, 0);\n  const c3 = innerBottomLeftRadiusX * (1.0 - KAPPA);\n  const c4 = innerBottomLeftRadiusY * (1.0 - KAPPA);\n  const bottomLeftXCoord = left + Math.max(rbl, borderLeftWidth);\n  // Clip inner top left cap\n  ctx.bezierCurveTo(left + borderLeftWidth, top + height - borderBottomWidth - c4, left + borderLeftWidth + c3, top + height - borderBottomWidth, bottomLeftXCoord, top + height - borderBottomWidth);\n  ctx.lineTo(bottomLeftXCoord, top + height);\n  // Move left in case the margin exceedes the radius\n  ctx.lineTo(left + rbl, top + height);\n  // Ellipse coefficients outer top right cap\n  const c5 = rbl * (1.0 - KAPPA);\n  // Clip outer top right cap\n  ctx.bezierCurveTo(left + c5, top + height, left, top + height - c5, left, top + height - rbl);\n  ctx.closePath();\n  ctx.clip();\n  // Clip border right cap joins\n  if (borderBottomWidth) {\n    const trSlope = -borderBottomWidth / borderLeftWidth;\n    ctx.moveTo(left + width / 2, trSlope * (width / 2) + top + height);\n    ctx.lineTo(left, top + height);\n    ctx.lineTo(left, top);\n    ctx.lineTo(left + width, top);\n    ctx.closePath();\n    ctx.clip();\n  }\n  if (borderBottomWidth) {\n    const trSlope = -borderTopWidth / borderLeftWidth;\n    ctx.moveTo(left + width / 2, trSlope * (-width / 2) + top);\n    ctx.lineTo(left, top);\n    ctx.lineTo(left, top + height);\n    ctx.lineTo(left + width, top + height);\n    ctx.closePath();\n    ctx.clip();\n  }\n};\nconst fillBorderLeft = (ctx, layout, style, rbl, rtl) => {\n  const {\n    top,\n    left,\n    height\n  } = layout;\n  const {\n    borderLeftColor,\n    borderLeftStyle,\n    borderLeftWidth,\n    borderTopWidth,\n    borderBottomWidth\n  } = style;\n  const c0 = rbl * (1.0 - KAPPA);\n  const c1 = rtl * (1.0 - KAPPA);\n  ctx.moveTo(left + rbl, top + height);\n  ctx.bezierCurveTo(left + c0, top + height, left, top + height - c0, left, top + height - rbl);\n  ctx.lineTo(left, top + rtl);\n  ctx.bezierCurveTo(left, top + c1, left + c1, top, left + rtl, top);\n  ctx.strokeColor(borderLeftColor);\n  ctx.lineWidth(Math.max(borderLeftWidth, borderTopWidth, borderBottomWidth) * 2);\n  if (borderLeftStyle === 'dashed') {\n    ctx.dash(borderLeftWidth * 2, {\n      space: borderLeftWidth * 1.2\n    });\n  } else if (borderLeftStyle === 'dotted') {\n    ctx.dash(borderLeftWidth, {\n      space: borderLeftWidth * 1.2\n    });\n  }\n  ctx.stroke();\n  ctx.undash();\n};\nconst shouldRenderBorders = node => node.box && (node.box.borderTopWidth || node.box.borderRightWidth || node.box.borderBottomWidth || node.box.borderLeftWidth);\nconst renderBorders = (ctx, node) => {\n  if (!node.box) return;\n  if (!shouldRenderBorders(node)) return;\n  const {\n    width,\n    height,\n    borderTopWidth = 0,\n    borderLeftWidth = 0,\n    borderRightWidth = 0,\n    borderBottomWidth = 0\n  } = node.box;\n  const {\n    opacity = 1,\n    borderTopColor = 'black',\n    borderTopStyle = 'solid',\n    borderLeftColor = 'black',\n    borderLeftStyle = 'solid',\n    borderRightColor = 'black',\n    borderRightStyle = 'solid',\n    borderBottomColor = 'black',\n    borderBottomStyle = 'solid'\n  } = node.style;\n  // @ts-expect-error this is always a number due to resolve border radius step\n  const borderTopLeftRadius = node.style.borderTopLeftRadius || 0;\n  // @ts-expect-error this is always a number due to resolve border radius step\n  const borderTopRightRadius = node.style.borderTopRightRadius || 0;\n  // @ts-expect-error this is always a number due to resolve border radius step\n  const borderBottomLeftRadius = node.style.borderBottomLeftRadius || 0;\n  // @ts-expect-error this is always a number due to resolve border radius step\n  const borderBottomRightRadius = node.style.borderBottomRightRadius || 0;\n  const style = {\n    borderTopColor,\n    borderTopWidth,\n    borderTopStyle,\n    borderLeftColor,\n    borderLeftWidth,\n    borderLeftStyle,\n    borderRightColor,\n    borderRightWidth,\n    borderRightStyle,\n    borderBottomColor,\n    borderBottomWidth,\n    borderBottomStyle\n  };\n  const rtr = Math.min(borderTopRightRadius, 0.5 * width, 0.5 * height);\n  const rtl = Math.min(borderTopLeftRadius, 0.5 * width, 0.5 * height);\n  const rbr = Math.min(borderBottomRightRadius, 0.5 * width, 0.5 * height);\n  const rbl = Math.min(borderBottomLeftRadius, 0.5 * width, 0.5 * height);\n  ctx.save();\n  ctx.strokeOpacity(opacity);\n  if (borderTopWidth) {\n    ctx.save();\n    clipBorderTop(ctx, node.box, style, rtr, rtl);\n    fillBorderTop(ctx, node.box, style, rtr, rtl);\n    ctx.restore();\n  }\n  if (borderRightWidth) {\n    ctx.save();\n    clipBorderRight(ctx, node.box, style, rtr, rbr);\n    fillBorderRight(ctx, node.box, style, rtr, rbr);\n    ctx.restore();\n  }\n  if (borderBottomWidth) {\n    ctx.save();\n    clipBorderBottom(ctx, node.box, style, rbl, rbr);\n    fillBorderBottom(ctx, node.box, style, rbl, rbr);\n    ctx.restore();\n  }\n  if (borderLeftWidth) {\n    ctx.save();\n    clipBorderLeft(ctx, node.box, style, rbl, rtl);\n    fillBorderLeft(ctx, node.box, style, rbl, rtl);\n    ctx.restore();\n  }\n  ctx.restore();\n};\nconst drawBackground = (ctx, node) => {\n  if (!node.box) return;\n  const {\n    top,\n    left,\n    width,\n    height\n  } = node.box;\n  const color = parseColor(node.style.backgroundColor);\n  const nodeOpacity = isNil(node.style?.opacity) ? 1 : node.style.opacity;\n  const opacity = Math.min(color.opacity, nodeOpacity);\n  ctx.fillOpacity(opacity).fillColor(color.value).rect(left, top, width, height).fill();\n};\nconst renderBackground = (ctx, node) => {\n  const hasBackground = !!node.box && !!node.style?.backgroundColor;\n  if (hasBackground) {\n    ctx.save();\n    clipNode(ctx, node);\n    drawBackground(ctx, node);\n    ctx.restore();\n  }\n};\nconst isString = value => typeof value === 'string';\nconst isSrcId = value => /^#.+/.test(value);\nconst renderLink = (ctx, node, src) => {\n  if (!src || !node.box) return;\n  const isId = isSrcId(src);\n  const method = isId ? 'goTo' : 'link';\n  const value = isId ? src.slice(1) : src;\n  const {\n    top,\n    left,\n    width,\n    height\n  } = node.box;\n  ctx[method](left, top, width, height, value);\n};\nconst setLink = (ctx, node) => {\n  const props = node.props || {};\n  if ('src' in props && isString(props.src)) return renderLink(ctx, node, props.src);\n  if ('href' in props && isString(props.href)) return renderLink(ctx, node, props.href);\n};\nconst setDestination = (ctx, node) => {\n  if (!node.box) return;\n  if (!node.props) return;\n  if ('id' in node.props) {\n    ctx.addNamedDestination(node.props.id, 'XYZ', null, node.box.top, null);\n  }\n};\nconst clean = options => {\n  const opt = {\n    ...options\n  };\n  // We need to ensure the elements are no present if not true\n  Object.entries(opt).forEach(pair => {\n    if (!pair[1]) {\n      delete opt[pair[0]];\n    }\n  });\n  return opt;\n};\nconst parseCommonFormOptions = node => {\n  // Common Options\n  return {\n    required: node.props?.required || false,\n    noExport: node.props?.noExport || false,\n    readOnly: node.props?.readOnly || false,\n    value: node.props?.value || undefined,\n    defaultValue: node.props?.defaultValue || undefined\n  };\n};\nconst parseTextInputOptions = (node, fieldSet) => {\n  return clean({\n    ...parseCommonFormOptions(node),\n    parent: fieldSet || undefined,\n    align: node.props?.align || 'left',\n    multiline: node.props?.multiline || undefined,\n    password: node.props?.password || false,\n    noSpell: node.props?.noSpell || false,\n    format: node.props?.format || undefined,\n    fontSize: node.props?.fontSize || undefined,\n    MaxLen: node.props?.maxLength || undefined\n  });\n};\nconst parseSelectAndListFieldOptions = node => {\n  return clean({\n    ...parseCommonFormOptions(node),\n    sort: node.props?.sort || false,\n    edit: node.props?.edit || false,\n    multiSelect: node.props?.multiSelect || false,\n    noSpell: node.props?.noSpell || false,\n    select: node.props?.select || ['']\n  });\n};\nconst getAppearance = (ctx, codepoint, width, height) => {\n  const appearance = ctx.ref({\n    Type: 'XObject',\n    Subtype: 'Form',\n    BBox: [0, 0, width, height],\n    Resources: {\n      ProcSet: ['PDF', 'Text', 'ImageB', 'ImageC', 'ImageI'],\n      Font: {\n        ZaDi: ctx._acroform.fonts.ZaDi\n      }\n    }\n  });\n  appearance.initDeflate();\n  appearance.write(`/Tx BMC\\nq\\n/ZaDi ${height * 0.8} Tf\\nBT\\n${width * 0.45} ${height / 4} Td (${codepoint}) Tj\\nET\\nQ\\nEMC`);\n  appearance.end(null);\n  return appearance;\n};\nconst parseCheckboxOptions = (ctx, node, fieldSet) => {\n  const {\n    width,\n    height\n  } = node.box || {};\n  const onOption = node.props?.onState || 'Yes';\n  const offOption = node.props?.offState || 'Off';\n  const xMark = node.props?.xMark || false;\n  if (!Object.prototype.hasOwnProperty.call(ctx._acroform.fonts, 'ZaDi')) {\n    const ref = ctx.ref({\n      Type: 'Font',\n      Subtype: 'Type1',\n      BaseFont: 'ZapfDingbats'\n    });\n    ctx._acroform.fonts.ZaDi = ref;\n    ref.end(null);\n  }\n  const normalAppearance = {\n    [onOption]: getAppearance(ctx, xMark ? '8' : '4', width, height),\n    [offOption]: getAppearance(ctx, xMark ? ' ' : '8', width, height)\n  };\n  return clean({\n    ...parseCommonFormOptions(node),\n    backgroundColor: node.props?.backgroundColor || undefined,\n    borderColor: node.props?.borderColor || undefined,\n    parent: fieldSet || undefined,\n    value: `/${node.props?.checked === true ? onOption : offOption}`,\n    defaultValue: `/${node.props?.checked === true ? onOption : offOption}`,\n    AS: node.props?.checked === true ? onOption : offOption,\n    AP: {\n      N: normalAppearance,\n      D: normalAppearance\n    }\n  });\n};\nconst renderTextInput = (ctx, node, options) => {\n  if (!node.box) return;\n  const {\n    top,\n    left,\n    width,\n    height\n  } = node.box;\n  // Element's name\n  const name = node.props?.name || '';\n  const fieldSetOptions = options.fieldSets?.at(0);\n  if (!ctx._root.data.AcroForm) {\n    ctx.initForm();\n  }\n  ctx.formText(name, left, top, width, height, parseTextInputOptions(node, fieldSetOptions));\n};\nconst renderSelect = (ctx, node) => {\n  if (!node.box) return;\n  const {\n    top,\n    left,\n    width,\n    height\n  } = node.box;\n  // Element's name\n  const name = node.props?.name || '';\n  if (!ctx._root.data.AcroForm) {\n    ctx.initForm();\n  }\n  ctx.formCombo(name, left, top, width, height, parseSelectAndListFieldOptions(node));\n};\nconst renderFieldSet = (ctx, node, options) => {\n  const name = node.props?.name || '';\n  if (!ctx._root.data.AcroForm) {\n    ctx.initForm();\n  }\n  const formField = ctx.formField(name);\n  const option = options;\n  if (!option.fieldSets) {\n    option.fieldSets = [formField];\n  } else {\n    option.fieldSets.push(formField);\n  }\n};\nconst cleanUpFieldSet = (_ctx, _node, options) => {\n  options.fieldSets.pop();\n};\nconst renderList = (ctx, node) => {\n  if (!node.box) return;\n  const {\n    top,\n    left,\n    width,\n    height\n  } = node.box || {};\n  // Element's name\n  const name = 'name' in node.props ? node.props.name || '' : '';\n  if (!ctx._root.data.AcroForm) {\n    ctx.initForm();\n  }\n  ctx.formList(name, left, top, width, height, parseSelectAndListFieldOptions(node));\n};\nconst renderCheckbox = (ctx, node, options) => {\n  if (!node.box) return;\n  const {\n    top,\n    left,\n    width,\n    height\n  } = node.box;\n  // Element's name\n  const name = node.props?.name || '';\n  const fieldSetOptions = options.fieldSets?.at(0);\n  if (!ctx._root.data.AcroForm) {\n    ctx.initForm();\n  }\n  ctx.formCheckbox(name, left, top, width, height, parseCheckboxOptions(ctx, node, fieldSetOptions));\n};\nconst isRecursiveNode = node => node.type !== P.Text && node.type !== P.Svg;\nconst renderChildren = (ctx, node, options) => {\n  ctx.save();\n  if (node.box) {\n    ctx.translate(node.box.left, node.box.top);\n  }\n  const children = node.children || [];\n  const renderChild = child => renderNode(ctx, child, options);\n  children.forEach(renderChild);\n  ctx.restore();\n};\nconst renderFns = {\n  [P.Text]: renderText,\n  [P.Note]: renderNote,\n  [P.Image]: renderImage,\n  [P.FieldSet]: renderFieldSet,\n  [P.TextInput]: renderTextInput,\n  [P.Select]: renderSelect,\n  [P.Checkbox]: renderCheckbox,\n  [P.List]: renderList,\n  [P.Canvas]: renderCanvas,\n  [P.Svg]: renderSvg,\n  [P.Link]: setLink\n};\nconst cleanUpFns = {\n  [P.FieldSet]: cleanUpFieldSet\n};\nconst renderNode = (ctx, node, options) => {\n  const overflowHidden = node.style?.overflow === 'hidden';\n  const shouldRenderChildren = isRecursiveNode(node);\n  if (node.type === P.Page) renderPage(ctx, node);\n  ctx.save();\n  if (overflowHidden) clipNode(ctx, node);\n  applyTransformations(ctx, node);\n  renderBackground(ctx, node);\n  renderBorders(ctx, node);\n  const renderFn = renderFns[node.type];\n  if (renderFn) renderFn(ctx, node, options);\n  if (shouldRenderChildren) renderChildren(ctx, node, options);\n  const cleanUpFn = cleanUpFns[node.type];\n  if (cleanUpFn) cleanUpFn(ctx, node, options);\n  setDestination(ctx, node);\n  renderDebug(ctx, node);\n  ctx.restore();\n};\nconst addNodeBookmark = (ctx, node, pageNumber, registry) => {\n  if (!node.box) return;\n  if (!node.props) return;\n  if ('bookmark' in node.props && node.props.bookmark) {\n    const bookmark = node.props.bookmark;\n    const {\n      title,\n      parent,\n      expanded,\n      zoom,\n      fit\n    } = bookmark;\n    const outline = registry[parent] || ctx.outline;\n    const top = bookmark.top || node.box.top;\n    const left = bookmark.left || node.box.left;\n    const instance = outline.addItem(title, {\n      pageNumber,\n      expanded,\n      top,\n      left,\n      zoom,\n      fit\n    });\n    registry[bookmark.ref] = instance;\n  }\n  if (!node.children) return;\n  node.children.forEach(child => addNodeBookmark(ctx, child, pageNumber, registry));\n};\nconst addBookmarks = (ctx, root) => {\n  const registry = {};\n  const pages = root.children || [];\n  pages.forEach((page, i) => {\n    addNodeBookmark(ctx, page, i, registry);\n  });\n};\nconst render = (ctx, doc) => {\n  const pages = doc.children || [];\n  const options = {\n    imageCache: new Map(),\n    fieldSets: []\n  };\n  pages.forEach(page => renderNode(ctx, page, options));\n  addBookmarks(ctx, doc);\n  ctx.end();\n  return ctx;\n};\nexport { render as default };","map":{"version":3,"names":["P","isNil","matchPercent","absPath","parsePath","normalizePath","colorString","renderPath","ctx","node","d","props","path","KAPPA$3","Math","sqrt","renderRect","x","y","rx","ry","width","height","krx","kry","moveTo","lineTo","bezierCurveTo","closePath","renderLine$1","x1","x2","y1","y2","renderGroup","KAPPA$2","drawEllipse","cx","arguments","length","undefined","cy","ox","oy","xe","ye","xm","ym","renderEllipse","renderCircle","r","number","n","round","Error","_renderGlyphs","encoded","positions","commands","scale","_fontSize","i","last","hadOffset","save","transform","page","fonts","_font","id","ref","addContent","addSegment","cur","hex","slice","join","advance","xAdvance","advanceWidth","push","flush","s","pos","xOffset","yOffset","restore","renderGlyphs","glyphs","unitsPerEm","font","advanceWidthScale","encodedGlyphs","encodeGlyphs","encodedPositions","map","yAdvance","renderRun$1","run","runAdvanceWidth","attributes","fontSize","color","opacity","fillColor","fillOpacity","type","fullName","error","console","log","translate","renderSpan","line","textAnchor","dominantBaseline","box","runs","ascent","xHeight","descent","capHeight","xTranslate","yTranslate","forEach","renderSvgText","children","span","lines","pairs","values","result","parsePoints","points","trim","replace","split","mappedValues","parseFloat","drawPolyline","p","renderPolyline","renderPolygon","renderImage$1","image","data","style","paddingTop","paddingLeft","warn","href","KAPPA$1","clipNode","top","left","borderTopLeftRadius","borderTopRightRadius","borderBottomRightRadius","borderBottomLeftRadius","rtr","min","ctr","rbr","cbr","rbl","cbl","rtl","ctl","clip","applySingleTransformation","origin","operation","value","scaleX","scaleY","angle","rotate","xAngle","yAngle","radx","PI","rady","tanx","tan","tany","Array","from","applyTransformations","propsTransform","operations","getPathBoundingBox","bounds","Infinity","l","j","getCircleBoundingBox","getEllipseBoundingBox","getLineBoundingBox","max","getRectBoundingBox","getPolylineBoundingBox","xValues","yValues","boundingBoxFns","Rect","Line","Path","Circle","Ellipse","Polygon","Polyline","getBoundingBox","boundingBoxFn","setStrokeWidth","lineWidth","strokeWidth","setStrokeColor","strokeColor","stroke","setOpacity","setFillOpacity","setStrokeOpacity","strokeOpacity","setLineJoin","lineJoin","strokeLinejoin","setLineCap","lineCap","strokeLinecap","setLineDash","strokeDasharray","dash","Number","hasLinearGradientFill","fill","LinearGradient","hasRadialGradientFill","RadialGradient","multiplyMatrices","m1","m2","a","b","c","e","f","transformGradient","grad","transforms","bbox","units","matrices","cos","sin","matrix","reduce","setTransform","setLinearGradientFill","gradient","gradientUnits","gradientTransform","m0","m3","m4","m5","linearGradient","stop","offset","stopColor","stopOpacity","setRadialGradientFill","fx","fy","radialGradient","setFillColor","setFill","draw","fillAndStroke","fillRule","noop","renderFns$1","Tspan","TextInstance","G","Text","Image","renderNode$1","renderFn","drawNode","clipPath","child","drawChildren","resolveAspectRatio","viewBox","preserveAspectRatio","meetOrSlice","align","minX","minY","logicalWidth","maxX","logicalHeight","maxY","logicalRatio","physicalRatio","moveToOrigin","renderSvg","black","parseColor","parsed","get","to","DEST_REGEXP","isSrcId$1","src","match","renderAttachment","attachment","fit","valign","renderAttachments","space","glyphForCodePoint","objectReplacement","attachmentAdvance","position","glyph","renderRun","link","goTo","renderBackground$1","rect","backgroundColor","renderDecorationLine","decorationLine","test","dist","step","stepCount","floor","remainingWidth","adjustment","cp1y","cp2y","renderLine","lineAscent","isLastRun","overflowRight","backgroundRect","decorationLines","renderBlock","block","renderText","blocks","initialY","offsetX","alignOffset","renderPage","dpi","userUnit","addPage","size","margin","renderNote","note","embedImage","_imageRegistry","openImage","obj","embed","isNumeric","isNaN","isFinite","applyContainObjectFit","cw","ch","iw","ih","px","py","cr","ir","pxp","pyp","pxv","percent","pyv","applyNoneObjectFit","applyCoverObjectFit","applyScaleDownObjectFit","containDimension","noneDimension","applyFillObjectFit","resolveObjectFit","drawImage","options","objectFit","objectPositionX","objectPositionY","paddingRight","paddingBottom","imageCache","Map","cacheKey","key","set","imageOpacity","JSON","stringify","source","renderImage","CONTENT_COLOR","PADDING_COLOR","MARGIN_COLOR","debugContent","borderLeftWidth","borderTopWidth","borderRightWidth","borderBottomWidth","debugPadding","debugMargin","marginLeft","marginTop","marginRight","marginBottom","debugText","roundedWidth","roundedHeight","text","debugOrigin","circle","renderDebug","debug","availableMethods","painter","acc","prop","renderCanvas","availableWidth","availableHeight","paint","KAPPA","clipBorderTop","layout","c0","topRightYCoord","innerTopRightRadiusX","innerTopRightRadiusY","c1","c2","innerTopLeftRadiusX","innerTopLeftRadiusY","c3","c4","topLeftYCoord","c5","trSlope","fillBorderTop","borderTopColor","borderTopStyle","undash","clipBorderRight","topBottomXCoord","innerBottomRightRadiusX","innerBottomRightRadiusY","topRightXCoord","brSlope","fillBorderRight","borderRightColor","borderRightStyle","clipBorderBottom","bottomLeftYCoord","innerBottomLeftRadiusX","innerBottomLeftRadiusY","bottomRightYCoord","fillBorderBottom","borderBottomColor","borderBottomStyle","clipBorderLeft","topLeftCoordX","bottomLeftXCoord","fillBorderLeft","borderLeftColor","borderLeftStyle","shouldRenderBorders","renderBorders","drawBackground","nodeOpacity","renderBackground","hasBackground","isString","isSrcId","renderLink","isId","method","setLink","setDestination","addNamedDestination","clean","opt","Object","entries","pair","parseCommonFormOptions","required","noExport","readOnly","defaultValue","parseTextInputOptions","fieldSet","parent","multiline","password","noSpell","format","MaxLen","maxLength","parseSelectAndListFieldOptions","sort","edit","multiSelect","select","getAppearance","codepoint","appearance","Type","Subtype","BBox","Resources","ProcSet","Font","ZaDi","_acroform","initDeflate","write","end","parseCheckboxOptions","onOption","onState","offOption","offState","xMark","prototype","hasOwnProperty","call","BaseFont","normalAppearance","borderColor","checked","AS","AP","N","D","renderTextInput","name","fieldSetOptions","fieldSets","at","_root","AcroForm","initForm","formText","renderSelect","formCombo","renderFieldSet","formField","option","cleanUpFieldSet","_ctx","_node","pop","renderList","formList","renderCheckbox","formCheckbox","isRecursiveNode","Svg","renderChildren","renderChild","renderNode","renderFns","Note","FieldSet","TextInput","Select","Checkbox","List","Canvas","Link","cleanUpFns","overflowHidden","overflow","shouldRenderChildren","Page","cleanUpFn","addNodeBookmark","pageNumber","registry","bookmark","title","expanded","zoom","outline","instance","addItem","addBookmarks","root","pages","render","doc","default"],"sources":["C:/Users/JS/testinge/node_modules/@react-pdf/render/lib/index.js"],"sourcesContent":["import * as P from '@react-pdf/primitives';\nimport { isNil, matchPercent } from '@react-pdf/fns';\nimport absPath from 'abs-svg-path';\nimport parsePath from 'parse-svg-path';\nimport normalizePath from 'normalize-svg-path';\nimport colorString from 'color-string';\n\nconst renderPath = (ctx, node) => {\n    const d = node.props?.d;\n    if (d)\n        ctx.path(node.props.d);\n};\n\nconst KAPPA$3 = 4.0 * ((Math.sqrt(2) - 1.0) / 3.0);\nconst renderRect = (ctx, node) => {\n    const x = node.props?.x || 0;\n    const y = node.props?.y || 0;\n    const rx = node.props?.rx || 0;\n    const ry = node.props?.ry || 0;\n    const width = node.props?.width || 0;\n    const height = node.props?.height || 0;\n    if (!width || !height)\n        return;\n    if (rx && ry) {\n        const krx = rx * KAPPA$3;\n        const kry = ry * KAPPA$3;\n        ctx.moveTo(x + rx, y);\n        ctx.lineTo(x - rx + width, y);\n        ctx.bezierCurveTo(x - rx + width + krx, y, x + width, y + ry - kry, x + width, y + ry);\n        ctx.lineTo(x + width, y + height - ry);\n        ctx.bezierCurveTo(x + width, y + height - ry + kry, x - rx + width + krx, y + height, x - rx + width, y + height);\n        ctx.lineTo(x + rx, y + height);\n        ctx.bezierCurveTo(x + rx - krx, y + height, x, y + height - ry + kry, x, y + height - ry);\n        ctx.lineTo(x, y + ry);\n        ctx.bezierCurveTo(x, y + ry - kry, x + rx - krx, y, x + rx, y);\n    }\n    else {\n        ctx.moveTo(x, y);\n        ctx.lineTo(x + width, y);\n        ctx.lineTo(x + width, y + height);\n        ctx.lineTo(x, y + height);\n    }\n    ctx.closePath();\n};\n\nconst renderLine$1 = (ctx, node) => {\n    const { x1, x2, y1, y2 } = node.props || {};\n    ctx.moveTo(x1, y1);\n    ctx.lineTo(x2, y2);\n};\n\nconst renderGroup = () => {\n    // noop\n};\n\nconst KAPPA$2 = 4.0 * ((Math.sqrt(2) - 1.0) / 3.0);\nconst drawEllipse = (ctx, rx, ry, cx = 0, cy = 0) => {\n    const x = cx - rx;\n    const y = cy - ry;\n    const ox = rx * KAPPA$2;\n    const oy = ry * KAPPA$2;\n    const xe = x + rx * 2;\n    const ye = y + ry * 2;\n    const xm = x + rx;\n    const ym = y + ry;\n    ctx.moveTo(x, ym);\n    ctx.bezierCurveTo(x, ym - oy, xm - ox, y, xm, y);\n    ctx.bezierCurveTo(xm + ox, y, xe, ym - oy, xe, ym);\n    ctx.bezierCurveTo(xe, ym + oy, xm + ox, ye, xm, ye);\n    ctx.bezierCurveTo(xm - ox, ye, x, ym + oy, x, ym);\n    ctx.closePath();\n};\nconst renderEllipse = (ctx, node) => {\n    const { cx, cy, rx, ry } = node.props || {};\n    drawEllipse(ctx, rx, ry, cx, cy);\n};\n\nconst renderCircle = (ctx, node) => {\n    const cx = node.props?.cx;\n    const cy = node.props?.cy;\n    const r = node.props?.r;\n    drawEllipse(ctx, r, r, cx, cy);\n};\n\n/* eslint-disable no-return-assign */\nconst number = (n) => {\n    if (n > -1e21 && n < 1e21) {\n        return Math.round(n * 1e6) / 1e6;\n    }\n    throw new Error(`unsupported number: ${n}`);\n};\nconst _renderGlyphs = (ctx, encoded, positions, x, y) => {\n    const commands = [];\n    const scale = ctx._fontSize / 1000;\n    let i;\n    let last = 0;\n    let hadOffset = false;\n    ctx.save();\n    // flip coordinate system\n    ctx.transform(1, 0, 0, -1, 0, ctx.page.height);\n    y = ctx.page.height - y;\n    // add current font to page if necessary\n    if (ctx.page.fonts[ctx._font.id] == null) {\n        ctx.page.fonts[ctx._font.id] = ctx._font.ref();\n    }\n    // begin the text object\n    ctx.addContent('BT');\n    // text position\n    ctx.addContent(`1 0 0 1 ${number(x)} ${number(y)} Tm`);\n    // font and font size\n    ctx.addContent(`/${ctx._font.id} ${number(ctx._fontSize)} Tf`);\n    // Adds a segment of text to the TJ command buffer\n    const addSegment = (cur) => {\n        if (last < cur) {\n            const hex = encoded.slice(last, cur).join('');\n            const advance = positions[cur - 1].xAdvance - positions[cur - 1].advanceWidth;\n            commands.push(`<${hex}> ${number(-advance)}`);\n        }\n        return (last = cur);\n    };\n    // Flushes the current TJ commands to the output stream\n    const flush = (s) => {\n        addSegment(s);\n        if (commands.length > 0) {\n            ctx.addContent(`[${commands.join(' ')}] TJ`);\n            return (commands.length = 0);\n        }\n    };\n    for (i = 0; i < positions.length; i += 1) {\n        // If we have an x or y offset, we have to break out of the current TJ command\n        // so we can move the text position.\n        const pos = positions[i];\n        if (pos.xOffset || pos.yOffset) {\n            // Flush the current buffer\n            flush(i);\n            // Move the text position and flush just the current character\n            ctx.addContent(`1 0 0 1 ${number(x + pos.xOffset * scale)} ${number(y + pos.yOffset * scale)} Tm`);\n            flush(i + 1);\n            hadOffset = true;\n        }\n        else {\n            // If the last character had an offset, reset the text position\n            if (hadOffset) {\n                ctx.addContent(`1 0 0 1 ${number(x)} ${number(y)} Tm`);\n                hadOffset = false;\n            }\n            // Group segments that don't have any advance adjustments\n            if (pos.xAdvance - pos.advanceWidth !== 0) {\n                addSegment(i + 1);\n            }\n        }\n        x += pos.xAdvance * scale;\n    }\n    // Flush any remaining commands\n    flush(i);\n    // end the text object\n    ctx.addContent('ET');\n    // restore flipped coordinate system\n    return ctx.restore();\n};\nconst renderGlyphs = (ctx, glyphs, positions, x, y) => {\n    const scale = 1000 / ctx._fontSize;\n    const unitsPerEm = ctx._font.font.unitsPerEm || 1000;\n    const advanceWidthScale = 1000 / unitsPerEm;\n    // Glyph encoding and positioning\n    const encodedGlyphs = ctx._font.encodeGlyphs(glyphs);\n    const encodedPositions = positions.map((pos, i) => ({\n        xAdvance: pos.xAdvance * scale,\n        yAdvance: pos.yAdvance * scale,\n        xOffset: pos.xOffset,\n        yOffset: pos.yOffset,\n        advanceWidth: glyphs[i].advanceWidth * advanceWidthScale,\n    }));\n    return _renderGlyphs(ctx, encodedGlyphs, encodedPositions, x, y);\n};\n\nconst renderRun$1 = (ctx, run) => {\n    if (!run.glyphs)\n        return;\n    if (!run.positions)\n        return;\n    const runAdvanceWidth = run.xAdvance;\n    const font = run.attributes.font?.[0];\n    const { fontSize, color, opacity } = run.attributes;\n    if (color)\n        ctx.fillColor(color);\n    ctx.fillOpacity(opacity);\n    if (font) {\n        ctx.font(font.type === 'STANDARD' ? font.fullName : font, fontSize);\n    }\n    try {\n        renderGlyphs(ctx, run.glyphs, run.positions, 0, 0);\n    }\n    catch (error) {\n        console.log(error);\n    }\n    ctx.translate(runAdvanceWidth, 0);\n};\nconst renderSpan = (ctx, line, textAnchor, dominantBaseline) => {\n    ctx.save();\n    const x = line.box?.x || 0;\n    const y = line.box?.y || 0;\n    const font = line.runs[0]?.attributes.font?.[0];\n    const scale = line.runs[0]?.attributes?.scale || 1;\n    const width = line.xAdvance;\n    if (!font)\n        return;\n    const ascent = font.ascent * scale;\n    const xHeight = font.xHeight * scale;\n    const descent = font.descent * scale;\n    const capHeight = font.capHeight * scale;\n    let xTranslate = x;\n    let yTranslate = y;\n    switch (textAnchor) {\n        case 'middle':\n            xTranslate = x - width / 2;\n            break;\n        case 'end':\n            xTranslate = x - width;\n            break;\n        default:\n            xTranslate = x;\n            break;\n    }\n    switch (dominantBaseline) {\n        case 'middle':\n        case 'central':\n            yTranslate = y + capHeight / 2;\n            break;\n        case 'hanging':\n            yTranslate = y + capHeight;\n            break;\n        case 'mathematical':\n            yTranslate = y + xHeight;\n            break;\n        case 'text-after-edge':\n            yTranslate = y + descent;\n            break;\n        case 'text-before-edge':\n            yTranslate = y + ascent;\n            break;\n        default:\n            yTranslate = y;\n            break;\n    }\n    ctx.translate(xTranslate, yTranslate);\n    line.runs.forEach((run) => renderRun$1(ctx, run));\n    ctx.restore();\n};\nconst renderSvgText = (ctx, node) => {\n    const children = node.children;\n    children.forEach((span) => renderSpan(ctx, span.lines[0], span.props.textAnchor, span.props.dominantBaseline));\n};\n\nconst pairs = (values) => {\n    const result = [];\n    for (let i = 0; i < values.length; i += 2) {\n        result.push([values[i], values[i + 1]]);\n    }\n    return result;\n};\n/**\n * Parse svg-like points into number arrays\n *\n * @param points string ex. \"20,30 50,60\"\n * @returns points array ex. [[20, 30], [50, 60]]\n */\nconst parsePoints = (points) => {\n    let values = (points || '')\n        .trim()\n        .replace(/,/g, ' ')\n        .replace(/(\\d)-(\\d)/g, '$1 -$2')\n        .split(/\\s+/);\n    if (values.length % 2 !== 0) {\n        values = values.slice(0, -1);\n    }\n    const mappedValues = values.map(parseFloat);\n    return pairs(mappedValues);\n};\n\nconst drawPolyline = (ctx, points) => {\n    if (points.length > 0) {\n        ctx.moveTo(points[0][0], points[0][1]);\n        points.slice(1).forEach((p) => ctx.lineTo(p[0], p[1]));\n    }\n};\nconst renderPolyline = (ctx, node) => {\n    const points = parsePoints(node.props.points || '');\n    drawPolyline(ctx, points);\n};\n\nconst renderPolygon = (ctx, node) => {\n    const points = parsePoints(node.props.points || '');\n    drawPolyline(ctx, points);\n    ctx.closePath();\n};\n\nconst renderImage$1 = (ctx, node) => {\n    if (!node.box)\n        return;\n    if (!node.image?.data)\n        return;\n    const { x = 0, y = 0 } = node.props;\n    const { width, height, opacity } = node.style;\n    const paddingTop = node.box.paddingLeft || 0;\n    const paddingLeft = node.box.paddingLeft || 0;\n    if (width === 0 || height === 0) {\n        console.warn(`Image with src '${node.props.href}' skipped due to invalid dimensions`);\n        return;\n    }\n    if (typeof width === 'string' || typeof height === 'string') {\n        console.warn(`Image with src '${node.props.href}' skipped due to percentage width or height`);\n        return;\n    }\n    ctx.save();\n    ctx\n        .fillOpacity(opacity || 1)\n        .image(node.image.data, x + paddingLeft, y + paddingTop, {\n        width,\n        height,\n    });\n    ctx.restore();\n};\n\n// This constant is used to approximate a symmetrical arc using a cubic\n// Bezier curve.\nconst KAPPA$1 = 4.0 * ((Math.sqrt(2) - 1.0) / 3.0);\nconst clipNode = (ctx, node) => {\n    if (!node.box)\n        return;\n    if (!node.style)\n        return;\n    const { top, left, width, height } = node.box;\n    const { borderTopLeftRadius = 0, borderTopRightRadius = 0, borderBottomRightRadius = 0, borderBottomLeftRadius = 0, } = node.style;\n    // Border top\n    // @ts-expect-error this is always a number due to resolve border radius step\n    const rtr = Math.min(borderTopRightRadius, 0.5 * width, 0.5 * height);\n    const ctr = rtr * (1.0 - KAPPA$1);\n    ctx.moveTo(left + rtr, top);\n    ctx.lineTo(left + width - rtr, top);\n    ctx.bezierCurveTo(left + width - ctr, top, left + width, top + ctr, left + width, top + rtr);\n    // Border right\n    // @ts-expect-error this is always a number due to resolve border radius step\n    const rbr = Math.min(borderBottomRightRadius, 0.5 * width, 0.5 * height);\n    const cbr = rbr * (1.0 - KAPPA$1);\n    ctx.lineTo(left + width, top + height - rbr);\n    ctx.bezierCurveTo(left + width, top + height - cbr, left + width - cbr, top + height, left + width - rbr, top + height);\n    // Border bottom\n    // @ts-expect-error this is always a number due to resolve border radius step\n    const rbl = Math.min(borderBottomLeftRadius, 0.5 * width, 0.5 * height);\n    const cbl = rbl * (1.0 - KAPPA$1);\n    ctx.lineTo(left + rbl, top + height);\n    ctx.bezierCurveTo(left + cbl, top + height, left, top + height - cbl, left, top + height - rbl);\n    // Border left\n    // @ts-expect-error this is always a number due to resolve border radius step\n    const rtl = Math.min(borderTopLeftRadius, 0.5 * width, 0.5 * height);\n    const ctl = rtl * (1.0 - KAPPA$1);\n    ctx.lineTo(left, top + rtl);\n    ctx.bezierCurveTo(left, top + ctl, left + ctl, top, left + rtl, top);\n    ctx.closePath();\n    ctx.clip();\n};\n\nconst applySingleTransformation = (ctx, transform, origin) => {\n    const { operation, value } = transform;\n    switch (operation) {\n        case 'scale': {\n            const [scaleX, scaleY] = value;\n            ctx.scale(scaleX, scaleY, { origin });\n            break;\n        }\n        case 'rotate': {\n            const [angle] = value;\n            ctx.rotate(angle, { origin });\n            break;\n        }\n        case 'translate': {\n            const [x, y = 0] = value;\n            ctx.translate(x, y, { origin });\n            break;\n        }\n        case 'skew': {\n            const [xAngle = 0, yAngle = 0] = value;\n            const radx = (xAngle * Math.PI) / 180;\n            const rady = (yAngle * Math.PI) / 180;\n            const tanx = Math.tan(radx);\n            const tany = Math.tan(rady);\n            let x = 0;\n            let y = 0;\n            if (origin != null) {\n                [x, y] = Array.from(origin);\n                const x1 = x + tanx * y;\n                const y1 = y + tany * x;\n                x -= x1;\n                y -= y1;\n            }\n            ctx.transform(1, tany, tanx, 1, x, y);\n            break;\n        }\n        case 'matrix': {\n            ctx.transform(...value);\n            break;\n        }\n        default: {\n            console.error(`Transform operation: '${operation}' doesn't supported`);\n        }\n    }\n};\nconst applyTransformations = (ctx, node) => {\n    if (!node.origin)\n        return;\n    const { props, style } = node;\n    const origin = [node.origin.left, node.origin.top];\n    const propsTransform = 'transform' in props ? props.transform : undefined;\n    const operations = style?.transform || propsTransform || [];\n    operations.forEach((operation) => {\n        applySingleTransformation(ctx, operation, origin);\n    });\n};\n\n// From https://github.com/dy/svg-path-bounds/blob/master/index.js\nconst getPathBoundingBox = (node) => {\n    const path = normalizePath(absPath(parsePath(node.props?.d || '')));\n    if (!path.length)\n        return [0, 0, 0, 0];\n    const bounds = [Infinity, Infinity, -Infinity, -Infinity];\n    for (let i = 0, l = path.length; i < l; i += 1) {\n        const points = path[i].slice(1);\n        for (let j = 0; j < points.length; j += 2) {\n            if (points[j + 0] < bounds[0])\n                bounds[0] = points[j + 0];\n            if (points[j + 1] < bounds[1])\n                bounds[1] = points[j + 1];\n            if (points[j + 0] > bounds[2])\n                bounds[2] = points[j + 0];\n            if (points[j + 1] > bounds[3])\n                bounds[3] = points[j + 1];\n        }\n    }\n    return bounds;\n};\nconst getCircleBoundingBox = (node) => {\n    const r = node.props?.r || 0;\n    const cx = node.props?.cx || 0;\n    const cy = node.props?.cy || 0;\n    return [cx - r, cy - r, cx + r, cy + r];\n};\nconst getEllipseBoundingBox = (node) => {\n    const cx = node.props?.cx || 0;\n    const cy = node.props?.cy || 0;\n    const rx = node.props?.rx || 0;\n    const ry = node.props?.ry || 0;\n    return [cx - rx, cy - ry, cx + rx, cy + ry];\n};\nconst getLineBoundingBox = (node) => {\n    const x1 = node.props?.x1 || 0;\n    const y1 = node.props?.y1 || 0;\n    const x2 = node.props?.x2 || 0;\n    const y2 = node.props?.y2 || 0;\n    return [\n        Math.min(x1, x2),\n        Math.min(y1, y2),\n        Math.max(x1, x2),\n        Math.max(y1, y2),\n    ];\n};\nconst getRectBoundingBox = (node) => {\n    const x = node.props?.x || 0;\n    const y = node.props?.y || 0;\n    const width = node.props?.width || 0;\n    const height = node.props?.height || 0;\n    return [x, y, x + width, y + height];\n};\nconst max = (values) => Math.max(-Infinity, ...values);\nconst min = (values) => Math.min(Infinity, ...values);\nconst getPolylineBoundingBox = (node) => {\n    const points = parsePoints(node.props?.points);\n    const xValues = points.map((p) => p[0]);\n    const yValues = points.map((p) => p[1]);\n    return [min(xValues), min(yValues), max(xValues), max(yValues)];\n};\nconst boundingBoxFns = {\n    [P.Rect]: getRectBoundingBox,\n    [P.Line]: getLineBoundingBox,\n    [P.Path]: getPathBoundingBox,\n    [P.Circle]: getCircleBoundingBox,\n    [P.Ellipse]: getEllipseBoundingBox,\n    [P.Polygon]: getPolylineBoundingBox,\n    [P.Polyline]: getPolylineBoundingBox,\n};\nconst getBoundingBox = (node) => {\n    const boundingBoxFn = boundingBoxFns[node.type];\n    return boundingBoxFn ? boundingBoxFn(node) : [0, 0, 0, 0];\n};\n\nconst setStrokeWidth = (ctx, node) => {\n    if (!node.props)\n        return;\n    if (!('strokeWidth' in node.props))\n        return;\n    const lineWidth = node.props.strokeWidth;\n    if (lineWidth)\n        ctx.lineWidth(lineWidth);\n};\nconst setStrokeColor = (ctx, node) => {\n    if (!node.props)\n        return;\n    if (!('stroke' in node.props))\n        return;\n    const strokeColor = node.props.stroke;\n    if (strokeColor)\n        ctx.strokeColor(strokeColor);\n};\nconst setOpacity = (ctx, node) => {\n    if (!node.props)\n        return;\n    if (!('opacity' in node.props))\n        return;\n    const opacity = node.props.opacity;\n    if (!isNil(opacity))\n        ctx.opacity(opacity);\n};\nconst setFillOpacity = (ctx, node) => {\n    if (!node.props)\n        return;\n    if (!('fillOpacity' in node.props))\n        return;\n    const fillOpacity = node.props.fillOpacity || null;\n    if (!isNil(fillOpacity))\n        ctx.fillOpacity(fillOpacity);\n};\nconst setStrokeOpacity = (ctx, node) => {\n    if (!node.props)\n        return;\n    if (!('strokeOpacity' in node.props))\n        return;\n    const strokeOpacity = node.props?.strokeOpacity;\n    if (!isNil(strokeOpacity))\n        ctx.strokeOpacity(strokeOpacity);\n};\nconst setLineJoin = (ctx, node) => {\n    if (!node.props)\n        return;\n    if (!('strokeLinejoin' in node.props))\n        return;\n    const lineJoin = node.props.strokeLinejoin;\n    if (lineJoin)\n        ctx.lineJoin(lineJoin);\n};\nconst setLineCap = (ctx, node) => {\n    if (!node.props)\n        return;\n    if (!('strokeLinecap' in node.props))\n        return;\n    const lineCap = node.props?.strokeLinecap;\n    if (lineCap)\n        ctx.lineCap(lineCap);\n};\nconst setLineDash = (ctx, node) => {\n    if (!node.props)\n        return;\n    if (!('strokeDasharray' in node.props))\n        return;\n    const value = node.props?.strokeDasharray || null;\n    // @ts-expect-error check this works as expected\n    if (value)\n        ctx.dash(value.split(/[\\s,]+/).map(Number));\n};\nconst hasLinearGradientFill = (node) => {\n    if (!node.props)\n        return false;\n    if (!('fill' in node.props))\n        return false;\n    if (typeof node.props.fill === 'string')\n        return false;\n    return node.props.fill?.type === P.LinearGradient;\n};\nconst hasRadialGradientFill = (node) => {\n    if (!node.props)\n        return false;\n    if (!('fill' in node.props))\n        return false;\n    if (typeof node.props.fill === 'string')\n        return false;\n    return node.props.fill?.type === P.RadialGradient;\n};\nfunction multiplyMatrices(m1, m2) {\n    const a = m1[0] * m2[0] + m1[2] * m2[1];\n    const b = m1[1] * m2[0] + m1[3] * m2[1];\n    const c = m1[0] * m2[2] + m1[2] * m2[3];\n    const d = m1[1] * m2[2] + m1[3] * m2[3];\n    const e = m1[0] * m2[4] + m1[2] * m2[5] + m1[4];\n    const f = m1[1] * m2[4] + m1[3] * m2[5] + m1[5];\n    return [a, b, c, d, e, f];\n}\nconst transformGradient = (grad, transforms, bbox, units) => {\n    const matrices = transforms.map((transform) => {\n        switch (transform.operation) {\n            case 'scale': {\n                const value = transform.value;\n                return [value[0], 0, 0, value[1], 0, 0];\n            }\n            case 'translate': {\n                const value = transform.value;\n                let x = value[0] || 0;\n                let y = value[1] || 0;\n                if (units === 'objectBoundingBox') {\n                    x = (bbox[2] - bbox[0]) * x;\n                    y = (bbox[3] - bbox[1]) * y;\n                }\n                return [1, 0, 0, 1, x, y];\n            }\n            case 'rotate': {\n                const value = transform.value;\n                const cos = Math.cos(value[0]);\n                const sin = Math.sin(value[0]);\n                return [cos, sin, -sin, cos, 0, 0];\n            }\n            case 'skew': {\n                const value = transform.value;\n                return [1, Math.tan(value[0]), Math.tan(value[1]), 1, 0, 0];\n            }\n            case 'matrix': {\n                const value = transform.value;\n                let x = value[4] || 0;\n                let y = value[5] || 0;\n                if (units === 'objectBoundingBox') {\n                    x = (bbox[2] - bbox[0]) * x;\n                    y = (bbox[3] - bbox[1]) * y;\n                }\n                return [value[0], value[1], value[2], value[3], x, y];\n            }\n            default:\n                return [1, 0, 0, 1, 0, 0];\n        }\n    });\n    const matrix = matrices.reduce(multiplyMatrices, [1, 0, 0, 1, 0, 0]);\n    grad.setTransform(...matrix);\n};\n// Math simplified from https://github.com/devongovett/svgkit/blob/master/src/elements/SVGGradient.js#L104\nconst setLinearGradientFill = (ctx, node) => {\n    if (!node.props)\n        return;\n    if (!('fill' in node.props))\n        return;\n    const bbox = getBoundingBox(node);\n    const gradient = node.props?.fill;\n    if (!gradient)\n        return;\n    const units = gradient.props.gradientUnits || 'objectBoundingBox';\n    const transforms = gradient.props.gradientTransform || [];\n    let x1 = gradient.props.x1 || 0;\n    let y1 = gradient.props.y1 || 0;\n    let x2 = gradient.props.x2 || 1;\n    let y2 = gradient.props.y2 || 0;\n    if (units === 'objectBoundingBox') {\n        const m0 = bbox[2] - bbox[0];\n        const m3 = bbox[3] - bbox[1];\n        const m4 = bbox[0];\n        const m5 = bbox[1];\n        x1 = m0 * x1 + m4;\n        y1 = m3 * y1 + m5;\n        x2 = m0 * x2 + m4;\n        y2 = m3 * y2 + m5;\n    }\n    const grad = ctx.linearGradient(x1, y1, x2, y2);\n    transformGradient(grad, transforms, bbox, units);\n    gradient.children?.forEach((stop) => {\n        grad.stop(stop.props.offset, stop.props.stopColor, stop.props.stopOpacity);\n    });\n    ctx.fill(grad);\n};\n// Math simplified from https://github.com/devongovett/svgkit/blob/master/src/elements/SVGGradient.js#L155\nconst setRadialGradientFill = (ctx, node) => {\n    if (!node.props)\n        return;\n    if (!('fill' in node.props))\n        return;\n    const bbox = getBoundingBox(node);\n    const gradient = node.props?.fill;\n    if (!gradient)\n        return;\n    const units = gradient.props.gradientUnits || 'objectBoundingBox';\n    const transforms = gradient.props.gradientTransform || [];\n    let r = gradient.props.r || 0.5;\n    let cx = gradient.props.cx || 0.5;\n    let cy = gradient.props.cy || 0.5;\n    let fx = gradient.props.fx || cx;\n    let fy = gradient.props.fy || cy;\n    if (units === 'objectBoundingBox') {\n        const m0 = bbox[2] - bbox[0];\n        const m3 = bbox[3] - bbox[1];\n        const m4 = bbox[0];\n        const m5 = bbox[1];\n        r = r * m0;\n        cx = m0 * cx + m4;\n        cy = m3 * cy + m5;\n        fx = m0 * fx + m4;\n        fy = m3 * fy + m5;\n    }\n    const grad = ctx.radialGradient(cx, cy, 0, fx, fy, r);\n    transformGradient(grad, transforms, bbox, units);\n    gradient.children?.forEach((stop) => {\n        grad.stop(stop.props.offset, stop.props.stopColor, stop.props.stopOpacity);\n    });\n    ctx.fill(grad);\n};\nconst setFillColor = (ctx, node) => {\n    if (!node.props)\n        return;\n    if (!('fill' in node.props))\n        return;\n    const fillColor = node.props?.fill;\n    if (fillColor)\n        ctx.fillColor(fillColor);\n};\nconst setFill = (ctx, node) => {\n    if (hasLinearGradientFill(node))\n        return setLinearGradientFill(ctx, node);\n    if (hasRadialGradientFill(node))\n        return setRadialGradientFill(ctx, node);\n    return setFillColor(ctx, node);\n};\nconst draw = (ctx, node) => {\n    const props = node.props || {};\n    if ('fill' in props && 'stroke' in props && props.fill && props.stroke) {\n        ctx.fillAndStroke(props.fillRule);\n    }\n    else if ('fill' in props && props.fill) {\n        ctx.fill(props.fillRule);\n    }\n    else if ('stroke' in props && props.stroke) {\n        ctx.stroke();\n    }\n    else {\n        ctx.save();\n        ctx.opacity(0);\n        ctx.fill(null);\n        ctx.restore();\n    }\n};\nconst noop = () => { };\nconst renderFns$1 = {\n    [P.Tspan]: noop,\n    [P.TextInstance]: noop,\n    [P.Path]: renderPath,\n    [P.Rect]: renderRect,\n    [P.Line]: renderLine$1,\n    [P.G]: renderGroup,\n    [P.Text]: renderSvgText,\n    [P.Circle]: renderCircle,\n    [P.Image]: renderImage$1,\n    [P.Ellipse]: renderEllipse,\n    [P.Polygon]: renderPolygon,\n    [P.Polyline]: renderPolyline,\n};\nconst renderNode$1 = (ctx, node) => {\n    const renderFn = renderFns$1[node.type];\n    if (renderFn) {\n        renderFn(ctx, node);\n    }\n    else {\n        console.warn(`SVG node of type ${node.type} is not currently supported`);\n    }\n};\nconst drawNode = (ctx, node) => {\n    setLineCap(ctx, node);\n    setLineDash(ctx, node);\n    setLineJoin(ctx, node);\n    setStrokeWidth(ctx, node);\n    setStrokeColor(ctx, node);\n    setFill(ctx, node);\n    setStrokeOpacity(ctx, node);\n    setFillOpacity(ctx, node);\n    setOpacity(ctx, node);\n    applyTransformations(ctx, node);\n    renderNode$1(ctx, node);\n    draw(ctx, node);\n};\nconst clipPath = (ctx, node) => {\n    if (!node.props)\n        return;\n    if (!('clipPath' in node.props))\n        return;\n    const value = node.props.clipPath;\n    if (value) {\n        const children = value.children || [];\n        children.forEach((child) => renderNode$1(ctx, child));\n        ctx.clip();\n    }\n};\nconst drawChildren = (ctx, node) => {\n    const children = node.children || [];\n    children.forEach((child) => {\n        ctx.save();\n        clipPath(ctx, child);\n        drawNode(ctx, child);\n        drawChildren(ctx, child);\n        ctx.restore();\n    });\n};\nconst resolveAspectRatio = (ctx, node) => {\n    if (!node.box)\n        return;\n    const { width, height } = node.box;\n    const { viewBox, preserveAspectRatio } = node.props;\n    const { meetOrSlice = 'meet', align = 'xMidYMid' } = preserveAspectRatio || {};\n    if (viewBox == null || width == null || height == null)\n        return;\n    const x = viewBox?.minX || 0;\n    const y = viewBox?.minY || 0;\n    const logicalWidth = viewBox?.maxX || width;\n    const logicalHeight = viewBox?.maxY || height;\n    const logicalRatio = logicalWidth / logicalHeight;\n    const physicalRatio = width / height;\n    const scaleX = width / logicalWidth;\n    const scaleY = height / logicalHeight;\n    if (align === 'none') {\n        ctx.scale(scaleX, scaleY);\n        ctx.translate(-x, -y);\n        return;\n    }\n    if ((logicalRatio < physicalRatio && meetOrSlice === 'meet') ||\n        (logicalRatio >= physicalRatio && meetOrSlice === 'slice')) {\n        ctx.scale(scaleY, scaleY);\n        switch (align) {\n            case 'xMinYMin':\n            case 'xMinYMid':\n            case 'xMinYMax':\n                ctx.translate(-x, -y);\n                break;\n            case 'xMidYMin':\n            case 'xMidYMid':\n            case 'xMidYMax':\n                ctx.translate(-x - (logicalWidth - (width * logicalHeight) / height) / 2, -y);\n                break;\n            default:\n                ctx.translate(-x - (logicalWidth - (width * logicalHeight) / height), -y);\n        }\n    }\n    else {\n        ctx.scale(scaleX, scaleX);\n        switch (align) {\n            case 'xMinYMin':\n            case 'xMidYMin':\n            case 'xMaxYMin':\n                ctx.translate(-x, -y);\n                break;\n            case 'xMinYMid':\n            case 'xMidYMid':\n            case 'xMaxYMid':\n                ctx.translate(-x, -y - (logicalHeight - (height * logicalWidth) / width) / 2);\n                break;\n            default:\n                ctx.translate(-x, -y - (logicalHeight - (height * logicalWidth) / width));\n        }\n    }\n};\nconst moveToOrigin = (ctx, node) => {\n    if (!node.box)\n        return;\n    const { top, left } = node.box;\n    const paddingLeft = node.box.paddingLeft || 0;\n    const paddingTop = node.box.paddingTop || 0;\n    ctx.translate(left + paddingLeft, top + paddingTop);\n};\nconst renderSvg = (ctx, node) => {\n    ctx.save();\n    clipNode(ctx, node);\n    moveToOrigin(ctx, node);\n    resolveAspectRatio(ctx, node);\n    drawChildren(ctx, node);\n    ctx.restore();\n};\n\nconst black = { value: '#000', opacity: 1 };\n// TODO: parse to number[] in layout to avoid this step\nconst parseColor = (hex) => {\n    if (!hex)\n        return black;\n    const parsed = colorString.get(hex);\n    if (!parsed)\n        return black;\n    const value = colorString.to.hex(parsed.value.slice(0, 3));\n    const opacity = parsed.value[3];\n    return { value, opacity };\n};\n\nconst DEST_REGEXP = /^#.+/;\nconst isSrcId$1 = (src) => src.match(DEST_REGEXP);\nconst renderAttachment = (ctx, attachment) => {\n    const { xOffset = 0, yOffset = 0, width, height, image } = attachment;\n    ctx.translate(-width + xOffset, -height + yOffset);\n    ctx.image(image, 0, 0, {\n        fit: [width, height],\n        align: 'center',\n        valign: 'bottom',\n    });\n};\nconst renderAttachments = (ctx, run) => {\n    if (!run.glyphs)\n        return;\n    if (!run.positions)\n        return;\n    const font = run.attributes.font?.[0];\n    if (!font)\n        return;\n    ctx.save();\n    const space = font.glyphForCodePoint(0x20);\n    const objectReplacement = font.glyphForCodePoint(0xfffc);\n    let attachmentAdvance = 0;\n    for (let i = 0; i < run.glyphs.length; i += 1) {\n        const position = run.positions[i];\n        const glyph = run.glyphs[i];\n        attachmentAdvance += position.xAdvance || 0;\n        if (glyph.id === objectReplacement.id && run.attributes.attachment) {\n            ctx.translate(attachmentAdvance, position.yOffset || 0);\n            renderAttachment(ctx, run.attributes.attachment);\n            run.glyphs[i] = space;\n            attachmentAdvance = 0;\n        }\n    }\n    ctx.restore();\n};\nconst renderRun = (ctx, run) => {\n    if (!run.glyphs)\n        return;\n    if (!run.positions)\n        return;\n    const font = run.attributes.font?.[0];\n    if (!font)\n        return;\n    const { fontSize, link } = run.attributes;\n    const color = parseColor(run.attributes.color);\n    const opacity = isNil(run.attributes.opacity)\n        ? color.opacity\n        : run.attributes.opacity;\n    const { height = 0, descent = 0, xAdvance = 0 } = run;\n    ctx.fillColor(color.value);\n    ctx.fillOpacity(opacity);\n    if (link) {\n        if (isSrcId$1(link)) {\n            ctx.goTo(0, -height - descent, xAdvance, height, link.slice(1));\n        }\n        else {\n            ctx.link(0, -height - descent, xAdvance, height, link);\n        }\n    }\n    renderAttachments(ctx, run);\n    ctx.font(font.type === 'STANDARD' ? font.fullName : font, fontSize);\n    try {\n        renderGlyphs(ctx, run.glyphs, run.positions, 0, 0);\n    }\n    catch (error) {\n        console.log(error);\n    }\n    ctx.translate(xAdvance, 0);\n};\nconst renderBackground$1 = (ctx, rect, backgroundColor) => {\n    const color = parseColor(backgroundColor);\n    ctx.save();\n    ctx.fillOpacity(color.opacity);\n    ctx.rect(rect.x, rect.y, rect.width, rect.height);\n    ctx.fill(color.value);\n    ctx.restore();\n};\nconst renderDecorationLine = (ctx, decorationLine) => {\n    ctx.save();\n    ctx.lineWidth(decorationLine.rect.height);\n    ctx.strokeOpacity(decorationLine.opacity);\n    if (/dashed/.test(decorationLine.style)) {\n        ctx.dash(3 * decorationLine.rect.height, {});\n    }\n    else if (/dotted/.test(decorationLine.style)) {\n        ctx.dash(decorationLine.rect.height, {});\n    }\n    if (/wavy/.test(decorationLine.style)) {\n        const dist = Math.max(2, decorationLine.rect.height);\n        let step = 1.1 * dist;\n        const stepCount = Math.floor(decorationLine.rect.width / (2 * step));\n        // Adjust step to fill entire width\n        const remainingWidth = decorationLine.rect.width - stepCount * 2 * step;\n        const adjustment = remainingWidth / stepCount / 2;\n        step += adjustment;\n        const cp1y = decorationLine.rect.y + dist;\n        const cp2y = decorationLine.rect.y - dist;\n        let { x } = decorationLine.rect;\n        ctx.moveTo(decorationLine.rect.x, decorationLine.rect.y);\n        for (let i = 0; i < stepCount; i += 1) {\n            ctx.bezierCurveTo(x + step, cp1y, x + step, cp2y, x + 2 * step, decorationLine.rect.y);\n            x += 2 * step;\n        }\n    }\n    else {\n        ctx.moveTo(decorationLine.rect.x, decorationLine.rect.y);\n        ctx.lineTo(decorationLine.rect.x + decorationLine.rect.width, decorationLine.rect.y);\n        if (/double/.test(decorationLine.style)) {\n            ctx.moveTo(decorationLine.rect.x, decorationLine.rect.y + decorationLine.rect.height * 2);\n            ctx.lineTo(decorationLine.rect.x + decorationLine.rect.width, decorationLine.rect.y + decorationLine.rect.height * 2);\n        }\n    }\n    ctx.stroke(decorationLine.color);\n    ctx.restore();\n};\nconst renderLine = (ctx, line) => {\n    if (!line.box)\n        return;\n    const lineAscent = line.ascent || 0;\n    ctx.save();\n    ctx.translate(line.box.x, line.box.y + lineAscent);\n    for (let i = 0; i < line.runs.length; i += 1) {\n        const run = line.runs[i];\n        const isLastRun = i === line.runs.length - 1;\n        if (run.attributes.backgroundColor) {\n            const xAdvance = run.xAdvance ?? 0;\n            const overflowRight = isLastRun ? line.overflowRight ?? 0 : 0;\n            const backgroundRect = {\n                x: 0,\n                y: -lineAscent,\n                height: line.box.height,\n                width: xAdvance - overflowRight,\n            };\n            renderBackground$1(ctx, backgroundRect, run.attributes.backgroundColor);\n        }\n        renderRun(ctx, run);\n    }\n    ctx.restore();\n    ctx.save();\n    ctx.translate(line.box.x, line.box.y);\n    if (line.decorationLines) {\n        for (let i = 0; i < line.decorationLines.length; i += 1) {\n            const decorationLine = line.decorationLines[i];\n            renderDecorationLine(ctx, decorationLine);\n        }\n    }\n    ctx.restore();\n};\nconst renderBlock = (ctx, block) => {\n    block.forEach((line) => {\n        renderLine(ctx, line);\n    });\n};\nconst renderText = (ctx, node) => {\n    if (!node.box)\n        return;\n    if (!node.lines)\n        return;\n    const { top, left } = node.box;\n    const blocks = [node.lines];\n    const paddingTop = node.box?.paddingTop || 0;\n    const paddingLeft = node.box?.paddingLeft || 0;\n    const initialY = node.lines[0] ? node.lines[0].box.y : 0;\n    const offsetX = node.alignOffset || 0;\n    ctx.save();\n    ctx.translate(left + paddingLeft - offsetX, top + paddingTop - initialY);\n    blocks.forEach((block) => {\n        renderBlock(ctx, block);\n    });\n    ctx.restore();\n};\n\nconst renderPage = (ctx, node) => {\n    if (!node.box)\n        return;\n    const { width, height } = node.box;\n    const dpi = node.props?.dpi || 72;\n    const userUnit = dpi / 72;\n    ctx.addPage({ size: [width, height], margin: 0, userUnit });\n};\n\nconst renderNote = (ctx, node) => {\n    if (!node.box)\n        return;\n    const { top, left } = node.box;\n    const value = node?.children?.[0].value || '';\n    const color = node.style?.backgroundColor;\n    ctx.note(left, top, 0, 0, value, { color });\n};\n\nconst embedImage = (ctx, node) => {\n    const src = node.image.data;\n    let image;\n    if (typeof src === 'string') {\n        image = ctx._imageRegistry[src];\n    }\n    if (!image) {\n        image = ctx.openImage(src);\n    }\n    if (!image.obj) {\n        image.embed(ctx);\n    }\n    return image;\n};\n\nconst isNumeric = (n) => {\n    return !Number.isNaN(parseFloat(n)) && Number.isFinite(n);\n};\nconst applyContainObjectFit = (cw, ch, iw, ih, px, py) => {\n    const cr = cw / ch;\n    const ir = iw / ih;\n    const pxp = matchPercent(px ?? null);\n    const pyp = matchPercent(py ?? null);\n    const pxv = pxp ? pxp.percent : 0.5;\n    const pyv = pyp ? pyp.percent : 0.5;\n    if (cr > ir) {\n        const height = ch;\n        const width = height * ir;\n        const yOffset = isNumeric(py) ? py : 0;\n        const xOffset = isNumeric(px) ? px : (cw - width) * pxv;\n        return { width, height, xOffset, yOffset };\n    }\n    const width = cw;\n    const height = width / ir;\n    const xOffset = isNumeric(px) ? px : 0;\n    const yOffset = isNumeric(py) ? py : (ch - height) * pyv;\n    return { width, height, yOffset, xOffset };\n};\nconst applyNoneObjectFit = (cw, ch, iw, ih, px, py) => {\n    const width = iw;\n    const height = ih;\n    const pxp = matchPercent(px ?? null);\n    const pyp = matchPercent(py ?? null);\n    const pxv = pxp ? pxp.percent : 0.5;\n    const pyv = pyp ? pyp.percent : 0.5;\n    const xOffset = isNumeric(px) ? px : (cw - width) * pxv;\n    const yOffset = isNumeric(py) ? py : (ch - height) * pyv;\n    return { width, height, xOffset, yOffset };\n};\nconst applyCoverObjectFit = (cw, ch, iw, ih, px, py) => {\n    const ir = iw / ih;\n    const cr = cw / ch;\n    const pxp = matchPercent(px ?? null);\n    const pyp = matchPercent(py ?? null);\n    const pxv = pxp ? pxp.percent : 0.5;\n    const pyv = pyp ? pyp.percent : 0.5;\n    if (cr > ir) {\n        const width = cw;\n        const height = width / ir;\n        const xOffset = isNumeric(px) ? px : 0;\n        const yOffset = isNumeric(py) ? py : (ch - height) * pyv;\n        return { width, height, yOffset, xOffset };\n    }\n    const height = ch;\n    const width = height * ir;\n    const xOffset = isNumeric(px) ? px : (cw - width) * pxv;\n    const yOffset = isNumeric(py) ? py : 0;\n    return { width, height, xOffset, yOffset };\n};\nconst applyScaleDownObjectFit = (cw, ch, iw, ih, px, py) => {\n    const containDimension = applyContainObjectFit(cw, ch, iw, ih, px, py);\n    const noneDimension = applyNoneObjectFit(cw, ch, iw, ih, px, py);\n    return containDimension.width < noneDimension.width\n        ? containDimension\n        : noneDimension;\n};\nconst applyFillObjectFit = (cw, ch, px, py) => {\n    return {\n        width: cw,\n        height: ch,\n        xOffset: matchPercent(px ?? null) ? 0 : px || 0,\n        yOffset: matchPercent(py ?? null) ? 0 : py || 0,\n    };\n};\nconst resolveObjectFit = (type = 'fill', cw, ch, iw, ih, px, py) => {\n    switch (type) {\n        case 'contain':\n            return applyContainObjectFit(cw, ch, iw, ih, px, py);\n        case 'cover':\n            return applyCoverObjectFit(cw, ch, iw, ih, px, py);\n        case 'none':\n            return applyNoneObjectFit(cw, ch, iw, ih, px, py);\n        case 'scale-down':\n            return applyScaleDownObjectFit(cw, ch, iw, ih, px, py);\n        default:\n            return applyFillObjectFit(cw, ch, px, py);\n    }\n};\n\nconst drawImage = (ctx, node, options) => {\n    if (!node.box)\n        return;\n    if (!node.image)\n        return;\n    const { left, top } = node.box;\n    const opacity = node.style?.opacity;\n    const objectFit = node.style?.objectFit;\n    const objectPositionX = node.style?.objectPositionX;\n    const objectPositionY = node.style?.objectPositionY;\n    const paddingTop = node.box.paddingTop || 0;\n    const paddingRight = node.box.paddingRight || 0;\n    const paddingBottom = node.box.paddingBottom || 0;\n    const paddingLeft = node.box.paddingLeft || 0;\n    const imageCache = options.imageCache || new Map();\n    const { width, height, xOffset, yOffset } = resolveObjectFit(objectFit, node.box.width - paddingLeft - paddingRight, node.box.height - paddingTop - paddingBottom, node.image.width, node.image.height, objectPositionX, objectPositionY);\n    if (node.image.data) {\n        if (width !== 0 && height !== 0) {\n            const cacheKey = node.image.key;\n            const image = imageCache.get(cacheKey) || embedImage(ctx, node);\n            if (cacheKey)\n                imageCache.set(cacheKey, image);\n            const imageOpacity = isNil(opacity) ? 1 : opacity;\n            ctx\n                .fillOpacity(imageOpacity)\n                .image(image, left + paddingLeft + xOffset, top + paddingTop + yOffset, {\n                width,\n                height,\n            });\n        }\n        else {\n            console.warn(`Image with src '${JSON.stringify(node.props.src || node.props.source)}' skipped due to invalid dimensions`);\n        }\n    }\n};\nconst renderImage = (ctx, node, options) => {\n    ctx.save();\n    clipNode(ctx, node);\n    drawImage(ctx, node, options);\n    ctx.restore();\n};\n\nconst CONTENT_COLOR = '#a1c6e7';\nconst PADDING_COLOR = '#c4deb9';\nconst MARGIN_COLOR = '#f8cca1';\n// TODO: Draw debug boxes using clipping to enhance quality\nconst debugContent = (ctx, node) => {\n    if (!node.box)\n        return;\n    const { left, top, width, height, paddingLeft = 0, paddingTop = 0, paddingRight = 0, paddingBottom = 0, borderLeftWidth = 0, borderTopWidth = 0, borderRightWidth = 0, borderBottomWidth = 0, } = node.box;\n    ctx\n        .fillColor(CONTENT_COLOR)\n        .opacity(0.5)\n        .rect(left + paddingLeft + borderLeftWidth, top + paddingTop + borderTopWidth, width - paddingLeft - paddingRight - borderRightWidth - borderLeftWidth, height - paddingTop - paddingBottom - borderTopWidth - borderBottomWidth)\n        .fill();\n};\nconst debugPadding = (ctx, node) => {\n    if (!node.box)\n        return;\n    const { left, top, width, height, paddingLeft = 0, paddingTop = 0, paddingRight = 0, paddingBottom = 0, borderLeftWidth = 0, borderTopWidth = 0, borderRightWidth = 0, borderBottomWidth = 0, } = node.box;\n    ctx.fillColor(PADDING_COLOR).opacity(0.5);\n    // Padding top\n    ctx\n        .rect(left + paddingLeft + borderLeftWidth, top + borderTopWidth, width - paddingRight - paddingLeft - borderLeftWidth - borderRightWidth, paddingTop)\n        .fill();\n    // Padding left\n    ctx\n        .rect(left + borderLeftWidth, top + borderTopWidth, paddingLeft, height - borderTopWidth - borderBottomWidth)\n        .fill();\n    // Padding right\n    ctx\n        .rect(left + width - paddingRight - borderRightWidth, top + borderTopWidth, paddingRight, height - borderTopWidth - borderBottomWidth)\n        .fill();\n    // Padding bottom\n    ctx\n        .rect(left + paddingLeft + borderLeftWidth, top + height - paddingBottom - borderBottomWidth, width - paddingRight - paddingLeft - borderLeftWidth - borderRightWidth, paddingBottom)\n        .fill();\n};\nconst debugMargin = (ctx, node) => {\n    if (!node.box)\n        return;\n    const { left, top, width, height } = node.box;\n    const { marginLeft = 0, marginTop = 0, marginRight = 0, marginBottom = 0, } = node.box;\n    ctx.fillColor(MARGIN_COLOR).opacity(0.5);\n    // Margin top\n    ctx.rect(left, top - marginTop, width, marginTop).fill();\n    // Margin left\n    ctx\n        .rect(left - marginLeft, top - marginTop, marginLeft, height + marginTop + marginBottom)\n        .fill();\n    // Margin right\n    ctx\n        .rect(left + width, top - marginTop, marginRight, height + marginTop + marginBottom)\n        .fill();\n    // Margin bottom\n    ctx.rect(left, top + height, width, marginBottom).fill();\n};\nconst debugText = (ctx, node) => {\n    if (!node.box)\n        return;\n    const { left, top, width, height } = node.box;\n    const { marginLeft = 0, marginTop = 0, marginRight = 0, marginBottom = 0, } = node.box;\n    const roundedWidth = Math.round(width + marginLeft + marginRight);\n    const roundedHeight = Math.round(height + marginTop + marginBottom);\n    ctx\n        .fontSize(6)\n        .opacity(1)\n        .fillColor('black')\n        .text(`${roundedWidth} x ${roundedHeight}`, left - marginLeft, Math.max(top - marginTop - 4, 1), { width: Infinity });\n};\nconst debugOrigin = (ctx, node) => {\n    if (node.origin) {\n        ctx\n            .circle(node.origin.left, node.origin.top, 3)\n            .fill('red')\n            .circle(node.origin.left, node.origin.top, 5)\n            .stroke('red');\n    }\n};\nconst renderDebug = (ctx, node) => {\n    if (!node.props)\n        return;\n    if (!('debug' in node.props) || !node.props.debug)\n        return;\n    ctx.save();\n    debugContent(ctx, node);\n    debugPadding(ctx, node);\n    debugMargin(ctx, node);\n    debugText(ctx, node);\n    debugOrigin(ctx, node);\n    ctx.restore();\n};\n\nconst availableMethods = [\n    'dash',\n    'clip',\n    'save',\n    'path',\n    'fill',\n    'font',\n    'text',\n    'rect',\n    'scale',\n    'moveTo',\n    'lineTo',\n    'stroke',\n    'rotate',\n    'circle',\n    'lineCap',\n    'opacity',\n    'ellipse',\n    'polygon',\n    'restore',\n    'lineJoin',\n    'fontSize',\n    'fillColor',\n    'lineWidth',\n    'translate',\n    'miterLimit',\n    'strokeColor',\n    'fillOpacity',\n    'roundedRect',\n    'fillAndStroke',\n    'strokeOpacity',\n    'bezierCurveTo',\n    'quadraticCurveTo',\n    'linearGradient',\n    'radialGradient',\n];\nconst painter = (ctx) => {\n    const p = availableMethods.reduce((acc, prop) => ({\n        ...acc,\n        [prop]: (...args) => {\n            // @ts-expect-error ctx[prop] is a function\n            ctx[prop](...args);\n            return p;\n        },\n    }), {});\n    return p;\n};\nconst renderCanvas = (ctx, node) => {\n    if (!node.box)\n        return;\n    const { top, left, width, height } = node.box;\n    const paddingTop = node.box.paddingTop || 0;\n    const paddingLeft = node.box.paddingLeft || 0;\n    const paddingRight = node.box.paddingRight || 0;\n    const paddingBottom = node.box.paddingBottom || 0;\n    const availableWidth = width - paddingLeft - paddingRight;\n    const availableHeight = height - paddingTop - paddingBottom;\n    if (!availableWidth || !availableHeight) {\n        console.warn('Canvas element has null width or height. Please provide valid values via the `style` prop in order to correctly render it.');\n    }\n    ctx.save().translate(left + paddingLeft, top + paddingTop);\n    if (node.props.paint) {\n        node.props.paint(painter(ctx), availableWidth, availableHeight);\n    }\n    ctx.restore();\n};\n\n// Ref: https://www.w3.org/TR/css-backgrounds-3/#borders\n// This constant is used to approximate a symmetrical arc using a cubic Bezier curve.\nconst KAPPA = 4.0 * ((Math.sqrt(2) - 1.0) / 3.0);\nconst clipBorderTop = (ctx, layout, style, rtr, rtl) => {\n    const { top, left, width, height } = layout;\n    const { borderTopWidth, borderRightWidth, borderLeftWidth } = style;\n    // Clip outer top border edge\n    ctx.moveTo(left + rtl, top);\n    ctx.lineTo(left + width - rtr, top);\n    // Ellipse coefficients outer top right cap\n    const c0 = rtr * (1.0 - KAPPA);\n    // Clip outer top right cap\n    ctx.bezierCurveTo(left + width - c0, top, left + width, top + c0, left + width, top + rtr);\n    // Move down in case the margin exceedes the radius\n    const topRightYCoord = top + Math.max(borderTopWidth, rtr);\n    ctx.lineTo(left + width, topRightYCoord);\n    // Clip inner top right cap\n    ctx.lineTo(left + width - borderRightWidth, topRightYCoord);\n    // Ellipse coefficients inner top right cap\n    const innerTopRightRadiusX = Math.max(rtr - borderRightWidth, 0);\n    const innerTopRightRadiusY = Math.max(rtr - borderTopWidth, 0);\n    const c1 = innerTopRightRadiusX * (1.0 - KAPPA);\n    const c2 = innerTopRightRadiusY * (1.0 - KAPPA);\n    // Clip inner top right cap\n    ctx.bezierCurveTo(left + width - borderRightWidth, top + borderTopWidth + c2, left + width - borderRightWidth - c1, top + borderTopWidth, left + width - borderRightWidth - innerTopRightRadiusX, top + borderTopWidth);\n    // Clip inner top border edge\n    ctx.lineTo(left + Math.max(rtl, borderLeftWidth), top + borderTopWidth);\n    // Ellipse coefficients inner top left cap\n    const innerTopLeftRadiusX = Math.max(rtl - borderLeftWidth, 0);\n    const innerTopLeftRadiusY = Math.max(rtl - borderTopWidth, 0);\n    const c3 = innerTopLeftRadiusX * (1.0 - KAPPA);\n    const c4 = innerTopLeftRadiusY * (1.0 - KAPPA);\n    const topLeftYCoord = top + Math.max(borderTopWidth, rtl);\n    // Clip inner top left cap\n    ctx.bezierCurveTo(left + borderLeftWidth + c3, top + borderTopWidth, left + borderLeftWidth, top + borderTopWidth + c4, left + borderLeftWidth, topLeftYCoord);\n    ctx.lineTo(left, topLeftYCoord);\n    // Move down in case the margin exceedes the radius\n    ctx.lineTo(left, top + rtl);\n    // Ellipse coefficients outer top left cap\n    const c5 = rtl * (1.0 - KAPPA);\n    // Clip outer top left cap\n    ctx.bezierCurveTo(left, top + c5, left + c5, top, left + rtl, top);\n    ctx.closePath();\n    ctx.clip();\n    // Clip border top cap joins\n    if (borderRightWidth) {\n        const trSlope = -borderTopWidth / borderRightWidth;\n        ctx.moveTo(left + width / 2, trSlope * (-width / 2) + top);\n        ctx.lineTo(left + width, top);\n        ctx.lineTo(left, top);\n        ctx.lineTo(left, top + height);\n        ctx.closePath();\n        ctx.clip();\n    }\n    if (borderLeftWidth) {\n        const trSlope = -borderTopWidth / borderLeftWidth;\n        ctx.moveTo(left + width / 2, trSlope * (-width / 2) + top);\n        ctx.lineTo(left, top);\n        ctx.lineTo(left + width, top);\n        ctx.lineTo(left + width, top + height);\n        ctx.closePath();\n        ctx.clip();\n    }\n};\nconst fillBorderTop = (ctx, layout, style, rtr, rtl) => {\n    const { top, left, width } = layout;\n    const { borderTopColor, borderTopWidth, borderTopStyle, borderRightWidth, borderLeftWidth, } = style;\n    const c0 = rtl * (1.0 - KAPPA);\n    const c1 = rtr * (1.0 - KAPPA);\n    ctx.moveTo(left, top + Math.max(rtl, borderTopWidth));\n    ctx.bezierCurveTo(left, top + c0, left + c0, top, left + rtl, top);\n    ctx.lineTo(left + width - rtr, top);\n    ctx.bezierCurveTo(left + width - c1, top, left + width, top + c1, left + width, top + rtr);\n    ctx.strokeColor(borderTopColor);\n    ctx.lineWidth(Math.max(borderRightWidth, borderTopWidth, borderLeftWidth) * 2);\n    if (borderTopStyle === 'dashed') {\n        ctx.dash(borderTopWidth * 2, { space: borderTopWidth * 1.2 });\n    }\n    else if (borderTopStyle === 'dotted') {\n        ctx.dash(borderTopWidth, { space: borderTopWidth * 1.2 });\n    }\n    ctx.stroke();\n    ctx.undash();\n};\nconst clipBorderRight = (ctx, layout, style, rtr, rbr) => {\n    const { top, left, width, height } = layout;\n    const { borderTopWidth, borderRightWidth, borderBottomWidth } = style;\n    // Clip outer right border edge\n    ctx.moveTo(left + width, top + rtr);\n    ctx.lineTo(left + width, top + height - rbr);\n    // Ellipse coefficients outer bottom right cap\n    const c0 = rbr * (1.0 - KAPPA);\n    // Clip outer top right cap\n    ctx.bezierCurveTo(left + width, top + height - c0, left + width - c0, top + height, left + width - rbr, top + height);\n    // Move left in case the margin exceedes the radius\n    const topBottomXCoord = left + width - Math.max(borderRightWidth, rbr);\n    ctx.lineTo(topBottomXCoord, top + height);\n    // Clip inner bottom right cap\n    ctx.lineTo(topBottomXCoord, top + height - borderBottomWidth);\n    // Ellipse coefficients inner bottom right cap\n    const innerBottomRightRadiusX = Math.max(rbr - borderRightWidth, 0);\n    const innerBottomRightRadiusY = Math.max(rbr - borderBottomWidth, 0);\n    const c1 = innerBottomRightRadiusX * (1.0 - KAPPA);\n    const c2 = innerBottomRightRadiusY * (1.0 - KAPPA);\n    // Clip inner top right cap\n    ctx.bezierCurveTo(left + width - borderRightWidth - c1, top + height - borderBottomWidth, left + width - borderRightWidth, top + height - borderBottomWidth - c2, left + width - borderRightWidth, top + height - Math.max(rbr, borderBottomWidth));\n    // Clip inner right border edge\n    ctx.lineTo(left + width - borderRightWidth, top + Math.max(rtr, borderTopWidth));\n    // Ellipse coefficients inner top right cap\n    const innerTopRightRadiusX = Math.max(rtr - borderRightWidth, 0);\n    const innerTopRightRadiusY = Math.max(rtr - borderTopWidth, 0);\n    const c3 = innerTopRightRadiusX * (1.0 - KAPPA);\n    const c4 = innerTopRightRadiusY * (1.0 - KAPPA);\n    const topRightXCoord = left + width - Math.max(rtr, borderRightWidth);\n    // Clip inner top left cap\n    ctx.bezierCurveTo(left + width - borderRightWidth, top + borderTopWidth + c4, left + width - borderRightWidth - c3, top + borderTopWidth, topRightXCoord, top + borderTopWidth);\n    ctx.lineTo(topRightXCoord, top);\n    // Move right in case the margin exceedes the radius\n    ctx.lineTo(left + width - rtr, top);\n    // Ellipse coefficients outer top right cap\n    const c5 = rtr * (1.0 - KAPPA);\n    // Clip outer top right cap\n    ctx.bezierCurveTo(left + width - c5, top, left + width, top + c5, left + width, top + rtr);\n    ctx.closePath();\n    ctx.clip();\n    // Clip border right cap joins\n    if (borderTopWidth) {\n        const trSlope = -borderTopWidth / borderRightWidth;\n        ctx.moveTo(left + width / 2, trSlope * (-width / 2) + top);\n        ctx.lineTo(left + width, top);\n        ctx.lineTo(left + width, top + height);\n        ctx.lineTo(left, top + height);\n        ctx.closePath();\n        ctx.clip();\n    }\n    if (borderBottomWidth) {\n        const brSlope = borderBottomWidth / borderRightWidth;\n        ctx.moveTo(left + width / 2, brSlope * (-width / 2) + top + height);\n        ctx.lineTo(left + width, top + height);\n        ctx.lineTo(left + width, top);\n        ctx.lineTo(left, top);\n        ctx.closePath();\n        ctx.clip();\n    }\n};\nconst fillBorderRight = (ctx, layout, style, rtr, rbr) => {\n    const { top, left, width, height } = layout;\n    const { borderRightColor, borderRightStyle, borderRightWidth, borderTopWidth, borderBottomWidth, } = style;\n    const c0 = rbr * (1.0 - KAPPA);\n    const c1 = rtr * (1.0 - KAPPA);\n    ctx.moveTo(left + width - rtr, top);\n    ctx.bezierCurveTo(left + width - c1, top, left + width, top + c1, left + width, top + rtr);\n    ctx.lineTo(left + width, top + height - rbr);\n    ctx.bezierCurveTo(left + width, top + height - c0, left + width - c0, top + height, left + width - rbr, top + height);\n    ctx.strokeColor(borderRightColor);\n    ctx.lineWidth(Math.max(borderRightWidth, borderTopWidth, borderBottomWidth) * 2);\n    if (borderRightStyle === 'dashed') {\n        ctx.dash(borderRightWidth * 2, { space: borderRightWidth * 1.2 });\n    }\n    else if (borderRightStyle === 'dotted') {\n        ctx.dash(borderRightWidth, { space: borderRightWidth * 1.2 });\n    }\n    ctx.stroke();\n    ctx.undash();\n};\nconst clipBorderBottom = (ctx, layout, style, rbl, rbr) => {\n    const { top, left, width, height } = layout;\n    const { borderBottomWidth, borderRightWidth, borderLeftWidth } = style;\n    // Clip outer top border edge\n    ctx.moveTo(left + width - rbr, top + height);\n    ctx.lineTo(left + rbl, top + height);\n    // Ellipse coefficients outer top right cap\n    const c0 = rbl * (1.0 - KAPPA);\n    // Clip outer top right cap\n    ctx.bezierCurveTo(left + c0, top + height, left, top + height - c0, left, top + height - rbl);\n    // Move up in case the margin exceedes the radius\n    const bottomLeftYCoord = top + height - Math.max(borderBottomWidth, rbl);\n    ctx.lineTo(left, bottomLeftYCoord);\n    // Clip inner bottom left cap\n    ctx.lineTo(left + borderLeftWidth, bottomLeftYCoord);\n    // Ellipse coefficients inner top right cap\n    const innerBottomLeftRadiusX = Math.max(rbl - borderLeftWidth, 0);\n    const innerBottomLeftRadiusY = Math.max(rbl - borderBottomWidth, 0);\n    const c1 = innerBottomLeftRadiusX * (1.0 - KAPPA);\n    const c2 = innerBottomLeftRadiusY * (1.0 - KAPPA);\n    // Clip inner bottom left cap\n    ctx.bezierCurveTo(left + borderLeftWidth, top + height - borderBottomWidth - c2, left + borderLeftWidth + c1, top + height - borderBottomWidth, left + borderLeftWidth + innerBottomLeftRadiusX, top + height - borderBottomWidth);\n    // Clip inner bottom border edge\n    ctx.lineTo(left + width - Math.max(rbr, borderRightWidth), top + height - borderBottomWidth);\n    // Ellipse coefficients inner top left cap\n    const innerBottomRightRadiusX = Math.max(rbr - borderRightWidth, 0);\n    const innerBottomRightRadiusY = Math.max(rbr - borderBottomWidth, 0);\n    const c3 = innerBottomRightRadiusX * (1.0 - KAPPA);\n    const c4 = innerBottomRightRadiusY * (1.0 - KAPPA);\n    const bottomRightYCoord = top + height - Math.max(borderBottomWidth, rbr);\n    // Clip inner top left cap\n    ctx.bezierCurveTo(left + width - borderRightWidth - c3, top + height - borderBottomWidth, left + width - borderRightWidth, top + height - borderBottomWidth - c4, left + width - borderRightWidth, bottomRightYCoord);\n    ctx.lineTo(left + width, bottomRightYCoord);\n    // Move down in case the margin exceedes the radius\n    ctx.lineTo(left + width, top + height - rbr);\n    // Ellipse coefficients outer top left cap\n    const c5 = rbr * (1.0 - KAPPA);\n    // Clip outer top left cap\n    ctx.bezierCurveTo(left + width, top + height - c5, left + width - c5, top + height, left + width - rbr, top + height);\n    ctx.closePath();\n    ctx.clip();\n    // Clip border bottom cap joins\n    if (borderRightWidth) {\n        const brSlope = borderBottomWidth / borderRightWidth;\n        ctx.moveTo(left + width / 2, brSlope * (-width / 2) + top + height);\n        ctx.lineTo(left + width, top + height);\n        ctx.lineTo(left, top + height);\n        ctx.lineTo(left, top);\n        ctx.closePath();\n        ctx.clip();\n    }\n    if (borderLeftWidth) {\n        const trSlope = -borderBottomWidth / borderLeftWidth;\n        ctx.moveTo(left + width / 2, trSlope * (width / 2) + top + height);\n        ctx.lineTo(left, top + height);\n        ctx.lineTo(left + width, top + height);\n        ctx.lineTo(left + width, top);\n        ctx.closePath();\n        ctx.clip();\n    }\n};\nconst fillBorderBottom = (ctx, layout, style, rbl, rbr) => {\n    const { top, left, width, height } = layout;\n    const { borderBottomColor, borderBottomStyle, borderBottomWidth, borderRightWidth, borderLeftWidth, } = style;\n    const c0 = rbl * (1.0 - KAPPA);\n    const c1 = rbr * (1.0 - KAPPA);\n    ctx.moveTo(left + width, top + height - rbr);\n    ctx.bezierCurveTo(left + width, top + height - c1, left + width - c1, top + height, left + width - rbr, top + height);\n    ctx.lineTo(left + rbl, top + height);\n    ctx.bezierCurveTo(left + c0, top + height, left, top + height - c0, left, top + height - rbl);\n    ctx.strokeColor(borderBottomColor);\n    ctx.lineWidth(Math.max(borderBottomWidth, borderRightWidth, borderLeftWidth) * 2);\n    if (borderBottomStyle === 'dashed') {\n        ctx.dash(borderBottomWidth * 2, { space: borderBottomWidth * 1.2 });\n    }\n    else if (borderBottomStyle === 'dotted') {\n        ctx.dash(borderBottomWidth, { space: borderBottomWidth * 1.2 });\n    }\n    ctx.stroke();\n    ctx.undash();\n};\nconst clipBorderLeft = (ctx, layout, style, rbl, rtl) => {\n    const { top, left, width, height } = layout;\n    const { borderTopWidth, borderLeftWidth, borderBottomWidth } = style;\n    // Clip outer left border edge\n    ctx.moveTo(left, top + height - rbl);\n    ctx.lineTo(left, top + rtl);\n    // Ellipse coefficients outer top left cap\n    const c0 = rtl * (1.0 - KAPPA);\n    // Clip outer top left cap\n    ctx.bezierCurveTo(left, top + c0, left + c0, top, left + rtl, top);\n    // Move right in case the margin exceedes the radius\n    const topLeftCoordX = left + Math.max(borderLeftWidth, rtl);\n    ctx.lineTo(topLeftCoordX, top);\n    // Clip inner top left cap\n    ctx.lineTo(topLeftCoordX, top + borderTopWidth);\n    // Ellipse coefficients inner top left cap\n    const innerTopLeftRadiusX = Math.max(rtl - borderLeftWidth, 0);\n    const innerTopLeftRadiusY = Math.max(rtl - borderTopWidth, 0);\n    const c1 = innerTopLeftRadiusX * (1.0 - KAPPA);\n    const c2 = innerTopLeftRadiusY * (1.0 - KAPPA);\n    // Clip inner top right cap\n    ctx.bezierCurveTo(left + borderLeftWidth + c1, top + borderTopWidth, left + borderLeftWidth, top + borderTopWidth + c2, left + borderLeftWidth, top + Math.max(rtl, borderTopWidth));\n    // Clip inner left border edge\n    ctx.lineTo(left + borderLeftWidth, top + height - Math.max(rbl, borderBottomWidth));\n    // Ellipse coefficients inner bottom left cap\n    const innerBottomLeftRadiusX = Math.max(rbl - borderLeftWidth, 0);\n    const innerBottomLeftRadiusY = Math.max(rbl - borderBottomWidth, 0);\n    const c3 = innerBottomLeftRadiusX * (1.0 - KAPPA);\n    const c4 = innerBottomLeftRadiusY * (1.0 - KAPPA);\n    const bottomLeftXCoord = left + Math.max(rbl, borderLeftWidth);\n    // Clip inner top left cap\n    ctx.bezierCurveTo(left + borderLeftWidth, top + height - borderBottomWidth - c4, left + borderLeftWidth + c3, top + height - borderBottomWidth, bottomLeftXCoord, top + height - borderBottomWidth);\n    ctx.lineTo(bottomLeftXCoord, top + height);\n    // Move left in case the margin exceedes the radius\n    ctx.lineTo(left + rbl, top + height);\n    // Ellipse coefficients outer top right cap\n    const c5 = rbl * (1.0 - KAPPA);\n    // Clip outer top right cap\n    ctx.bezierCurveTo(left + c5, top + height, left, top + height - c5, left, top + height - rbl);\n    ctx.closePath();\n    ctx.clip();\n    // Clip border right cap joins\n    if (borderBottomWidth) {\n        const trSlope = -borderBottomWidth / borderLeftWidth;\n        ctx.moveTo(left + width / 2, trSlope * (width / 2) + top + height);\n        ctx.lineTo(left, top + height);\n        ctx.lineTo(left, top);\n        ctx.lineTo(left + width, top);\n        ctx.closePath();\n        ctx.clip();\n    }\n    if (borderBottomWidth) {\n        const trSlope = -borderTopWidth / borderLeftWidth;\n        ctx.moveTo(left + width / 2, trSlope * (-width / 2) + top);\n        ctx.lineTo(left, top);\n        ctx.lineTo(left, top + height);\n        ctx.lineTo(left + width, top + height);\n        ctx.closePath();\n        ctx.clip();\n    }\n};\nconst fillBorderLeft = (ctx, layout, style, rbl, rtl) => {\n    const { top, left, height } = layout;\n    const { borderLeftColor, borderLeftStyle, borderLeftWidth, borderTopWidth, borderBottomWidth, } = style;\n    const c0 = rbl * (1.0 - KAPPA);\n    const c1 = rtl * (1.0 - KAPPA);\n    ctx.moveTo(left + rbl, top + height);\n    ctx.bezierCurveTo(left + c0, top + height, left, top + height - c0, left, top + height - rbl);\n    ctx.lineTo(left, top + rtl);\n    ctx.bezierCurveTo(left, top + c1, left + c1, top, left + rtl, top);\n    ctx.strokeColor(borderLeftColor);\n    ctx.lineWidth(Math.max(borderLeftWidth, borderTopWidth, borderBottomWidth) * 2);\n    if (borderLeftStyle === 'dashed') {\n        ctx.dash(borderLeftWidth * 2, { space: borderLeftWidth * 1.2 });\n    }\n    else if (borderLeftStyle === 'dotted') {\n        ctx.dash(borderLeftWidth, { space: borderLeftWidth * 1.2 });\n    }\n    ctx.stroke();\n    ctx.undash();\n};\nconst shouldRenderBorders = (node) => node.box &&\n    (node.box.borderTopWidth ||\n        node.box.borderRightWidth ||\n        node.box.borderBottomWidth ||\n        node.box.borderLeftWidth);\nconst renderBorders = (ctx, node) => {\n    if (!node.box)\n        return;\n    if (!shouldRenderBorders(node))\n        return;\n    const { width, height, borderTopWidth = 0, borderLeftWidth = 0, borderRightWidth = 0, borderBottomWidth = 0, } = node.box;\n    const { opacity = 1, borderTopColor = 'black', borderTopStyle = 'solid', borderLeftColor = 'black', borderLeftStyle = 'solid', borderRightColor = 'black', borderRightStyle = 'solid', borderBottomColor = 'black', borderBottomStyle = 'solid', } = node.style;\n    // @ts-expect-error this is always a number due to resolve border radius step\n    const borderTopLeftRadius = node.style.borderTopLeftRadius || 0;\n    // @ts-expect-error this is always a number due to resolve border radius step\n    const borderTopRightRadius = node.style.borderTopRightRadius || 0;\n    // @ts-expect-error this is always a number due to resolve border radius step\n    const borderBottomLeftRadius = node.style.borderBottomLeftRadius || 0;\n    // @ts-expect-error this is always a number due to resolve border radius step\n    const borderBottomRightRadius = node.style.borderBottomRightRadius || 0;\n    const style = {\n        borderTopColor,\n        borderTopWidth,\n        borderTopStyle,\n        borderLeftColor,\n        borderLeftWidth,\n        borderLeftStyle,\n        borderRightColor,\n        borderRightWidth,\n        borderRightStyle,\n        borderBottomColor,\n        borderBottomWidth,\n        borderBottomStyle};\n    const rtr = Math.min(borderTopRightRadius, 0.5 * width, 0.5 * height);\n    const rtl = Math.min(borderTopLeftRadius, 0.5 * width, 0.5 * height);\n    const rbr = Math.min(borderBottomRightRadius, 0.5 * width, 0.5 * height);\n    const rbl = Math.min(borderBottomLeftRadius, 0.5 * width, 0.5 * height);\n    ctx.save();\n    ctx.strokeOpacity(opacity);\n    if (borderTopWidth) {\n        ctx.save();\n        clipBorderTop(ctx, node.box, style, rtr, rtl);\n        fillBorderTop(ctx, node.box, style, rtr, rtl);\n        ctx.restore();\n    }\n    if (borderRightWidth) {\n        ctx.save();\n        clipBorderRight(ctx, node.box, style, rtr, rbr);\n        fillBorderRight(ctx, node.box, style, rtr, rbr);\n        ctx.restore();\n    }\n    if (borderBottomWidth) {\n        ctx.save();\n        clipBorderBottom(ctx, node.box, style, rbl, rbr);\n        fillBorderBottom(ctx, node.box, style, rbl, rbr);\n        ctx.restore();\n    }\n    if (borderLeftWidth) {\n        ctx.save();\n        clipBorderLeft(ctx, node.box, style, rbl, rtl);\n        fillBorderLeft(ctx, node.box, style, rbl, rtl);\n        ctx.restore();\n    }\n    ctx.restore();\n};\n\nconst drawBackground = (ctx, node) => {\n    if (!node.box)\n        return;\n    const { top, left, width, height } = node.box;\n    const color = parseColor(node.style.backgroundColor);\n    const nodeOpacity = isNil(node.style?.opacity) ? 1 : node.style.opacity;\n    const opacity = Math.min(color.opacity, nodeOpacity);\n    ctx\n        .fillOpacity(opacity)\n        .fillColor(color.value)\n        .rect(left, top, width, height)\n        .fill();\n};\nconst renderBackground = (ctx, node) => {\n    const hasBackground = !!node.box && !!node.style?.backgroundColor;\n    if (hasBackground) {\n        ctx.save();\n        clipNode(ctx, node);\n        drawBackground(ctx, node);\n        ctx.restore();\n    }\n};\n\nconst isString = (value) => typeof value === 'string';\nconst isSrcId = (value) => /^#.+/.test(value);\nconst renderLink = (ctx, node, src) => {\n    if (!src || !node.box)\n        return;\n    const isId = isSrcId(src);\n    const method = isId ? 'goTo' : 'link';\n    const value = isId ? src.slice(1) : src;\n    const { top, left, width, height } = node.box;\n    ctx[method](left, top, width, height, value);\n};\nconst setLink = (ctx, node) => {\n    const props = node.props || {};\n    if ('src' in props && isString(props.src))\n        return renderLink(ctx, node, props.src);\n    if ('href' in props && isString(props.href))\n        return renderLink(ctx, node, props.href);\n};\n\nconst setDestination = (ctx, node) => {\n    if (!node.box)\n        return;\n    if (!node.props)\n        return;\n    if ('id' in node.props) {\n        ctx.addNamedDestination(node.props.id, 'XYZ', null, node.box.top, null);\n    }\n};\n\nconst clean = (options) => {\n    const opt = { ...options };\n    // We need to ensure the elements are no present if not true\n    Object.entries(opt).forEach((pair) => {\n        if (!pair[1]) {\n            delete opt[pair[0]];\n        }\n    });\n    return opt;\n};\nconst parseCommonFormOptions = (node) => {\n    // Common Options\n    return {\n        required: node.props?.required || false,\n        noExport: node.props?.noExport || false,\n        readOnly: node.props?.readOnly || false,\n        value: node.props?.value || undefined,\n        defaultValue: node.props?.defaultValue || undefined,\n    };\n};\nconst parseTextInputOptions = (node, fieldSet) => {\n    return clean({\n        ...parseCommonFormOptions(node),\n        parent: fieldSet || undefined,\n        align: node.props?.align || 'left',\n        multiline: node.props?.multiline || undefined,\n        password: node.props?.password || false,\n        noSpell: node.props?.noSpell || false,\n        format: node.props?.format || undefined,\n        fontSize: node.props?.fontSize || undefined,\n        MaxLen: node.props?.maxLength || undefined,\n    });\n};\nconst parseSelectAndListFieldOptions = (node) => {\n    return clean({\n        ...parseCommonFormOptions(node),\n        sort: node.props?.sort || false,\n        edit: node.props?.edit || false,\n        multiSelect: node.props?.multiSelect || false,\n        noSpell: node.props?.noSpell || false,\n        select: node.props?.select || [''],\n    });\n};\nconst getAppearance = (ctx, codepoint, width, height) => {\n    const appearance = ctx.ref({\n        Type: 'XObject',\n        Subtype: 'Form',\n        BBox: [0, 0, width, height],\n        Resources: {\n            ProcSet: ['PDF', 'Text', 'ImageB', 'ImageC', 'ImageI'],\n            Font: {\n                ZaDi: ctx._acroform.fonts.ZaDi,\n            },\n        },\n    });\n    appearance.initDeflate();\n    appearance.write(`/Tx BMC\\nq\\n/ZaDi ${height * 0.8} Tf\\nBT\\n${width * 0.45} ${height / 4} Td (${codepoint}) Tj\\nET\\nQ\\nEMC`);\n    appearance.end(null);\n    return appearance;\n};\nconst parseCheckboxOptions = (ctx, node, fieldSet) => {\n    const { width, height } = node.box || {};\n    const onOption = node.props?.onState || 'Yes';\n    const offOption = node.props?.offState || 'Off';\n    const xMark = node.props?.xMark || false;\n    if (!Object.prototype.hasOwnProperty.call(ctx._acroform.fonts, 'ZaDi')) {\n        const ref = ctx.ref({\n            Type: 'Font',\n            Subtype: 'Type1',\n            BaseFont: 'ZapfDingbats',\n        });\n        ctx._acroform.fonts.ZaDi = ref;\n        ref.end(null);\n    }\n    const normalAppearance = {\n        [onOption]: getAppearance(ctx, xMark ? '8' : '4', width, height),\n        [offOption]: getAppearance(ctx, xMark ? ' ' : '8', width, height),\n    };\n    return clean({\n        ...parseCommonFormOptions(node),\n        backgroundColor: node.props?.backgroundColor || undefined,\n        borderColor: node.props?.borderColor || undefined,\n        parent: fieldSet || undefined,\n        value: `/${node.props?.checked === true ? onOption : offOption}`,\n        defaultValue: `/${node.props?.checked === true ? onOption : offOption}`,\n        AS: node.props?.checked === true ? onOption : offOption,\n        AP: { N: normalAppearance, D: normalAppearance },\n    });\n};\n\nconst renderTextInput = (ctx, node, options) => {\n    if (!node.box)\n        return;\n    const { top, left, width, height } = node.box;\n    // Element's name\n    const name = node.props?.name || '';\n    const fieldSetOptions = options.fieldSets?.at(0);\n    if (!ctx._root.data.AcroForm) {\n        ctx.initForm();\n    }\n    ctx.formText(name, left, top, width, height, parseTextInputOptions(node, fieldSetOptions));\n};\n\nconst renderSelect = (ctx, node) => {\n    if (!node.box)\n        return;\n    const { top, left, width, height } = node.box;\n    // Element's name\n    const name = node.props?.name || '';\n    if (!ctx._root.data.AcroForm) {\n        ctx.initForm();\n    }\n    ctx.formCombo(name, left, top, width, height, parseSelectAndListFieldOptions(node));\n};\n\nconst renderFieldSet = (ctx, node, options) => {\n    const name = node.props?.name || '';\n    if (!ctx._root.data.AcroForm) {\n        ctx.initForm();\n    }\n    const formField = ctx.formField(name);\n    const option = options;\n    if (!option.fieldSets) {\n        option.fieldSets = [formField];\n    }\n    else {\n        option.fieldSets.push(formField);\n    }\n};\nconst cleanUpFieldSet = (_ctx, _node, options) => {\n    options.fieldSets.pop();\n};\n\nconst renderList = (ctx, node) => {\n    if (!node.box)\n        return;\n    const { top, left, width, height } = node.box || {};\n    // Element's name\n    const name = ('name' in node.props ? node.props.name || '' : '');\n    if (!ctx._root.data.AcroForm) {\n        ctx.initForm();\n    }\n    ctx.formList(name, left, top, width, height, parseSelectAndListFieldOptions(node));\n};\n\nconst renderCheckbox = (ctx, node, options) => {\n    if (!node.box)\n        return;\n    const { top, left, width, height } = node.box;\n    // Element's name\n    const name = node.props?.name || '';\n    const fieldSetOptions = options.fieldSets?.at(0);\n    if (!ctx._root.data.AcroForm) {\n        ctx.initForm();\n    }\n    ctx.formCheckbox(name, left, top, width, height, parseCheckboxOptions(ctx, node, fieldSetOptions));\n};\n\nconst isRecursiveNode = (node) => node.type !== P.Text && node.type !== P.Svg;\nconst renderChildren = (ctx, node, options) => {\n    ctx.save();\n    if (node.box) {\n        ctx.translate(node.box.left, node.box.top);\n    }\n    const children = node.children || [];\n    const renderChild = (child) => renderNode(ctx, child, options);\n    children.forEach(renderChild);\n    ctx.restore();\n};\nconst renderFns = {\n    [P.Text]: renderText,\n    [P.Note]: renderNote,\n    [P.Image]: renderImage,\n    [P.FieldSet]: renderFieldSet,\n    [P.TextInput]: renderTextInput,\n    [P.Select]: renderSelect,\n    [P.Checkbox]: renderCheckbox,\n    [P.List]: renderList,\n    [P.Canvas]: renderCanvas,\n    [P.Svg]: renderSvg,\n    [P.Link]: setLink,\n};\nconst cleanUpFns = {\n    [P.FieldSet]: cleanUpFieldSet,\n};\nconst renderNode = (ctx, node, options) => {\n    const overflowHidden = node.style?.overflow === 'hidden';\n    const shouldRenderChildren = isRecursiveNode(node);\n    if (node.type === P.Page)\n        renderPage(ctx, node);\n    ctx.save();\n    if (overflowHidden)\n        clipNode(ctx, node);\n    applyTransformations(ctx, node);\n    renderBackground(ctx, node);\n    renderBorders(ctx, node);\n    const renderFn = renderFns[node.type];\n    if (renderFn)\n        renderFn(ctx, node, options);\n    if (shouldRenderChildren)\n        renderChildren(ctx, node, options);\n    const cleanUpFn = cleanUpFns[node.type];\n    if (cleanUpFn)\n        cleanUpFn(ctx, node, options);\n    setDestination(ctx, node);\n    renderDebug(ctx, node);\n    ctx.restore();\n};\n\nconst addNodeBookmark = (ctx, node, pageNumber, registry) => {\n    if (!node.box)\n        return;\n    if (!node.props)\n        return;\n    if ('bookmark' in node.props && node.props.bookmark) {\n        const bookmark = node.props.bookmark;\n        const { title, parent, expanded, zoom, fit } = bookmark;\n        const outline = registry[parent] || ctx.outline;\n        const top = bookmark.top || node.box.top;\n        const left = bookmark.left || node.box.left;\n        const instance = outline.addItem(title, {\n            pageNumber,\n            expanded,\n            top,\n            left,\n            zoom,\n            fit,\n        });\n        registry[bookmark.ref] = instance;\n    }\n    if (!node.children)\n        return;\n    node.children.forEach((child) => addNodeBookmark(ctx, child, pageNumber, registry));\n};\nconst addBookmarks = (ctx, root) => {\n    const registry = {};\n    const pages = root.children || [];\n    pages.forEach((page, i) => {\n        addNodeBookmark(ctx, page, i, registry);\n    });\n};\n\nconst render = (ctx, doc) => {\n    const pages = doc.children || [];\n    const options = { imageCache: new Map(), fieldSets: [] };\n    pages.forEach((page) => renderNode(ctx, page, options));\n    addBookmarks(ctx, doc);\n    ctx.end();\n    return ctx;\n};\n\nexport { render as default };\n"],"mappings":"AAAA,OAAO,KAAKA,CAAC,MAAM,uBAAuB;AAC1C,SAASC,KAAK,EAAEC,YAAY,QAAQ,gBAAgB;AACpD,OAAOC,OAAO,MAAM,cAAc;AAClC,OAAOC,SAAS,MAAM,gBAAgB;AACtC,OAAOC,aAAa,MAAM,oBAAoB;AAC9C,OAAOC,WAAW,MAAM,cAAc;AAEtC,MAAMC,UAAU,GAAGA,CAACC,GAAG,EAAEC,IAAI,KAAK;EAC9B,MAAMC,CAAC,GAAGD,IAAI,CAACE,KAAK,EAAED,CAAC;EACvB,IAAIA,CAAC,EACDF,GAAG,CAACI,IAAI,CAACH,IAAI,CAACE,KAAK,CAACD,CAAC,CAAC;AAC9B,CAAC;AAED,MAAMG,OAAO,GAAG,GAAG,IAAI,CAACC,IAAI,CAACC,IAAI,CAAC,CAAC,CAAC,GAAG,GAAG,IAAI,GAAG,CAAC;AAClD,MAAMC,UAAU,GAAGA,CAACR,GAAG,EAAEC,IAAI,KAAK;EAC9B,MAAMQ,CAAC,GAAGR,IAAI,CAACE,KAAK,EAAEM,CAAC,IAAI,CAAC;EAC5B,MAAMC,CAAC,GAAGT,IAAI,CAACE,KAAK,EAAEO,CAAC,IAAI,CAAC;EAC5B,MAAMC,EAAE,GAAGV,IAAI,CAACE,KAAK,EAAEQ,EAAE,IAAI,CAAC;EAC9B,MAAMC,EAAE,GAAGX,IAAI,CAACE,KAAK,EAAES,EAAE,IAAI,CAAC;EAC9B,MAAMC,KAAK,GAAGZ,IAAI,CAACE,KAAK,EAAEU,KAAK,IAAI,CAAC;EACpC,MAAMC,MAAM,GAAGb,IAAI,CAACE,KAAK,EAAEW,MAAM,IAAI,CAAC;EACtC,IAAI,CAACD,KAAK,IAAI,CAACC,MAAM,EACjB;EACJ,IAAIH,EAAE,IAAIC,EAAE,EAAE;IACV,MAAMG,GAAG,GAAGJ,EAAE,GAAGN,OAAO;IACxB,MAAMW,GAAG,GAAGJ,EAAE,GAAGP,OAAO;IACxBL,GAAG,CAACiB,MAAM,CAACR,CAAC,GAAGE,EAAE,EAAED,CAAC,CAAC;IACrBV,GAAG,CAACkB,MAAM,CAACT,CAAC,GAAGE,EAAE,GAAGE,KAAK,EAAEH,CAAC,CAAC;IAC7BV,GAAG,CAACmB,aAAa,CAACV,CAAC,GAAGE,EAAE,GAAGE,KAAK,GAAGE,GAAG,EAAEL,CAAC,EAAED,CAAC,GAAGI,KAAK,EAAEH,CAAC,GAAGE,EAAE,GAAGI,GAAG,EAAEP,CAAC,GAAGI,KAAK,EAAEH,CAAC,GAAGE,EAAE,CAAC;IACtFZ,GAAG,CAACkB,MAAM,CAACT,CAAC,GAAGI,KAAK,EAAEH,CAAC,GAAGI,MAAM,GAAGF,EAAE,CAAC;IACtCZ,GAAG,CAACmB,aAAa,CAACV,CAAC,GAAGI,KAAK,EAAEH,CAAC,GAAGI,MAAM,GAAGF,EAAE,GAAGI,GAAG,EAAEP,CAAC,GAAGE,EAAE,GAAGE,KAAK,GAAGE,GAAG,EAAEL,CAAC,GAAGI,MAAM,EAAEL,CAAC,GAAGE,EAAE,GAAGE,KAAK,EAAEH,CAAC,GAAGI,MAAM,CAAC;IACjHd,GAAG,CAACkB,MAAM,CAACT,CAAC,GAAGE,EAAE,EAAED,CAAC,GAAGI,MAAM,CAAC;IAC9Bd,GAAG,CAACmB,aAAa,CAACV,CAAC,GAAGE,EAAE,GAAGI,GAAG,EAAEL,CAAC,GAAGI,MAAM,EAAEL,CAAC,EAAEC,CAAC,GAAGI,MAAM,GAAGF,EAAE,GAAGI,GAAG,EAAEP,CAAC,EAAEC,CAAC,GAAGI,MAAM,GAAGF,EAAE,CAAC;IACzFZ,GAAG,CAACkB,MAAM,CAACT,CAAC,EAAEC,CAAC,GAAGE,EAAE,CAAC;IACrBZ,GAAG,CAACmB,aAAa,CAACV,CAAC,EAAEC,CAAC,GAAGE,EAAE,GAAGI,GAAG,EAAEP,CAAC,GAAGE,EAAE,GAAGI,GAAG,EAAEL,CAAC,EAAED,CAAC,GAAGE,EAAE,EAAED,CAAC,CAAC;EAClE,CAAC,MACI;IACDV,GAAG,CAACiB,MAAM,CAACR,CAAC,EAAEC,CAAC,CAAC;IAChBV,GAAG,CAACkB,MAAM,CAACT,CAAC,GAAGI,KAAK,EAAEH,CAAC,CAAC;IACxBV,GAAG,CAACkB,MAAM,CAACT,CAAC,GAAGI,KAAK,EAAEH,CAAC,GAAGI,MAAM,CAAC;IACjCd,GAAG,CAACkB,MAAM,CAACT,CAAC,EAAEC,CAAC,GAAGI,MAAM,CAAC;EAC7B;EACAd,GAAG,CAACoB,SAAS,CAAC,CAAC;AACnB,CAAC;AAED,MAAMC,YAAY,GAAGA,CAACrB,GAAG,EAAEC,IAAI,KAAK;EAChC,MAAM;IAAEqB,EAAE;IAAEC,EAAE;IAAEC,EAAE;IAAEC;EAAG,CAAC,GAAGxB,IAAI,CAACE,KAAK,IAAI,CAAC,CAAC;EAC3CH,GAAG,CAACiB,MAAM,CAACK,EAAE,EAAEE,EAAE,CAAC;EAClBxB,GAAG,CAACkB,MAAM,CAACK,EAAE,EAAEE,EAAE,CAAC;AACtB,CAAC;AAED,MAAMC,WAAW,GAAGA,CAAA,KAAM;EACtB;AAAA,CACH;AAED,MAAMC,OAAO,GAAG,GAAG,IAAI,CAACrB,IAAI,CAACC,IAAI,CAAC,CAAC,CAAC,GAAG,GAAG,IAAI,GAAG,CAAC;AAClD,MAAMqB,WAAW,GAAG,SAAAA,CAAC5B,GAAG,EAAEW,EAAE,EAAEC,EAAE,EAAqB;EAAA,IAAnBiB,EAAE,GAAAC,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAAE,SAAA,GAAAF,SAAA,MAAG,CAAC;EAAA,IAAEG,EAAE,GAAAH,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAAE,SAAA,GAAAF,SAAA,MAAG,CAAC;EAC5C,MAAMrB,CAAC,GAAGoB,EAAE,GAAGlB,EAAE;EACjB,MAAMD,CAAC,GAAGuB,EAAE,GAAGrB,EAAE;EACjB,MAAMsB,EAAE,GAAGvB,EAAE,GAAGgB,OAAO;EACvB,MAAMQ,EAAE,GAAGvB,EAAE,GAAGe,OAAO;EACvB,MAAMS,EAAE,GAAG3B,CAAC,GAAGE,EAAE,GAAG,CAAC;EACrB,MAAM0B,EAAE,GAAG3B,CAAC,GAAGE,EAAE,GAAG,CAAC;EACrB,MAAM0B,EAAE,GAAG7B,CAAC,GAAGE,EAAE;EACjB,MAAM4B,EAAE,GAAG7B,CAAC,GAAGE,EAAE;EACjBZ,GAAG,CAACiB,MAAM,CAACR,CAAC,EAAE8B,EAAE,CAAC;EACjBvC,GAAG,CAACmB,aAAa,CAACV,CAAC,EAAE8B,EAAE,GAAGJ,EAAE,EAAEG,EAAE,GAAGJ,EAAE,EAAExB,CAAC,EAAE4B,EAAE,EAAE5B,CAAC,CAAC;EAChDV,GAAG,CAACmB,aAAa,CAACmB,EAAE,GAAGJ,EAAE,EAAExB,CAAC,EAAE0B,EAAE,EAAEG,EAAE,GAAGJ,EAAE,EAAEC,EAAE,EAAEG,EAAE,CAAC;EAClDvC,GAAG,CAACmB,aAAa,CAACiB,EAAE,EAAEG,EAAE,GAAGJ,EAAE,EAAEG,EAAE,GAAGJ,EAAE,EAAEG,EAAE,EAAEC,EAAE,EAAED,EAAE,CAAC;EACnDrC,GAAG,CAACmB,aAAa,CAACmB,EAAE,GAAGJ,EAAE,EAAEG,EAAE,EAAE5B,CAAC,EAAE8B,EAAE,GAAGJ,EAAE,EAAE1B,CAAC,EAAE8B,EAAE,CAAC;EACjDvC,GAAG,CAACoB,SAAS,CAAC,CAAC;AACnB,CAAC;AACD,MAAMoB,aAAa,GAAGA,CAACxC,GAAG,EAAEC,IAAI,KAAK;EACjC,MAAM;IAAE4B,EAAE;IAAEI,EAAE;IAAEtB,EAAE;IAAEC;EAAG,CAAC,GAAGX,IAAI,CAACE,KAAK,IAAI,CAAC,CAAC;EAC3CyB,WAAW,CAAC5B,GAAG,EAAEW,EAAE,EAAEC,EAAE,EAAEiB,EAAE,EAAEI,EAAE,CAAC;AACpC,CAAC;AAED,MAAMQ,YAAY,GAAGA,CAACzC,GAAG,EAAEC,IAAI,KAAK;EAChC,MAAM4B,EAAE,GAAG5B,IAAI,CAACE,KAAK,EAAE0B,EAAE;EACzB,MAAMI,EAAE,GAAGhC,IAAI,CAACE,KAAK,EAAE8B,EAAE;EACzB,MAAMS,CAAC,GAAGzC,IAAI,CAACE,KAAK,EAAEuC,CAAC;EACvBd,WAAW,CAAC5B,GAAG,EAAE0C,CAAC,EAAEA,CAAC,EAAEb,EAAE,EAAEI,EAAE,CAAC;AAClC,CAAC;;AAED;AACA,MAAMU,MAAM,GAAIC,CAAC,IAAK;EAClB,IAAIA,CAAC,GAAG,CAAC,IAAI,IAAIA,CAAC,GAAG,IAAI,EAAE;IACvB,OAAOtC,IAAI,CAACuC,KAAK,CAACD,CAAC,GAAG,GAAG,CAAC,GAAG,GAAG;EACpC;EACA,MAAM,IAAIE,KAAK,CAAC,uBAAuBF,CAAC,EAAE,CAAC;AAC/C,CAAC;AACD,MAAMG,aAAa,GAAGA,CAAC/C,GAAG,EAAEgD,OAAO,EAAEC,SAAS,EAAExC,CAAC,EAAEC,CAAC,KAAK;EACrD,MAAMwC,QAAQ,GAAG,EAAE;EACnB,MAAMC,KAAK,GAAGnD,GAAG,CAACoD,SAAS,GAAG,IAAI;EAClC,IAAIC,CAAC;EACL,IAAIC,IAAI,GAAG,CAAC;EACZ,IAAIC,SAAS,GAAG,KAAK;EACrBvD,GAAG,CAACwD,IAAI,CAAC,CAAC;EACV;EACAxD,GAAG,CAACyD,SAAS,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC,EAAE,CAAC,EAAEzD,GAAG,CAAC0D,IAAI,CAAC5C,MAAM,CAAC;EAC9CJ,CAAC,GAAGV,GAAG,CAAC0D,IAAI,CAAC5C,MAAM,GAAGJ,CAAC;EACvB;EACA,IAAIV,GAAG,CAAC0D,IAAI,CAACC,KAAK,CAAC3D,GAAG,CAAC4D,KAAK,CAACC,EAAE,CAAC,IAAI,IAAI,EAAE;IACtC7D,GAAG,CAAC0D,IAAI,CAACC,KAAK,CAAC3D,GAAG,CAAC4D,KAAK,CAACC,EAAE,CAAC,GAAG7D,GAAG,CAAC4D,KAAK,CAACE,GAAG,CAAC,CAAC;EAClD;EACA;EACA9D,GAAG,CAAC+D,UAAU,CAAC,IAAI,CAAC;EACpB;EACA/D,GAAG,CAAC+D,UAAU,CAAC,WAAWpB,MAAM,CAAClC,CAAC,CAAC,IAAIkC,MAAM,CAACjC,CAAC,CAAC,KAAK,CAAC;EACtD;EACAV,GAAG,CAAC+D,UAAU,CAAC,IAAI/D,GAAG,CAAC4D,KAAK,CAACC,EAAE,IAAIlB,MAAM,CAAC3C,GAAG,CAACoD,SAAS,CAAC,KAAK,CAAC;EAC9D;EACA,MAAMY,UAAU,GAAIC,GAAG,IAAK;IACxB,IAAIX,IAAI,GAAGW,GAAG,EAAE;MACZ,MAAMC,GAAG,GAAGlB,OAAO,CAACmB,KAAK,CAACb,IAAI,EAAEW,GAAG,CAAC,CAACG,IAAI,CAAC,EAAE,CAAC;MAC7C,MAAMC,OAAO,GAAGpB,SAAS,CAACgB,GAAG,GAAG,CAAC,CAAC,CAACK,QAAQ,GAAGrB,SAAS,CAACgB,GAAG,GAAG,CAAC,CAAC,CAACM,YAAY;MAC7ErB,QAAQ,CAACsB,IAAI,CAAC,IAAIN,GAAG,KAAKvB,MAAM,CAAC,CAAC0B,OAAO,CAAC,EAAE,CAAC;IACjD;IACA,OAAQf,IAAI,GAAGW,GAAG;EACtB,CAAC;EACD;EACA,MAAMQ,KAAK,GAAIC,CAAC,IAAK;IACjBV,UAAU,CAACU,CAAC,CAAC;IACb,IAAIxB,QAAQ,CAACnB,MAAM,GAAG,CAAC,EAAE;MACrB/B,GAAG,CAAC+D,UAAU,CAAC,IAAIb,QAAQ,CAACkB,IAAI,CAAC,GAAG,CAAC,MAAM,CAAC;MAC5C,OAAQlB,QAAQ,CAACnB,MAAM,GAAG,CAAC;IAC/B;EACJ,CAAC;EACD,KAAKsB,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGJ,SAAS,CAAClB,MAAM,EAAEsB,CAAC,IAAI,CAAC,EAAE;IACtC;IACA;IACA,MAAMsB,GAAG,GAAG1B,SAAS,CAACI,CAAC,CAAC;IACxB,IAAIsB,GAAG,CAACC,OAAO,IAAID,GAAG,CAACE,OAAO,EAAE;MAC5B;MACAJ,KAAK,CAACpB,CAAC,CAAC;MACR;MACArD,GAAG,CAAC+D,UAAU,CAAC,WAAWpB,MAAM,CAAClC,CAAC,GAAGkE,GAAG,CAACC,OAAO,GAAGzB,KAAK,CAAC,IAAIR,MAAM,CAACjC,CAAC,GAAGiE,GAAG,CAACE,OAAO,GAAG1B,KAAK,CAAC,KAAK,CAAC;MAClGsB,KAAK,CAACpB,CAAC,GAAG,CAAC,CAAC;MACZE,SAAS,GAAG,IAAI;IACpB,CAAC,MACI;MACD;MACA,IAAIA,SAAS,EAAE;QACXvD,GAAG,CAAC+D,UAAU,CAAC,WAAWpB,MAAM,CAAClC,CAAC,CAAC,IAAIkC,MAAM,CAACjC,CAAC,CAAC,KAAK,CAAC;QACtD6C,SAAS,GAAG,KAAK;MACrB;MACA;MACA,IAAIoB,GAAG,CAACL,QAAQ,GAAGK,GAAG,CAACJ,YAAY,KAAK,CAAC,EAAE;QACvCP,UAAU,CAACX,CAAC,GAAG,CAAC,CAAC;MACrB;IACJ;IACA5C,CAAC,IAAIkE,GAAG,CAACL,QAAQ,GAAGnB,KAAK;EAC7B;EACA;EACAsB,KAAK,CAACpB,CAAC,CAAC;EACR;EACArD,GAAG,CAAC+D,UAAU,CAAC,IAAI,CAAC;EACpB;EACA,OAAO/D,GAAG,CAAC8E,OAAO,CAAC,CAAC;AACxB,CAAC;AACD,MAAMC,YAAY,GAAGA,CAAC/E,GAAG,EAAEgF,MAAM,EAAE/B,SAAS,EAAExC,CAAC,EAAEC,CAAC,KAAK;EACnD,MAAMyC,KAAK,GAAG,IAAI,GAAGnD,GAAG,CAACoD,SAAS;EAClC,MAAM6B,UAAU,GAAGjF,GAAG,CAAC4D,KAAK,CAACsB,IAAI,CAACD,UAAU,IAAI,IAAI;EACpD,MAAME,iBAAiB,GAAG,IAAI,GAAGF,UAAU;EAC3C;EACA,MAAMG,aAAa,GAAGpF,GAAG,CAAC4D,KAAK,CAACyB,YAAY,CAACL,MAAM,CAAC;EACpD,MAAMM,gBAAgB,GAAGrC,SAAS,CAACsC,GAAG,CAAC,CAACZ,GAAG,EAAEtB,CAAC,MAAM;IAChDiB,QAAQ,EAAEK,GAAG,CAACL,QAAQ,GAAGnB,KAAK;IAC9BqC,QAAQ,EAAEb,GAAG,CAACa,QAAQ,GAAGrC,KAAK;IAC9ByB,OAAO,EAAED,GAAG,CAACC,OAAO;IACpBC,OAAO,EAAEF,GAAG,CAACE,OAAO;IACpBN,YAAY,EAAES,MAAM,CAAC3B,CAAC,CAAC,CAACkB,YAAY,GAAGY;EAC3C,CAAC,CAAC,CAAC;EACH,OAAOpC,aAAa,CAAC/C,GAAG,EAAEoF,aAAa,EAAEE,gBAAgB,EAAE7E,CAAC,EAAEC,CAAC,CAAC;AACpE,CAAC;AAED,MAAM+E,WAAW,GAAGA,CAACzF,GAAG,EAAE0F,GAAG,KAAK;EAC9B,IAAI,CAACA,GAAG,CAACV,MAAM,EACX;EACJ,IAAI,CAACU,GAAG,CAACzC,SAAS,EACd;EACJ,MAAM0C,eAAe,GAAGD,GAAG,CAACpB,QAAQ;EACpC,MAAMY,IAAI,GAAGQ,GAAG,CAACE,UAAU,CAACV,IAAI,GAAG,CAAC,CAAC;EACrC,MAAM;IAAEW,QAAQ;IAAEC,KAAK;IAAEC;EAAQ,CAAC,GAAGL,GAAG,CAACE,UAAU;EACnD,IAAIE,KAAK,EACL9F,GAAG,CAACgG,SAAS,CAACF,KAAK,CAAC;EACxB9F,GAAG,CAACiG,WAAW,CAACF,OAAO,CAAC;EACxB,IAAIb,IAAI,EAAE;IACNlF,GAAG,CAACkF,IAAI,CAACA,IAAI,CAACgB,IAAI,KAAK,UAAU,GAAGhB,IAAI,CAACiB,QAAQ,GAAGjB,IAAI,EAAEW,QAAQ,CAAC;EACvE;EACA,IAAI;IACAd,YAAY,CAAC/E,GAAG,EAAE0F,GAAG,CAACV,MAAM,EAAEU,GAAG,CAACzC,SAAS,EAAE,CAAC,EAAE,CAAC,CAAC;EACtD,CAAC,CACD,OAAOmD,KAAK,EAAE;IACVC,OAAO,CAACC,GAAG,CAACF,KAAK,CAAC;EACtB;EACApG,GAAG,CAACuG,SAAS,CAACZ,eAAe,EAAE,CAAC,CAAC;AACrC,CAAC;AACD,MAAMa,UAAU,GAAGA,CAACxG,GAAG,EAAEyG,IAAI,EAAEC,UAAU,EAAEC,gBAAgB,KAAK;EAC5D3G,GAAG,CAACwD,IAAI,CAAC,CAAC;EACV,MAAM/C,CAAC,GAAGgG,IAAI,CAACG,GAAG,EAAEnG,CAAC,IAAI,CAAC;EAC1B,MAAMC,CAAC,GAAG+F,IAAI,CAACG,GAAG,EAAElG,CAAC,IAAI,CAAC;EAC1B,MAAMwE,IAAI,GAAGuB,IAAI,CAACI,IAAI,CAAC,CAAC,CAAC,EAAEjB,UAAU,CAACV,IAAI,GAAG,CAAC,CAAC;EAC/C,MAAM/B,KAAK,GAAGsD,IAAI,CAACI,IAAI,CAAC,CAAC,CAAC,EAAEjB,UAAU,EAAEzC,KAAK,IAAI,CAAC;EAClD,MAAMtC,KAAK,GAAG4F,IAAI,CAACnC,QAAQ;EAC3B,IAAI,CAACY,IAAI,EACL;EACJ,MAAM4B,MAAM,GAAG5B,IAAI,CAAC4B,MAAM,GAAG3D,KAAK;EAClC,MAAM4D,OAAO,GAAG7B,IAAI,CAAC6B,OAAO,GAAG5D,KAAK;EACpC,MAAM6D,OAAO,GAAG9B,IAAI,CAAC8B,OAAO,GAAG7D,KAAK;EACpC,MAAM8D,SAAS,GAAG/B,IAAI,CAAC+B,SAAS,GAAG9D,KAAK;EACxC,IAAI+D,UAAU,GAAGzG,CAAC;EAClB,IAAI0G,UAAU,GAAGzG,CAAC;EAClB,QAAQgG,UAAU;IACd,KAAK,QAAQ;MACTQ,UAAU,GAAGzG,CAAC,GAAGI,KAAK,GAAG,CAAC;MAC1B;IACJ,KAAK,KAAK;MACNqG,UAAU,GAAGzG,CAAC,GAAGI,KAAK;MACtB;IACJ;MACIqG,UAAU,GAAGzG,CAAC;MACd;EACR;EACA,QAAQkG,gBAAgB;IACpB,KAAK,QAAQ;IACb,KAAK,SAAS;MACVQ,UAAU,GAAGzG,CAAC,GAAGuG,SAAS,GAAG,CAAC;MAC9B;IACJ,KAAK,SAAS;MACVE,UAAU,GAAGzG,CAAC,GAAGuG,SAAS;MAC1B;IACJ,KAAK,cAAc;MACfE,UAAU,GAAGzG,CAAC,GAAGqG,OAAO;MACxB;IACJ,KAAK,iBAAiB;MAClBI,UAAU,GAAGzG,CAAC,GAAGsG,OAAO;MACxB;IACJ,KAAK,kBAAkB;MACnBG,UAAU,GAAGzG,CAAC,GAAGoG,MAAM;MACvB;IACJ;MACIK,UAAU,GAAGzG,CAAC;MACd;EACR;EACAV,GAAG,CAACuG,SAAS,CAACW,UAAU,EAAEC,UAAU,CAAC;EACrCV,IAAI,CAACI,IAAI,CAACO,OAAO,CAAE1B,GAAG,IAAKD,WAAW,CAACzF,GAAG,EAAE0F,GAAG,CAAC,CAAC;EACjD1F,GAAG,CAAC8E,OAAO,CAAC,CAAC;AACjB,CAAC;AACD,MAAMuC,aAAa,GAAGA,CAACrH,GAAG,EAAEC,IAAI,KAAK;EACjC,MAAMqH,QAAQ,GAAGrH,IAAI,CAACqH,QAAQ;EAC9BA,QAAQ,CAACF,OAAO,CAAEG,IAAI,IAAKf,UAAU,CAACxG,GAAG,EAAEuH,IAAI,CAACC,KAAK,CAAC,CAAC,CAAC,EAAED,IAAI,CAACpH,KAAK,CAACuG,UAAU,EAAEa,IAAI,CAACpH,KAAK,CAACwG,gBAAgB,CAAC,CAAC;AAClH,CAAC;AAED,MAAMc,KAAK,GAAIC,MAAM,IAAK;EACtB,MAAMC,MAAM,GAAG,EAAE;EACjB,KAAK,IAAItE,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGqE,MAAM,CAAC3F,MAAM,EAAEsB,CAAC,IAAI,CAAC,EAAE;IACvCsE,MAAM,CAACnD,IAAI,CAAC,CAACkD,MAAM,CAACrE,CAAC,CAAC,EAAEqE,MAAM,CAACrE,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC;EAC3C;EACA,OAAOsE,MAAM;AACjB,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA,MAAMC,WAAW,GAAIC,MAAM,IAAK;EAC5B,IAAIH,MAAM,GAAG,CAACG,MAAM,IAAI,EAAE,EACrBC,IAAI,CAAC,CAAC,CACNC,OAAO,CAAC,IAAI,EAAE,GAAG,CAAC,CAClBA,OAAO,CAAC,YAAY,EAAE,QAAQ,CAAC,CAC/BC,KAAK,CAAC,KAAK,CAAC;EACjB,IAAIN,MAAM,CAAC3F,MAAM,GAAG,CAAC,KAAK,CAAC,EAAE;IACzB2F,MAAM,GAAGA,MAAM,CAACvD,KAAK,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC;EAChC;EACA,MAAM8D,YAAY,GAAGP,MAAM,CAACnC,GAAG,CAAC2C,UAAU,CAAC;EAC3C,OAAOT,KAAK,CAACQ,YAAY,CAAC;AAC9B,CAAC;AAED,MAAME,YAAY,GAAGA,CAACnI,GAAG,EAAE6H,MAAM,KAAK;EAClC,IAAIA,MAAM,CAAC9F,MAAM,GAAG,CAAC,EAAE;IACnB/B,GAAG,CAACiB,MAAM,CAAC4G,MAAM,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,EAAEA,MAAM,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;IACtCA,MAAM,CAAC1D,KAAK,CAAC,CAAC,CAAC,CAACiD,OAAO,CAAEgB,CAAC,IAAKpI,GAAG,CAACkB,MAAM,CAACkH,CAAC,CAAC,CAAC,CAAC,EAAEA,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;EAC1D;AACJ,CAAC;AACD,MAAMC,cAAc,GAAGA,CAACrI,GAAG,EAAEC,IAAI,KAAK;EAClC,MAAM4H,MAAM,GAAGD,WAAW,CAAC3H,IAAI,CAACE,KAAK,CAAC0H,MAAM,IAAI,EAAE,CAAC;EACnDM,YAAY,CAACnI,GAAG,EAAE6H,MAAM,CAAC;AAC7B,CAAC;AAED,MAAMS,aAAa,GAAGA,CAACtI,GAAG,EAAEC,IAAI,KAAK;EACjC,MAAM4H,MAAM,GAAGD,WAAW,CAAC3H,IAAI,CAACE,KAAK,CAAC0H,MAAM,IAAI,EAAE,CAAC;EACnDM,YAAY,CAACnI,GAAG,EAAE6H,MAAM,CAAC;EACzB7H,GAAG,CAACoB,SAAS,CAAC,CAAC;AACnB,CAAC;AAED,MAAMmH,aAAa,GAAGA,CAACvI,GAAG,EAAEC,IAAI,KAAK;EACjC,IAAI,CAACA,IAAI,CAAC2G,GAAG,EACT;EACJ,IAAI,CAAC3G,IAAI,CAACuI,KAAK,EAAEC,IAAI,EACjB;EACJ,MAAM;IAAEhI,CAAC,GAAG,CAAC;IAAEC,CAAC,GAAG;EAAE,CAAC,GAAGT,IAAI,CAACE,KAAK;EACnC,MAAM;IAAEU,KAAK;IAAEC,MAAM;IAAEiF;EAAQ,CAAC,GAAG9F,IAAI,CAACyI,KAAK;EAC7C,MAAMC,UAAU,GAAG1I,IAAI,CAAC2G,GAAG,CAACgC,WAAW,IAAI,CAAC;EAC5C,MAAMA,WAAW,GAAG3I,IAAI,CAAC2G,GAAG,CAACgC,WAAW,IAAI,CAAC;EAC7C,IAAI/H,KAAK,KAAK,CAAC,IAAIC,MAAM,KAAK,CAAC,EAAE;IAC7BuF,OAAO,CAACwC,IAAI,CAAC,mBAAmB5I,IAAI,CAACE,KAAK,CAAC2I,IAAI,qCAAqC,CAAC;IACrF;EACJ;EACA,IAAI,OAAOjI,KAAK,KAAK,QAAQ,IAAI,OAAOC,MAAM,KAAK,QAAQ,EAAE;IACzDuF,OAAO,CAACwC,IAAI,CAAC,mBAAmB5I,IAAI,CAACE,KAAK,CAAC2I,IAAI,6CAA6C,CAAC;IAC7F;EACJ;EACA9I,GAAG,CAACwD,IAAI,CAAC,CAAC;EACVxD,GAAG,CACEiG,WAAW,CAACF,OAAO,IAAI,CAAC,CAAC,CACzByC,KAAK,CAACvI,IAAI,CAACuI,KAAK,CAACC,IAAI,EAAEhI,CAAC,GAAGmI,WAAW,EAAElI,CAAC,GAAGiI,UAAU,EAAE;IACzD9H,KAAK;IACLC;EACJ,CAAC,CAAC;EACFd,GAAG,CAAC8E,OAAO,CAAC,CAAC;AACjB,CAAC;;AAED;AACA;AACA,MAAMiE,OAAO,GAAG,GAAG,IAAI,CAACzI,IAAI,CAACC,IAAI,CAAC,CAAC,CAAC,GAAG,GAAG,IAAI,GAAG,CAAC;AAClD,MAAMyI,QAAQ,GAAGA,CAAChJ,GAAG,EAAEC,IAAI,KAAK;EAC5B,IAAI,CAACA,IAAI,CAAC2G,GAAG,EACT;EACJ,IAAI,CAAC3G,IAAI,CAACyI,KAAK,EACX;EACJ,MAAM;IAAEO,GAAG;IAAEC,IAAI;IAAErI,KAAK;IAAEC;EAAO,CAAC,GAAGb,IAAI,CAAC2G,GAAG;EAC7C,MAAM;IAAEuC,mBAAmB,GAAG,CAAC;IAAEC,oBAAoB,GAAG,CAAC;IAAEC,uBAAuB,GAAG,CAAC;IAAEC,sBAAsB,GAAG;EAAG,CAAC,GAAGrJ,IAAI,CAACyI,KAAK;EAClI;EACA;EACA,MAAMa,GAAG,GAAGjJ,IAAI,CAACkJ,GAAG,CAACJ,oBAAoB,EAAE,GAAG,GAAGvI,KAAK,EAAE,GAAG,GAAGC,MAAM,CAAC;EACrE,MAAM2I,GAAG,GAAGF,GAAG,IAAI,GAAG,GAAGR,OAAO,CAAC;EACjC/I,GAAG,CAACiB,MAAM,CAACiI,IAAI,GAAGK,GAAG,EAAEN,GAAG,CAAC;EAC3BjJ,GAAG,CAACkB,MAAM,CAACgI,IAAI,GAAGrI,KAAK,GAAG0I,GAAG,EAAEN,GAAG,CAAC;EACnCjJ,GAAG,CAACmB,aAAa,CAAC+H,IAAI,GAAGrI,KAAK,GAAG4I,GAAG,EAAER,GAAG,EAAEC,IAAI,GAAGrI,KAAK,EAAEoI,GAAG,GAAGQ,GAAG,EAAEP,IAAI,GAAGrI,KAAK,EAAEoI,GAAG,GAAGM,GAAG,CAAC;EAC5F;EACA;EACA,MAAMG,GAAG,GAAGpJ,IAAI,CAACkJ,GAAG,CAACH,uBAAuB,EAAE,GAAG,GAAGxI,KAAK,EAAE,GAAG,GAAGC,MAAM,CAAC;EACxE,MAAM6I,GAAG,GAAGD,GAAG,IAAI,GAAG,GAAGX,OAAO,CAAC;EACjC/I,GAAG,CAACkB,MAAM,CAACgI,IAAI,GAAGrI,KAAK,EAAEoI,GAAG,GAAGnI,MAAM,GAAG4I,GAAG,CAAC;EAC5C1J,GAAG,CAACmB,aAAa,CAAC+H,IAAI,GAAGrI,KAAK,EAAEoI,GAAG,GAAGnI,MAAM,GAAG6I,GAAG,EAAET,IAAI,GAAGrI,KAAK,GAAG8I,GAAG,EAAEV,GAAG,GAAGnI,MAAM,EAAEoI,IAAI,GAAGrI,KAAK,GAAG6I,GAAG,EAAET,GAAG,GAAGnI,MAAM,CAAC;EACvH;EACA;EACA,MAAM8I,GAAG,GAAGtJ,IAAI,CAACkJ,GAAG,CAACF,sBAAsB,EAAE,GAAG,GAAGzI,KAAK,EAAE,GAAG,GAAGC,MAAM,CAAC;EACvE,MAAM+I,GAAG,GAAGD,GAAG,IAAI,GAAG,GAAGb,OAAO,CAAC;EACjC/I,GAAG,CAACkB,MAAM,CAACgI,IAAI,GAAGU,GAAG,EAAEX,GAAG,GAAGnI,MAAM,CAAC;EACpCd,GAAG,CAACmB,aAAa,CAAC+H,IAAI,GAAGW,GAAG,EAAEZ,GAAG,GAAGnI,MAAM,EAAEoI,IAAI,EAAED,GAAG,GAAGnI,MAAM,GAAG+I,GAAG,EAAEX,IAAI,EAAED,GAAG,GAAGnI,MAAM,GAAG8I,GAAG,CAAC;EAC/F;EACA;EACA,MAAME,GAAG,GAAGxJ,IAAI,CAACkJ,GAAG,CAACL,mBAAmB,EAAE,GAAG,GAAGtI,KAAK,EAAE,GAAG,GAAGC,MAAM,CAAC;EACpE,MAAMiJ,GAAG,GAAGD,GAAG,IAAI,GAAG,GAAGf,OAAO,CAAC;EACjC/I,GAAG,CAACkB,MAAM,CAACgI,IAAI,EAAED,GAAG,GAAGa,GAAG,CAAC;EAC3B9J,GAAG,CAACmB,aAAa,CAAC+H,IAAI,EAAED,GAAG,GAAGc,GAAG,EAAEb,IAAI,GAAGa,GAAG,EAAEd,GAAG,EAAEC,IAAI,GAAGY,GAAG,EAAEb,GAAG,CAAC;EACpEjJ,GAAG,CAACoB,SAAS,CAAC,CAAC;EACfpB,GAAG,CAACgK,IAAI,CAAC,CAAC;AACd,CAAC;AAED,MAAMC,yBAAyB,GAAGA,CAACjK,GAAG,EAAEyD,SAAS,EAAEyG,MAAM,KAAK;EAC1D,MAAM;IAAEC,SAAS;IAAEC;EAAM,CAAC,GAAG3G,SAAS;EACtC,QAAQ0G,SAAS;IACb,KAAK,OAAO;MAAE;QACV,MAAM,CAACE,MAAM,EAAEC,MAAM,CAAC,GAAGF,KAAK;QAC9BpK,GAAG,CAACmD,KAAK,CAACkH,MAAM,EAAEC,MAAM,EAAE;UAAEJ;QAAO,CAAC,CAAC;QACrC;MACJ;IACA,KAAK,QAAQ;MAAE;QACX,MAAM,CAACK,KAAK,CAAC,GAAGH,KAAK;QACrBpK,GAAG,CAACwK,MAAM,CAACD,KAAK,EAAE;UAAEL;QAAO,CAAC,CAAC;QAC7B;MACJ;IACA,KAAK,WAAW;MAAE;QACd,MAAM,CAACzJ,CAAC,EAAEC,CAAC,GAAG,CAAC,CAAC,GAAG0J,KAAK;QACxBpK,GAAG,CAACuG,SAAS,CAAC9F,CAAC,EAAEC,CAAC,EAAE;UAAEwJ;QAAO,CAAC,CAAC;QAC/B;MACJ;IACA,KAAK,MAAM;MAAE;QACT,MAAM,CAACO,MAAM,GAAG,CAAC,EAAEC,MAAM,GAAG,CAAC,CAAC,GAAGN,KAAK;QACtC,MAAMO,IAAI,GAAIF,MAAM,GAAGnK,IAAI,CAACsK,EAAE,GAAI,GAAG;QACrC,MAAMC,IAAI,GAAIH,MAAM,GAAGpK,IAAI,CAACsK,EAAE,GAAI,GAAG;QACrC,MAAME,IAAI,GAAGxK,IAAI,CAACyK,GAAG,CAACJ,IAAI,CAAC;QAC3B,MAAMK,IAAI,GAAG1K,IAAI,CAACyK,GAAG,CAACF,IAAI,CAAC;QAC3B,IAAIpK,CAAC,GAAG,CAAC;QACT,IAAIC,CAAC,GAAG,CAAC;QACT,IAAIwJ,MAAM,IAAI,IAAI,EAAE;UAChB,CAACzJ,CAAC,EAAEC,CAAC,CAAC,GAAGuK,KAAK,CAACC,IAAI,CAAChB,MAAM,CAAC;UAC3B,MAAM5I,EAAE,GAAGb,CAAC,GAAGqK,IAAI,GAAGpK,CAAC;UACvB,MAAMc,EAAE,GAAGd,CAAC,GAAGsK,IAAI,GAAGvK,CAAC;UACvBA,CAAC,IAAIa,EAAE;UACPZ,CAAC,IAAIc,EAAE;QACX;QACAxB,GAAG,CAACyD,SAAS,CAAC,CAAC,EAAEuH,IAAI,EAAEF,IAAI,EAAE,CAAC,EAAErK,CAAC,EAAEC,CAAC,CAAC;QACrC;MACJ;IACA,KAAK,QAAQ;MAAE;QACXV,GAAG,CAACyD,SAAS,CAAC,GAAG2G,KAAK,CAAC;QACvB;MACJ;IACA;MAAS;QACL/D,OAAO,CAACD,KAAK,CAAC,yBAAyB+D,SAAS,qBAAqB,CAAC;MAC1E;EACJ;AACJ,CAAC;AACD,MAAMgB,oBAAoB,GAAGA,CAACnL,GAAG,EAAEC,IAAI,KAAK;EACxC,IAAI,CAACA,IAAI,CAACiK,MAAM,EACZ;EACJ,MAAM;IAAE/J,KAAK;IAAEuI;EAAM,CAAC,GAAGzI,IAAI;EAC7B,MAAMiK,MAAM,GAAG,CAACjK,IAAI,CAACiK,MAAM,CAAChB,IAAI,EAAEjJ,IAAI,CAACiK,MAAM,CAACjB,GAAG,CAAC;EAClD,MAAMmC,cAAc,GAAG,WAAW,IAAIjL,KAAK,GAAGA,KAAK,CAACsD,SAAS,GAAGzB,SAAS;EACzE,MAAMqJ,UAAU,GAAG3C,KAAK,EAAEjF,SAAS,IAAI2H,cAAc,IAAI,EAAE;EAC3DC,UAAU,CAACjE,OAAO,CAAE+C,SAAS,IAAK;IAC9BF,yBAAyB,CAACjK,GAAG,EAAEmK,SAAS,EAAED,MAAM,CAAC;EACrD,CAAC,CAAC;AACN,CAAC;;AAED;AACA,MAAMoB,kBAAkB,GAAIrL,IAAI,IAAK;EACjC,MAAMG,IAAI,GAAGP,aAAa,CAACF,OAAO,CAACC,SAAS,CAACK,IAAI,CAACE,KAAK,EAAED,CAAC,IAAI,EAAE,CAAC,CAAC,CAAC;EACnE,IAAI,CAACE,IAAI,CAAC2B,MAAM,EACZ,OAAO,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC;EACvB,MAAMwJ,MAAM,GAAG,CAACC,QAAQ,EAAEA,QAAQ,EAAE,CAACA,QAAQ,EAAE,CAACA,QAAQ,CAAC;EACzD,KAAK,IAAInI,CAAC,GAAG,CAAC,EAAEoI,CAAC,GAAGrL,IAAI,CAAC2B,MAAM,EAAEsB,CAAC,GAAGoI,CAAC,EAAEpI,CAAC,IAAI,CAAC,EAAE;IAC5C,MAAMwE,MAAM,GAAGzH,IAAI,CAACiD,CAAC,CAAC,CAACc,KAAK,CAAC,CAAC,CAAC;IAC/B,KAAK,IAAIuH,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG7D,MAAM,CAAC9F,MAAM,EAAE2J,CAAC,IAAI,CAAC,EAAE;MACvC,IAAI7D,MAAM,CAAC6D,CAAC,GAAG,CAAC,CAAC,GAAGH,MAAM,CAAC,CAAC,CAAC,EACzBA,MAAM,CAAC,CAAC,CAAC,GAAG1D,MAAM,CAAC6D,CAAC,GAAG,CAAC,CAAC;MAC7B,IAAI7D,MAAM,CAAC6D,CAAC,GAAG,CAAC,CAAC,GAAGH,MAAM,CAAC,CAAC,CAAC,EACzBA,MAAM,CAAC,CAAC,CAAC,GAAG1D,MAAM,CAAC6D,CAAC,GAAG,CAAC,CAAC;MAC7B,IAAI7D,MAAM,CAAC6D,CAAC,GAAG,CAAC,CAAC,GAAGH,MAAM,CAAC,CAAC,CAAC,EACzBA,MAAM,CAAC,CAAC,CAAC,GAAG1D,MAAM,CAAC6D,CAAC,GAAG,CAAC,CAAC;MAC7B,IAAI7D,MAAM,CAAC6D,CAAC,GAAG,CAAC,CAAC,GAAGH,MAAM,CAAC,CAAC,CAAC,EACzBA,MAAM,CAAC,CAAC,CAAC,GAAG1D,MAAM,CAAC6D,CAAC,GAAG,CAAC,CAAC;IACjC;EACJ;EACA,OAAOH,MAAM;AACjB,CAAC;AACD,MAAMI,oBAAoB,GAAI1L,IAAI,IAAK;EACnC,MAAMyC,CAAC,GAAGzC,IAAI,CAACE,KAAK,EAAEuC,CAAC,IAAI,CAAC;EAC5B,MAAMb,EAAE,GAAG5B,IAAI,CAACE,KAAK,EAAE0B,EAAE,IAAI,CAAC;EAC9B,MAAMI,EAAE,GAAGhC,IAAI,CAACE,KAAK,EAAE8B,EAAE,IAAI,CAAC;EAC9B,OAAO,CAACJ,EAAE,GAAGa,CAAC,EAAET,EAAE,GAAGS,CAAC,EAAEb,EAAE,GAAGa,CAAC,EAAET,EAAE,GAAGS,CAAC,CAAC;AAC3C,CAAC;AACD,MAAMkJ,qBAAqB,GAAI3L,IAAI,IAAK;EACpC,MAAM4B,EAAE,GAAG5B,IAAI,CAACE,KAAK,EAAE0B,EAAE,IAAI,CAAC;EAC9B,MAAMI,EAAE,GAAGhC,IAAI,CAACE,KAAK,EAAE8B,EAAE,IAAI,CAAC;EAC9B,MAAMtB,EAAE,GAAGV,IAAI,CAACE,KAAK,EAAEQ,EAAE,IAAI,CAAC;EAC9B,MAAMC,EAAE,GAAGX,IAAI,CAACE,KAAK,EAAES,EAAE,IAAI,CAAC;EAC9B,OAAO,CAACiB,EAAE,GAAGlB,EAAE,EAAEsB,EAAE,GAAGrB,EAAE,EAAEiB,EAAE,GAAGlB,EAAE,EAAEsB,EAAE,GAAGrB,EAAE,CAAC;AAC/C,CAAC;AACD,MAAMiL,kBAAkB,GAAI5L,IAAI,IAAK;EACjC,MAAMqB,EAAE,GAAGrB,IAAI,CAACE,KAAK,EAAEmB,EAAE,IAAI,CAAC;EAC9B,MAAME,EAAE,GAAGvB,IAAI,CAACE,KAAK,EAAEqB,EAAE,IAAI,CAAC;EAC9B,MAAMD,EAAE,GAAGtB,IAAI,CAACE,KAAK,EAAEoB,EAAE,IAAI,CAAC;EAC9B,MAAME,EAAE,GAAGxB,IAAI,CAACE,KAAK,EAAEsB,EAAE,IAAI,CAAC;EAC9B,OAAO,CACHnB,IAAI,CAACkJ,GAAG,CAAClI,EAAE,EAAEC,EAAE,CAAC,EAChBjB,IAAI,CAACkJ,GAAG,CAAChI,EAAE,EAAEC,EAAE,CAAC,EAChBnB,IAAI,CAACwL,GAAG,CAACxK,EAAE,EAAEC,EAAE,CAAC,EAChBjB,IAAI,CAACwL,GAAG,CAACtK,EAAE,EAAEC,EAAE,CAAC,CACnB;AACL,CAAC;AACD,MAAMsK,kBAAkB,GAAI9L,IAAI,IAAK;EACjC,MAAMQ,CAAC,GAAGR,IAAI,CAACE,KAAK,EAAEM,CAAC,IAAI,CAAC;EAC5B,MAAMC,CAAC,GAAGT,IAAI,CAACE,KAAK,EAAEO,CAAC,IAAI,CAAC;EAC5B,MAAMG,KAAK,GAAGZ,IAAI,CAACE,KAAK,EAAEU,KAAK,IAAI,CAAC;EACpC,MAAMC,MAAM,GAAGb,IAAI,CAACE,KAAK,EAAEW,MAAM,IAAI,CAAC;EACtC,OAAO,CAACL,CAAC,EAAEC,CAAC,EAAED,CAAC,GAAGI,KAAK,EAAEH,CAAC,GAAGI,MAAM,CAAC;AACxC,CAAC;AACD,MAAMgL,GAAG,GAAIpE,MAAM,IAAKpH,IAAI,CAACwL,GAAG,CAAC,CAACN,QAAQ,EAAE,GAAG9D,MAAM,CAAC;AACtD,MAAM8B,GAAG,GAAI9B,MAAM,IAAKpH,IAAI,CAACkJ,GAAG,CAACgC,QAAQ,EAAE,GAAG9D,MAAM,CAAC;AACrD,MAAMsE,sBAAsB,GAAI/L,IAAI,IAAK;EACrC,MAAM4H,MAAM,GAAGD,WAAW,CAAC3H,IAAI,CAACE,KAAK,EAAE0H,MAAM,CAAC;EAC9C,MAAMoE,OAAO,GAAGpE,MAAM,CAACtC,GAAG,CAAE6C,CAAC,IAAKA,CAAC,CAAC,CAAC,CAAC,CAAC;EACvC,MAAM8D,OAAO,GAAGrE,MAAM,CAACtC,GAAG,CAAE6C,CAAC,IAAKA,CAAC,CAAC,CAAC,CAAC,CAAC;EACvC,OAAO,CAACoB,GAAG,CAACyC,OAAO,CAAC,EAAEzC,GAAG,CAAC0C,OAAO,CAAC,EAAEJ,GAAG,CAACG,OAAO,CAAC,EAAEH,GAAG,CAACI,OAAO,CAAC,CAAC;AACnE,CAAC;AACD,MAAMC,cAAc,GAAG;EACnB,CAAC3M,CAAC,CAAC4M,IAAI,GAAGL,kBAAkB;EAC5B,CAACvM,CAAC,CAAC6M,IAAI,GAAGR,kBAAkB;EAC5B,CAACrM,CAAC,CAAC8M,IAAI,GAAGhB,kBAAkB;EAC5B,CAAC9L,CAAC,CAAC+M,MAAM,GAAGZ,oBAAoB;EAChC,CAACnM,CAAC,CAACgN,OAAO,GAAGZ,qBAAqB;EAClC,CAACpM,CAAC,CAACiN,OAAO,GAAGT,sBAAsB;EACnC,CAACxM,CAAC,CAACkN,QAAQ,GAAGV;AAClB,CAAC;AACD,MAAMW,cAAc,GAAI1M,IAAI,IAAK;EAC7B,MAAM2M,aAAa,GAAGT,cAAc,CAAClM,IAAI,CAACiG,IAAI,CAAC;EAC/C,OAAO0G,aAAa,GAAGA,aAAa,CAAC3M,IAAI,CAAC,GAAG,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC;AAC7D,CAAC;AAED,MAAM4M,cAAc,GAAGA,CAAC7M,GAAG,EAAEC,IAAI,KAAK;EAClC,IAAI,CAACA,IAAI,CAACE,KAAK,EACX;EACJ,IAAI,EAAE,aAAa,IAAIF,IAAI,CAACE,KAAK,CAAC,EAC9B;EACJ,MAAM2M,SAAS,GAAG7M,IAAI,CAACE,KAAK,CAAC4M,WAAW;EACxC,IAAID,SAAS,EACT9M,GAAG,CAAC8M,SAAS,CAACA,SAAS,CAAC;AAChC,CAAC;AACD,MAAME,cAAc,GAAGA,CAAChN,GAAG,EAAEC,IAAI,KAAK;EAClC,IAAI,CAACA,IAAI,CAACE,KAAK,EACX;EACJ,IAAI,EAAE,QAAQ,IAAIF,IAAI,CAACE,KAAK,CAAC,EACzB;EACJ,MAAM8M,WAAW,GAAGhN,IAAI,CAACE,KAAK,CAAC+M,MAAM;EACrC,IAAID,WAAW,EACXjN,GAAG,CAACiN,WAAW,CAACA,WAAW,CAAC;AACpC,CAAC;AACD,MAAME,UAAU,GAAGA,CAACnN,GAAG,EAAEC,IAAI,KAAK;EAC9B,IAAI,CAACA,IAAI,CAACE,KAAK,EACX;EACJ,IAAI,EAAE,SAAS,IAAIF,IAAI,CAACE,KAAK,CAAC,EAC1B;EACJ,MAAM4F,OAAO,GAAG9F,IAAI,CAACE,KAAK,CAAC4F,OAAO;EAClC,IAAI,CAACtG,KAAK,CAACsG,OAAO,CAAC,EACf/F,GAAG,CAAC+F,OAAO,CAACA,OAAO,CAAC;AAC5B,CAAC;AACD,MAAMqH,cAAc,GAAGA,CAACpN,GAAG,EAAEC,IAAI,KAAK;EAClC,IAAI,CAACA,IAAI,CAACE,KAAK,EACX;EACJ,IAAI,EAAE,aAAa,IAAIF,IAAI,CAACE,KAAK,CAAC,EAC9B;EACJ,MAAM8F,WAAW,GAAGhG,IAAI,CAACE,KAAK,CAAC8F,WAAW,IAAI,IAAI;EAClD,IAAI,CAACxG,KAAK,CAACwG,WAAW,CAAC,EACnBjG,GAAG,CAACiG,WAAW,CAACA,WAAW,CAAC;AACpC,CAAC;AACD,MAAMoH,gBAAgB,GAAGA,CAACrN,GAAG,EAAEC,IAAI,KAAK;EACpC,IAAI,CAACA,IAAI,CAACE,KAAK,EACX;EACJ,IAAI,EAAE,eAAe,IAAIF,IAAI,CAACE,KAAK,CAAC,EAChC;EACJ,MAAMmN,aAAa,GAAGrN,IAAI,CAACE,KAAK,EAAEmN,aAAa;EAC/C,IAAI,CAAC7N,KAAK,CAAC6N,aAAa,CAAC,EACrBtN,GAAG,CAACsN,aAAa,CAACA,aAAa,CAAC;AACxC,CAAC;AACD,MAAMC,WAAW,GAAGA,CAACvN,GAAG,EAAEC,IAAI,KAAK;EAC/B,IAAI,CAACA,IAAI,CAACE,KAAK,EACX;EACJ,IAAI,EAAE,gBAAgB,IAAIF,IAAI,CAACE,KAAK,CAAC,EACjC;EACJ,MAAMqN,QAAQ,GAAGvN,IAAI,CAACE,KAAK,CAACsN,cAAc;EAC1C,IAAID,QAAQ,EACRxN,GAAG,CAACwN,QAAQ,CAACA,QAAQ,CAAC;AAC9B,CAAC;AACD,MAAME,UAAU,GAAGA,CAAC1N,GAAG,EAAEC,IAAI,KAAK;EAC9B,IAAI,CAACA,IAAI,CAACE,KAAK,EACX;EACJ,IAAI,EAAE,eAAe,IAAIF,IAAI,CAACE,KAAK,CAAC,EAChC;EACJ,MAAMwN,OAAO,GAAG1N,IAAI,CAACE,KAAK,EAAEyN,aAAa;EACzC,IAAID,OAAO,EACP3N,GAAG,CAAC2N,OAAO,CAACA,OAAO,CAAC;AAC5B,CAAC;AACD,MAAME,WAAW,GAAGA,CAAC7N,GAAG,EAAEC,IAAI,KAAK;EAC/B,IAAI,CAACA,IAAI,CAACE,KAAK,EACX;EACJ,IAAI,EAAE,iBAAiB,IAAIF,IAAI,CAACE,KAAK,CAAC,EAClC;EACJ,MAAMiK,KAAK,GAAGnK,IAAI,CAACE,KAAK,EAAE2N,eAAe,IAAI,IAAI;EACjD;EACA,IAAI1D,KAAK,EACLpK,GAAG,CAAC+N,IAAI,CAAC3D,KAAK,CAACpC,KAAK,CAAC,QAAQ,CAAC,CAACzC,GAAG,CAACyI,MAAM,CAAC,CAAC;AACnD,CAAC;AACD,MAAMC,qBAAqB,GAAIhO,IAAI,IAAK;EACpC,IAAI,CAACA,IAAI,CAACE,KAAK,EACX,OAAO,KAAK;EAChB,IAAI,EAAE,MAAM,IAAIF,IAAI,CAACE,KAAK,CAAC,EACvB,OAAO,KAAK;EAChB,IAAI,OAAOF,IAAI,CAACE,KAAK,CAAC+N,IAAI,KAAK,QAAQ,EACnC,OAAO,KAAK;EAChB,OAAOjO,IAAI,CAACE,KAAK,CAAC+N,IAAI,EAAEhI,IAAI,KAAK1G,CAAC,CAAC2O,cAAc;AACrD,CAAC;AACD,MAAMC,qBAAqB,GAAInO,IAAI,IAAK;EACpC,IAAI,CAACA,IAAI,CAACE,KAAK,EACX,OAAO,KAAK;EAChB,IAAI,EAAE,MAAM,IAAIF,IAAI,CAACE,KAAK,CAAC,EACvB,OAAO,KAAK;EAChB,IAAI,OAAOF,IAAI,CAACE,KAAK,CAAC+N,IAAI,KAAK,QAAQ,EACnC,OAAO,KAAK;EAChB,OAAOjO,IAAI,CAACE,KAAK,CAAC+N,IAAI,EAAEhI,IAAI,KAAK1G,CAAC,CAAC6O,cAAc;AACrD,CAAC;AACD,SAASC,gBAAgBA,CAACC,EAAE,EAAEC,EAAE,EAAE;EAC9B,MAAMC,CAAC,GAAGF,EAAE,CAAC,CAAC,CAAC,GAAGC,EAAE,CAAC,CAAC,CAAC,GAAGD,EAAE,CAAC,CAAC,CAAC,GAAGC,EAAE,CAAC,CAAC,CAAC;EACvC,MAAME,CAAC,GAAGH,EAAE,CAAC,CAAC,CAAC,GAAGC,EAAE,CAAC,CAAC,CAAC,GAAGD,EAAE,CAAC,CAAC,CAAC,GAAGC,EAAE,CAAC,CAAC,CAAC;EACvC,MAAMG,CAAC,GAAGJ,EAAE,CAAC,CAAC,CAAC,GAAGC,EAAE,CAAC,CAAC,CAAC,GAAGD,EAAE,CAAC,CAAC,CAAC,GAAGC,EAAE,CAAC,CAAC,CAAC;EACvC,MAAMtO,CAAC,GAAGqO,EAAE,CAAC,CAAC,CAAC,GAAGC,EAAE,CAAC,CAAC,CAAC,GAAGD,EAAE,CAAC,CAAC,CAAC,GAAGC,EAAE,CAAC,CAAC,CAAC;EACvC,MAAMI,CAAC,GAAGL,EAAE,CAAC,CAAC,CAAC,GAAGC,EAAE,CAAC,CAAC,CAAC,GAAGD,EAAE,CAAC,CAAC,CAAC,GAAGC,EAAE,CAAC,CAAC,CAAC,GAAGD,EAAE,CAAC,CAAC,CAAC;EAC/C,MAAMM,CAAC,GAAGN,EAAE,CAAC,CAAC,CAAC,GAAGC,EAAE,CAAC,CAAC,CAAC,GAAGD,EAAE,CAAC,CAAC,CAAC,GAAGC,EAAE,CAAC,CAAC,CAAC,GAAGD,EAAE,CAAC,CAAC,CAAC;EAC/C,OAAO,CAACE,CAAC,EAAEC,CAAC,EAAEC,CAAC,EAAEzO,CAAC,EAAE0O,CAAC,EAAEC,CAAC,CAAC;AAC7B;AACA,MAAMC,iBAAiB,GAAGA,CAACC,IAAI,EAAEC,UAAU,EAAEC,IAAI,EAAEC,KAAK,KAAK;EACzD,MAAMC,QAAQ,GAAGH,UAAU,CAACzJ,GAAG,CAAE9B,SAAS,IAAK;IAC3C,QAAQA,SAAS,CAAC0G,SAAS;MACvB,KAAK,OAAO;QAAE;UACV,MAAMC,KAAK,GAAG3G,SAAS,CAAC2G,KAAK;UAC7B,OAAO,CAACA,KAAK,CAAC,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,EAAEA,KAAK,CAAC,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC;QAC3C;MACA,KAAK,WAAW;QAAE;UACd,MAAMA,KAAK,GAAG3G,SAAS,CAAC2G,KAAK;UAC7B,IAAI3J,CAAC,GAAG2J,KAAK,CAAC,CAAC,CAAC,IAAI,CAAC;UACrB,IAAI1J,CAAC,GAAG0J,KAAK,CAAC,CAAC,CAAC,IAAI,CAAC;UACrB,IAAI8E,KAAK,KAAK,mBAAmB,EAAE;YAC/BzO,CAAC,GAAG,CAACwO,IAAI,CAAC,CAAC,CAAC,GAAGA,IAAI,CAAC,CAAC,CAAC,IAAIxO,CAAC;YAC3BC,CAAC,GAAG,CAACuO,IAAI,CAAC,CAAC,CAAC,GAAGA,IAAI,CAAC,CAAC,CAAC,IAAIvO,CAAC;UAC/B;UACA,OAAO,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAED,CAAC,EAAEC,CAAC,CAAC;QAC7B;MACA,KAAK,QAAQ;QAAE;UACX,MAAM0J,KAAK,GAAG3G,SAAS,CAAC2G,KAAK;UAC7B,MAAMgF,GAAG,GAAG9O,IAAI,CAAC8O,GAAG,CAAChF,KAAK,CAAC,CAAC,CAAC,CAAC;UAC9B,MAAMiF,GAAG,GAAG/O,IAAI,CAAC+O,GAAG,CAACjF,KAAK,CAAC,CAAC,CAAC,CAAC;UAC9B,OAAO,CAACgF,GAAG,EAAEC,GAAG,EAAE,CAACA,GAAG,EAAED,GAAG,EAAE,CAAC,EAAE,CAAC,CAAC;QACtC;MACA,KAAK,MAAM;QAAE;UACT,MAAMhF,KAAK,GAAG3G,SAAS,CAAC2G,KAAK;UAC7B,OAAO,CAAC,CAAC,EAAE9J,IAAI,CAACyK,GAAG,CAACX,KAAK,CAAC,CAAC,CAAC,CAAC,EAAE9J,IAAI,CAACyK,GAAG,CAACX,KAAK,CAAC,CAAC,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC;QAC/D;MACA,KAAK,QAAQ;QAAE;UACX,MAAMA,KAAK,GAAG3G,SAAS,CAAC2G,KAAK;UAC7B,IAAI3J,CAAC,GAAG2J,KAAK,CAAC,CAAC,CAAC,IAAI,CAAC;UACrB,IAAI1J,CAAC,GAAG0J,KAAK,CAAC,CAAC,CAAC,IAAI,CAAC;UACrB,IAAI8E,KAAK,KAAK,mBAAmB,EAAE;YAC/BzO,CAAC,GAAG,CAACwO,IAAI,CAAC,CAAC,CAAC,GAAGA,IAAI,CAAC,CAAC,CAAC,IAAIxO,CAAC;YAC3BC,CAAC,GAAG,CAACuO,IAAI,CAAC,CAAC,CAAC,GAAGA,IAAI,CAAC,CAAC,CAAC,IAAIvO,CAAC;UAC/B;UACA,OAAO,CAAC0J,KAAK,CAAC,CAAC,CAAC,EAAEA,KAAK,CAAC,CAAC,CAAC,EAAEA,KAAK,CAAC,CAAC,CAAC,EAAEA,KAAK,CAAC,CAAC,CAAC,EAAE3J,CAAC,EAAEC,CAAC,CAAC;QACzD;MACA;QACI,OAAO,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC;IACjC;EACJ,CAAC,CAAC;EACF,MAAM4O,MAAM,GAAGH,QAAQ,CAACI,MAAM,CAACjB,gBAAgB,EAAE,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC,CAAC;EACpES,IAAI,CAACS,YAAY,CAAC,GAAGF,MAAM,CAAC;AAChC,CAAC;AACD;AACA,MAAMG,qBAAqB,GAAGA,CAACzP,GAAG,EAAEC,IAAI,KAAK;EACzC,IAAI,CAACA,IAAI,CAACE,KAAK,EACX;EACJ,IAAI,EAAE,MAAM,IAAIF,IAAI,CAACE,KAAK,CAAC,EACvB;EACJ,MAAM8O,IAAI,GAAGtC,cAAc,CAAC1M,IAAI,CAAC;EACjC,MAAMyP,QAAQ,GAAGzP,IAAI,CAACE,KAAK,EAAE+N,IAAI;EACjC,IAAI,CAACwB,QAAQ,EACT;EACJ,MAAMR,KAAK,GAAGQ,QAAQ,CAACvP,KAAK,CAACwP,aAAa,IAAI,mBAAmB;EACjE,MAAMX,UAAU,GAAGU,QAAQ,CAACvP,KAAK,CAACyP,iBAAiB,IAAI,EAAE;EACzD,IAAItO,EAAE,GAAGoO,QAAQ,CAACvP,KAAK,CAACmB,EAAE,IAAI,CAAC;EAC/B,IAAIE,EAAE,GAAGkO,QAAQ,CAACvP,KAAK,CAACqB,EAAE,IAAI,CAAC;EAC/B,IAAID,EAAE,GAAGmO,QAAQ,CAACvP,KAAK,CAACoB,EAAE,IAAI,CAAC;EAC/B,IAAIE,EAAE,GAAGiO,QAAQ,CAACvP,KAAK,CAACsB,EAAE,IAAI,CAAC;EAC/B,IAAIyN,KAAK,KAAK,mBAAmB,EAAE;IAC/B,MAAMW,EAAE,GAAGZ,IAAI,CAAC,CAAC,CAAC,GAAGA,IAAI,CAAC,CAAC,CAAC;IAC5B,MAAMa,EAAE,GAAGb,IAAI,CAAC,CAAC,CAAC,GAAGA,IAAI,CAAC,CAAC,CAAC;IAC5B,MAAMc,EAAE,GAAGd,IAAI,CAAC,CAAC,CAAC;IAClB,MAAMe,EAAE,GAAGf,IAAI,CAAC,CAAC,CAAC;IAClB3N,EAAE,GAAGuO,EAAE,GAAGvO,EAAE,GAAGyO,EAAE;IACjBvO,EAAE,GAAGsO,EAAE,GAAGtO,EAAE,GAAGwO,EAAE;IACjBzO,EAAE,GAAGsO,EAAE,GAAGtO,EAAE,GAAGwO,EAAE;IACjBtO,EAAE,GAAGqO,EAAE,GAAGrO,EAAE,GAAGuO,EAAE;EACrB;EACA,MAAMjB,IAAI,GAAG/O,GAAG,CAACiQ,cAAc,CAAC3O,EAAE,EAAEE,EAAE,EAAED,EAAE,EAAEE,EAAE,CAAC;EAC/CqN,iBAAiB,CAACC,IAAI,EAAEC,UAAU,EAAEC,IAAI,EAAEC,KAAK,CAAC;EAChDQ,QAAQ,CAACpI,QAAQ,EAAEF,OAAO,CAAE8I,IAAI,IAAK;IACjCnB,IAAI,CAACmB,IAAI,CAACA,IAAI,CAAC/P,KAAK,CAACgQ,MAAM,EAAED,IAAI,CAAC/P,KAAK,CAACiQ,SAAS,EAAEF,IAAI,CAAC/P,KAAK,CAACkQ,WAAW,CAAC;EAC9E,CAAC,CAAC;EACFrQ,GAAG,CAACkO,IAAI,CAACa,IAAI,CAAC;AAClB,CAAC;AACD;AACA,MAAMuB,qBAAqB,GAAGA,CAACtQ,GAAG,EAAEC,IAAI,KAAK;EACzC,IAAI,CAACA,IAAI,CAACE,KAAK,EACX;EACJ,IAAI,EAAE,MAAM,IAAIF,IAAI,CAACE,KAAK,CAAC,EACvB;EACJ,MAAM8O,IAAI,GAAGtC,cAAc,CAAC1M,IAAI,CAAC;EACjC,MAAMyP,QAAQ,GAAGzP,IAAI,CAACE,KAAK,EAAE+N,IAAI;EACjC,IAAI,CAACwB,QAAQ,EACT;EACJ,MAAMR,KAAK,GAAGQ,QAAQ,CAACvP,KAAK,CAACwP,aAAa,IAAI,mBAAmB;EACjE,MAAMX,UAAU,GAAGU,QAAQ,CAACvP,KAAK,CAACyP,iBAAiB,IAAI,EAAE;EACzD,IAAIlN,CAAC,GAAGgN,QAAQ,CAACvP,KAAK,CAACuC,CAAC,IAAI,GAAG;EAC/B,IAAIb,EAAE,GAAG6N,QAAQ,CAACvP,KAAK,CAAC0B,EAAE,IAAI,GAAG;EACjC,IAAII,EAAE,GAAGyN,QAAQ,CAACvP,KAAK,CAAC8B,EAAE,IAAI,GAAG;EACjC,IAAIsO,EAAE,GAAGb,QAAQ,CAACvP,KAAK,CAACoQ,EAAE,IAAI1O,EAAE;EAChC,IAAI2O,EAAE,GAAGd,QAAQ,CAACvP,KAAK,CAACqQ,EAAE,IAAIvO,EAAE;EAChC,IAAIiN,KAAK,KAAK,mBAAmB,EAAE;IAC/B,MAAMW,EAAE,GAAGZ,IAAI,CAAC,CAAC,CAAC,GAAGA,IAAI,CAAC,CAAC,CAAC;IAC5B,MAAMa,EAAE,GAAGb,IAAI,CAAC,CAAC,CAAC,GAAGA,IAAI,CAAC,CAAC,CAAC;IAC5B,MAAMc,EAAE,GAAGd,IAAI,CAAC,CAAC,CAAC;IAClB,MAAMe,EAAE,GAAGf,IAAI,CAAC,CAAC,CAAC;IAClBvM,CAAC,GAAGA,CAAC,GAAGmN,EAAE;IACVhO,EAAE,GAAGgO,EAAE,GAAGhO,EAAE,GAAGkO,EAAE;IACjB9N,EAAE,GAAG6N,EAAE,GAAG7N,EAAE,GAAG+N,EAAE;IACjBO,EAAE,GAAGV,EAAE,GAAGU,EAAE,GAAGR,EAAE;IACjBS,EAAE,GAAGV,EAAE,GAAGU,EAAE,GAAGR,EAAE;EACrB;EACA,MAAMjB,IAAI,GAAG/O,GAAG,CAACyQ,cAAc,CAAC5O,EAAE,EAAEI,EAAE,EAAE,CAAC,EAAEsO,EAAE,EAAEC,EAAE,EAAE9N,CAAC,CAAC;EACrDoM,iBAAiB,CAACC,IAAI,EAAEC,UAAU,EAAEC,IAAI,EAAEC,KAAK,CAAC;EAChDQ,QAAQ,CAACpI,QAAQ,EAAEF,OAAO,CAAE8I,IAAI,IAAK;IACjCnB,IAAI,CAACmB,IAAI,CAACA,IAAI,CAAC/P,KAAK,CAACgQ,MAAM,EAAED,IAAI,CAAC/P,KAAK,CAACiQ,SAAS,EAAEF,IAAI,CAAC/P,KAAK,CAACkQ,WAAW,CAAC;EAC9E,CAAC,CAAC;EACFrQ,GAAG,CAACkO,IAAI,CAACa,IAAI,CAAC;AAClB,CAAC;AACD,MAAM2B,YAAY,GAAGA,CAAC1Q,GAAG,EAAEC,IAAI,KAAK;EAChC,IAAI,CAACA,IAAI,CAACE,KAAK,EACX;EACJ,IAAI,EAAE,MAAM,IAAIF,IAAI,CAACE,KAAK,CAAC,EACvB;EACJ,MAAM6F,SAAS,GAAG/F,IAAI,CAACE,KAAK,EAAE+N,IAAI;EAClC,IAAIlI,SAAS,EACThG,GAAG,CAACgG,SAAS,CAACA,SAAS,CAAC;AAChC,CAAC;AACD,MAAM2K,OAAO,GAAGA,CAAC3Q,GAAG,EAAEC,IAAI,KAAK;EAC3B,IAAIgO,qBAAqB,CAAChO,IAAI,CAAC,EAC3B,OAAOwP,qBAAqB,CAACzP,GAAG,EAAEC,IAAI,CAAC;EAC3C,IAAImO,qBAAqB,CAACnO,IAAI,CAAC,EAC3B,OAAOqQ,qBAAqB,CAACtQ,GAAG,EAAEC,IAAI,CAAC;EAC3C,OAAOyQ,YAAY,CAAC1Q,GAAG,EAAEC,IAAI,CAAC;AAClC,CAAC;AACD,MAAM2Q,IAAI,GAAGA,CAAC5Q,GAAG,EAAEC,IAAI,KAAK;EACxB,MAAME,KAAK,GAAGF,IAAI,CAACE,KAAK,IAAI,CAAC,CAAC;EAC9B,IAAI,MAAM,IAAIA,KAAK,IAAI,QAAQ,IAAIA,KAAK,IAAIA,KAAK,CAAC+N,IAAI,IAAI/N,KAAK,CAAC+M,MAAM,EAAE;IACpElN,GAAG,CAAC6Q,aAAa,CAAC1Q,KAAK,CAAC2Q,QAAQ,CAAC;EACrC,CAAC,MACI,IAAI,MAAM,IAAI3Q,KAAK,IAAIA,KAAK,CAAC+N,IAAI,EAAE;IACpClO,GAAG,CAACkO,IAAI,CAAC/N,KAAK,CAAC2Q,QAAQ,CAAC;EAC5B,CAAC,MACI,IAAI,QAAQ,IAAI3Q,KAAK,IAAIA,KAAK,CAAC+M,MAAM,EAAE;IACxClN,GAAG,CAACkN,MAAM,CAAC,CAAC;EAChB,CAAC,MACI;IACDlN,GAAG,CAACwD,IAAI,CAAC,CAAC;IACVxD,GAAG,CAAC+F,OAAO,CAAC,CAAC,CAAC;IACd/F,GAAG,CAACkO,IAAI,CAAC,IAAI,CAAC;IACdlO,GAAG,CAAC8E,OAAO,CAAC,CAAC;EACjB;AACJ,CAAC;AACD,MAAMiM,IAAI,GAAGA,CAAA,KAAM,CAAE,CAAC;AACtB,MAAMC,WAAW,GAAG;EAChB,CAACxR,CAAC,CAACyR,KAAK,GAAGF,IAAI;EACf,CAACvR,CAAC,CAAC0R,YAAY,GAAGH,IAAI;EACtB,CAACvR,CAAC,CAAC8M,IAAI,GAAGvM,UAAU;EACpB,CAACP,CAAC,CAAC4M,IAAI,GAAG5L,UAAU;EACpB,CAAChB,CAAC,CAAC6M,IAAI,GAAGhL,YAAY;EACtB,CAAC7B,CAAC,CAAC2R,CAAC,GAAGzP,WAAW;EAClB,CAAClC,CAAC,CAAC4R,IAAI,GAAG/J,aAAa;EACvB,CAAC7H,CAAC,CAAC+M,MAAM,GAAG9J,YAAY;EACxB,CAACjD,CAAC,CAAC6R,KAAK,GAAG9I,aAAa;EACxB,CAAC/I,CAAC,CAACgN,OAAO,GAAGhK,aAAa;EAC1B,CAAChD,CAAC,CAACiN,OAAO,GAAGnE,aAAa;EAC1B,CAAC9I,CAAC,CAACkN,QAAQ,GAAGrE;AAClB,CAAC;AACD,MAAMiJ,YAAY,GAAGA,CAACtR,GAAG,EAAEC,IAAI,KAAK;EAChC,MAAMsR,QAAQ,GAAGP,WAAW,CAAC/Q,IAAI,CAACiG,IAAI,CAAC;EACvC,IAAIqL,QAAQ,EAAE;IACVA,QAAQ,CAACvR,GAAG,EAAEC,IAAI,CAAC;EACvB,CAAC,MACI;IACDoG,OAAO,CAACwC,IAAI,CAAC,oBAAoB5I,IAAI,CAACiG,IAAI,6BAA6B,CAAC;EAC5E;AACJ,CAAC;AACD,MAAMsL,QAAQ,GAAGA,CAACxR,GAAG,EAAEC,IAAI,KAAK;EAC5ByN,UAAU,CAAC1N,GAAG,EAAEC,IAAI,CAAC;EACrB4N,WAAW,CAAC7N,GAAG,EAAEC,IAAI,CAAC;EACtBsN,WAAW,CAACvN,GAAG,EAAEC,IAAI,CAAC;EACtB4M,cAAc,CAAC7M,GAAG,EAAEC,IAAI,CAAC;EACzB+M,cAAc,CAAChN,GAAG,EAAEC,IAAI,CAAC;EACzB0Q,OAAO,CAAC3Q,GAAG,EAAEC,IAAI,CAAC;EAClBoN,gBAAgB,CAACrN,GAAG,EAAEC,IAAI,CAAC;EAC3BmN,cAAc,CAACpN,GAAG,EAAEC,IAAI,CAAC;EACzBkN,UAAU,CAACnN,GAAG,EAAEC,IAAI,CAAC;EACrBkL,oBAAoB,CAACnL,GAAG,EAAEC,IAAI,CAAC;EAC/BqR,YAAY,CAACtR,GAAG,EAAEC,IAAI,CAAC;EACvB2Q,IAAI,CAAC5Q,GAAG,EAAEC,IAAI,CAAC;AACnB,CAAC;AACD,MAAMwR,QAAQ,GAAGA,CAACzR,GAAG,EAAEC,IAAI,KAAK;EAC5B,IAAI,CAACA,IAAI,CAACE,KAAK,EACX;EACJ,IAAI,EAAE,UAAU,IAAIF,IAAI,CAACE,KAAK,CAAC,EAC3B;EACJ,MAAMiK,KAAK,GAAGnK,IAAI,CAACE,KAAK,CAACsR,QAAQ;EACjC,IAAIrH,KAAK,EAAE;IACP,MAAM9C,QAAQ,GAAG8C,KAAK,CAAC9C,QAAQ,IAAI,EAAE;IACrCA,QAAQ,CAACF,OAAO,CAAEsK,KAAK,IAAKJ,YAAY,CAACtR,GAAG,EAAE0R,KAAK,CAAC,CAAC;IACrD1R,GAAG,CAACgK,IAAI,CAAC,CAAC;EACd;AACJ,CAAC;AACD,MAAM2H,YAAY,GAAGA,CAAC3R,GAAG,EAAEC,IAAI,KAAK;EAChC,MAAMqH,QAAQ,GAAGrH,IAAI,CAACqH,QAAQ,IAAI,EAAE;EACpCA,QAAQ,CAACF,OAAO,CAAEsK,KAAK,IAAK;IACxB1R,GAAG,CAACwD,IAAI,CAAC,CAAC;IACViO,QAAQ,CAACzR,GAAG,EAAE0R,KAAK,CAAC;IACpBF,QAAQ,CAACxR,GAAG,EAAE0R,KAAK,CAAC;IACpBC,YAAY,CAAC3R,GAAG,EAAE0R,KAAK,CAAC;IACxB1R,GAAG,CAAC8E,OAAO,CAAC,CAAC;EACjB,CAAC,CAAC;AACN,CAAC;AACD,MAAM8M,kBAAkB,GAAGA,CAAC5R,GAAG,EAAEC,IAAI,KAAK;EACtC,IAAI,CAACA,IAAI,CAAC2G,GAAG,EACT;EACJ,MAAM;IAAE/F,KAAK;IAAEC;EAAO,CAAC,GAAGb,IAAI,CAAC2G,GAAG;EAClC,MAAM;IAAEiL,OAAO;IAAEC;EAAoB,CAAC,GAAG7R,IAAI,CAACE,KAAK;EACnD,MAAM;IAAE4R,WAAW,GAAG,MAAM;IAAEC,KAAK,GAAG;EAAW,CAAC,GAAGF,mBAAmB,IAAI,CAAC,CAAC;EAC9E,IAAID,OAAO,IAAI,IAAI,IAAIhR,KAAK,IAAI,IAAI,IAAIC,MAAM,IAAI,IAAI,EAClD;EACJ,MAAML,CAAC,GAAGoR,OAAO,EAAEI,IAAI,IAAI,CAAC;EAC5B,MAAMvR,CAAC,GAAGmR,OAAO,EAAEK,IAAI,IAAI,CAAC;EAC5B,MAAMC,YAAY,GAAGN,OAAO,EAAEO,IAAI,IAAIvR,KAAK;EAC3C,MAAMwR,aAAa,GAAGR,OAAO,EAAES,IAAI,IAAIxR,MAAM;EAC7C,MAAMyR,YAAY,GAAGJ,YAAY,GAAGE,aAAa;EACjD,MAAMG,aAAa,GAAG3R,KAAK,GAAGC,MAAM;EACpC,MAAMuJ,MAAM,GAAGxJ,KAAK,GAAGsR,YAAY;EACnC,MAAM7H,MAAM,GAAGxJ,MAAM,GAAGuR,aAAa;EACrC,IAAIL,KAAK,KAAK,MAAM,EAAE;IAClBhS,GAAG,CAACmD,KAAK,CAACkH,MAAM,EAAEC,MAAM,CAAC;IACzBtK,GAAG,CAACuG,SAAS,CAAC,CAAC9F,CAAC,EAAE,CAACC,CAAC,CAAC;IACrB;EACJ;EACA,IAAK6R,YAAY,GAAGC,aAAa,IAAIT,WAAW,KAAK,MAAM,IACtDQ,YAAY,IAAIC,aAAa,IAAIT,WAAW,KAAK,OAAQ,EAAE;IAC5D/R,GAAG,CAACmD,KAAK,CAACmH,MAAM,EAAEA,MAAM,CAAC;IACzB,QAAQ0H,KAAK;MACT,KAAK,UAAU;MACf,KAAK,UAAU;MACf,KAAK,UAAU;QACXhS,GAAG,CAACuG,SAAS,CAAC,CAAC9F,CAAC,EAAE,CAACC,CAAC,CAAC;QACrB;MACJ,KAAK,UAAU;MACf,KAAK,UAAU;MACf,KAAK,UAAU;QACXV,GAAG,CAACuG,SAAS,CAAC,CAAC9F,CAAC,GAAG,CAAC0R,YAAY,GAAItR,KAAK,GAAGwR,aAAa,GAAIvR,MAAM,IAAI,CAAC,EAAE,CAACJ,CAAC,CAAC;QAC7E;MACJ;QACIV,GAAG,CAACuG,SAAS,CAAC,CAAC9F,CAAC,IAAI0R,YAAY,GAAItR,KAAK,GAAGwR,aAAa,GAAIvR,MAAM,CAAC,EAAE,CAACJ,CAAC,CAAC;IACjF;EACJ,CAAC,MACI;IACDV,GAAG,CAACmD,KAAK,CAACkH,MAAM,EAAEA,MAAM,CAAC;IACzB,QAAQ2H,KAAK;MACT,KAAK,UAAU;MACf,KAAK,UAAU;MACf,KAAK,UAAU;QACXhS,GAAG,CAACuG,SAAS,CAAC,CAAC9F,CAAC,EAAE,CAACC,CAAC,CAAC;QACrB;MACJ,KAAK,UAAU;MACf,KAAK,UAAU;MACf,KAAK,UAAU;QACXV,GAAG,CAACuG,SAAS,CAAC,CAAC9F,CAAC,EAAE,CAACC,CAAC,GAAG,CAAC2R,aAAa,GAAIvR,MAAM,GAAGqR,YAAY,GAAItR,KAAK,IAAI,CAAC,CAAC;QAC7E;MACJ;QACIb,GAAG,CAACuG,SAAS,CAAC,CAAC9F,CAAC,EAAE,CAACC,CAAC,IAAI2R,aAAa,GAAIvR,MAAM,GAAGqR,YAAY,GAAItR,KAAK,CAAC,CAAC;IACjF;EACJ;AACJ,CAAC;AACD,MAAM4R,YAAY,GAAGA,CAACzS,GAAG,EAAEC,IAAI,KAAK;EAChC,IAAI,CAACA,IAAI,CAAC2G,GAAG,EACT;EACJ,MAAM;IAAEqC,GAAG;IAAEC;EAAK,CAAC,GAAGjJ,IAAI,CAAC2G,GAAG;EAC9B,MAAMgC,WAAW,GAAG3I,IAAI,CAAC2G,GAAG,CAACgC,WAAW,IAAI,CAAC;EAC7C,MAAMD,UAAU,GAAG1I,IAAI,CAAC2G,GAAG,CAAC+B,UAAU,IAAI,CAAC;EAC3C3I,GAAG,CAACuG,SAAS,CAAC2C,IAAI,GAAGN,WAAW,EAAEK,GAAG,GAAGN,UAAU,CAAC;AACvD,CAAC;AACD,MAAM+J,SAAS,GAAGA,CAAC1S,GAAG,EAAEC,IAAI,KAAK;EAC7BD,GAAG,CAACwD,IAAI,CAAC,CAAC;EACVwF,QAAQ,CAAChJ,GAAG,EAAEC,IAAI,CAAC;EACnBwS,YAAY,CAACzS,GAAG,EAAEC,IAAI,CAAC;EACvB2R,kBAAkB,CAAC5R,GAAG,EAAEC,IAAI,CAAC;EAC7B0R,YAAY,CAAC3R,GAAG,EAAEC,IAAI,CAAC;EACvBD,GAAG,CAAC8E,OAAO,CAAC,CAAC;AACjB,CAAC;AAED,MAAM6N,KAAK,GAAG;EAAEvI,KAAK,EAAE,MAAM;EAAErE,OAAO,EAAE;AAAE,CAAC;AAC3C;AACA,MAAM6M,UAAU,GAAI1O,GAAG,IAAK;EACxB,IAAI,CAACA,GAAG,EACJ,OAAOyO,KAAK;EAChB,MAAME,MAAM,GAAG/S,WAAW,CAACgT,GAAG,CAAC5O,GAAG,CAAC;EACnC,IAAI,CAAC2O,MAAM,EACP,OAAOF,KAAK;EAChB,MAAMvI,KAAK,GAAGtK,WAAW,CAACiT,EAAE,CAAC7O,GAAG,CAAC2O,MAAM,CAACzI,KAAK,CAACjG,KAAK,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC;EAC1D,MAAM4B,OAAO,GAAG8M,MAAM,CAACzI,KAAK,CAAC,CAAC,CAAC;EAC/B,OAAO;IAAEA,KAAK;IAAErE;EAAQ,CAAC;AAC7B,CAAC;AAED,MAAMiN,WAAW,GAAG,MAAM;AAC1B,MAAMC,SAAS,GAAIC,GAAG,IAAKA,GAAG,CAACC,KAAK,CAACH,WAAW,CAAC;AACjD,MAAMI,gBAAgB,GAAGA,CAACpT,GAAG,EAAEqT,UAAU,KAAK;EAC1C,MAAM;IAAEzO,OAAO,GAAG,CAAC;IAAEC,OAAO,GAAG,CAAC;IAAEhE,KAAK;IAAEC,MAAM;IAAE0H;EAAM,CAAC,GAAG6K,UAAU;EACrErT,GAAG,CAACuG,SAAS,CAAC,CAAC1F,KAAK,GAAG+D,OAAO,EAAE,CAAC9D,MAAM,GAAG+D,OAAO,CAAC;EAClD7E,GAAG,CAACwI,KAAK,CAACA,KAAK,EAAE,CAAC,EAAE,CAAC,EAAE;IACnB8K,GAAG,EAAE,CAACzS,KAAK,EAAEC,MAAM,CAAC;IACpBkR,KAAK,EAAE,QAAQ;IACfuB,MAAM,EAAE;EACZ,CAAC,CAAC;AACN,CAAC;AACD,MAAMC,iBAAiB,GAAGA,CAACxT,GAAG,EAAE0F,GAAG,KAAK;EACpC,IAAI,CAACA,GAAG,CAACV,MAAM,EACX;EACJ,IAAI,CAACU,GAAG,CAACzC,SAAS,EACd;EACJ,MAAMiC,IAAI,GAAGQ,GAAG,CAACE,UAAU,CAACV,IAAI,GAAG,CAAC,CAAC;EACrC,IAAI,CAACA,IAAI,EACL;EACJlF,GAAG,CAACwD,IAAI,CAAC,CAAC;EACV,MAAMiQ,KAAK,GAAGvO,IAAI,CAACwO,iBAAiB,CAAC,IAAI,CAAC;EAC1C,MAAMC,iBAAiB,GAAGzO,IAAI,CAACwO,iBAAiB,CAAC,MAAM,CAAC;EACxD,IAAIE,iBAAiB,GAAG,CAAC;EACzB,KAAK,IAAIvQ,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGqC,GAAG,CAACV,MAAM,CAACjD,MAAM,EAAEsB,CAAC,IAAI,CAAC,EAAE;IAC3C,MAAMwQ,QAAQ,GAAGnO,GAAG,CAACzC,SAAS,CAACI,CAAC,CAAC;IACjC,MAAMyQ,KAAK,GAAGpO,GAAG,CAACV,MAAM,CAAC3B,CAAC,CAAC;IAC3BuQ,iBAAiB,IAAIC,QAAQ,CAACvP,QAAQ,IAAI,CAAC;IAC3C,IAAIwP,KAAK,CAACjQ,EAAE,KAAK8P,iBAAiB,CAAC9P,EAAE,IAAI6B,GAAG,CAACE,UAAU,CAACyN,UAAU,EAAE;MAChErT,GAAG,CAACuG,SAAS,CAACqN,iBAAiB,EAAEC,QAAQ,CAAChP,OAAO,IAAI,CAAC,CAAC;MACvDuO,gBAAgB,CAACpT,GAAG,EAAE0F,GAAG,CAACE,UAAU,CAACyN,UAAU,CAAC;MAChD3N,GAAG,CAACV,MAAM,CAAC3B,CAAC,CAAC,GAAGoQ,KAAK;MACrBG,iBAAiB,GAAG,CAAC;IACzB;EACJ;EACA5T,GAAG,CAAC8E,OAAO,CAAC,CAAC;AACjB,CAAC;AACD,MAAMiP,SAAS,GAAGA,CAAC/T,GAAG,EAAE0F,GAAG,KAAK;EAC5B,IAAI,CAACA,GAAG,CAACV,MAAM,EACX;EACJ,IAAI,CAACU,GAAG,CAACzC,SAAS,EACd;EACJ,MAAMiC,IAAI,GAAGQ,GAAG,CAACE,UAAU,CAACV,IAAI,GAAG,CAAC,CAAC;EACrC,IAAI,CAACA,IAAI,EACL;EACJ,MAAM;IAAEW,QAAQ;IAAEmO;EAAK,CAAC,GAAGtO,GAAG,CAACE,UAAU;EACzC,MAAME,KAAK,GAAG8M,UAAU,CAAClN,GAAG,CAACE,UAAU,CAACE,KAAK,CAAC;EAC9C,MAAMC,OAAO,GAAGtG,KAAK,CAACiG,GAAG,CAACE,UAAU,CAACG,OAAO,CAAC,GACvCD,KAAK,CAACC,OAAO,GACbL,GAAG,CAACE,UAAU,CAACG,OAAO;EAC5B,MAAM;IAAEjF,MAAM,GAAG,CAAC;IAAEkG,OAAO,GAAG,CAAC;IAAE1C,QAAQ,GAAG;EAAE,CAAC,GAAGoB,GAAG;EACrD1F,GAAG,CAACgG,SAAS,CAACF,KAAK,CAACsE,KAAK,CAAC;EAC1BpK,GAAG,CAACiG,WAAW,CAACF,OAAO,CAAC;EACxB,IAAIiO,IAAI,EAAE;IACN,IAAIf,SAAS,CAACe,IAAI,CAAC,EAAE;MACjBhU,GAAG,CAACiU,IAAI,CAAC,CAAC,EAAE,CAACnT,MAAM,GAAGkG,OAAO,EAAE1C,QAAQ,EAAExD,MAAM,EAAEkT,IAAI,CAAC7P,KAAK,CAAC,CAAC,CAAC,CAAC;IACnE,CAAC,MACI;MACDnE,GAAG,CAACgU,IAAI,CAAC,CAAC,EAAE,CAAClT,MAAM,GAAGkG,OAAO,EAAE1C,QAAQ,EAAExD,MAAM,EAAEkT,IAAI,CAAC;IAC1D;EACJ;EACAR,iBAAiB,CAACxT,GAAG,EAAE0F,GAAG,CAAC;EAC3B1F,GAAG,CAACkF,IAAI,CAACA,IAAI,CAACgB,IAAI,KAAK,UAAU,GAAGhB,IAAI,CAACiB,QAAQ,GAAGjB,IAAI,EAAEW,QAAQ,CAAC;EACnE,IAAI;IACAd,YAAY,CAAC/E,GAAG,EAAE0F,GAAG,CAACV,MAAM,EAAEU,GAAG,CAACzC,SAAS,EAAE,CAAC,EAAE,CAAC,CAAC;EACtD,CAAC,CACD,OAAOmD,KAAK,EAAE;IACVC,OAAO,CAACC,GAAG,CAACF,KAAK,CAAC;EACtB;EACApG,GAAG,CAACuG,SAAS,CAACjC,QAAQ,EAAE,CAAC,CAAC;AAC9B,CAAC;AACD,MAAM4P,kBAAkB,GAAGA,CAAClU,GAAG,EAAEmU,IAAI,EAAEC,eAAe,KAAK;EACvD,MAAMtO,KAAK,GAAG8M,UAAU,CAACwB,eAAe,CAAC;EACzCpU,GAAG,CAACwD,IAAI,CAAC,CAAC;EACVxD,GAAG,CAACiG,WAAW,CAACH,KAAK,CAACC,OAAO,CAAC;EAC9B/F,GAAG,CAACmU,IAAI,CAACA,IAAI,CAAC1T,CAAC,EAAE0T,IAAI,CAACzT,CAAC,EAAEyT,IAAI,CAACtT,KAAK,EAAEsT,IAAI,CAACrT,MAAM,CAAC;EACjDd,GAAG,CAACkO,IAAI,CAACpI,KAAK,CAACsE,KAAK,CAAC;EACrBpK,GAAG,CAAC8E,OAAO,CAAC,CAAC;AACjB,CAAC;AACD,MAAMuP,oBAAoB,GAAGA,CAACrU,GAAG,EAAEsU,cAAc,KAAK;EAClDtU,GAAG,CAACwD,IAAI,CAAC,CAAC;EACVxD,GAAG,CAAC8M,SAAS,CAACwH,cAAc,CAACH,IAAI,CAACrT,MAAM,CAAC;EACzCd,GAAG,CAACsN,aAAa,CAACgH,cAAc,CAACvO,OAAO,CAAC;EACzC,IAAI,QAAQ,CAACwO,IAAI,CAACD,cAAc,CAAC5L,KAAK,CAAC,EAAE;IACrC1I,GAAG,CAAC+N,IAAI,CAAC,CAAC,GAAGuG,cAAc,CAACH,IAAI,CAACrT,MAAM,EAAE,CAAC,CAAC,CAAC;EAChD,CAAC,MACI,IAAI,QAAQ,CAACyT,IAAI,CAACD,cAAc,CAAC5L,KAAK,CAAC,EAAE;IAC1C1I,GAAG,CAAC+N,IAAI,CAACuG,cAAc,CAACH,IAAI,CAACrT,MAAM,EAAE,CAAC,CAAC,CAAC;EAC5C;EACA,IAAI,MAAM,CAACyT,IAAI,CAACD,cAAc,CAAC5L,KAAK,CAAC,EAAE;IACnC,MAAM8L,IAAI,GAAGlU,IAAI,CAACwL,GAAG,CAAC,CAAC,EAAEwI,cAAc,CAACH,IAAI,CAACrT,MAAM,CAAC;IACpD,IAAI2T,IAAI,GAAG,GAAG,GAAGD,IAAI;IACrB,MAAME,SAAS,GAAGpU,IAAI,CAACqU,KAAK,CAACL,cAAc,CAACH,IAAI,CAACtT,KAAK,IAAI,CAAC,GAAG4T,IAAI,CAAC,CAAC;IACpE;IACA,MAAMG,cAAc,GAAGN,cAAc,CAACH,IAAI,CAACtT,KAAK,GAAG6T,SAAS,GAAG,CAAC,GAAGD,IAAI;IACvE,MAAMI,UAAU,GAAGD,cAAc,GAAGF,SAAS,GAAG,CAAC;IACjDD,IAAI,IAAII,UAAU;IAClB,MAAMC,IAAI,GAAGR,cAAc,CAACH,IAAI,CAACzT,CAAC,GAAG8T,IAAI;IACzC,MAAMO,IAAI,GAAGT,cAAc,CAACH,IAAI,CAACzT,CAAC,GAAG8T,IAAI;IACzC,IAAI;MAAE/T;IAAE,CAAC,GAAG6T,cAAc,CAACH,IAAI;IAC/BnU,GAAG,CAACiB,MAAM,CAACqT,cAAc,CAACH,IAAI,CAAC1T,CAAC,EAAE6T,cAAc,CAACH,IAAI,CAACzT,CAAC,CAAC;IACxD,KAAK,IAAI2C,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGqR,SAAS,EAAErR,CAAC,IAAI,CAAC,EAAE;MACnCrD,GAAG,CAACmB,aAAa,CAACV,CAAC,GAAGgU,IAAI,EAAEK,IAAI,EAAErU,CAAC,GAAGgU,IAAI,EAAEM,IAAI,EAAEtU,CAAC,GAAG,CAAC,GAAGgU,IAAI,EAAEH,cAAc,CAACH,IAAI,CAACzT,CAAC,CAAC;MACtFD,CAAC,IAAI,CAAC,GAAGgU,IAAI;IACjB;EACJ,CAAC,MACI;IACDzU,GAAG,CAACiB,MAAM,CAACqT,cAAc,CAACH,IAAI,CAAC1T,CAAC,EAAE6T,cAAc,CAACH,IAAI,CAACzT,CAAC,CAAC;IACxDV,GAAG,CAACkB,MAAM,CAACoT,cAAc,CAACH,IAAI,CAAC1T,CAAC,GAAG6T,cAAc,CAACH,IAAI,CAACtT,KAAK,EAAEyT,cAAc,CAACH,IAAI,CAACzT,CAAC,CAAC;IACpF,IAAI,QAAQ,CAAC6T,IAAI,CAACD,cAAc,CAAC5L,KAAK,CAAC,EAAE;MACrC1I,GAAG,CAACiB,MAAM,CAACqT,cAAc,CAACH,IAAI,CAAC1T,CAAC,EAAE6T,cAAc,CAACH,IAAI,CAACzT,CAAC,GAAG4T,cAAc,CAACH,IAAI,CAACrT,MAAM,GAAG,CAAC,CAAC;MACzFd,GAAG,CAACkB,MAAM,CAACoT,cAAc,CAACH,IAAI,CAAC1T,CAAC,GAAG6T,cAAc,CAACH,IAAI,CAACtT,KAAK,EAAEyT,cAAc,CAACH,IAAI,CAACzT,CAAC,GAAG4T,cAAc,CAACH,IAAI,CAACrT,MAAM,GAAG,CAAC,CAAC;IACzH;EACJ;EACAd,GAAG,CAACkN,MAAM,CAACoH,cAAc,CAACxO,KAAK,CAAC;EAChC9F,GAAG,CAAC8E,OAAO,CAAC,CAAC;AACjB,CAAC;AACD,MAAMkQ,UAAU,GAAGA,CAAChV,GAAG,EAAEyG,IAAI,KAAK;EAC9B,IAAI,CAACA,IAAI,CAACG,GAAG,EACT;EACJ,MAAMqO,UAAU,GAAGxO,IAAI,CAACK,MAAM,IAAI,CAAC;EACnC9G,GAAG,CAACwD,IAAI,CAAC,CAAC;EACVxD,GAAG,CAACuG,SAAS,CAACE,IAAI,CAACG,GAAG,CAACnG,CAAC,EAAEgG,IAAI,CAACG,GAAG,CAAClG,CAAC,GAAGuU,UAAU,CAAC;EAClD,KAAK,IAAI5R,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGoD,IAAI,CAACI,IAAI,CAAC9E,MAAM,EAAEsB,CAAC,IAAI,CAAC,EAAE;IAC1C,MAAMqC,GAAG,GAAGe,IAAI,CAACI,IAAI,CAACxD,CAAC,CAAC;IACxB,MAAM6R,SAAS,GAAG7R,CAAC,KAAKoD,IAAI,CAACI,IAAI,CAAC9E,MAAM,GAAG,CAAC;IAC5C,IAAI2D,GAAG,CAACE,UAAU,CAACwO,eAAe,EAAE;MAChC,MAAM9P,QAAQ,GAAGoB,GAAG,CAACpB,QAAQ,IAAI,CAAC;MAClC,MAAM6Q,aAAa,GAAGD,SAAS,GAAGzO,IAAI,CAAC0O,aAAa,IAAI,CAAC,GAAG,CAAC;MAC7D,MAAMC,cAAc,GAAG;QACnB3U,CAAC,EAAE,CAAC;QACJC,CAAC,EAAE,CAACuU,UAAU;QACdnU,MAAM,EAAE2F,IAAI,CAACG,GAAG,CAAC9F,MAAM;QACvBD,KAAK,EAAEyD,QAAQ,GAAG6Q;MACtB,CAAC;MACDjB,kBAAkB,CAAClU,GAAG,EAAEoV,cAAc,EAAE1P,GAAG,CAACE,UAAU,CAACwO,eAAe,CAAC;IAC3E;IACAL,SAAS,CAAC/T,GAAG,EAAE0F,GAAG,CAAC;EACvB;EACA1F,GAAG,CAAC8E,OAAO,CAAC,CAAC;EACb9E,GAAG,CAACwD,IAAI,CAAC,CAAC;EACVxD,GAAG,CAACuG,SAAS,CAACE,IAAI,CAACG,GAAG,CAACnG,CAAC,EAAEgG,IAAI,CAACG,GAAG,CAAClG,CAAC,CAAC;EACrC,IAAI+F,IAAI,CAAC4O,eAAe,EAAE;IACtB,KAAK,IAAIhS,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGoD,IAAI,CAAC4O,eAAe,CAACtT,MAAM,EAAEsB,CAAC,IAAI,CAAC,EAAE;MACrD,MAAMiR,cAAc,GAAG7N,IAAI,CAAC4O,eAAe,CAAChS,CAAC,CAAC;MAC9CgR,oBAAoB,CAACrU,GAAG,EAAEsU,cAAc,CAAC;IAC7C;EACJ;EACAtU,GAAG,CAAC8E,OAAO,CAAC,CAAC;AACjB,CAAC;AACD,MAAMwQ,WAAW,GAAGA,CAACtV,GAAG,EAAEuV,KAAK,KAAK;EAChCA,KAAK,CAACnO,OAAO,CAAEX,IAAI,IAAK;IACpBuO,UAAU,CAAChV,GAAG,EAAEyG,IAAI,CAAC;EACzB,CAAC,CAAC;AACN,CAAC;AACD,MAAM+O,UAAU,GAAGA,CAACxV,GAAG,EAAEC,IAAI,KAAK;EAC9B,IAAI,CAACA,IAAI,CAAC2G,GAAG,EACT;EACJ,IAAI,CAAC3G,IAAI,CAACuH,KAAK,EACX;EACJ,MAAM;IAAEyB,GAAG;IAAEC;EAAK,CAAC,GAAGjJ,IAAI,CAAC2G,GAAG;EAC9B,MAAM6O,MAAM,GAAG,CAACxV,IAAI,CAACuH,KAAK,CAAC;EAC3B,MAAMmB,UAAU,GAAG1I,IAAI,CAAC2G,GAAG,EAAE+B,UAAU,IAAI,CAAC;EAC5C,MAAMC,WAAW,GAAG3I,IAAI,CAAC2G,GAAG,EAAEgC,WAAW,IAAI,CAAC;EAC9C,MAAM8M,QAAQ,GAAGzV,IAAI,CAACuH,KAAK,CAAC,CAAC,CAAC,GAAGvH,IAAI,CAACuH,KAAK,CAAC,CAAC,CAAC,CAACZ,GAAG,CAAClG,CAAC,GAAG,CAAC;EACxD,MAAMiV,OAAO,GAAG1V,IAAI,CAAC2V,WAAW,IAAI,CAAC;EACrC5V,GAAG,CAACwD,IAAI,CAAC,CAAC;EACVxD,GAAG,CAACuG,SAAS,CAAC2C,IAAI,GAAGN,WAAW,GAAG+M,OAAO,EAAE1M,GAAG,GAAGN,UAAU,GAAG+M,QAAQ,CAAC;EACxED,MAAM,CAACrO,OAAO,CAAEmO,KAAK,IAAK;IACtBD,WAAW,CAACtV,GAAG,EAAEuV,KAAK,CAAC;EAC3B,CAAC,CAAC;EACFvV,GAAG,CAAC8E,OAAO,CAAC,CAAC;AACjB,CAAC;AAED,MAAM+Q,UAAU,GAAGA,CAAC7V,GAAG,EAAEC,IAAI,KAAK;EAC9B,IAAI,CAACA,IAAI,CAAC2G,GAAG,EACT;EACJ,MAAM;IAAE/F,KAAK;IAAEC;EAAO,CAAC,GAAGb,IAAI,CAAC2G,GAAG;EAClC,MAAMkP,GAAG,GAAG7V,IAAI,CAACE,KAAK,EAAE2V,GAAG,IAAI,EAAE;EACjC,MAAMC,QAAQ,GAAGD,GAAG,GAAG,EAAE;EACzB9V,GAAG,CAACgW,OAAO,CAAC;IAAEC,IAAI,EAAE,CAACpV,KAAK,EAAEC,MAAM,CAAC;IAAEoV,MAAM,EAAE,CAAC;IAAEH;EAAS,CAAC,CAAC;AAC/D,CAAC;AAED,MAAMI,UAAU,GAAGA,CAACnW,GAAG,EAAEC,IAAI,KAAK;EAC9B,IAAI,CAACA,IAAI,CAAC2G,GAAG,EACT;EACJ,MAAM;IAAEqC,GAAG;IAAEC;EAAK,CAAC,GAAGjJ,IAAI,CAAC2G,GAAG;EAC9B,MAAMwD,KAAK,GAAGnK,IAAI,EAAEqH,QAAQ,GAAG,CAAC,CAAC,CAAC8C,KAAK,IAAI,EAAE;EAC7C,MAAMtE,KAAK,GAAG7F,IAAI,CAACyI,KAAK,EAAE0L,eAAe;EACzCpU,GAAG,CAACoW,IAAI,CAAClN,IAAI,EAAED,GAAG,EAAE,CAAC,EAAE,CAAC,EAAEmB,KAAK,EAAE;IAAEtE;EAAM,CAAC,CAAC;AAC/C,CAAC;AAED,MAAMuQ,UAAU,GAAGA,CAACrW,GAAG,EAAEC,IAAI,KAAK;EAC9B,MAAMiT,GAAG,GAAGjT,IAAI,CAACuI,KAAK,CAACC,IAAI;EAC3B,IAAID,KAAK;EACT,IAAI,OAAO0K,GAAG,KAAK,QAAQ,EAAE;IACzB1K,KAAK,GAAGxI,GAAG,CAACsW,cAAc,CAACpD,GAAG,CAAC;EACnC;EACA,IAAI,CAAC1K,KAAK,EAAE;IACRA,KAAK,GAAGxI,GAAG,CAACuW,SAAS,CAACrD,GAAG,CAAC;EAC9B;EACA,IAAI,CAAC1K,KAAK,CAACgO,GAAG,EAAE;IACZhO,KAAK,CAACiO,KAAK,CAACzW,GAAG,CAAC;EACpB;EACA,OAAOwI,KAAK;AAChB,CAAC;AAED,MAAMkO,SAAS,GAAI9T,CAAC,IAAK;EACrB,OAAO,CAACoL,MAAM,CAAC2I,KAAK,CAACzO,UAAU,CAACtF,CAAC,CAAC,CAAC,IAAIoL,MAAM,CAAC4I,QAAQ,CAAChU,CAAC,CAAC;AAC7D,CAAC;AACD,MAAMiU,qBAAqB,GAAGA,CAACC,EAAE,EAAEC,EAAE,EAAEC,EAAE,EAAEC,EAAE,EAAEC,EAAE,EAAEC,EAAE,KAAK;EACtD,MAAMC,EAAE,GAAGN,EAAE,GAAGC,EAAE;EAClB,MAAMM,EAAE,GAAGL,EAAE,GAAGC,EAAE;EAClB,MAAMK,GAAG,GAAG5X,YAAY,CAACwX,EAAE,IAAI,IAAI,CAAC;EACpC,MAAMK,GAAG,GAAG7X,YAAY,CAACyX,EAAE,IAAI,IAAI,CAAC;EACpC,MAAMK,GAAG,GAAGF,GAAG,GAAGA,GAAG,CAACG,OAAO,GAAG,GAAG;EACnC,MAAMC,GAAG,GAAGH,GAAG,GAAGA,GAAG,CAACE,OAAO,GAAG,GAAG;EACnC,IAAIL,EAAE,GAAGC,EAAE,EAAE;IACT,MAAMvW,MAAM,GAAGiW,EAAE;IACjB,MAAMlW,KAAK,GAAGC,MAAM,GAAGuW,EAAE;IACzB,MAAMxS,OAAO,GAAG6R,SAAS,CAACS,EAAE,CAAC,GAAGA,EAAE,GAAG,CAAC;IACtC,MAAMvS,OAAO,GAAG8R,SAAS,CAACQ,EAAE,CAAC,GAAGA,EAAE,GAAG,CAACJ,EAAE,GAAGjW,KAAK,IAAI2W,GAAG;IACvD,OAAO;MAAE3W,KAAK;MAAEC,MAAM;MAAE8D,OAAO;MAAEC;IAAQ,CAAC;EAC9C;EACA,MAAMhE,KAAK,GAAGiW,EAAE;EAChB,MAAMhW,MAAM,GAAGD,KAAK,GAAGwW,EAAE;EACzB,MAAMzS,OAAO,GAAG8R,SAAS,CAACQ,EAAE,CAAC,GAAGA,EAAE,GAAG,CAAC;EACtC,MAAMrS,OAAO,GAAG6R,SAAS,CAACS,EAAE,CAAC,GAAGA,EAAE,GAAG,CAACJ,EAAE,GAAGjW,MAAM,IAAI4W,GAAG;EACxD,OAAO;IAAE7W,KAAK;IAAEC,MAAM;IAAE+D,OAAO;IAAED;EAAQ,CAAC;AAC9C,CAAC;AACD,MAAM+S,kBAAkB,GAAGA,CAACb,EAAE,EAAEC,EAAE,EAAEC,EAAE,EAAEC,EAAE,EAAEC,EAAE,EAAEC,EAAE,KAAK;EACnD,MAAMtW,KAAK,GAAGmW,EAAE;EAChB,MAAMlW,MAAM,GAAGmW,EAAE;EACjB,MAAMK,GAAG,GAAG5X,YAAY,CAACwX,EAAE,IAAI,IAAI,CAAC;EACpC,MAAMK,GAAG,GAAG7X,YAAY,CAACyX,EAAE,IAAI,IAAI,CAAC;EACpC,MAAMK,GAAG,GAAGF,GAAG,GAAGA,GAAG,CAACG,OAAO,GAAG,GAAG;EACnC,MAAMC,GAAG,GAAGH,GAAG,GAAGA,GAAG,CAACE,OAAO,GAAG,GAAG;EACnC,MAAM7S,OAAO,GAAG8R,SAAS,CAACQ,EAAE,CAAC,GAAGA,EAAE,GAAG,CAACJ,EAAE,GAAGjW,KAAK,IAAI2W,GAAG;EACvD,MAAM3S,OAAO,GAAG6R,SAAS,CAACS,EAAE,CAAC,GAAGA,EAAE,GAAG,CAACJ,EAAE,GAAGjW,MAAM,IAAI4W,GAAG;EACxD,OAAO;IAAE7W,KAAK;IAAEC,MAAM;IAAE8D,OAAO;IAAEC;EAAQ,CAAC;AAC9C,CAAC;AACD,MAAM+S,mBAAmB,GAAGA,CAACd,EAAE,EAAEC,EAAE,EAAEC,EAAE,EAAEC,EAAE,EAAEC,EAAE,EAAEC,EAAE,KAAK;EACpD,MAAME,EAAE,GAAGL,EAAE,GAAGC,EAAE;EAClB,MAAMG,EAAE,GAAGN,EAAE,GAAGC,EAAE;EAClB,MAAMO,GAAG,GAAG5X,YAAY,CAACwX,EAAE,IAAI,IAAI,CAAC;EACpC,MAAMK,GAAG,GAAG7X,YAAY,CAACyX,EAAE,IAAI,IAAI,CAAC;EACpC,MAAMK,GAAG,GAAGF,GAAG,GAAGA,GAAG,CAACG,OAAO,GAAG,GAAG;EACnC,MAAMC,GAAG,GAAGH,GAAG,GAAGA,GAAG,CAACE,OAAO,GAAG,GAAG;EACnC,IAAIL,EAAE,GAAGC,EAAE,EAAE;IACT,MAAMxW,KAAK,GAAGiW,EAAE;IAChB,MAAMhW,MAAM,GAAGD,KAAK,GAAGwW,EAAE;IACzB,MAAMzS,OAAO,GAAG8R,SAAS,CAACQ,EAAE,CAAC,GAAGA,EAAE,GAAG,CAAC;IACtC,MAAMrS,OAAO,GAAG6R,SAAS,CAACS,EAAE,CAAC,GAAGA,EAAE,GAAG,CAACJ,EAAE,GAAGjW,MAAM,IAAI4W,GAAG;IACxD,OAAO;MAAE7W,KAAK;MAAEC,MAAM;MAAE+D,OAAO;MAAED;IAAQ,CAAC;EAC9C;EACA,MAAM9D,MAAM,GAAGiW,EAAE;EACjB,MAAMlW,KAAK,GAAGC,MAAM,GAAGuW,EAAE;EACzB,MAAMzS,OAAO,GAAG8R,SAAS,CAACQ,EAAE,CAAC,GAAGA,EAAE,GAAG,CAACJ,EAAE,GAAGjW,KAAK,IAAI2W,GAAG;EACvD,MAAM3S,OAAO,GAAG6R,SAAS,CAACS,EAAE,CAAC,GAAGA,EAAE,GAAG,CAAC;EACtC,OAAO;IAAEtW,KAAK;IAAEC,MAAM;IAAE8D,OAAO;IAAEC;EAAQ,CAAC;AAC9C,CAAC;AACD,MAAMgT,uBAAuB,GAAGA,CAACf,EAAE,EAAEC,EAAE,EAAEC,EAAE,EAAEC,EAAE,EAAEC,EAAE,EAAEC,EAAE,KAAK;EACxD,MAAMW,gBAAgB,GAAGjB,qBAAqB,CAACC,EAAE,EAAEC,EAAE,EAAEC,EAAE,EAAEC,EAAE,EAAEC,EAAE,EAAEC,EAAE,CAAC;EACtE,MAAMY,aAAa,GAAGJ,kBAAkB,CAACb,EAAE,EAAEC,EAAE,EAAEC,EAAE,EAAEC,EAAE,EAAEC,EAAE,EAAEC,EAAE,CAAC;EAChE,OAAOW,gBAAgB,CAACjX,KAAK,GAAGkX,aAAa,CAAClX,KAAK,GAC7CiX,gBAAgB,GAChBC,aAAa;AACvB,CAAC;AACD,MAAMC,kBAAkB,GAAGA,CAAClB,EAAE,EAAEC,EAAE,EAAEG,EAAE,EAAEC,EAAE,KAAK;EAC3C,OAAO;IACHtW,KAAK,EAAEiW,EAAE;IACThW,MAAM,EAAEiW,EAAE;IACVnS,OAAO,EAAElF,YAAY,CAACwX,EAAE,IAAI,IAAI,CAAC,GAAG,CAAC,GAAGA,EAAE,IAAI,CAAC;IAC/CrS,OAAO,EAAEnF,YAAY,CAACyX,EAAE,IAAI,IAAI,CAAC,GAAG,CAAC,GAAGA,EAAE,IAAI;EAClD,CAAC;AACL,CAAC;AACD,MAAMc,gBAAgB,GAAG,SAAAA,CAAA,EAA2C;EAAA,IAA1C/R,IAAI,GAAApE,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAAE,SAAA,GAAAF,SAAA,MAAG,MAAM;EAAA,IAAEgV,EAAE,GAAAhV,SAAA,CAAAC,MAAA,OAAAD,SAAA,MAAAE,SAAA;EAAA,IAAE+U,EAAE,GAAAjV,SAAA,CAAAC,MAAA,OAAAD,SAAA,MAAAE,SAAA;EAAA,IAAEgV,EAAE,GAAAlV,SAAA,CAAAC,MAAA,OAAAD,SAAA,MAAAE,SAAA;EAAA,IAAEiV,EAAE,GAAAnV,SAAA,CAAAC,MAAA,OAAAD,SAAA,MAAAE,SAAA;EAAA,IAAEkV,EAAE,GAAApV,SAAA,CAAAC,MAAA,OAAAD,SAAA,MAAAE,SAAA;EAAA,IAAEmV,EAAE,GAAArV,SAAA,CAAAC,MAAA,OAAAD,SAAA,MAAAE,SAAA;EAC3D,QAAQkE,IAAI;IACR,KAAK,SAAS;MACV,OAAO2Q,qBAAqB,CAACC,EAAE,EAAEC,EAAE,EAAEC,EAAE,EAAEC,EAAE,EAAEC,EAAE,EAAEC,EAAE,CAAC;IACxD,KAAK,OAAO;MACR,OAAOS,mBAAmB,CAACd,EAAE,EAAEC,EAAE,EAAEC,EAAE,EAAEC,EAAE,EAAEC,EAAE,EAAEC,EAAE,CAAC;IACtD,KAAK,MAAM;MACP,OAAOQ,kBAAkB,CAACb,EAAE,EAAEC,EAAE,EAAEC,EAAE,EAAEC,EAAE,EAAEC,EAAE,EAAEC,EAAE,CAAC;IACrD,KAAK,YAAY;MACb,OAAOU,uBAAuB,CAACf,EAAE,EAAEC,EAAE,EAAEC,EAAE,EAAEC,EAAE,EAAEC,EAAE,EAAEC,EAAE,CAAC;IAC1D;MACI,OAAOa,kBAAkB,CAAClB,EAAE,EAAEC,EAAE,EAAEG,EAAE,EAAEC,EAAE,CAAC;EACjD;AACJ,CAAC;AAED,MAAMe,SAAS,GAAGA,CAAClY,GAAG,EAAEC,IAAI,EAAEkY,OAAO,KAAK;EACtC,IAAI,CAAClY,IAAI,CAAC2G,GAAG,EACT;EACJ,IAAI,CAAC3G,IAAI,CAACuI,KAAK,EACX;EACJ,MAAM;IAAEU,IAAI;IAAED;EAAI,CAAC,GAAGhJ,IAAI,CAAC2G,GAAG;EAC9B,MAAMb,OAAO,GAAG9F,IAAI,CAACyI,KAAK,EAAE3C,OAAO;EACnC,MAAMqS,SAAS,GAAGnY,IAAI,CAACyI,KAAK,EAAE0P,SAAS;EACvC,MAAMC,eAAe,GAAGpY,IAAI,CAACyI,KAAK,EAAE2P,eAAe;EACnD,MAAMC,eAAe,GAAGrY,IAAI,CAACyI,KAAK,EAAE4P,eAAe;EACnD,MAAM3P,UAAU,GAAG1I,IAAI,CAAC2G,GAAG,CAAC+B,UAAU,IAAI,CAAC;EAC3C,MAAM4P,YAAY,GAAGtY,IAAI,CAAC2G,GAAG,CAAC2R,YAAY,IAAI,CAAC;EAC/C,MAAMC,aAAa,GAAGvY,IAAI,CAAC2G,GAAG,CAAC4R,aAAa,IAAI,CAAC;EACjD,MAAM5P,WAAW,GAAG3I,IAAI,CAAC2G,GAAG,CAACgC,WAAW,IAAI,CAAC;EAC7C,MAAM6P,UAAU,GAAGN,OAAO,CAACM,UAAU,IAAI,IAAIC,GAAG,CAAC,CAAC;EAClD,MAAM;IAAE7X,KAAK;IAAEC,MAAM;IAAE8D,OAAO;IAAEC;EAAQ,CAAC,GAAGoT,gBAAgB,CAACG,SAAS,EAAEnY,IAAI,CAAC2G,GAAG,CAAC/F,KAAK,GAAG+H,WAAW,GAAG2P,YAAY,EAAEtY,IAAI,CAAC2G,GAAG,CAAC9F,MAAM,GAAG6H,UAAU,GAAG6P,aAAa,EAAEvY,IAAI,CAACuI,KAAK,CAAC3H,KAAK,EAAEZ,IAAI,CAACuI,KAAK,CAAC1H,MAAM,EAAEuX,eAAe,EAAEC,eAAe,CAAC;EACzO,IAAIrY,IAAI,CAACuI,KAAK,CAACC,IAAI,EAAE;IACjB,IAAI5H,KAAK,KAAK,CAAC,IAAIC,MAAM,KAAK,CAAC,EAAE;MAC7B,MAAM6X,QAAQ,GAAG1Y,IAAI,CAACuI,KAAK,CAACoQ,GAAG;MAC/B,MAAMpQ,KAAK,GAAGiQ,UAAU,CAAC3F,GAAG,CAAC6F,QAAQ,CAAC,IAAItC,UAAU,CAACrW,GAAG,EAAEC,IAAI,CAAC;MAC/D,IAAI0Y,QAAQ,EACRF,UAAU,CAACI,GAAG,CAACF,QAAQ,EAAEnQ,KAAK,CAAC;MACnC,MAAMsQ,YAAY,GAAGrZ,KAAK,CAACsG,OAAO,CAAC,GAAG,CAAC,GAAGA,OAAO;MACjD/F,GAAG,CACEiG,WAAW,CAAC6S,YAAY,CAAC,CACzBtQ,KAAK,CAACA,KAAK,EAAEU,IAAI,GAAGN,WAAW,GAAGhE,OAAO,EAAEqE,GAAG,GAAGN,UAAU,GAAG9D,OAAO,EAAE;QACxEhE,KAAK;QACLC;MACJ,CAAC,CAAC;IACN,CAAC,MACI;MACDuF,OAAO,CAACwC,IAAI,CAAC,mBAAmBkQ,IAAI,CAACC,SAAS,CAAC/Y,IAAI,CAACE,KAAK,CAAC+S,GAAG,IAAIjT,IAAI,CAACE,KAAK,CAAC8Y,MAAM,CAAC,qCAAqC,CAAC;IAC7H;EACJ;AACJ,CAAC;AACD,MAAMC,WAAW,GAAGA,CAAClZ,GAAG,EAAEC,IAAI,EAAEkY,OAAO,KAAK;EACxCnY,GAAG,CAACwD,IAAI,CAAC,CAAC;EACVwF,QAAQ,CAAChJ,GAAG,EAAEC,IAAI,CAAC;EACnBiY,SAAS,CAAClY,GAAG,EAAEC,IAAI,EAAEkY,OAAO,CAAC;EAC7BnY,GAAG,CAAC8E,OAAO,CAAC,CAAC;AACjB,CAAC;AAED,MAAMqU,aAAa,GAAG,SAAS;AAC/B,MAAMC,aAAa,GAAG,SAAS;AAC/B,MAAMC,YAAY,GAAG,SAAS;AAC9B;AACA,MAAMC,YAAY,GAAGA,CAACtZ,GAAG,EAAEC,IAAI,KAAK;EAChC,IAAI,CAACA,IAAI,CAAC2G,GAAG,EACT;EACJ,MAAM;IAAEsC,IAAI;IAAED,GAAG;IAAEpI,KAAK;IAAEC,MAAM;IAAE8H,WAAW,GAAG,CAAC;IAAED,UAAU,GAAG,CAAC;IAAE4P,YAAY,GAAG,CAAC;IAAEC,aAAa,GAAG,CAAC;IAAEe,eAAe,GAAG,CAAC;IAAEC,cAAc,GAAG,CAAC;IAAEC,gBAAgB,GAAG,CAAC;IAAEC,iBAAiB,GAAG;EAAG,CAAC,GAAGzZ,IAAI,CAAC2G,GAAG;EAC1M5G,GAAG,CACEgG,SAAS,CAACmT,aAAa,CAAC,CACxBpT,OAAO,CAAC,GAAG,CAAC,CACZoO,IAAI,CAACjL,IAAI,GAAGN,WAAW,GAAG2Q,eAAe,EAAEtQ,GAAG,GAAGN,UAAU,GAAG6Q,cAAc,EAAE3Y,KAAK,GAAG+H,WAAW,GAAG2P,YAAY,GAAGkB,gBAAgB,GAAGF,eAAe,EAAEzY,MAAM,GAAG6H,UAAU,GAAG6P,aAAa,GAAGgB,cAAc,GAAGE,iBAAiB,CAAC,CAChOxL,IAAI,CAAC,CAAC;AACf,CAAC;AACD,MAAMyL,YAAY,GAAGA,CAAC3Z,GAAG,EAAEC,IAAI,KAAK;EAChC,IAAI,CAACA,IAAI,CAAC2G,GAAG,EACT;EACJ,MAAM;IAAEsC,IAAI;IAAED,GAAG;IAAEpI,KAAK;IAAEC,MAAM;IAAE8H,WAAW,GAAG,CAAC;IAAED,UAAU,GAAG,CAAC;IAAE4P,YAAY,GAAG,CAAC;IAAEC,aAAa,GAAG,CAAC;IAAEe,eAAe,GAAG,CAAC;IAAEC,cAAc,GAAG,CAAC;IAAEC,gBAAgB,GAAG,CAAC;IAAEC,iBAAiB,GAAG;EAAG,CAAC,GAAGzZ,IAAI,CAAC2G,GAAG;EAC1M5G,GAAG,CAACgG,SAAS,CAACoT,aAAa,CAAC,CAACrT,OAAO,CAAC,GAAG,CAAC;EACzC;EACA/F,GAAG,CACEmU,IAAI,CAACjL,IAAI,GAAGN,WAAW,GAAG2Q,eAAe,EAAEtQ,GAAG,GAAGuQ,cAAc,EAAE3Y,KAAK,GAAG0X,YAAY,GAAG3P,WAAW,GAAG2Q,eAAe,GAAGE,gBAAgB,EAAE9Q,UAAU,CAAC,CACrJuF,IAAI,CAAC,CAAC;EACX;EACAlO,GAAG,CACEmU,IAAI,CAACjL,IAAI,GAAGqQ,eAAe,EAAEtQ,GAAG,GAAGuQ,cAAc,EAAE5Q,WAAW,EAAE9H,MAAM,GAAG0Y,cAAc,GAAGE,iBAAiB,CAAC,CAC5GxL,IAAI,CAAC,CAAC;EACX;EACAlO,GAAG,CACEmU,IAAI,CAACjL,IAAI,GAAGrI,KAAK,GAAG0X,YAAY,GAAGkB,gBAAgB,EAAExQ,GAAG,GAAGuQ,cAAc,EAAEjB,YAAY,EAAEzX,MAAM,GAAG0Y,cAAc,GAAGE,iBAAiB,CAAC,CACrIxL,IAAI,CAAC,CAAC;EACX;EACAlO,GAAG,CACEmU,IAAI,CAACjL,IAAI,GAAGN,WAAW,GAAG2Q,eAAe,EAAEtQ,GAAG,GAAGnI,MAAM,GAAG0X,aAAa,GAAGkB,iBAAiB,EAAE7Y,KAAK,GAAG0X,YAAY,GAAG3P,WAAW,GAAG2Q,eAAe,GAAGE,gBAAgB,EAAEjB,aAAa,CAAC,CACpLtK,IAAI,CAAC,CAAC;AACf,CAAC;AACD,MAAM0L,WAAW,GAAGA,CAAC5Z,GAAG,EAAEC,IAAI,KAAK;EAC/B,IAAI,CAACA,IAAI,CAAC2G,GAAG,EACT;EACJ,MAAM;IAAEsC,IAAI;IAAED,GAAG;IAAEpI,KAAK;IAAEC;EAAO,CAAC,GAAGb,IAAI,CAAC2G,GAAG;EAC7C,MAAM;IAAEiT,UAAU,GAAG,CAAC;IAAEC,SAAS,GAAG,CAAC;IAAEC,WAAW,GAAG,CAAC;IAAEC,YAAY,GAAG;EAAG,CAAC,GAAG/Z,IAAI,CAAC2G,GAAG;EACtF5G,GAAG,CAACgG,SAAS,CAACqT,YAAY,CAAC,CAACtT,OAAO,CAAC,GAAG,CAAC;EACxC;EACA/F,GAAG,CAACmU,IAAI,CAACjL,IAAI,EAAED,GAAG,GAAG6Q,SAAS,EAAEjZ,KAAK,EAAEiZ,SAAS,CAAC,CAAC5L,IAAI,CAAC,CAAC;EACxD;EACAlO,GAAG,CACEmU,IAAI,CAACjL,IAAI,GAAG2Q,UAAU,EAAE5Q,GAAG,GAAG6Q,SAAS,EAAED,UAAU,EAAE/Y,MAAM,GAAGgZ,SAAS,GAAGE,YAAY,CAAC,CACvF9L,IAAI,CAAC,CAAC;EACX;EACAlO,GAAG,CACEmU,IAAI,CAACjL,IAAI,GAAGrI,KAAK,EAAEoI,GAAG,GAAG6Q,SAAS,EAAEC,WAAW,EAAEjZ,MAAM,GAAGgZ,SAAS,GAAGE,YAAY,CAAC,CACnF9L,IAAI,CAAC,CAAC;EACX;EACAlO,GAAG,CAACmU,IAAI,CAACjL,IAAI,EAAED,GAAG,GAAGnI,MAAM,EAAED,KAAK,EAAEmZ,YAAY,CAAC,CAAC9L,IAAI,CAAC,CAAC;AAC5D,CAAC;AACD,MAAM+L,SAAS,GAAGA,CAACja,GAAG,EAAEC,IAAI,KAAK;EAC7B,IAAI,CAACA,IAAI,CAAC2G,GAAG,EACT;EACJ,MAAM;IAAEsC,IAAI;IAAED,GAAG;IAAEpI,KAAK;IAAEC;EAAO,CAAC,GAAGb,IAAI,CAAC2G,GAAG;EAC7C,MAAM;IAAEiT,UAAU,GAAG,CAAC;IAAEC,SAAS,GAAG,CAAC;IAAEC,WAAW,GAAG,CAAC;IAAEC,YAAY,GAAG;EAAG,CAAC,GAAG/Z,IAAI,CAAC2G,GAAG;EACtF,MAAMsT,YAAY,GAAG5Z,IAAI,CAACuC,KAAK,CAAChC,KAAK,GAAGgZ,UAAU,GAAGE,WAAW,CAAC;EACjE,MAAMI,aAAa,GAAG7Z,IAAI,CAACuC,KAAK,CAAC/B,MAAM,GAAGgZ,SAAS,GAAGE,YAAY,CAAC;EACnEha,GAAG,CACE6F,QAAQ,CAAC,CAAC,CAAC,CACXE,OAAO,CAAC,CAAC,CAAC,CACVC,SAAS,CAAC,OAAO,CAAC,CAClBoU,IAAI,CAAC,GAAGF,YAAY,MAAMC,aAAa,EAAE,EAAEjR,IAAI,GAAG2Q,UAAU,EAAEvZ,IAAI,CAACwL,GAAG,CAAC7C,GAAG,GAAG6Q,SAAS,GAAG,CAAC,EAAE,CAAC,CAAC,EAAE;IAAEjZ,KAAK,EAAE2K;EAAS,CAAC,CAAC;AAC7H,CAAC;AACD,MAAM6O,WAAW,GAAGA,CAACra,GAAG,EAAEC,IAAI,KAAK;EAC/B,IAAIA,IAAI,CAACiK,MAAM,EAAE;IACblK,GAAG,CACEsa,MAAM,CAACra,IAAI,CAACiK,MAAM,CAAChB,IAAI,EAAEjJ,IAAI,CAACiK,MAAM,CAACjB,GAAG,EAAE,CAAC,CAAC,CAC5CiF,IAAI,CAAC,KAAK,CAAC,CACXoM,MAAM,CAACra,IAAI,CAACiK,MAAM,CAAChB,IAAI,EAAEjJ,IAAI,CAACiK,MAAM,CAACjB,GAAG,EAAE,CAAC,CAAC,CAC5CiE,MAAM,CAAC,KAAK,CAAC;EACtB;AACJ,CAAC;AACD,MAAMqN,WAAW,GAAGA,CAACva,GAAG,EAAEC,IAAI,KAAK;EAC/B,IAAI,CAACA,IAAI,CAACE,KAAK,EACX;EACJ,IAAI,EAAE,OAAO,IAAIF,IAAI,CAACE,KAAK,CAAC,IAAI,CAACF,IAAI,CAACE,KAAK,CAACqa,KAAK,EAC7C;EACJxa,GAAG,CAACwD,IAAI,CAAC,CAAC;EACV8V,YAAY,CAACtZ,GAAG,EAAEC,IAAI,CAAC;EACvB0Z,YAAY,CAAC3Z,GAAG,EAAEC,IAAI,CAAC;EACvB2Z,WAAW,CAAC5Z,GAAG,EAAEC,IAAI,CAAC;EACtBga,SAAS,CAACja,GAAG,EAAEC,IAAI,CAAC;EACpBoa,WAAW,CAACra,GAAG,EAAEC,IAAI,CAAC;EACtBD,GAAG,CAAC8E,OAAO,CAAC,CAAC;AACjB,CAAC;AAED,MAAM2V,gBAAgB,GAAG,CACrB,MAAM,EACN,MAAM,EACN,MAAM,EACN,MAAM,EACN,MAAM,EACN,MAAM,EACN,MAAM,EACN,MAAM,EACN,OAAO,EACP,QAAQ,EACR,QAAQ,EACR,QAAQ,EACR,QAAQ,EACR,QAAQ,EACR,SAAS,EACT,SAAS,EACT,SAAS,EACT,SAAS,EACT,SAAS,EACT,UAAU,EACV,UAAU,EACV,WAAW,EACX,WAAW,EACX,WAAW,EACX,YAAY,EACZ,aAAa,EACb,aAAa,EACb,aAAa,EACb,eAAe,EACf,eAAe,EACf,eAAe,EACf,kBAAkB,EAClB,gBAAgB,EAChB,gBAAgB,CACnB;AACD,MAAMC,OAAO,GAAI1a,GAAG,IAAK;EACrB,MAAMoI,CAAC,GAAGqS,gBAAgB,CAAClL,MAAM,CAAC,CAACoL,GAAG,EAAEC,IAAI,MAAM;IAC9C,GAAGD,GAAG;IACN,CAACC,IAAI,GAAG,YAAa;MACjB;MACA5a,GAAG,CAAC4a,IAAI,CAAC,CAAC,GAAA9Y,SAAO,CAAC;MAClB,OAAOsG,CAAC;IACZ;EACJ,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC;EACP,OAAOA,CAAC;AACZ,CAAC;AACD,MAAMyS,YAAY,GAAGA,CAAC7a,GAAG,EAAEC,IAAI,KAAK;EAChC,IAAI,CAACA,IAAI,CAAC2G,GAAG,EACT;EACJ,MAAM;IAAEqC,GAAG;IAAEC,IAAI;IAAErI,KAAK;IAAEC;EAAO,CAAC,GAAGb,IAAI,CAAC2G,GAAG;EAC7C,MAAM+B,UAAU,GAAG1I,IAAI,CAAC2G,GAAG,CAAC+B,UAAU,IAAI,CAAC;EAC3C,MAAMC,WAAW,GAAG3I,IAAI,CAAC2G,GAAG,CAACgC,WAAW,IAAI,CAAC;EAC7C,MAAM2P,YAAY,GAAGtY,IAAI,CAAC2G,GAAG,CAAC2R,YAAY,IAAI,CAAC;EAC/C,MAAMC,aAAa,GAAGvY,IAAI,CAAC2G,GAAG,CAAC4R,aAAa,IAAI,CAAC;EACjD,MAAMsC,cAAc,GAAGja,KAAK,GAAG+H,WAAW,GAAG2P,YAAY;EACzD,MAAMwC,eAAe,GAAGja,MAAM,GAAG6H,UAAU,GAAG6P,aAAa;EAC3D,IAAI,CAACsC,cAAc,IAAI,CAACC,eAAe,EAAE;IACrC1U,OAAO,CAACwC,IAAI,CAAC,4HAA4H,CAAC;EAC9I;EACA7I,GAAG,CAACwD,IAAI,CAAC,CAAC,CAAC+C,SAAS,CAAC2C,IAAI,GAAGN,WAAW,EAAEK,GAAG,GAAGN,UAAU,CAAC;EAC1D,IAAI1I,IAAI,CAACE,KAAK,CAAC6a,KAAK,EAAE;IAClB/a,IAAI,CAACE,KAAK,CAAC6a,KAAK,CAACN,OAAO,CAAC1a,GAAG,CAAC,EAAE8a,cAAc,EAAEC,eAAe,CAAC;EACnE;EACA/a,GAAG,CAAC8E,OAAO,CAAC,CAAC;AACjB,CAAC;;AAED;AACA;AACA,MAAMmW,KAAK,GAAG,GAAG,IAAI,CAAC3a,IAAI,CAACC,IAAI,CAAC,CAAC,CAAC,GAAG,GAAG,IAAI,GAAG,CAAC;AAChD,MAAM2a,aAAa,GAAGA,CAAClb,GAAG,EAAEmb,MAAM,EAAEzS,KAAK,EAAEa,GAAG,EAAEO,GAAG,KAAK;EACpD,MAAM;IAAEb,GAAG;IAAEC,IAAI;IAAErI,KAAK;IAAEC;EAAO,CAAC,GAAGqa,MAAM;EAC3C,MAAM;IAAE3B,cAAc;IAAEC,gBAAgB;IAAEF;EAAgB,CAAC,GAAG7Q,KAAK;EACnE;EACA1I,GAAG,CAACiB,MAAM,CAACiI,IAAI,GAAGY,GAAG,EAAEb,GAAG,CAAC;EAC3BjJ,GAAG,CAACkB,MAAM,CAACgI,IAAI,GAAGrI,KAAK,GAAG0I,GAAG,EAAEN,GAAG,CAAC;EACnC;EACA,MAAMmS,EAAE,GAAG7R,GAAG,IAAI,GAAG,GAAG0R,KAAK,CAAC;EAC9B;EACAjb,GAAG,CAACmB,aAAa,CAAC+H,IAAI,GAAGrI,KAAK,GAAGua,EAAE,EAAEnS,GAAG,EAAEC,IAAI,GAAGrI,KAAK,EAAEoI,GAAG,GAAGmS,EAAE,EAAElS,IAAI,GAAGrI,KAAK,EAAEoI,GAAG,GAAGM,GAAG,CAAC;EAC1F;EACA,MAAM8R,cAAc,GAAGpS,GAAG,GAAG3I,IAAI,CAACwL,GAAG,CAAC0N,cAAc,EAAEjQ,GAAG,CAAC;EAC1DvJ,GAAG,CAACkB,MAAM,CAACgI,IAAI,GAAGrI,KAAK,EAAEwa,cAAc,CAAC;EACxC;EACArb,GAAG,CAACkB,MAAM,CAACgI,IAAI,GAAGrI,KAAK,GAAG4Y,gBAAgB,EAAE4B,cAAc,CAAC;EAC3D;EACA,MAAMC,oBAAoB,GAAGhb,IAAI,CAACwL,GAAG,CAACvC,GAAG,GAAGkQ,gBAAgB,EAAE,CAAC,CAAC;EAChE,MAAM8B,oBAAoB,GAAGjb,IAAI,CAACwL,GAAG,CAACvC,GAAG,GAAGiQ,cAAc,EAAE,CAAC,CAAC;EAC9D,MAAMgC,EAAE,GAAGF,oBAAoB,IAAI,GAAG,GAAGL,KAAK,CAAC;EAC/C,MAAMQ,EAAE,GAAGF,oBAAoB,IAAI,GAAG,GAAGN,KAAK,CAAC;EAC/C;EACAjb,GAAG,CAACmB,aAAa,CAAC+H,IAAI,GAAGrI,KAAK,GAAG4Y,gBAAgB,EAAExQ,GAAG,GAAGuQ,cAAc,GAAGiC,EAAE,EAAEvS,IAAI,GAAGrI,KAAK,GAAG4Y,gBAAgB,GAAG+B,EAAE,EAAEvS,GAAG,GAAGuQ,cAAc,EAAEtQ,IAAI,GAAGrI,KAAK,GAAG4Y,gBAAgB,GAAG6B,oBAAoB,EAAErS,GAAG,GAAGuQ,cAAc,CAAC;EACvN;EACAxZ,GAAG,CAACkB,MAAM,CAACgI,IAAI,GAAG5I,IAAI,CAACwL,GAAG,CAAChC,GAAG,EAAEyP,eAAe,CAAC,EAAEtQ,GAAG,GAAGuQ,cAAc,CAAC;EACvE;EACA,MAAMkC,mBAAmB,GAAGpb,IAAI,CAACwL,GAAG,CAAChC,GAAG,GAAGyP,eAAe,EAAE,CAAC,CAAC;EAC9D,MAAMoC,mBAAmB,GAAGrb,IAAI,CAACwL,GAAG,CAAChC,GAAG,GAAG0P,cAAc,EAAE,CAAC,CAAC;EAC7D,MAAMoC,EAAE,GAAGF,mBAAmB,IAAI,GAAG,GAAGT,KAAK,CAAC;EAC9C,MAAMY,EAAE,GAAGF,mBAAmB,IAAI,GAAG,GAAGV,KAAK,CAAC;EAC9C,MAAMa,aAAa,GAAG7S,GAAG,GAAG3I,IAAI,CAACwL,GAAG,CAAC0N,cAAc,EAAE1P,GAAG,CAAC;EACzD;EACA9J,GAAG,CAACmB,aAAa,CAAC+H,IAAI,GAAGqQ,eAAe,GAAGqC,EAAE,EAAE3S,GAAG,GAAGuQ,cAAc,EAAEtQ,IAAI,GAAGqQ,eAAe,EAAEtQ,GAAG,GAAGuQ,cAAc,GAAGqC,EAAE,EAAE3S,IAAI,GAAGqQ,eAAe,EAAEuC,aAAa,CAAC;EAC9J9b,GAAG,CAACkB,MAAM,CAACgI,IAAI,EAAE4S,aAAa,CAAC;EAC/B;EACA9b,GAAG,CAACkB,MAAM,CAACgI,IAAI,EAAED,GAAG,GAAGa,GAAG,CAAC;EAC3B;EACA,MAAMiS,EAAE,GAAGjS,GAAG,IAAI,GAAG,GAAGmR,KAAK,CAAC;EAC9B;EACAjb,GAAG,CAACmB,aAAa,CAAC+H,IAAI,EAAED,GAAG,GAAG8S,EAAE,EAAE7S,IAAI,GAAG6S,EAAE,EAAE9S,GAAG,EAAEC,IAAI,GAAGY,GAAG,EAAEb,GAAG,CAAC;EAClEjJ,GAAG,CAACoB,SAAS,CAAC,CAAC;EACfpB,GAAG,CAACgK,IAAI,CAAC,CAAC;EACV;EACA,IAAIyP,gBAAgB,EAAE;IAClB,MAAMuC,OAAO,GAAG,CAACxC,cAAc,GAAGC,gBAAgB;IAClDzZ,GAAG,CAACiB,MAAM,CAACiI,IAAI,GAAGrI,KAAK,GAAG,CAAC,EAAEmb,OAAO,IAAI,CAACnb,KAAK,GAAG,CAAC,CAAC,GAAGoI,GAAG,CAAC;IAC1DjJ,GAAG,CAACkB,MAAM,CAACgI,IAAI,GAAGrI,KAAK,EAAEoI,GAAG,CAAC;IAC7BjJ,GAAG,CAACkB,MAAM,CAACgI,IAAI,EAAED,GAAG,CAAC;IACrBjJ,GAAG,CAACkB,MAAM,CAACgI,IAAI,EAAED,GAAG,GAAGnI,MAAM,CAAC;IAC9Bd,GAAG,CAACoB,SAAS,CAAC,CAAC;IACfpB,GAAG,CAACgK,IAAI,CAAC,CAAC;EACd;EACA,IAAIuP,eAAe,EAAE;IACjB,MAAMyC,OAAO,GAAG,CAACxC,cAAc,GAAGD,eAAe;IACjDvZ,GAAG,CAACiB,MAAM,CAACiI,IAAI,GAAGrI,KAAK,GAAG,CAAC,EAAEmb,OAAO,IAAI,CAACnb,KAAK,GAAG,CAAC,CAAC,GAAGoI,GAAG,CAAC;IAC1DjJ,GAAG,CAACkB,MAAM,CAACgI,IAAI,EAAED,GAAG,CAAC;IACrBjJ,GAAG,CAACkB,MAAM,CAACgI,IAAI,GAAGrI,KAAK,EAAEoI,GAAG,CAAC;IAC7BjJ,GAAG,CAACkB,MAAM,CAACgI,IAAI,GAAGrI,KAAK,EAAEoI,GAAG,GAAGnI,MAAM,CAAC;IACtCd,GAAG,CAACoB,SAAS,CAAC,CAAC;IACfpB,GAAG,CAACgK,IAAI,CAAC,CAAC;EACd;AACJ,CAAC;AACD,MAAMiS,aAAa,GAAGA,CAACjc,GAAG,EAAEmb,MAAM,EAAEzS,KAAK,EAAEa,GAAG,EAAEO,GAAG,KAAK;EACpD,MAAM;IAAEb,GAAG;IAAEC,IAAI;IAAErI;EAAM,CAAC,GAAGsa,MAAM;EACnC,MAAM;IAAEe,cAAc;IAAE1C,cAAc;IAAE2C,cAAc;IAAE1C,gBAAgB;IAAEF;EAAiB,CAAC,GAAG7Q,KAAK;EACpG,MAAM0S,EAAE,GAAGtR,GAAG,IAAI,GAAG,GAAGmR,KAAK,CAAC;EAC9B,MAAMO,EAAE,GAAGjS,GAAG,IAAI,GAAG,GAAG0R,KAAK,CAAC;EAC9Bjb,GAAG,CAACiB,MAAM,CAACiI,IAAI,EAAED,GAAG,GAAG3I,IAAI,CAACwL,GAAG,CAAChC,GAAG,EAAE0P,cAAc,CAAC,CAAC;EACrDxZ,GAAG,CAACmB,aAAa,CAAC+H,IAAI,EAAED,GAAG,GAAGmS,EAAE,EAAElS,IAAI,GAAGkS,EAAE,EAAEnS,GAAG,EAAEC,IAAI,GAAGY,GAAG,EAAEb,GAAG,CAAC;EAClEjJ,GAAG,CAACkB,MAAM,CAACgI,IAAI,GAAGrI,KAAK,GAAG0I,GAAG,EAAEN,GAAG,CAAC;EACnCjJ,GAAG,CAACmB,aAAa,CAAC+H,IAAI,GAAGrI,KAAK,GAAG2a,EAAE,EAAEvS,GAAG,EAAEC,IAAI,GAAGrI,KAAK,EAAEoI,GAAG,GAAGuS,EAAE,EAAEtS,IAAI,GAAGrI,KAAK,EAAEoI,GAAG,GAAGM,GAAG,CAAC;EAC1FvJ,GAAG,CAACiN,WAAW,CAACiP,cAAc,CAAC;EAC/Blc,GAAG,CAAC8M,SAAS,CAACxM,IAAI,CAACwL,GAAG,CAAC2N,gBAAgB,EAAED,cAAc,EAAED,eAAe,CAAC,GAAG,CAAC,CAAC;EAC9E,IAAI4C,cAAc,KAAK,QAAQ,EAAE;IAC7Bnc,GAAG,CAAC+N,IAAI,CAACyL,cAAc,GAAG,CAAC,EAAE;MAAE/F,KAAK,EAAE+F,cAAc,GAAG;IAAI,CAAC,CAAC;EACjE,CAAC,MACI,IAAI2C,cAAc,KAAK,QAAQ,EAAE;IAClCnc,GAAG,CAAC+N,IAAI,CAACyL,cAAc,EAAE;MAAE/F,KAAK,EAAE+F,cAAc,GAAG;IAAI,CAAC,CAAC;EAC7D;EACAxZ,GAAG,CAACkN,MAAM,CAAC,CAAC;EACZlN,GAAG,CAACoc,MAAM,CAAC,CAAC;AAChB,CAAC;AACD,MAAMC,eAAe,GAAGA,CAACrc,GAAG,EAAEmb,MAAM,EAAEzS,KAAK,EAAEa,GAAG,EAAEG,GAAG,KAAK;EACtD,MAAM;IAAET,GAAG;IAAEC,IAAI;IAAErI,KAAK;IAAEC;EAAO,CAAC,GAAGqa,MAAM;EAC3C,MAAM;IAAE3B,cAAc;IAAEC,gBAAgB;IAAEC;EAAkB,CAAC,GAAGhR,KAAK;EACrE;EACA1I,GAAG,CAACiB,MAAM,CAACiI,IAAI,GAAGrI,KAAK,EAAEoI,GAAG,GAAGM,GAAG,CAAC;EACnCvJ,GAAG,CAACkB,MAAM,CAACgI,IAAI,GAAGrI,KAAK,EAAEoI,GAAG,GAAGnI,MAAM,GAAG4I,GAAG,CAAC;EAC5C;EACA,MAAM0R,EAAE,GAAG1R,GAAG,IAAI,GAAG,GAAGuR,KAAK,CAAC;EAC9B;EACAjb,GAAG,CAACmB,aAAa,CAAC+H,IAAI,GAAGrI,KAAK,EAAEoI,GAAG,GAAGnI,MAAM,GAAGsa,EAAE,EAAElS,IAAI,GAAGrI,KAAK,GAAGua,EAAE,EAAEnS,GAAG,GAAGnI,MAAM,EAAEoI,IAAI,GAAGrI,KAAK,GAAG6I,GAAG,EAAET,GAAG,GAAGnI,MAAM,CAAC;EACrH;EACA,MAAMwb,eAAe,GAAGpT,IAAI,GAAGrI,KAAK,GAAGP,IAAI,CAACwL,GAAG,CAAC2N,gBAAgB,EAAE/P,GAAG,CAAC;EACtE1J,GAAG,CAACkB,MAAM,CAACob,eAAe,EAAErT,GAAG,GAAGnI,MAAM,CAAC;EACzC;EACAd,GAAG,CAACkB,MAAM,CAACob,eAAe,EAAErT,GAAG,GAAGnI,MAAM,GAAG4Y,iBAAiB,CAAC;EAC7D;EACA,MAAM6C,uBAAuB,GAAGjc,IAAI,CAACwL,GAAG,CAACpC,GAAG,GAAG+P,gBAAgB,EAAE,CAAC,CAAC;EACnE,MAAM+C,uBAAuB,GAAGlc,IAAI,CAACwL,GAAG,CAACpC,GAAG,GAAGgQ,iBAAiB,EAAE,CAAC,CAAC;EACpE,MAAM8B,EAAE,GAAGe,uBAAuB,IAAI,GAAG,GAAGtB,KAAK,CAAC;EAClD,MAAMQ,EAAE,GAAGe,uBAAuB,IAAI,GAAG,GAAGvB,KAAK,CAAC;EAClD;EACAjb,GAAG,CAACmB,aAAa,CAAC+H,IAAI,GAAGrI,KAAK,GAAG4Y,gBAAgB,GAAG+B,EAAE,EAAEvS,GAAG,GAAGnI,MAAM,GAAG4Y,iBAAiB,EAAExQ,IAAI,GAAGrI,KAAK,GAAG4Y,gBAAgB,EAAExQ,GAAG,GAAGnI,MAAM,GAAG4Y,iBAAiB,GAAG+B,EAAE,EAAEvS,IAAI,GAAGrI,KAAK,GAAG4Y,gBAAgB,EAAExQ,GAAG,GAAGnI,MAAM,GAAGR,IAAI,CAACwL,GAAG,CAACpC,GAAG,EAAEgQ,iBAAiB,CAAC,CAAC;EACnP;EACA1Z,GAAG,CAACkB,MAAM,CAACgI,IAAI,GAAGrI,KAAK,GAAG4Y,gBAAgB,EAAExQ,GAAG,GAAG3I,IAAI,CAACwL,GAAG,CAACvC,GAAG,EAAEiQ,cAAc,CAAC,CAAC;EAChF;EACA,MAAM8B,oBAAoB,GAAGhb,IAAI,CAACwL,GAAG,CAACvC,GAAG,GAAGkQ,gBAAgB,EAAE,CAAC,CAAC;EAChE,MAAM8B,oBAAoB,GAAGjb,IAAI,CAACwL,GAAG,CAACvC,GAAG,GAAGiQ,cAAc,EAAE,CAAC,CAAC;EAC9D,MAAMoC,EAAE,GAAGN,oBAAoB,IAAI,GAAG,GAAGL,KAAK,CAAC;EAC/C,MAAMY,EAAE,GAAGN,oBAAoB,IAAI,GAAG,GAAGN,KAAK,CAAC;EAC/C,MAAMwB,cAAc,GAAGvT,IAAI,GAAGrI,KAAK,GAAGP,IAAI,CAACwL,GAAG,CAACvC,GAAG,EAAEkQ,gBAAgB,CAAC;EACrE;EACAzZ,GAAG,CAACmB,aAAa,CAAC+H,IAAI,GAAGrI,KAAK,GAAG4Y,gBAAgB,EAAExQ,GAAG,GAAGuQ,cAAc,GAAGqC,EAAE,EAAE3S,IAAI,GAAGrI,KAAK,GAAG4Y,gBAAgB,GAAGmC,EAAE,EAAE3S,GAAG,GAAGuQ,cAAc,EAAEiD,cAAc,EAAExT,GAAG,GAAGuQ,cAAc,CAAC;EAC/KxZ,GAAG,CAACkB,MAAM,CAACub,cAAc,EAAExT,GAAG,CAAC;EAC/B;EACAjJ,GAAG,CAACkB,MAAM,CAACgI,IAAI,GAAGrI,KAAK,GAAG0I,GAAG,EAAEN,GAAG,CAAC;EACnC;EACA,MAAM8S,EAAE,GAAGxS,GAAG,IAAI,GAAG,GAAG0R,KAAK,CAAC;EAC9B;EACAjb,GAAG,CAACmB,aAAa,CAAC+H,IAAI,GAAGrI,KAAK,GAAGkb,EAAE,EAAE9S,GAAG,EAAEC,IAAI,GAAGrI,KAAK,EAAEoI,GAAG,GAAG8S,EAAE,EAAE7S,IAAI,GAAGrI,KAAK,EAAEoI,GAAG,GAAGM,GAAG,CAAC;EAC1FvJ,GAAG,CAACoB,SAAS,CAAC,CAAC;EACfpB,GAAG,CAACgK,IAAI,CAAC,CAAC;EACV;EACA,IAAIwP,cAAc,EAAE;IAChB,MAAMwC,OAAO,GAAG,CAACxC,cAAc,GAAGC,gBAAgB;IAClDzZ,GAAG,CAACiB,MAAM,CAACiI,IAAI,GAAGrI,KAAK,GAAG,CAAC,EAAEmb,OAAO,IAAI,CAACnb,KAAK,GAAG,CAAC,CAAC,GAAGoI,GAAG,CAAC;IAC1DjJ,GAAG,CAACkB,MAAM,CAACgI,IAAI,GAAGrI,KAAK,EAAEoI,GAAG,CAAC;IAC7BjJ,GAAG,CAACkB,MAAM,CAACgI,IAAI,GAAGrI,KAAK,EAAEoI,GAAG,GAAGnI,MAAM,CAAC;IACtCd,GAAG,CAACkB,MAAM,CAACgI,IAAI,EAAED,GAAG,GAAGnI,MAAM,CAAC;IAC9Bd,GAAG,CAACoB,SAAS,CAAC,CAAC;IACfpB,GAAG,CAACgK,IAAI,CAAC,CAAC;EACd;EACA,IAAI0P,iBAAiB,EAAE;IACnB,MAAMgD,OAAO,GAAGhD,iBAAiB,GAAGD,gBAAgB;IACpDzZ,GAAG,CAACiB,MAAM,CAACiI,IAAI,GAAGrI,KAAK,GAAG,CAAC,EAAE6b,OAAO,IAAI,CAAC7b,KAAK,GAAG,CAAC,CAAC,GAAGoI,GAAG,GAAGnI,MAAM,CAAC;IACnEd,GAAG,CAACkB,MAAM,CAACgI,IAAI,GAAGrI,KAAK,EAAEoI,GAAG,GAAGnI,MAAM,CAAC;IACtCd,GAAG,CAACkB,MAAM,CAACgI,IAAI,GAAGrI,KAAK,EAAEoI,GAAG,CAAC;IAC7BjJ,GAAG,CAACkB,MAAM,CAACgI,IAAI,EAAED,GAAG,CAAC;IACrBjJ,GAAG,CAACoB,SAAS,CAAC,CAAC;IACfpB,GAAG,CAACgK,IAAI,CAAC,CAAC;EACd;AACJ,CAAC;AACD,MAAM2S,eAAe,GAAGA,CAAC3c,GAAG,EAAEmb,MAAM,EAAEzS,KAAK,EAAEa,GAAG,EAAEG,GAAG,KAAK;EACtD,MAAM;IAAET,GAAG;IAAEC,IAAI;IAAErI,KAAK;IAAEC;EAAO,CAAC,GAAGqa,MAAM;EAC3C,MAAM;IAAEyB,gBAAgB;IAAEC,gBAAgB;IAAEpD,gBAAgB;IAAED,cAAc;IAAEE;EAAmB,CAAC,GAAGhR,KAAK;EAC1G,MAAM0S,EAAE,GAAG1R,GAAG,IAAI,GAAG,GAAGuR,KAAK,CAAC;EAC9B,MAAMO,EAAE,GAAGjS,GAAG,IAAI,GAAG,GAAG0R,KAAK,CAAC;EAC9Bjb,GAAG,CAACiB,MAAM,CAACiI,IAAI,GAAGrI,KAAK,GAAG0I,GAAG,EAAEN,GAAG,CAAC;EACnCjJ,GAAG,CAACmB,aAAa,CAAC+H,IAAI,GAAGrI,KAAK,GAAG2a,EAAE,EAAEvS,GAAG,EAAEC,IAAI,GAAGrI,KAAK,EAAEoI,GAAG,GAAGuS,EAAE,EAAEtS,IAAI,GAAGrI,KAAK,EAAEoI,GAAG,GAAGM,GAAG,CAAC;EAC1FvJ,GAAG,CAACkB,MAAM,CAACgI,IAAI,GAAGrI,KAAK,EAAEoI,GAAG,GAAGnI,MAAM,GAAG4I,GAAG,CAAC;EAC5C1J,GAAG,CAACmB,aAAa,CAAC+H,IAAI,GAAGrI,KAAK,EAAEoI,GAAG,GAAGnI,MAAM,GAAGsa,EAAE,EAAElS,IAAI,GAAGrI,KAAK,GAAGua,EAAE,EAAEnS,GAAG,GAAGnI,MAAM,EAAEoI,IAAI,GAAGrI,KAAK,GAAG6I,GAAG,EAAET,GAAG,GAAGnI,MAAM,CAAC;EACrHd,GAAG,CAACiN,WAAW,CAAC2P,gBAAgB,CAAC;EACjC5c,GAAG,CAAC8M,SAAS,CAACxM,IAAI,CAACwL,GAAG,CAAC2N,gBAAgB,EAAED,cAAc,EAAEE,iBAAiB,CAAC,GAAG,CAAC,CAAC;EAChF,IAAImD,gBAAgB,KAAK,QAAQ,EAAE;IAC/B7c,GAAG,CAAC+N,IAAI,CAAC0L,gBAAgB,GAAG,CAAC,EAAE;MAAEhG,KAAK,EAAEgG,gBAAgB,GAAG;IAAI,CAAC,CAAC;EACrE,CAAC,MACI,IAAIoD,gBAAgB,KAAK,QAAQ,EAAE;IACpC7c,GAAG,CAAC+N,IAAI,CAAC0L,gBAAgB,EAAE;MAAEhG,KAAK,EAAEgG,gBAAgB,GAAG;IAAI,CAAC,CAAC;EACjE;EACAzZ,GAAG,CAACkN,MAAM,CAAC,CAAC;EACZlN,GAAG,CAACoc,MAAM,CAAC,CAAC;AAChB,CAAC;AACD,MAAMU,gBAAgB,GAAGA,CAAC9c,GAAG,EAAEmb,MAAM,EAAEzS,KAAK,EAAEkB,GAAG,EAAEF,GAAG,KAAK;EACvD,MAAM;IAAET,GAAG;IAAEC,IAAI;IAAErI,KAAK;IAAEC;EAAO,CAAC,GAAGqa,MAAM;EAC3C,MAAM;IAAEzB,iBAAiB;IAAED,gBAAgB;IAAEF;EAAgB,CAAC,GAAG7Q,KAAK;EACtE;EACA1I,GAAG,CAACiB,MAAM,CAACiI,IAAI,GAAGrI,KAAK,GAAG6I,GAAG,EAAET,GAAG,GAAGnI,MAAM,CAAC;EAC5Cd,GAAG,CAACkB,MAAM,CAACgI,IAAI,GAAGU,GAAG,EAAEX,GAAG,GAAGnI,MAAM,CAAC;EACpC;EACA,MAAMsa,EAAE,GAAGxR,GAAG,IAAI,GAAG,GAAGqR,KAAK,CAAC;EAC9B;EACAjb,GAAG,CAACmB,aAAa,CAAC+H,IAAI,GAAGkS,EAAE,EAAEnS,GAAG,GAAGnI,MAAM,EAAEoI,IAAI,EAAED,GAAG,GAAGnI,MAAM,GAAGsa,EAAE,EAAElS,IAAI,EAAED,GAAG,GAAGnI,MAAM,GAAG8I,GAAG,CAAC;EAC7F;EACA,MAAMmT,gBAAgB,GAAG9T,GAAG,GAAGnI,MAAM,GAAGR,IAAI,CAACwL,GAAG,CAAC4N,iBAAiB,EAAE9P,GAAG,CAAC;EACxE5J,GAAG,CAACkB,MAAM,CAACgI,IAAI,EAAE6T,gBAAgB,CAAC;EAClC;EACA/c,GAAG,CAACkB,MAAM,CAACgI,IAAI,GAAGqQ,eAAe,EAAEwD,gBAAgB,CAAC;EACpD;EACA,MAAMC,sBAAsB,GAAG1c,IAAI,CAACwL,GAAG,CAAClC,GAAG,GAAG2P,eAAe,EAAE,CAAC,CAAC;EACjE,MAAM0D,sBAAsB,GAAG3c,IAAI,CAACwL,GAAG,CAAClC,GAAG,GAAG8P,iBAAiB,EAAE,CAAC,CAAC;EACnE,MAAM8B,EAAE,GAAGwB,sBAAsB,IAAI,GAAG,GAAG/B,KAAK,CAAC;EACjD,MAAMQ,EAAE,GAAGwB,sBAAsB,IAAI,GAAG,GAAGhC,KAAK,CAAC;EACjD;EACAjb,GAAG,CAACmB,aAAa,CAAC+H,IAAI,GAAGqQ,eAAe,EAAEtQ,GAAG,GAAGnI,MAAM,GAAG4Y,iBAAiB,GAAG+B,EAAE,EAAEvS,IAAI,GAAGqQ,eAAe,GAAGiC,EAAE,EAAEvS,GAAG,GAAGnI,MAAM,GAAG4Y,iBAAiB,EAAExQ,IAAI,GAAGqQ,eAAe,GAAGyD,sBAAsB,EAAE/T,GAAG,GAAGnI,MAAM,GAAG4Y,iBAAiB,CAAC;EAClO;EACA1Z,GAAG,CAACkB,MAAM,CAACgI,IAAI,GAAGrI,KAAK,GAAGP,IAAI,CAACwL,GAAG,CAACpC,GAAG,EAAE+P,gBAAgB,CAAC,EAAExQ,GAAG,GAAGnI,MAAM,GAAG4Y,iBAAiB,CAAC;EAC5F;EACA,MAAM6C,uBAAuB,GAAGjc,IAAI,CAACwL,GAAG,CAACpC,GAAG,GAAG+P,gBAAgB,EAAE,CAAC,CAAC;EACnE,MAAM+C,uBAAuB,GAAGlc,IAAI,CAACwL,GAAG,CAACpC,GAAG,GAAGgQ,iBAAiB,EAAE,CAAC,CAAC;EACpE,MAAMkC,EAAE,GAAGW,uBAAuB,IAAI,GAAG,GAAGtB,KAAK,CAAC;EAClD,MAAMY,EAAE,GAAGW,uBAAuB,IAAI,GAAG,GAAGvB,KAAK,CAAC;EAClD,MAAMiC,iBAAiB,GAAGjU,GAAG,GAAGnI,MAAM,GAAGR,IAAI,CAACwL,GAAG,CAAC4N,iBAAiB,EAAEhQ,GAAG,CAAC;EACzE;EACA1J,GAAG,CAACmB,aAAa,CAAC+H,IAAI,GAAGrI,KAAK,GAAG4Y,gBAAgB,GAAGmC,EAAE,EAAE3S,GAAG,GAAGnI,MAAM,GAAG4Y,iBAAiB,EAAExQ,IAAI,GAAGrI,KAAK,GAAG4Y,gBAAgB,EAAExQ,GAAG,GAAGnI,MAAM,GAAG4Y,iBAAiB,GAAGmC,EAAE,EAAE3S,IAAI,GAAGrI,KAAK,GAAG4Y,gBAAgB,EAAEyD,iBAAiB,CAAC;EACrNld,GAAG,CAACkB,MAAM,CAACgI,IAAI,GAAGrI,KAAK,EAAEqc,iBAAiB,CAAC;EAC3C;EACAld,GAAG,CAACkB,MAAM,CAACgI,IAAI,GAAGrI,KAAK,EAAEoI,GAAG,GAAGnI,MAAM,GAAG4I,GAAG,CAAC;EAC5C;EACA,MAAMqS,EAAE,GAAGrS,GAAG,IAAI,GAAG,GAAGuR,KAAK,CAAC;EAC9B;EACAjb,GAAG,CAACmB,aAAa,CAAC+H,IAAI,GAAGrI,KAAK,EAAEoI,GAAG,GAAGnI,MAAM,GAAGib,EAAE,EAAE7S,IAAI,GAAGrI,KAAK,GAAGkb,EAAE,EAAE9S,GAAG,GAAGnI,MAAM,EAAEoI,IAAI,GAAGrI,KAAK,GAAG6I,GAAG,EAAET,GAAG,GAAGnI,MAAM,CAAC;EACrHd,GAAG,CAACoB,SAAS,CAAC,CAAC;EACfpB,GAAG,CAACgK,IAAI,CAAC,CAAC;EACV;EACA,IAAIyP,gBAAgB,EAAE;IAClB,MAAMiD,OAAO,GAAGhD,iBAAiB,GAAGD,gBAAgB;IACpDzZ,GAAG,CAACiB,MAAM,CAACiI,IAAI,GAAGrI,KAAK,GAAG,CAAC,EAAE6b,OAAO,IAAI,CAAC7b,KAAK,GAAG,CAAC,CAAC,GAAGoI,GAAG,GAAGnI,MAAM,CAAC;IACnEd,GAAG,CAACkB,MAAM,CAACgI,IAAI,GAAGrI,KAAK,EAAEoI,GAAG,GAAGnI,MAAM,CAAC;IACtCd,GAAG,CAACkB,MAAM,CAACgI,IAAI,EAAED,GAAG,GAAGnI,MAAM,CAAC;IAC9Bd,GAAG,CAACkB,MAAM,CAACgI,IAAI,EAAED,GAAG,CAAC;IACrBjJ,GAAG,CAACoB,SAAS,CAAC,CAAC;IACfpB,GAAG,CAACgK,IAAI,CAAC,CAAC;EACd;EACA,IAAIuP,eAAe,EAAE;IACjB,MAAMyC,OAAO,GAAG,CAACtC,iBAAiB,GAAGH,eAAe;IACpDvZ,GAAG,CAACiB,MAAM,CAACiI,IAAI,GAAGrI,KAAK,GAAG,CAAC,EAAEmb,OAAO,IAAInb,KAAK,GAAG,CAAC,CAAC,GAAGoI,GAAG,GAAGnI,MAAM,CAAC;IAClEd,GAAG,CAACkB,MAAM,CAACgI,IAAI,EAAED,GAAG,GAAGnI,MAAM,CAAC;IAC9Bd,GAAG,CAACkB,MAAM,CAACgI,IAAI,GAAGrI,KAAK,EAAEoI,GAAG,GAAGnI,MAAM,CAAC;IACtCd,GAAG,CAACkB,MAAM,CAACgI,IAAI,GAAGrI,KAAK,EAAEoI,GAAG,CAAC;IAC7BjJ,GAAG,CAACoB,SAAS,CAAC,CAAC;IACfpB,GAAG,CAACgK,IAAI,CAAC,CAAC;EACd;AACJ,CAAC;AACD,MAAMmT,gBAAgB,GAAGA,CAACnd,GAAG,EAAEmb,MAAM,EAAEzS,KAAK,EAAEkB,GAAG,EAAEF,GAAG,KAAK;EACvD,MAAM;IAAET,GAAG;IAAEC,IAAI;IAAErI,KAAK;IAAEC;EAAO,CAAC,GAAGqa,MAAM;EAC3C,MAAM;IAAEiC,iBAAiB;IAAEC,iBAAiB;IAAE3D,iBAAiB;IAAED,gBAAgB;IAAEF;EAAiB,CAAC,GAAG7Q,KAAK;EAC7G,MAAM0S,EAAE,GAAGxR,GAAG,IAAI,GAAG,GAAGqR,KAAK,CAAC;EAC9B,MAAMO,EAAE,GAAG9R,GAAG,IAAI,GAAG,GAAGuR,KAAK,CAAC;EAC9Bjb,GAAG,CAACiB,MAAM,CAACiI,IAAI,GAAGrI,KAAK,EAAEoI,GAAG,GAAGnI,MAAM,GAAG4I,GAAG,CAAC;EAC5C1J,GAAG,CAACmB,aAAa,CAAC+H,IAAI,GAAGrI,KAAK,EAAEoI,GAAG,GAAGnI,MAAM,GAAG0a,EAAE,EAAEtS,IAAI,GAAGrI,KAAK,GAAG2a,EAAE,EAAEvS,GAAG,GAAGnI,MAAM,EAAEoI,IAAI,GAAGrI,KAAK,GAAG6I,GAAG,EAAET,GAAG,GAAGnI,MAAM,CAAC;EACrHd,GAAG,CAACkB,MAAM,CAACgI,IAAI,GAAGU,GAAG,EAAEX,GAAG,GAAGnI,MAAM,CAAC;EACpCd,GAAG,CAACmB,aAAa,CAAC+H,IAAI,GAAGkS,EAAE,EAAEnS,GAAG,GAAGnI,MAAM,EAAEoI,IAAI,EAAED,GAAG,GAAGnI,MAAM,GAAGsa,EAAE,EAAElS,IAAI,EAAED,GAAG,GAAGnI,MAAM,GAAG8I,GAAG,CAAC;EAC7F5J,GAAG,CAACiN,WAAW,CAACmQ,iBAAiB,CAAC;EAClCpd,GAAG,CAAC8M,SAAS,CAACxM,IAAI,CAACwL,GAAG,CAAC4N,iBAAiB,EAAED,gBAAgB,EAAEF,eAAe,CAAC,GAAG,CAAC,CAAC;EACjF,IAAI8D,iBAAiB,KAAK,QAAQ,EAAE;IAChCrd,GAAG,CAAC+N,IAAI,CAAC2L,iBAAiB,GAAG,CAAC,EAAE;MAAEjG,KAAK,EAAEiG,iBAAiB,GAAG;IAAI,CAAC,CAAC;EACvE,CAAC,MACI,IAAI2D,iBAAiB,KAAK,QAAQ,EAAE;IACrCrd,GAAG,CAAC+N,IAAI,CAAC2L,iBAAiB,EAAE;MAAEjG,KAAK,EAAEiG,iBAAiB,GAAG;IAAI,CAAC,CAAC;EACnE;EACA1Z,GAAG,CAACkN,MAAM,CAAC,CAAC;EACZlN,GAAG,CAACoc,MAAM,CAAC,CAAC;AAChB,CAAC;AACD,MAAMkB,cAAc,GAAGA,CAACtd,GAAG,EAAEmb,MAAM,EAAEzS,KAAK,EAAEkB,GAAG,EAAEE,GAAG,KAAK;EACrD,MAAM;IAAEb,GAAG;IAAEC,IAAI;IAAErI,KAAK;IAAEC;EAAO,CAAC,GAAGqa,MAAM;EAC3C,MAAM;IAAE3B,cAAc;IAAED,eAAe;IAAEG;EAAkB,CAAC,GAAGhR,KAAK;EACpE;EACA1I,GAAG,CAACiB,MAAM,CAACiI,IAAI,EAAED,GAAG,GAAGnI,MAAM,GAAG8I,GAAG,CAAC;EACpC5J,GAAG,CAACkB,MAAM,CAACgI,IAAI,EAAED,GAAG,GAAGa,GAAG,CAAC;EAC3B;EACA,MAAMsR,EAAE,GAAGtR,GAAG,IAAI,GAAG,GAAGmR,KAAK,CAAC;EAC9B;EACAjb,GAAG,CAACmB,aAAa,CAAC+H,IAAI,EAAED,GAAG,GAAGmS,EAAE,EAAElS,IAAI,GAAGkS,EAAE,EAAEnS,GAAG,EAAEC,IAAI,GAAGY,GAAG,EAAEb,GAAG,CAAC;EAClE;EACA,MAAMsU,aAAa,GAAGrU,IAAI,GAAG5I,IAAI,CAACwL,GAAG,CAACyN,eAAe,EAAEzP,GAAG,CAAC;EAC3D9J,GAAG,CAACkB,MAAM,CAACqc,aAAa,EAAEtU,GAAG,CAAC;EAC9B;EACAjJ,GAAG,CAACkB,MAAM,CAACqc,aAAa,EAAEtU,GAAG,GAAGuQ,cAAc,CAAC;EAC/C;EACA,MAAMkC,mBAAmB,GAAGpb,IAAI,CAACwL,GAAG,CAAChC,GAAG,GAAGyP,eAAe,EAAE,CAAC,CAAC;EAC9D,MAAMoC,mBAAmB,GAAGrb,IAAI,CAACwL,GAAG,CAAChC,GAAG,GAAG0P,cAAc,EAAE,CAAC,CAAC;EAC7D,MAAMgC,EAAE,GAAGE,mBAAmB,IAAI,GAAG,GAAGT,KAAK,CAAC;EAC9C,MAAMQ,EAAE,GAAGE,mBAAmB,IAAI,GAAG,GAAGV,KAAK,CAAC;EAC9C;EACAjb,GAAG,CAACmB,aAAa,CAAC+H,IAAI,GAAGqQ,eAAe,GAAGiC,EAAE,EAAEvS,GAAG,GAAGuQ,cAAc,EAAEtQ,IAAI,GAAGqQ,eAAe,EAAEtQ,GAAG,GAAGuQ,cAAc,GAAGiC,EAAE,EAAEvS,IAAI,GAAGqQ,eAAe,EAAEtQ,GAAG,GAAG3I,IAAI,CAACwL,GAAG,CAAChC,GAAG,EAAE0P,cAAc,CAAC,CAAC;EACpL;EACAxZ,GAAG,CAACkB,MAAM,CAACgI,IAAI,GAAGqQ,eAAe,EAAEtQ,GAAG,GAAGnI,MAAM,GAAGR,IAAI,CAACwL,GAAG,CAAClC,GAAG,EAAE8P,iBAAiB,CAAC,CAAC;EACnF;EACA,MAAMsD,sBAAsB,GAAG1c,IAAI,CAACwL,GAAG,CAAClC,GAAG,GAAG2P,eAAe,EAAE,CAAC,CAAC;EACjE,MAAM0D,sBAAsB,GAAG3c,IAAI,CAACwL,GAAG,CAAClC,GAAG,GAAG8P,iBAAiB,EAAE,CAAC,CAAC;EACnE,MAAMkC,EAAE,GAAGoB,sBAAsB,IAAI,GAAG,GAAG/B,KAAK,CAAC;EACjD,MAAMY,EAAE,GAAGoB,sBAAsB,IAAI,GAAG,GAAGhC,KAAK,CAAC;EACjD,MAAMuC,gBAAgB,GAAGtU,IAAI,GAAG5I,IAAI,CAACwL,GAAG,CAAClC,GAAG,EAAE2P,eAAe,CAAC;EAC9D;EACAvZ,GAAG,CAACmB,aAAa,CAAC+H,IAAI,GAAGqQ,eAAe,EAAEtQ,GAAG,GAAGnI,MAAM,GAAG4Y,iBAAiB,GAAGmC,EAAE,EAAE3S,IAAI,GAAGqQ,eAAe,GAAGqC,EAAE,EAAE3S,GAAG,GAAGnI,MAAM,GAAG4Y,iBAAiB,EAAE8D,gBAAgB,EAAEvU,GAAG,GAAGnI,MAAM,GAAG4Y,iBAAiB,CAAC;EACnM1Z,GAAG,CAACkB,MAAM,CAACsc,gBAAgB,EAAEvU,GAAG,GAAGnI,MAAM,CAAC;EAC1C;EACAd,GAAG,CAACkB,MAAM,CAACgI,IAAI,GAAGU,GAAG,EAAEX,GAAG,GAAGnI,MAAM,CAAC;EACpC;EACA,MAAMib,EAAE,GAAGnS,GAAG,IAAI,GAAG,GAAGqR,KAAK,CAAC;EAC9B;EACAjb,GAAG,CAACmB,aAAa,CAAC+H,IAAI,GAAG6S,EAAE,EAAE9S,GAAG,GAAGnI,MAAM,EAAEoI,IAAI,EAAED,GAAG,GAAGnI,MAAM,GAAGib,EAAE,EAAE7S,IAAI,EAAED,GAAG,GAAGnI,MAAM,GAAG8I,GAAG,CAAC;EAC7F5J,GAAG,CAACoB,SAAS,CAAC,CAAC;EACfpB,GAAG,CAACgK,IAAI,CAAC,CAAC;EACV;EACA,IAAI0P,iBAAiB,EAAE;IACnB,MAAMsC,OAAO,GAAG,CAACtC,iBAAiB,GAAGH,eAAe;IACpDvZ,GAAG,CAACiB,MAAM,CAACiI,IAAI,GAAGrI,KAAK,GAAG,CAAC,EAAEmb,OAAO,IAAInb,KAAK,GAAG,CAAC,CAAC,GAAGoI,GAAG,GAAGnI,MAAM,CAAC;IAClEd,GAAG,CAACkB,MAAM,CAACgI,IAAI,EAAED,GAAG,GAAGnI,MAAM,CAAC;IAC9Bd,GAAG,CAACkB,MAAM,CAACgI,IAAI,EAAED,GAAG,CAAC;IACrBjJ,GAAG,CAACkB,MAAM,CAACgI,IAAI,GAAGrI,KAAK,EAAEoI,GAAG,CAAC;IAC7BjJ,GAAG,CAACoB,SAAS,CAAC,CAAC;IACfpB,GAAG,CAACgK,IAAI,CAAC,CAAC;EACd;EACA,IAAI0P,iBAAiB,EAAE;IACnB,MAAMsC,OAAO,GAAG,CAACxC,cAAc,GAAGD,eAAe;IACjDvZ,GAAG,CAACiB,MAAM,CAACiI,IAAI,GAAGrI,KAAK,GAAG,CAAC,EAAEmb,OAAO,IAAI,CAACnb,KAAK,GAAG,CAAC,CAAC,GAAGoI,GAAG,CAAC;IAC1DjJ,GAAG,CAACkB,MAAM,CAACgI,IAAI,EAAED,GAAG,CAAC;IACrBjJ,GAAG,CAACkB,MAAM,CAACgI,IAAI,EAAED,GAAG,GAAGnI,MAAM,CAAC;IAC9Bd,GAAG,CAACkB,MAAM,CAACgI,IAAI,GAAGrI,KAAK,EAAEoI,GAAG,GAAGnI,MAAM,CAAC;IACtCd,GAAG,CAACoB,SAAS,CAAC,CAAC;IACfpB,GAAG,CAACgK,IAAI,CAAC,CAAC;EACd;AACJ,CAAC;AACD,MAAMyT,cAAc,GAAGA,CAACzd,GAAG,EAAEmb,MAAM,EAAEzS,KAAK,EAAEkB,GAAG,EAAEE,GAAG,KAAK;EACrD,MAAM;IAAEb,GAAG;IAAEC,IAAI;IAAEpI;EAAO,CAAC,GAAGqa,MAAM;EACpC,MAAM;IAAEuC,eAAe;IAAEC,eAAe;IAAEpE,eAAe;IAAEC,cAAc;IAAEE;EAAmB,CAAC,GAAGhR,KAAK;EACvG,MAAM0S,EAAE,GAAGxR,GAAG,IAAI,GAAG,GAAGqR,KAAK,CAAC;EAC9B,MAAMO,EAAE,GAAG1R,GAAG,IAAI,GAAG,GAAGmR,KAAK,CAAC;EAC9Bjb,GAAG,CAACiB,MAAM,CAACiI,IAAI,GAAGU,GAAG,EAAEX,GAAG,GAAGnI,MAAM,CAAC;EACpCd,GAAG,CAACmB,aAAa,CAAC+H,IAAI,GAAGkS,EAAE,EAAEnS,GAAG,GAAGnI,MAAM,EAAEoI,IAAI,EAAED,GAAG,GAAGnI,MAAM,GAAGsa,EAAE,EAAElS,IAAI,EAAED,GAAG,GAAGnI,MAAM,GAAG8I,GAAG,CAAC;EAC7F5J,GAAG,CAACkB,MAAM,CAACgI,IAAI,EAAED,GAAG,GAAGa,GAAG,CAAC;EAC3B9J,GAAG,CAACmB,aAAa,CAAC+H,IAAI,EAAED,GAAG,GAAGuS,EAAE,EAAEtS,IAAI,GAAGsS,EAAE,EAAEvS,GAAG,EAAEC,IAAI,GAAGY,GAAG,EAAEb,GAAG,CAAC;EAClEjJ,GAAG,CAACiN,WAAW,CAACyQ,eAAe,CAAC;EAChC1d,GAAG,CAAC8M,SAAS,CAACxM,IAAI,CAACwL,GAAG,CAACyN,eAAe,EAAEC,cAAc,EAAEE,iBAAiB,CAAC,GAAG,CAAC,CAAC;EAC/E,IAAIiE,eAAe,KAAK,QAAQ,EAAE;IAC9B3d,GAAG,CAAC+N,IAAI,CAACwL,eAAe,GAAG,CAAC,EAAE;MAAE9F,KAAK,EAAE8F,eAAe,GAAG;IAAI,CAAC,CAAC;EACnE,CAAC,MACI,IAAIoE,eAAe,KAAK,QAAQ,EAAE;IACnC3d,GAAG,CAAC+N,IAAI,CAACwL,eAAe,EAAE;MAAE9F,KAAK,EAAE8F,eAAe,GAAG;IAAI,CAAC,CAAC;EAC/D;EACAvZ,GAAG,CAACkN,MAAM,CAAC,CAAC;EACZlN,GAAG,CAACoc,MAAM,CAAC,CAAC;AAChB,CAAC;AACD,MAAMwB,mBAAmB,GAAI3d,IAAI,IAAKA,IAAI,CAAC2G,GAAG,KACzC3G,IAAI,CAAC2G,GAAG,CAAC4S,cAAc,IACpBvZ,IAAI,CAAC2G,GAAG,CAAC6S,gBAAgB,IACzBxZ,IAAI,CAAC2G,GAAG,CAAC8S,iBAAiB,IAC1BzZ,IAAI,CAAC2G,GAAG,CAAC2S,eAAe,CAAC;AACjC,MAAMsE,aAAa,GAAGA,CAAC7d,GAAG,EAAEC,IAAI,KAAK;EACjC,IAAI,CAACA,IAAI,CAAC2G,GAAG,EACT;EACJ,IAAI,CAACgX,mBAAmB,CAAC3d,IAAI,CAAC,EAC1B;EACJ,MAAM;IAAEY,KAAK;IAAEC,MAAM;IAAE0Y,cAAc,GAAG,CAAC;IAAED,eAAe,GAAG,CAAC;IAAEE,gBAAgB,GAAG,CAAC;IAAEC,iBAAiB,GAAG;EAAG,CAAC,GAAGzZ,IAAI,CAAC2G,GAAG;EACzH,MAAM;IAAEb,OAAO,GAAG,CAAC;IAAEmW,cAAc,GAAG,OAAO;IAAEC,cAAc,GAAG,OAAO;IAAEuB,eAAe,GAAG,OAAO;IAAEC,eAAe,GAAG,OAAO;IAAEf,gBAAgB,GAAG,OAAO;IAAEC,gBAAgB,GAAG,OAAO;IAAEO,iBAAiB,GAAG,OAAO;IAAEC,iBAAiB,GAAG;EAAS,CAAC,GAAGpd,IAAI,CAACyI,KAAK;EAC/P;EACA,MAAMS,mBAAmB,GAAGlJ,IAAI,CAACyI,KAAK,CAACS,mBAAmB,IAAI,CAAC;EAC/D;EACA,MAAMC,oBAAoB,GAAGnJ,IAAI,CAACyI,KAAK,CAACU,oBAAoB,IAAI,CAAC;EACjE;EACA,MAAME,sBAAsB,GAAGrJ,IAAI,CAACyI,KAAK,CAACY,sBAAsB,IAAI,CAAC;EACrE;EACA,MAAMD,uBAAuB,GAAGpJ,IAAI,CAACyI,KAAK,CAACW,uBAAuB,IAAI,CAAC;EACvE,MAAMX,KAAK,GAAG;IACVwT,cAAc;IACd1C,cAAc;IACd2C,cAAc;IACduB,eAAe;IACfnE,eAAe;IACfoE,eAAe;IACff,gBAAgB;IAChBnD,gBAAgB;IAChBoD,gBAAgB;IAChBO,iBAAiB;IACjB1D,iBAAiB;IACjB2D;EAAiB,CAAC;EACtB,MAAM9T,GAAG,GAAGjJ,IAAI,CAACkJ,GAAG,CAACJ,oBAAoB,EAAE,GAAG,GAAGvI,KAAK,EAAE,GAAG,GAAGC,MAAM,CAAC;EACrE,MAAMgJ,GAAG,GAAGxJ,IAAI,CAACkJ,GAAG,CAACL,mBAAmB,EAAE,GAAG,GAAGtI,KAAK,EAAE,GAAG,GAAGC,MAAM,CAAC;EACpE,MAAM4I,GAAG,GAAGpJ,IAAI,CAACkJ,GAAG,CAACH,uBAAuB,EAAE,GAAG,GAAGxI,KAAK,EAAE,GAAG,GAAGC,MAAM,CAAC;EACxE,MAAM8I,GAAG,GAAGtJ,IAAI,CAACkJ,GAAG,CAACF,sBAAsB,EAAE,GAAG,GAAGzI,KAAK,EAAE,GAAG,GAAGC,MAAM,CAAC;EACvEd,GAAG,CAACwD,IAAI,CAAC,CAAC;EACVxD,GAAG,CAACsN,aAAa,CAACvH,OAAO,CAAC;EAC1B,IAAIyT,cAAc,EAAE;IAChBxZ,GAAG,CAACwD,IAAI,CAAC,CAAC;IACV0X,aAAa,CAAClb,GAAG,EAAEC,IAAI,CAAC2G,GAAG,EAAE8B,KAAK,EAAEa,GAAG,EAAEO,GAAG,CAAC;IAC7CmS,aAAa,CAACjc,GAAG,EAAEC,IAAI,CAAC2G,GAAG,EAAE8B,KAAK,EAAEa,GAAG,EAAEO,GAAG,CAAC;IAC7C9J,GAAG,CAAC8E,OAAO,CAAC,CAAC;EACjB;EACA,IAAI2U,gBAAgB,EAAE;IAClBzZ,GAAG,CAACwD,IAAI,CAAC,CAAC;IACV6Y,eAAe,CAACrc,GAAG,EAAEC,IAAI,CAAC2G,GAAG,EAAE8B,KAAK,EAAEa,GAAG,EAAEG,GAAG,CAAC;IAC/CiT,eAAe,CAAC3c,GAAG,EAAEC,IAAI,CAAC2G,GAAG,EAAE8B,KAAK,EAAEa,GAAG,EAAEG,GAAG,CAAC;IAC/C1J,GAAG,CAAC8E,OAAO,CAAC,CAAC;EACjB;EACA,IAAI4U,iBAAiB,EAAE;IACnB1Z,GAAG,CAACwD,IAAI,CAAC,CAAC;IACVsZ,gBAAgB,CAAC9c,GAAG,EAAEC,IAAI,CAAC2G,GAAG,EAAE8B,KAAK,EAAEkB,GAAG,EAAEF,GAAG,CAAC;IAChDyT,gBAAgB,CAACnd,GAAG,EAAEC,IAAI,CAAC2G,GAAG,EAAE8B,KAAK,EAAEkB,GAAG,EAAEF,GAAG,CAAC;IAChD1J,GAAG,CAAC8E,OAAO,CAAC,CAAC;EACjB;EACA,IAAIyU,eAAe,EAAE;IACjBvZ,GAAG,CAACwD,IAAI,CAAC,CAAC;IACV8Z,cAAc,CAACtd,GAAG,EAAEC,IAAI,CAAC2G,GAAG,EAAE8B,KAAK,EAAEkB,GAAG,EAAEE,GAAG,CAAC;IAC9C2T,cAAc,CAACzd,GAAG,EAAEC,IAAI,CAAC2G,GAAG,EAAE8B,KAAK,EAAEkB,GAAG,EAAEE,GAAG,CAAC;IAC9C9J,GAAG,CAAC8E,OAAO,CAAC,CAAC;EACjB;EACA9E,GAAG,CAAC8E,OAAO,CAAC,CAAC;AACjB,CAAC;AAED,MAAMgZ,cAAc,GAAGA,CAAC9d,GAAG,EAAEC,IAAI,KAAK;EAClC,IAAI,CAACA,IAAI,CAAC2G,GAAG,EACT;EACJ,MAAM;IAAEqC,GAAG;IAAEC,IAAI;IAAErI,KAAK;IAAEC;EAAO,CAAC,GAAGb,IAAI,CAAC2G,GAAG;EAC7C,MAAMd,KAAK,GAAG8M,UAAU,CAAC3S,IAAI,CAACyI,KAAK,CAAC0L,eAAe,CAAC;EACpD,MAAM2J,WAAW,GAAGte,KAAK,CAACQ,IAAI,CAACyI,KAAK,EAAE3C,OAAO,CAAC,GAAG,CAAC,GAAG9F,IAAI,CAACyI,KAAK,CAAC3C,OAAO;EACvE,MAAMA,OAAO,GAAGzF,IAAI,CAACkJ,GAAG,CAAC1D,KAAK,CAACC,OAAO,EAAEgY,WAAW,CAAC;EACpD/d,GAAG,CACEiG,WAAW,CAACF,OAAO,CAAC,CACpBC,SAAS,CAACF,KAAK,CAACsE,KAAK,CAAC,CACtB+J,IAAI,CAACjL,IAAI,EAAED,GAAG,EAAEpI,KAAK,EAAEC,MAAM,CAAC,CAC9BoN,IAAI,CAAC,CAAC;AACf,CAAC;AACD,MAAM8P,gBAAgB,GAAGA,CAAChe,GAAG,EAAEC,IAAI,KAAK;EACpC,MAAMge,aAAa,GAAG,CAAC,CAAChe,IAAI,CAAC2G,GAAG,IAAI,CAAC,CAAC3G,IAAI,CAACyI,KAAK,EAAE0L,eAAe;EACjE,IAAI6J,aAAa,EAAE;IACfje,GAAG,CAACwD,IAAI,CAAC,CAAC;IACVwF,QAAQ,CAAChJ,GAAG,EAAEC,IAAI,CAAC;IACnB6d,cAAc,CAAC9d,GAAG,EAAEC,IAAI,CAAC;IACzBD,GAAG,CAAC8E,OAAO,CAAC,CAAC;EACjB;AACJ,CAAC;AAED,MAAMoZ,QAAQ,GAAI9T,KAAK,IAAK,OAAOA,KAAK,KAAK,QAAQ;AACrD,MAAM+T,OAAO,GAAI/T,KAAK,IAAK,MAAM,CAACmK,IAAI,CAACnK,KAAK,CAAC;AAC7C,MAAMgU,UAAU,GAAGA,CAACpe,GAAG,EAAEC,IAAI,EAAEiT,GAAG,KAAK;EACnC,IAAI,CAACA,GAAG,IAAI,CAACjT,IAAI,CAAC2G,GAAG,EACjB;EACJ,MAAMyX,IAAI,GAAGF,OAAO,CAACjL,GAAG,CAAC;EACzB,MAAMoL,MAAM,GAAGD,IAAI,GAAG,MAAM,GAAG,MAAM;EACrC,MAAMjU,KAAK,GAAGiU,IAAI,GAAGnL,GAAG,CAAC/O,KAAK,CAAC,CAAC,CAAC,GAAG+O,GAAG;EACvC,MAAM;IAAEjK,GAAG;IAAEC,IAAI;IAAErI,KAAK;IAAEC;EAAO,CAAC,GAAGb,IAAI,CAAC2G,GAAG;EAC7C5G,GAAG,CAACse,MAAM,CAAC,CAACpV,IAAI,EAAED,GAAG,EAAEpI,KAAK,EAAEC,MAAM,EAAEsJ,KAAK,CAAC;AAChD,CAAC;AACD,MAAMmU,OAAO,GAAGA,CAACve,GAAG,EAAEC,IAAI,KAAK;EAC3B,MAAME,KAAK,GAAGF,IAAI,CAACE,KAAK,IAAI,CAAC,CAAC;EAC9B,IAAI,KAAK,IAAIA,KAAK,IAAI+d,QAAQ,CAAC/d,KAAK,CAAC+S,GAAG,CAAC,EACrC,OAAOkL,UAAU,CAACpe,GAAG,EAAEC,IAAI,EAAEE,KAAK,CAAC+S,GAAG,CAAC;EAC3C,IAAI,MAAM,IAAI/S,KAAK,IAAI+d,QAAQ,CAAC/d,KAAK,CAAC2I,IAAI,CAAC,EACvC,OAAOsV,UAAU,CAACpe,GAAG,EAAEC,IAAI,EAAEE,KAAK,CAAC2I,IAAI,CAAC;AAChD,CAAC;AAED,MAAM0V,cAAc,GAAGA,CAACxe,GAAG,EAAEC,IAAI,KAAK;EAClC,IAAI,CAACA,IAAI,CAAC2G,GAAG,EACT;EACJ,IAAI,CAAC3G,IAAI,CAACE,KAAK,EACX;EACJ,IAAI,IAAI,IAAIF,IAAI,CAACE,KAAK,EAAE;IACpBH,GAAG,CAACye,mBAAmB,CAACxe,IAAI,CAACE,KAAK,CAAC0D,EAAE,EAAE,KAAK,EAAE,IAAI,EAAE5D,IAAI,CAAC2G,GAAG,CAACqC,GAAG,EAAE,IAAI,CAAC;EAC3E;AACJ,CAAC;AAED,MAAMyV,KAAK,GAAIvG,OAAO,IAAK;EACvB,MAAMwG,GAAG,GAAG;IAAE,GAAGxG;EAAQ,CAAC;EAC1B;EACAyG,MAAM,CAACC,OAAO,CAACF,GAAG,CAAC,CAACvX,OAAO,CAAE0X,IAAI,IAAK;IAClC,IAAI,CAACA,IAAI,CAAC,CAAC,CAAC,EAAE;MACV,OAAOH,GAAG,CAACG,IAAI,CAAC,CAAC,CAAC,CAAC;IACvB;EACJ,CAAC,CAAC;EACF,OAAOH,GAAG;AACd,CAAC;AACD,MAAMI,sBAAsB,GAAI9e,IAAI,IAAK;EACrC;EACA,OAAO;IACH+e,QAAQ,EAAE/e,IAAI,CAACE,KAAK,EAAE6e,QAAQ,IAAI,KAAK;IACvCC,QAAQ,EAAEhf,IAAI,CAACE,KAAK,EAAE8e,QAAQ,IAAI,KAAK;IACvCC,QAAQ,EAAEjf,IAAI,CAACE,KAAK,EAAE+e,QAAQ,IAAI,KAAK;IACvC9U,KAAK,EAAEnK,IAAI,CAACE,KAAK,EAAEiK,KAAK,IAAIpI,SAAS;IACrCmd,YAAY,EAAElf,IAAI,CAACE,KAAK,EAAEgf,YAAY,IAAInd;EAC9C,CAAC;AACL,CAAC;AACD,MAAMod,qBAAqB,GAAGA,CAACnf,IAAI,EAAEof,QAAQ,KAAK;EAC9C,OAAOX,KAAK,CAAC;IACT,GAAGK,sBAAsB,CAAC9e,IAAI,CAAC;IAC/Bqf,MAAM,EAAED,QAAQ,IAAIrd,SAAS;IAC7BgQ,KAAK,EAAE/R,IAAI,CAACE,KAAK,EAAE6R,KAAK,IAAI,MAAM;IAClCuN,SAAS,EAAEtf,IAAI,CAACE,KAAK,EAAEof,SAAS,IAAIvd,SAAS;IAC7Cwd,QAAQ,EAAEvf,IAAI,CAACE,KAAK,EAAEqf,QAAQ,IAAI,KAAK;IACvCC,OAAO,EAAExf,IAAI,CAACE,KAAK,EAAEsf,OAAO,IAAI,KAAK;IACrCC,MAAM,EAAEzf,IAAI,CAACE,KAAK,EAAEuf,MAAM,IAAI1d,SAAS;IACvC6D,QAAQ,EAAE5F,IAAI,CAACE,KAAK,EAAE0F,QAAQ,IAAI7D,SAAS;IAC3C2d,MAAM,EAAE1f,IAAI,CAACE,KAAK,EAAEyf,SAAS,IAAI5d;EACrC,CAAC,CAAC;AACN,CAAC;AACD,MAAM6d,8BAA8B,GAAI5f,IAAI,IAAK;EAC7C,OAAOye,KAAK,CAAC;IACT,GAAGK,sBAAsB,CAAC9e,IAAI,CAAC;IAC/B6f,IAAI,EAAE7f,IAAI,CAACE,KAAK,EAAE2f,IAAI,IAAI,KAAK;IAC/BC,IAAI,EAAE9f,IAAI,CAACE,KAAK,EAAE4f,IAAI,IAAI,KAAK;IAC/BC,WAAW,EAAE/f,IAAI,CAACE,KAAK,EAAE6f,WAAW,IAAI,KAAK;IAC7CP,OAAO,EAAExf,IAAI,CAACE,KAAK,EAAEsf,OAAO,IAAI,KAAK;IACrCQ,MAAM,EAAEhgB,IAAI,CAACE,KAAK,EAAE8f,MAAM,IAAI,CAAC,EAAE;EACrC,CAAC,CAAC;AACN,CAAC;AACD,MAAMC,aAAa,GAAGA,CAAClgB,GAAG,EAAEmgB,SAAS,EAAEtf,KAAK,EAAEC,MAAM,KAAK;EACrD,MAAMsf,UAAU,GAAGpgB,GAAG,CAAC8D,GAAG,CAAC;IACvBuc,IAAI,EAAE,SAAS;IACfC,OAAO,EAAE,MAAM;IACfC,IAAI,EAAE,CAAC,CAAC,EAAE,CAAC,EAAE1f,KAAK,EAAEC,MAAM,CAAC;IAC3B0f,SAAS,EAAE;MACPC,OAAO,EAAE,CAAC,KAAK,EAAE,MAAM,EAAE,QAAQ,EAAE,QAAQ,EAAE,QAAQ,CAAC;MACtDC,IAAI,EAAE;QACFC,IAAI,EAAE3gB,GAAG,CAAC4gB,SAAS,CAACjd,KAAK,CAACgd;MAC9B;IACJ;EACJ,CAAC,CAAC;EACFP,UAAU,CAACS,WAAW,CAAC,CAAC;EACxBT,UAAU,CAACU,KAAK,CAAC,qBAAqBhgB,MAAM,GAAG,GAAG,YAAYD,KAAK,GAAG,IAAI,IAAIC,MAAM,GAAG,CAAC,QAAQqf,SAAS,kBAAkB,CAAC;EAC5HC,UAAU,CAACW,GAAG,CAAC,IAAI,CAAC;EACpB,OAAOX,UAAU;AACrB,CAAC;AACD,MAAMY,oBAAoB,GAAGA,CAAChhB,GAAG,EAAEC,IAAI,EAAEof,QAAQ,KAAK;EAClD,MAAM;IAAExe,KAAK;IAAEC;EAAO,CAAC,GAAGb,IAAI,CAAC2G,GAAG,IAAI,CAAC,CAAC;EACxC,MAAMqa,QAAQ,GAAGhhB,IAAI,CAACE,KAAK,EAAE+gB,OAAO,IAAI,KAAK;EAC7C,MAAMC,SAAS,GAAGlhB,IAAI,CAACE,KAAK,EAAEihB,QAAQ,IAAI,KAAK;EAC/C,MAAMC,KAAK,GAAGphB,IAAI,CAACE,KAAK,EAAEkhB,KAAK,IAAI,KAAK;EACxC,IAAI,CAACzC,MAAM,CAAC0C,SAAS,CAACC,cAAc,CAACC,IAAI,CAACxhB,GAAG,CAAC4gB,SAAS,CAACjd,KAAK,EAAE,MAAM,CAAC,EAAE;IACpE,MAAMG,GAAG,GAAG9D,GAAG,CAAC8D,GAAG,CAAC;MAChBuc,IAAI,EAAE,MAAM;MACZC,OAAO,EAAE,OAAO;MAChBmB,QAAQ,EAAE;IACd,CAAC,CAAC;IACFzhB,GAAG,CAAC4gB,SAAS,CAACjd,KAAK,CAACgd,IAAI,GAAG7c,GAAG;IAC9BA,GAAG,CAACid,GAAG,CAAC,IAAI,CAAC;EACjB;EACA,MAAMW,gBAAgB,GAAG;IACrB,CAACT,QAAQ,GAAGf,aAAa,CAAClgB,GAAG,EAAEqhB,KAAK,GAAG,GAAG,GAAG,GAAG,EAAExgB,KAAK,EAAEC,MAAM,CAAC;IAChE,CAACqgB,SAAS,GAAGjB,aAAa,CAAClgB,GAAG,EAAEqhB,KAAK,GAAG,GAAG,GAAG,GAAG,EAAExgB,KAAK,EAAEC,MAAM;EACpE,CAAC;EACD,OAAO4d,KAAK,CAAC;IACT,GAAGK,sBAAsB,CAAC9e,IAAI,CAAC;IAC/BmU,eAAe,EAAEnU,IAAI,CAACE,KAAK,EAAEiU,eAAe,IAAIpS,SAAS;IACzD2f,WAAW,EAAE1hB,IAAI,CAACE,KAAK,EAAEwhB,WAAW,IAAI3f,SAAS;IACjDsd,MAAM,EAAED,QAAQ,IAAIrd,SAAS;IAC7BoI,KAAK,EAAE,IAAInK,IAAI,CAACE,KAAK,EAAEyhB,OAAO,KAAK,IAAI,GAAGX,QAAQ,GAAGE,SAAS,EAAE;IAChEhC,YAAY,EAAE,IAAIlf,IAAI,CAACE,KAAK,EAAEyhB,OAAO,KAAK,IAAI,GAAGX,QAAQ,GAAGE,SAAS,EAAE;IACvEU,EAAE,EAAE5hB,IAAI,CAACE,KAAK,EAAEyhB,OAAO,KAAK,IAAI,GAAGX,QAAQ,GAAGE,SAAS;IACvDW,EAAE,EAAE;MAAEC,CAAC,EAAEL,gBAAgB;MAAEM,CAAC,EAAEN;IAAiB;EACnD,CAAC,CAAC;AACN,CAAC;AAED,MAAMO,eAAe,GAAGA,CAACjiB,GAAG,EAAEC,IAAI,EAAEkY,OAAO,KAAK;EAC5C,IAAI,CAAClY,IAAI,CAAC2G,GAAG,EACT;EACJ,MAAM;IAAEqC,GAAG;IAAEC,IAAI;IAAErI,KAAK;IAAEC;EAAO,CAAC,GAAGb,IAAI,CAAC2G,GAAG;EAC7C;EACA,MAAMsb,IAAI,GAAGjiB,IAAI,CAACE,KAAK,EAAE+hB,IAAI,IAAI,EAAE;EACnC,MAAMC,eAAe,GAAGhK,OAAO,CAACiK,SAAS,EAAEC,EAAE,CAAC,CAAC,CAAC;EAChD,IAAI,CAACriB,GAAG,CAACsiB,KAAK,CAAC7Z,IAAI,CAAC8Z,QAAQ,EAAE;IAC1BviB,GAAG,CAACwiB,QAAQ,CAAC,CAAC;EAClB;EACAxiB,GAAG,CAACyiB,QAAQ,CAACP,IAAI,EAAEhZ,IAAI,EAAED,GAAG,EAAEpI,KAAK,EAAEC,MAAM,EAAEse,qBAAqB,CAACnf,IAAI,EAAEkiB,eAAe,CAAC,CAAC;AAC9F,CAAC;AAED,MAAMO,YAAY,GAAGA,CAAC1iB,GAAG,EAAEC,IAAI,KAAK;EAChC,IAAI,CAACA,IAAI,CAAC2G,GAAG,EACT;EACJ,MAAM;IAAEqC,GAAG;IAAEC,IAAI;IAAErI,KAAK;IAAEC;EAAO,CAAC,GAAGb,IAAI,CAAC2G,GAAG;EAC7C;EACA,MAAMsb,IAAI,GAAGjiB,IAAI,CAACE,KAAK,EAAE+hB,IAAI,IAAI,EAAE;EACnC,IAAI,CAACliB,GAAG,CAACsiB,KAAK,CAAC7Z,IAAI,CAAC8Z,QAAQ,EAAE;IAC1BviB,GAAG,CAACwiB,QAAQ,CAAC,CAAC;EAClB;EACAxiB,GAAG,CAAC2iB,SAAS,CAACT,IAAI,EAAEhZ,IAAI,EAAED,GAAG,EAAEpI,KAAK,EAAEC,MAAM,EAAE+e,8BAA8B,CAAC5f,IAAI,CAAC,CAAC;AACvF,CAAC;AAED,MAAM2iB,cAAc,GAAGA,CAAC5iB,GAAG,EAAEC,IAAI,EAAEkY,OAAO,KAAK;EAC3C,MAAM+J,IAAI,GAAGjiB,IAAI,CAACE,KAAK,EAAE+hB,IAAI,IAAI,EAAE;EACnC,IAAI,CAACliB,GAAG,CAACsiB,KAAK,CAAC7Z,IAAI,CAAC8Z,QAAQ,EAAE;IAC1BviB,GAAG,CAACwiB,QAAQ,CAAC,CAAC;EAClB;EACA,MAAMK,SAAS,GAAG7iB,GAAG,CAAC6iB,SAAS,CAACX,IAAI,CAAC;EACrC,MAAMY,MAAM,GAAG3K,OAAO;EACtB,IAAI,CAAC2K,MAAM,CAACV,SAAS,EAAE;IACnBU,MAAM,CAACV,SAAS,GAAG,CAACS,SAAS,CAAC;EAClC,CAAC,MACI;IACDC,MAAM,CAACV,SAAS,CAAC5d,IAAI,CAACqe,SAAS,CAAC;EACpC;AACJ,CAAC;AACD,MAAME,eAAe,GAAGA,CAACC,IAAI,EAAEC,KAAK,EAAE9K,OAAO,KAAK;EAC9CA,OAAO,CAACiK,SAAS,CAACc,GAAG,CAAC,CAAC;AAC3B,CAAC;AAED,MAAMC,UAAU,GAAGA,CAACnjB,GAAG,EAAEC,IAAI,KAAK;EAC9B,IAAI,CAACA,IAAI,CAAC2G,GAAG,EACT;EACJ,MAAM;IAAEqC,GAAG;IAAEC,IAAI;IAAErI,KAAK;IAAEC;EAAO,CAAC,GAAGb,IAAI,CAAC2G,GAAG,IAAI,CAAC,CAAC;EACnD;EACA,MAAMsb,IAAI,GAAI,MAAM,IAAIjiB,IAAI,CAACE,KAAK,GAAGF,IAAI,CAACE,KAAK,CAAC+hB,IAAI,IAAI,EAAE,GAAG,EAAG;EAChE,IAAI,CAACliB,GAAG,CAACsiB,KAAK,CAAC7Z,IAAI,CAAC8Z,QAAQ,EAAE;IAC1BviB,GAAG,CAACwiB,QAAQ,CAAC,CAAC;EAClB;EACAxiB,GAAG,CAACojB,QAAQ,CAAClB,IAAI,EAAEhZ,IAAI,EAAED,GAAG,EAAEpI,KAAK,EAAEC,MAAM,EAAE+e,8BAA8B,CAAC5f,IAAI,CAAC,CAAC;AACtF,CAAC;AAED,MAAMojB,cAAc,GAAGA,CAACrjB,GAAG,EAAEC,IAAI,EAAEkY,OAAO,KAAK;EAC3C,IAAI,CAAClY,IAAI,CAAC2G,GAAG,EACT;EACJ,MAAM;IAAEqC,GAAG;IAAEC,IAAI;IAAErI,KAAK;IAAEC;EAAO,CAAC,GAAGb,IAAI,CAAC2G,GAAG;EAC7C;EACA,MAAMsb,IAAI,GAAGjiB,IAAI,CAACE,KAAK,EAAE+hB,IAAI,IAAI,EAAE;EACnC,MAAMC,eAAe,GAAGhK,OAAO,CAACiK,SAAS,EAAEC,EAAE,CAAC,CAAC,CAAC;EAChD,IAAI,CAACriB,GAAG,CAACsiB,KAAK,CAAC7Z,IAAI,CAAC8Z,QAAQ,EAAE;IAC1BviB,GAAG,CAACwiB,QAAQ,CAAC,CAAC;EAClB;EACAxiB,GAAG,CAACsjB,YAAY,CAACpB,IAAI,EAAEhZ,IAAI,EAAED,GAAG,EAAEpI,KAAK,EAAEC,MAAM,EAAEkgB,oBAAoB,CAAChhB,GAAG,EAAEC,IAAI,EAAEkiB,eAAe,CAAC,CAAC;AACtG,CAAC;AAED,MAAMoB,eAAe,GAAItjB,IAAI,IAAKA,IAAI,CAACiG,IAAI,KAAK1G,CAAC,CAAC4R,IAAI,IAAInR,IAAI,CAACiG,IAAI,KAAK1G,CAAC,CAACgkB,GAAG;AAC7E,MAAMC,cAAc,GAAGA,CAACzjB,GAAG,EAAEC,IAAI,EAAEkY,OAAO,KAAK;EAC3CnY,GAAG,CAACwD,IAAI,CAAC,CAAC;EACV,IAAIvD,IAAI,CAAC2G,GAAG,EAAE;IACV5G,GAAG,CAACuG,SAAS,CAACtG,IAAI,CAAC2G,GAAG,CAACsC,IAAI,EAAEjJ,IAAI,CAAC2G,GAAG,CAACqC,GAAG,CAAC;EAC9C;EACA,MAAM3B,QAAQ,GAAGrH,IAAI,CAACqH,QAAQ,IAAI,EAAE;EACpC,MAAMoc,WAAW,GAAIhS,KAAK,IAAKiS,UAAU,CAAC3jB,GAAG,EAAE0R,KAAK,EAAEyG,OAAO,CAAC;EAC9D7Q,QAAQ,CAACF,OAAO,CAACsc,WAAW,CAAC;EAC7B1jB,GAAG,CAAC8E,OAAO,CAAC,CAAC;AACjB,CAAC;AACD,MAAM8e,SAAS,GAAG;EACd,CAACpkB,CAAC,CAAC4R,IAAI,GAAGoE,UAAU;EACpB,CAAChW,CAAC,CAACqkB,IAAI,GAAG1N,UAAU;EACpB,CAAC3W,CAAC,CAAC6R,KAAK,GAAG6H,WAAW;EACtB,CAAC1Z,CAAC,CAACskB,QAAQ,GAAGlB,cAAc;EAC5B,CAACpjB,CAAC,CAACukB,SAAS,GAAG9B,eAAe;EAC9B,CAACziB,CAAC,CAACwkB,MAAM,GAAGtB,YAAY;EACxB,CAACljB,CAAC,CAACykB,QAAQ,GAAGZ,cAAc;EAC5B,CAAC7jB,CAAC,CAAC0kB,IAAI,GAAGf,UAAU;EACpB,CAAC3jB,CAAC,CAAC2kB,MAAM,GAAGtJ,YAAY;EACxB,CAACrb,CAAC,CAACgkB,GAAG,GAAG9Q,SAAS;EAClB,CAAClT,CAAC,CAAC4kB,IAAI,GAAG7F;AACd,CAAC;AACD,MAAM8F,UAAU,GAAG;EACf,CAAC7kB,CAAC,CAACskB,QAAQ,GAAGf;AAClB,CAAC;AACD,MAAMY,UAAU,GAAGA,CAAC3jB,GAAG,EAAEC,IAAI,EAAEkY,OAAO,KAAK;EACvC,MAAMmM,cAAc,GAAGrkB,IAAI,CAACyI,KAAK,EAAE6b,QAAQ,KAAK,QAAQ;EACxD,MAAMC,oBAAoB,GAAGjB,eAAe,CAACtjB,IAAI,CAAC;EAClD,IAAIA,IAAI,CAACiG,IAAI,KAAK1G,CAAC,CAACilB,IAAI,EACpB5O,UAAU,CAAC7V,GAAG,EAAEC,IAAI,CAAC;EACzBD,GAAG,CAACwD,IAAI,CAAC,CAAC;EACV,IAAI8gB,cAAc,EACdtb,QAAQ,CAAChJ,GAAG,EAAEC,IAAI,CAAC;EACvBkL,oBAAoB,CAACnL,GAAG,EAAEC,IAAI,CAAC;EAC/B+d,gBAAgB,CAAChe,GAAG,EAAEC,IAAI,CAAC;EAC3B4d,aAAa,CAAC7d,GAAG,EAAEC,IAAI,CAAC;EACxB,MAAMsR,QAAQ,GAAGqS,SAAS,CAAC3jB,IAAI,CAACiG,IAAI,CAAC;EACrC,IAAIqL,QAAQ,EACRA,QAAQ,CAACvR,GAAG,EAAEC,IAAI,EAAEkY,OAAO,CAAC;EAChC,IAAIqM,oBAAoB,EACpBf,cAAc,CAACzjB,GAAG,EAAEC,IAAI,EAAEkY,OAAO,CAAC;EACtC,MAAMuM,SAAS,GAAGL,UAAU,CAACpkB,IAAI,CAACiG,IAAI,CAAC;EACvC,IAAIwe,SAAS,EACTA,SAAS,CAAC1kB,GAAG,EAAEC,IAAI,EAAEkY,OAAO,CAAC;EACjCqG,cAAc,CAACxe,GAAG,EAAEC,IAAI,CAAC;EACzBsa,WAAW,CAACva,GAAG,EAAEC,IAAI,CAAC;EACtBD,GAAG,CAAC8E,OAAO,CAAC,CAAC;AACjB,CAAC;AAED,MAAM6f,eAAe,GAAGA,CAAC3kB,GAAG,EAAEC,IAAI,EAAE2kB,UAAU,EAAEC,QAAQ,KAAK;EACzD,IAAI,CAAC5kB,IAAI,CAAC2G,GAAG,EACT;EACJ,IAAI,CAAC3G,IAAI,CAACE,KAAK,EACX;EACJ,IAAI,UAAU,IAAIF,IAAI,CAACE,KAAK,IAAIF,IAAI,CAACE,KAAK,CAAC2kB,QAAQ,EAAE;IACjD,MAAMA,QAAQ,GAAG7kB,IAAI,CAACE,KAAK,CAAC2kB,QAAQ;IACpC,MAAM;MAAEC,KAAK;MAAEzF,MAAM;MAAE0F,QAAQ;MAAEC,IAAI;MAAE3R;IAAI,CAAC,GAAGwR,QAAQ;IACvD,MAAMI,OAAO,GAAGL,QAAQ,CAACvF,MAAM,CAAC,IAAItf,GAAG,CAACklB,OAAO;IAC/C,MAAMjc,GAAG,GAAG6b,QAAQ,CAAC7b,GAAG,IAAIhJ,IAAI,CAAC2G,GAAG,CAACqC,GAAG;IACxC,MAAMC,IAAI,GAAG4b,QAAQ,CAAC5b,IAAI,IAAIjJ,IAAI,CAAC2G,GAAG,CAACsC,IAAI;IAC3C,MAAMic,QAAQ,GAAGD,OAAO,CAACE,OAAO,CAACL,KAAK,EAAE;MACpCH,UAAU;MACVI,QAAQ;MACR/b,GAAG;MACHC,IAAI;MACJ+b,IAAI;MACJ3R;IACJ,CAAC,CAAC;IACFuR,QAAQ,CAACC,QAAQ,CAAChhB,GAAG,CAAC,GAAGqhB,QAAQ;EACrC;EACA,IAAI,CAACllB,IAAI,CAACqH,QAAQ,EACd;EACJrH,IAAI,CAACqH,QAAQ,CAACF,OAAO,CAAEsK,KAAK,IAAKiT,eAAe,CAAC3kB,GAAG,EAAE0R,KAAK,EAAEkT,UAAU,EAAEC,QAAQ,CAAC,CAAC;AACvF,CAAC;AACD,MAAMQ,YAAY,GAAGA,CAACrlB,GAAG,EAAEslB,IAAI,KAAK;EAChC,MAAMT,QAAQ,GAAG,CAAC,CAAC;EACnB,MAAMU,KAAK,GAAGD,IAAI,CAAChe,QAAQ,IAAI,EAAE;EACjCie,KAAK,CAACne,OAAO,CAAC,CAAC1D,IAAI,EAAEL,CAAC,KAAK;IACvBshB,eAAe,CAAC3kB,GAAG,EAAE0D,IAAI,EAAEL,CAAC,EAAEwhB,QAAQ,CAAC;EAC3C,CAAC,CAAC;AACN,CAAC;AAED,MAAMW,MAAM,GAAGA,CAACxlB,GAAG,EAAEylB,GAAG,KAAK;EACzB,MAAMF,KAAK,GAAGE,GAAG,CAACne,QAAQ,IAAI,EAAE;EAChC,MAAM6Q,OAAO,GAAG;IAAEM,UAAU,EAAE,IAAIC,GAAG,CAAC,CAAC;IAAE0J,SAAS,EAAE;EAAG,CAAC;EACxDmD,KAAK,CAACne,OAAO,CAAE1D,IAAI,IAAKigB,UAAU,CAAC3jB,GAAG,EAAE0D,IAAI,EAAEyU,OAAO,CAAC,CAAC;EACvDkN,YAAY,CAACrlB,GAAG,EAAEylB,GAAG,CAAC;EACtBzlB,GAAG,CAAC+gB,GAAG,CAAC,CAAC;EACT,OAAO/gB,GAAG;AACd,CAAC;AAED,SAASwlB,MAAM,IAAIE,OAAO","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}