{"ast":null,"code":"import { DecodeStream as $6uUbQ$DecodeStream, Struct as $6uUbQ$Struct, String as $6uUbQ$String, uint32 as $6uUbQ$uint32, Pointer as $6uUbQ$Pointer, uint16 as $6uUbQ$uint16, Array as $6uUbQ$Array, VoidPointer as $6uUbQ$VoidPointer, int16 as $6uUbQ$int16, uint24 as $6uUbQ$uint24, uint8 as $6uUbQ$uint8, VersionedStruct as $6uUbQ$VersionedStruct, LazyArray as $6uUbQ$LazyArray, Reserved as $6uUbQ$Reserved, int32 as $6uUbQ$int32, Bitfield as $6uUbQ$Bitfield, fixed32 as $6uUbQ$fixed32, Buffer as $6uUbQ$Buffer, Number as $6uUbQ$Number, resolveLength as $6uUbQ$resolveLength, fixed16 as $6uUbQ$fixed16, PropertyDescriptor as $6uUbQ$PropertyDescriptor, Fixed as $6uUbQ$Fixed, int8 as $6uUbQ$int8, Optional as $6uUbQ$Optional, EncodeStream as $6uUbQ$EncodeStream } from \"restructure\";\nimport { _ as $6uUbQ$_ } from \"@swc/helpers/_/_define_property\";\nimport { _ as $6uUbQ$_1 } from \"@swc/helpers/_/_ts_decorate\";\nimport $6uUbQ$fastdeepequal from \"fast-deep-equal\";\nimport { getCombiningClass as $6uUbQ$getCombiningClass, getScript as $6uUbQ$getScript, isDigit as $6uUbQ$isDigit, getCategory as $6uUbQ$getCategory, isMark as $6uUbQ$isMark } from \"unicode-properties\";\nimport $6uUbQ$unicodetrie from \"unicode-trie\";\nimport $6uUbQ$dfa from \"dfa\";\nimport $6uUbQ$clone from \"clone\";\nimport $6uUbQ$tinyinflate from \"tiny-inflate\";\nimport $6uUbQ$brotlidecompressjs from \"brotli/decompress.js\";\nfunction $parcel$export(e, n, v, s) {\n  Object.defineProperty(e, n, {\n    get: v,\n    set: s,\n    enumerable: true,\n    configurable: true\n  });\n}\nfunction $parcel$interopDefault(a) {\n  return a && a.__esModule ? a.default : a;\n}\nvar $d636bc798e7178db$exports = {};\n$parcel$export($d636bc798e7178db$exports, \"logErrors\", () => $d636bc798e7178db$export$bd5c5d8b8dcafd78);\n$parcel$export($d636bc798e7178db$exports, \"registerFormat\", () => $d636bc798e7178db$export$36b2f24e97d43be);\n$parcel$export($d636bc798e7178db$exports, \"create\", () => $d636bc798e7178db$export$185802fd694ee1f5);\n$parcel$export($d636bc798e7178db$exports, \"defaultLanguage\", () => $d636bc798e7178db$export$42940898df819940);\n$parcel$export($d636bc798e7178db$exports, \"setDefaultLanguage\", () => $d636bc798e7178db$export$5157e7780d44cc36);\nlet $d636bc798e7178db$export$bd5c5d8b8dcafd78 = false;\nlet $d636bc798e7178db$var$formats = [];\nfunction $d636bc798e7178db$export$36b2f24e97d43be(format) {\n  $d636bc798e7178db$var$formats.push(format);\n}\nfunction $d636bc798e7178db$export$185802fd694ee1f5(buffer, postscriptName) {\n  for (let i = 0; i < $d636bc798e7178db$var$formats.length; i++) {\n    let format = $d636bc798e7178db$var$formats[i];\n    if (format.probe(buffer)) {\n      let font = new format(new (0, $6uUbQ$DecodeStream)(buffer));\n      if (postscriptName) return font.getFont(postscriptName);\n      return font;\n    }\n  }\n  throw new Error('Unknown font format');\n}\nlet $d636bc798e7178db$export$42940898df819940 = 'en';\nfunction $d636bc798e7178db$export$5157e7780d44cc36() {\n  let lang = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'en';\n  $d636bc798e7178db$export$42940898df819940 = lang;\n}\n\n/**\n * This decorator caches the results of a getter or method such that\n * the results are lazily computed once, and then cached.\n * @private\n */\nfunction $e71565f2ce09cb6b$export$69a3209f1a06c04d(target, key, descriptor) {\n  if (descriptor.get) {\n    let get = descriptor.get;\n    descriptor.get = function () {\n      let value = get.call(this);\n      Object.defineProperty(this, key, {\n        value: value\n      });\n      return value;\n    };\n  } else if (typeof descriptor.value === 'function') {\n    let fn = descriptor.value;\n    return {\n      get() {\n        let cache = new Map();\n        function memoized() {\n          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n            args[_key] = arguments[_key];\n          }\n          let key = args.length > 0 ? args[0] : 'value';\n          if (cache.has(key)) return cache.get(key);\n          let result = fn.apply(this, args);\n          cache.set(key, result);\n          return result;\n        }\n        Object.defineProperty(this, key, {\n          value: memoized\n        });\n        return memoized;\n      }\n    };\n  }\n}\nlet $26a62205ad06574e$var$SubHeader = new $6uUbQ$Struct({\n  firstCode: $6uUbQ$uint16,\n  entryCount: $6uUbQ$uint16,\n  idDelta: $6uUbQ$int16,\n  idRangeOffset: $6uUbQ$uint16\n});\nlet $26a62205ad06574e$var$CmapGroup = new $6uUbQ$Struct({\n  startCharCode: $6uUbQ$uint32,\n  endCharCode: $6uUbQ$uint32,\n  glyphID: $6uUbQ$uint32\n});\nlet $26a62205ad06574e$var$UnicodeValueRange = new $6uUbQ$Struct({\n  startUnicodeValue: $6uUbQ$uint24,\n  additionalCount: $6uUbQ$uint8\n});\nlet $26a62205ad06574e$var$UVSMapping = new $6uUbQ$Struct({\n  unicodeValue: $6uUbQ$uint24,\n  glyphID: $6uUbQ$uint16\n});\nlet $26a62205ad06574e$var$DefaultUVS = new $6uUbQ$Array($26a62205ad06574e$var$UnicodeValueRange, $6uUbQ$uint32);\nlet $26a62205ad06574e$var$NonDefaultUVS = new $6uUbQ$Array($26a62205ad06574e$var$UVSMapping, $6uUbQ$uint32);\nlet $26a62205ad06574e$var$VarSelectorRecord = new $6uUbQ$Struct({\n  varSelector: $6uUbQ$uint24,\n  defaultUVS: new $6uUbQ$Pointer($6uUbQ$uint32, $26a62205ad06574e$var$DefaultUVS, {\n    type: 'parent'\n  }),\n  nonDefaultUVS: new $6uUbQ$Pointer($6uUbQ$uint32, $26a62205ad06574e$var$NonDefaultUVS, {\n    type: 'parent'\n  })\n});\nlet $26a62205ad06574e$var$CmapSubtable = new $6uUbQ$VersionedStruct($6uUbQ$uint16, {\n  0: {\n    length: $6uUbQ$uint16,\n    language: $6uUbQ$uint16,\n    codeMap: new $6uUbQ$LazyArray($6uUbQ$uint8, 256)\n  },\n  2: {\n    length: $6uUbQ$uint16,\n    language: $6uUbQ$uint16,\n    subHeaderKeys: new $6uUbQ$Array($6uUbQ$uint16, 256),\n    subHeaderCount: t => Math.max.apply(Math, t.subHeaderKeys),\n    subHeaders: new $6uUbQ$LazyArray($26a62205ad06574e$var$SubHeader, 'subHeaderCount'),\n    glyphIndexArray: new $6uUbQ$LazyArray($6uUbQ$uint16, 'subHeaderCount')\n  },\n  4: {\n    length: $6uUbQ$uint16,\n    language: $6uUbQ$uint16,\n    segCountX2: $6uUbQ$uint16,\n    segCount: t => t.segCountX2 >> 1,\n    searchRange: $6uUbQ$uint16,\n    entrySelector: $6uUbQ$uint16,\n    rangeShift: $6uUbQ$uint16,\n    endCode: new $6uUbQ$LazyArray($6uUbQ$uint16, 'segCount'),\n    reservedPad: new $6uUbQ$Reserved($6uUbQ$uint16),\n    startCode: new $6uUbQ$LazyArray($6uUbQ$uint16, 'segCount'),\n    idDelta: new $6uUbQ$LazyArray($6uUbQ$int16, 'segCount'),\n    idRangeOffset: new $6uUbQ$LazyArray($6uUbQ$uint16, 'segCount'),\n    glyphIndexArray: new $6uUbQ$LazyArray($6uUbQ$uint16, t => (t.length - t._currentOffset) / 2)\n  },\n  6: {\n    length: $6uUbQ$uint16,\n    language: $6uUbQ$uint16,\n    firstCode: $6uUbQ$uint16,\n    entryCount: $6uUbQ$uint16,\n    glyphIndices: new $6uUbQ$LazyArray($6uUbQ$uint16, 'entryCount')\n  },\n  8: {\n    reserved: new $6uUbQ$Reserved($6uUbQ$uint16),\n    length: $6uUbQ$uint32,\n    language: $6uUbQ$uint16,\n    is32: new $6uUbQ$LazyArray($6uUbQ$uint8, 8192),\n    nGroups: $6uUbQ$uint32,\n    groups: new $6uUbQ$LazyArray($26a62205ad06574e$var$CmapGroup, 'nGroups')\n  },\n  10: {\n    reserved: new $6uUbQ$Reserved($6uUbQ$uint16),\n    length: $6uUbQ$uint32,\n    language: $6uUbQ$uint32,\n    firstCode: $6uUbQ$uint32,\n    entryCount: $6uUbQ$uint32,\n    glyphIndices: new $6uUbQ$LazyArray($6uUbQ$uint16, 'numChars')\n  },\n  12: {\n    reserved: new $6uUbQ$Reserved($6uUbQ$uint16),\n    length: $6uUbQ$uint32,\n    language: $6uUbQ$uint32,\n    nGroups: $6uUbQ$uint32,\n    groups: new $6uUbQ$LazyArray($26a62205ad06574e$var$CmapGroup, 'nGroups')\n  },\n  13: {\n    reserved: new $6uUbQ$Reserved($6uUbQ$uint16),\n    length: $6uUbQ$uint32,\n    language: $6uUbQ$uint32,\n    nGroups: $6uUbQ$uint32,\n    groups: new $6uUbQ$LazyArray($26a62205ad06574e$var$CmapGroup, 'nGroups')\n  },\n  14: {\n    length: $6uUbQ$uint32,\n    numRecords: $6uUbQ$uint32,\n    varSelectors: new $6uUbQ$LazyArray($26a62205ad06574e$var$VarSelectorRecord, 'numRecords')\n  }\n});\nlet $26a62205ad06574e$var$CmapEntry = new $6uUbQ$Struct({\n  platformID: $6uUbQ$uint16,\n  encodingID: $6uUbQ$uint16,\n  table: new $6uUbQ$Pointer($6uUbQ$uint32, $26a62205ad06574e$var$CmapSubtable, {\n    type: 'parent',\n    lazy: true\n  })\n});\nvar\n// character to glyph mapping\n$26a62205ad06574e$export$2e2bcd8739ae039 = new $6uUbQ$Struct({\n  version: $6uUbQ$uint16,\n  numSubtables: $6uUbQ$uint16,\n  tables: new $6uUbQ$Array($26a62205ad06574e$var$CmapEntry, 'numSubtables')\n});\nvar\n// font header\n$f2612a29f92ac062$export$2e2bcd8739ae039 = new $6uUbQ$Struct({\n  version: $6uUbQ$int32,\n  revision: $6uUbQ$int32,\n  checkSumAdjustment: $6uUbQ$uint32,\n  magicNumber: $6uUbQ$uint32,\n  flags: $6uUbQ$uint16,\n  unitsPerEm: $6uUbQ$uint16,\n  created: new $6uUbQ$Array($6uUbQ$int32, 2),\n  modified: new $6uUbQ$Array($6uUbQ$int32, 2),\n  xMin: $6uUbQ$int16,\n  yMin: $6uUbQ$int16,\n  xMax: $6uUbQ$int16,\n  yMax: $6uUbQ$int16,\n  macStyle: new $6uUbQ$Bitfield($6uUbQ$uint16, ['bold', 'italic', 'underline', 'outline', 'shadow', 'condensed', 'extended']),\n  lowestRecPPEM: $6uUbQ$uint16,\n  fontDirectionHint: $6uUbQ$int16,\n  indexToLocFormat: $6uUbQ$int16,\n  glyphDataFormat: $6uUbQ$int16 // 0 for current format\n});\nvar\n// horizontal header\n$2c179dd593583073$export$2e2bcd8739ae039 = new $6uUbQ$Struct({\n  version: $6uUbQ$int32,\n  ascent: $6uUbQ$int16,\n  descent: $6uUbQ$int16,\n  lineGap: $6uUbQ$int16,\n  advanceWidthMax: $6uUbQ$uint16,\n  minLeftSideBearing: $6uUbQ$int16,\n  minRightSideBearing: $6uUbQ$int16,\n  xMaxExtent: $6uUbQ$int16,\n  caretSlopeRise: $6uUbQ$int16,\n  caretSlopeRun: $6uUbQ$int16,\n  caretOffset: $6uUbQ$int16,\n  reserved: new $6uUbQ$Reserved($6uUbQ$int16, 4),\n  metricDataFormat: $6uUbQ$int16,\n  numberOfMetrics: $6uUbQ$uint16 // Number of advance widths in 'hmtx' table\n});\nlet $bdc9060542264b85$var$HmtxEntry = new $6uUbQ$Struct({\n  advance: $6uUbQ$uint16,\n  bearing: $6uUbQ$int16\n});\nvar $bdc9060542264b85$export$2e2bcd8739ae039 = new $6uUbQ$Struct({\n  metrics: new $6uUbQ$LazyArray($bdc9060542264b85$var$HmtxEntry, t => t.parent.hhea.numberOfMetrics),\n  bearings: new $6uUbQ$LazyArray($6uUbQ$int16, t => t.parent.maxp.numGlyphs - t.parent.hhea.numberOfMetrics)\n});\nvar\n// maxiumum profile\n$dbf51cb3d3fe409d$export$2e2bcd8739ae039 = new $6uUbQ$Struct({\n  version: $6uUbQ$int32,\n  numGlyphs: $6uUbQ$uint16,\n  maxPoints: $6uUbQ$uint16,\n  maxContours: $6uUbQ$uint16,\n  maxComponentPoints: $6uUbQ$uint16,\n  maxComponentContours: $6uUbQ$uint16,\n  maxZones: $6uUbQ$uint16,\n  maxTwilightPoints: $6uUbQ$uint16,\n  maxStorage: $6uUbQ$uint16,\n  maxFunctionDefs: $6uUbQ$uint16,\n  maxInstructionDefs: $6uUbQ$uint16,\n  maxStackElements: $6uUbQ$uint16,\n  maxSizeOfInstructions: $6uUbQ$uint16,\n  maxComponentElements: $6uUbQ$uint16,\n  maxComponentDepth: $6uUbQ$uint16 // Maximum levels of recursion; 1 for simple components\n});\n\n/**\n * Gets an encoding name from platform, encoding, and language ids.\n * Returned encoding names can be used in iconv-lite to decode text.\n */\nfunction $e449ad78d50845fe$export$badc544e0651b6b1(platformID, encodingID) {\n  let languageID = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n  if (platformID === 1 && $e449ad78d50845fe$export$479e671907f486d1[languageID]) return $e449ad78d50845fe$export$479e671907f486d1[languageID];\n  return $e449ad78d50845fe$export$6fef87b7618bdf0b[platformID][encodingID];\n}\nconst $e449ad78d50845fe$var$SINGLE_BYTE_ENCODINGS = new Set(['x-mac-roman', 'x-mac-cyrillic', 'iso-8859-6', 'iso-8859-8']);\nconst $e449ad78d50845fe$var$MAC_ENCODINGS = {\n  'x-mac-croatian': \"\\xc4\\xc5\\xc7\\xc9\\xd1\\xd6\\xdc\\xe1\\xe0\\xe2\\xe4\\xe3\\xe5\\xe7\\xe9\\xe8\\xea\\xeb\\xed\\xec\\xee\\xef\\xf1\\xf3\\xf2\\xf4\\xf6\\xf5\\xfa\\xf9\\xfb\\xfc\\u2020\\xb0\\xa2\\xa3\\xa7\\u2022\\xb6\\xdf\\xae\\u0160\\u2122\\xb4\\xa8\\u2260\\u017D\\xd8\\u221E\\xb1\\u2264\\u2265\\u2206\\xb5\\u2202\\u2211\\u220F\\u0161\\u222B\\xaa\\xba\\u03A9\\u017E\\xf8\\xbf\\xa1\\xac\\u221A\\u0192\\u2248\\u0106\\xab\\u010C\\u2026 \\xc0\\xc3\\xd5\\u0152\\u0153\\u0110\\u2014\\u201C\\u201D\\u2018\\u2019\\xf7\\u25CA\\uF8FF\\xa9\\u2044\\u20AC\\u2039\\u203A\\xc6\\xbb\\u2013\\xb7\\u201A\\u201E\\u2030\\xc2\\u0107\\xc1\\u010D\\xc8\\xcd\\xce\\xcf\\xcc\\xd3\\xd4\\u0111\\xd2\\xda\\xdb\\xd9\\u0131\\u02C6\\u02DC\\xaf\\u03C0\\xcb\\u02DA\\xb8\\xca\\xe6\\u02C7\",\n  'x-mac-gaelic': \"\\xc4\\xc5\\xc7\\xc9\\xd1\\xd6\\xdc\\xe1\\xe0\\xe2\\xe4\\xe3\\xe5\\xe7\\xe9\\xe8\\xea\\xeb\\xed\\xec\\xee\\xef\\xf1\\xf3\\xf2\\xf4\\xf6\\xf5\\xfa\\xf9\\xfb\\xfc\\u2020\\xb0\\xa2\\xa3\\xa7\\u2022\\xb6\\xdf\\xae\\xa9\\u2122\\xb4\\xa8\\u2260\\xc6\\xd8\\u1E02\\xb1\\u2264\\u2265\\u1E03\\u010A\\u010B\\u1E0A\\u1E0B\\u1E1E\\u1E1F\\u0120\\u0121\\u1E40\\xe6\\xf8\\u1E41\\u1E56\\u1E57\\u027C\\u0192\\u017F\\u1E60\\xab\\xbb\\u2026 \\xc0\\xc3\\xd5\\u0152\\u0153\\u2013\\u2014\\u201C\\u201D\\u2018\\u2019\\u1E61\\u1E9B\\xff\\u0178\\u1E6A\\u20AC\\u2039\\u203A\\u0176\\u0177\\u1E6B\\xb7\\u1EF2\\u1EF3\\u204A\\xc2\\xca\\xc1\\xcb\\xc8\\xcd\\xce\\xcf\\xcc\\xd3\\xd4\\u2663\\xd2\\xda\\xdb\\xd9\\u0131\\xdd\\xfd\\u0174\\u0175\\u1E84\\u1E85\\u1E80\\u1E81\\u1E82\\u1E83\",\n  'x-mac-greek': \"\\xc4\\xb9\\xb2\\xc9\\xb3\\xd6\\xdc\\u0385\\xe0\\xe2\\xe4\\u0384\\xa8\\xe7\\xe9\\xe8\\xea\\xeb\\xa3\\u2122\\xee\\xef\\u2022\\xbd\\u2030\\xf4\\xf6\\xa6\\u20AC\\xf9\\xfb\\xfc\\u2020\\u0393\\u0394\\u0398\\u039B\\u039E\\u03A0\\xdf\\xae\\xa9\\u03A3\\u03AA\\xa7\\u2260\\xb0\\xb7\\u0391\\xb1\\u2264\\u2265\\xa5\\u0392\\u0395\\u0396\\u0397\\u0399\\u039A\\u039C\\u03A6\\u03AB\\u03A8\\u03A9\\u03AC\\u039D\\xac\\u039F\\u03A1\\u2248\\u03A4\\xab\\xbb\\u2026 \\u03A5\\u03A7\\u0386\\u0388\\u0153\\u2013\\u2015\\u201C\\u201D\\u2018\\u2019\\xf7\\u0389\\u038A\\u038C\\u038E\\u03AD\\u03AE\\u03AF\\u03CC\\u038F\\u03CD\\u03B1\\u03B2\\u03C8\\u03B4\\u03B5\\u03C6\\u03B3\\u03B7\\u03B9\\u03BE\\u03BA\\u03BB\\u03BC\\u03BD\\u03BF\\u03C0\\u03CE\\u03C1\\u03C3\\u03C4\\u03B8\\u03C9\\u03C2\\u03C7\\u03C5\\u03B6\\u03CA\\u03CB\\u0390\\u03B0\\xad\",\n  'x-mac-icelandic': \"\\xc4\\xc5\\xc7\\xc9\\xd1\\xd6\\xdc\\xe1\\xe0\\xe2\\xe4\\xe3\\xe5\\xe7\\xe9\\xe8\\xea\\xeb\\xed\\xec\\xee\\xef\\xf1\\xf3\\xf2\\xf4\\xf6\\xf5\\xfa\\xf9\\xfb\\xfc\\xdd\\xb0\\xa2\\xa3\\xa7\\u2022\\xb6\\xdf\\xae\\xa9\\u2122\\xb4\\xa8\\u2260\\xc6\\xd8\\u221E\\xb1\\u2264\\u2265\\xa5\\xb5\\u2202\\u2211\\u220F\\u03C0\\u222B\\xaa\\xba\\u03A9\\xe6\\xf8\\xbf\\xa1\\xac\\u221A\\u0192\\u2248\\u2206\\xab\\xbb\\u2026 \\xc0\\xc3\\xd5\\u0152\\u0153\\u2013\\u2014\\u201C\\u201D\\u2018\\u2019\\xf7\\u25CA\\xff\\u0178\\u2044\\u20AC\\xd0\\xf0\\xde\\xfe\\xfd\\xb7\\u201A\\u201E\\u2030\\xc2\\xca\\xc1\\xcb\\xc8\\xcd\\xce\\xcf\\xcc\\xd3\\xd4\\uF8FF\\xd2\\xda\\xdb\\xd9\\u0131\\u02C6\\u02DC\\xaf\\u02D8\\u02D9\\u02DA\\xb8\\u02DD\\u02DB\\u02C7\",\n  'x-mac-inuit': \"\\u1403\\u1404\\u1405\\u1406\\u140A\\u140B\\u1431\\u1432\\u1433\\u1434\\u1438\\u1439\\u1449\\u144E\\u144F\\u1450\\u1451\\u1455\\u1456\\u1466\\u146D\\u146E\\u146F\\u1470\\u1472\\u1473\\u1483\\u148B\\u148C\\u148D\\u148E\\u1490\\u1491\\xb0\\u14A1\\u14A5\\u14A6\\u2022\\xb6\\u14A7\\xae\\xa9\\u2122\\u14A8\\u14AA\\u14AB\\u14BB\\u14C2\\u14C3\\u14C4\\u14C5\\u14C7\\u14C8\\u14D0\\u14EF\\u14F0\\u14F1\\u14F2\\u14F4\\u14F5\\u1505\\u14D5\\u14D6\\u14D7\\u14D8\\u14DA\\u14DB\\u14EA\\u1528\\u1529\\u152A\\u152B\\u152D\\u2026 \\u152E\\u153E\\u1555\\u1556\\u1557\\u2013\\u2014\\u201C\\u201D\\u2018\\u2019\\u1558\\u1559\\u155A\\u155D\\u1546\\u1547\\u1548\\u1549\\u154B\\u154C\\u1550\\u157F\\u1580\\u1581\\u1582\\u1583\\u1584\\u1585\\u158F\\u1590\\u1591\\u1592\\u1593\\u1594\\u1595\\u1671\\u1672\\u1673\\u1674\\u1675\\u1676\\u1596\\u15A0\\u15A1\\u15A2\\u15A3\\u15A4\\u15A5\\u15A6\\u157C\\u0141\\u0142\",\n  'x-mac-ce': \"\\xc4\\u0100\\u0101\\xc9\\u0104\\xd6\\xdc\\xe1\\u0105\\u010C\\xe4\\u010D\\u0106\\u0107\\xe9\\u0179\\u017A\\u010E\\xed\\u010F\\u0112\\u0113\\u0116\\xf3\\u0117\\xf4\\xf6\\xf5\\xfa\\u011A\\u011B\\xfc\\u2020\\xb0\\u0118\\xa3\\xa7\\u2022\\xb6\\xdf\\xae\\xa9\\u2122\\u0119\\xa8\\u2260\\u0123\\u012E\\u012F\\u012A\\u2264\\u2265\\u012B\\u0136\\u2202\\u2211\\u0142\\u013B\\u013C\\u013D\\u013E\\u0139\\u013A\\u0145\\u0146\\u0143\\xac\\u221A\\u0144\\u0147\\u2206\\xab\\xbb\\u2026 \\u0148\\u0150\\xd5\\u0151\\u014C\\u2013\\u2014\\u201C\\u201D\\u2018\\u2019\\xf7\\u25CA\\u014D\\u0154\\u0155\\u0158\\u2039\\u203A\\u0159\\u0156\\u0157\\u0160\\u201A\\u201E\\u0161\\u015A\\u015B\\xc1\\u0164\\u0165\\xcd\\u017D\\u017E\\u016A\\xd3\\xd4\\u016B\\u016E\\xda\\u016F\\u0170\\u0171\\u0172\\u0173\\xdd\\xfd\\u0137\\u017B\\u0141\\u017C\\u0122\\u02C7\",\n  'x-mac-romanian': \"\\xc4\\xc5\\xc7\\xc9\\xd1\\xd6\\xdc\\xe1\\xe0\\xe2\\xe4\\xe3\\xe5\\xe7\\xe9\\xe8\\xea\\xeb\\xed\\xec\\xee\\xef\\xf1\\xf3\\xf2\\xf4\\xf6\\xf5\\xfa\\xf9\\xfb\\xfc\\u2020\\xb0\\xa2\\xa3\\xa7\\u2022\\xb6\\xdf\\xae\\xa9\\u2122\\xb4\\xa8\\u2260\\u0102\\u0218\\u221E\\xb1\\u2264\\u2265\\xa5\\xb5\\u2202\\u2211\\u220F\\u03C0\\u222B\\xaa\\xba\\u03A9\\u0103\\u0219\\xbf\\xa1\\xac\\u221A\\u0192\\u2248\\u2206\\xab\\xbb\\u2026 \\xc0\\xc3\\xd5\\u0152\\u0153\\u2013\\u2014\\u201C\\u201D\\u2018\\u2019\\xf7\\u25CA\\xff\\u0178\\u2044\\u20AC\\u2039\\u203A\\u021A\\u021B\\u2021\\xb7\\u201A\\u201E\\u2030\\xc2\\xca\\xc1\\xcb\\xc8\\xcd\\xce\\xcf\\xcc\\xd3\\xd4\\uF8FF\\xd2\\xda\\xdb\\xd9\\u0131\\u02C6\\u02DC\\xaf\\u02D8\\u02D9\\u02DA\\xb8\\u02DD\\u02DB\\u02C7\",\n  'x-mac-turkish': \"\\xc4\\xc5\\xc7\\xc9\\xd1\\xd6\\xdc\\xe1\\xe0\\xe2\\xe4\\xe3\\xe5\\xe7\\xe9\\xe8\\xea\\xeb\\xed\\xec\\xee\\xef\\xf1\\xf3\\xf2\\xf4\\xf6\\xf5\\xfa\\xf9\\xfb\\xfc\\u2020\\xb0\\xa2\\xa3\\xa7\\u2022\\xb6\\xdf\\xae\\xa9\\u2122\\xb4\\xa8\\u2260\\xc6\\xd8\\u221E\\xb1\\u2264\\u2265\\xa5\\xb5\\u2202\\u2211\\u220F\\u03C0\\u222B\\xaa\\xba\\u03A9\\xe6\\xf8\\xbf\\xa1\\xac\\u221A\\u0192\\u2248\\u2206\\xab\\xbb\\u2026 \\xc0\\xc3\\xd5\\u0152\\u0153\\u2013\\u2014\\u201C\\u201D\\u2018\\u2019\\xf7\\u25CA\\xff\\u0178\\u011E\\u011F\\u0130\\u0131\\u015E\\u015F\\u2021\\xb7\\u201A\\u201E\\u2030\\xc2\\xca\\xc1\\xcb\\xc8\\xcd\\xce\\xcf\\xcc\\xd3\\xd4\\uF8FF\\xd2\\xda\\xdb\\xd9\\uF8A0\\u02C6\\u02DC\\xaf\\u02D8\\u02D9\\u02DA\\xb8\\u02DD\\u02DB\\u02C7\"\n};\nconst $e449ad78d50845fe$var$encodingCache = new Map();\nfunction $e449ad78d50845fe$export$1dceb3c14ed68bee(encoding) {\n  let cached = $e449ad78d50845fe$var$encodingCache.get(encoding);\n  if (cached) return cached;\n  // These encodings aren't supported by TextDecoder.\n  let mapping = $e449ad78d50845fe$var$MAC_ENCODINGS[encoding];\n  if (mapping) {\n    let res = new Map();\n    for (let i = 0; i < mapping.length; i++) res.set(mapping.charCodeAt(i), 0x80 + i);\n    $e449ad78d50845fe$var$encodingCache.set(encoding, res);\n    return res;\n  }\n  // Only single byte encodings can be mapped 1:1.\n  if ($e449ad78d50845fe$var$SINGLE_BYTE_ENCODINGS.has(encoding)) {\n    // TextEncoder only supports utf8, whereas TextDecoder supports legacy encodings.\n    // Use this to create a mapping of code points.\n    let decoder = new TextDecoder(encoding);\n    let mapping = new Uint8Array(0x80);\n    for (let i = 0; i < 0x80; i++) mapping[i] = 0x80 + i;\n    let res = new Map();\n    let s = decoder.decode(mapping);\n    for (let i = 0; i < 0x80; i++) res.set(s.charCodeAt(i), 0x80 + i);\n    $e449ad78d50845fe$var$encodingCache.set(encoding, res);\n    return res;\n  }\n}\nconst $e449ad78d50845fe$export$6fef87b7618bdf0b = [\n// unicode\n['utf-16be', 'utf-16be', 'utf-16be', 'utf-16be', 'utf-16be', 'utf-16be', 'utf-16be'],\n// macintosh\n// Mappings available at http://unicode.org/Public/MAPPINGS/VENDORS/APPLE/\n// 0\tRoman                 17\tMalayalam\n// 1\tJapanese\t            18\tSinhalese\n// 2\tTraditional Chinese\t  19\tBurmese\n// 3\tKorean\t              20\tKhmer\n// 4\tArabic\t              21\tThai\n// 5\tHebrew\t              22\tLaotian\n// 6\tGreek\t                23\tGeorgian\n// 7\tRussian\t              24\tArmenian\n// 8\tRSymbol\t              25\tSimplified Chinese\n// 9\tDevanagari\t          26\tTibetan\n// 10\tGurmukhi\t            27\tMongolian\n// 11\tGujarati\t            28\tGeez\n// 12\tOriya\t                29\tSlavic\n// 13\tBengali\t              30\tVietnamese\n// 14\tTamil\t                31\tSindhi\n// 15\tTelugu\t              32\t(Uninterpreted)\n// 16\tKannada\n['x-mac-roman', 'shift-jis', 'big5', 'euc-kr', 'iso-8859-6', 'iso-8859-8', 'x-mac-greek', 'x-mac-cyrillic', 'x-mac-symbol', 'x-mac-devanagari', 'x-mac-gurmukhi', 'x-mac-gujarati', 'Oriya', 'Bengali', 'Tamil', 'Telugu', 'Kannada', 'Malayalam', 'Sinhalese', 'Burmese', 'Khmer', 'iso-8859-11', 'Laotian', 'Georgian', 'Armenian', 'gbk', 'Tibetan', 'Mongolian', 'Geez', 'x-mac-ce', 'Vietnamese', 'Sindhi'],\n// ISO (deprecated)\n['ascii', null, 'iso-8859-1'],\n// windows\n// Docs here: http://msdn.microsoft.com/en-us/library/system.text.encoding(v=vs.110).aspx\n['symbol', 'utf-16be', 'shift-jis', 'gb18030', 'big5', 'euc-kr', 'johab', null, null, null, 'utf-16be']];\nconst $e449ad78d50845fe$export$479e671907f486d1 = {\n  15: 'x-mac-icelandic',\n  17: 'x-mac-turkish',\n  18: 'x-mac-croatian',\n  24: 'x-mac-ce',\n  25: 'x-mac-ce',\n  26: 'x-mac-ce',\n  27: 'x-mac-ce',\n  28: 'x-mac-ce',\n  30: 'x-mac-icelandic',\n  37: 'x-mac-romanian',\n  38: 'x-mac-ce',\n  39: 'x-mac-ce',\n  40: 'x-mac-ce',\n  143: 'x-mac-inuit',\n  146: 'x-mac-gaelic'\n};\nconst $e449ad78d50845fe$export$2092376fd002e13 = [\n// unicode\n[], {\n  0: 'en',\n  30: 'fo',\n  60: 'ks',\n  90: 'rw',\n  1: 'fr',\n  31: 'fa',\n  61: 'ku',\n  91: 'rn',\n  2: 'de',\n  32: 'ru',\n  62: 'sd',\n  92: 'ny',\n  3: 'it',\n  33: 'zh',\n  63: 'bo',\n  93: 'mg',\n  4: 'nl',\n  34: 'nl-BE',\n  64: 'ne',\n  94: 'eo',\n  5: 'sv',\n  35: 'ga',\n  65: 'sa',\n  128: 'cy',\n  6: 'es',\n  36: 'sq',\n  66: 'mr',\n  129: 'eu',\n  7: 'da',\n  37: 'ro',\n  67: 'bn',\n  130: 'ca',\n  8: 'pt',\n  38: 'cz',\n  68: 'as',\n  131: 'la',\n  9: 'no',\n  39: 'sk',\n  69: 'gu',\n  132: 'qu',\n  10: 'he',\n  40: 'si',\n  70: 'pa',\n  133: 'gn',\n  11: 'ja',\n  41: 'yi',\n  71: 'or',\n  134: 'ay',\n  12: 'ar',\n  42: 'sr',\n  72: 'ml',\n  135: 'tt',\n  13: 'fi',\n  43: 'mk',\n  73: 'kn',\n  136: 'ug',\n  14: 'el',\n  44: 'bg',\n  74: 'ta',\n  137: 'dz',\n  15: 'is',\n  45: 'uk',\n  75: 'te',\n  138: 'jv',\n  16: 'mt',\n  46: 'be',\n  76: 'si',\n  139: 'su',\n  17: 'tr',\n  47: 'uz',\n  77: 'my',\n  140: 'gl',\n  18: 'hr',\n  48: 'kk',\n  78: 'km',\n  141: 'af',\n  19: 'zh-Hant',\n  49: 'az-Cyrl',\n  79: 'lo',\n  142: 'br',\n  20: 'ur',\n  50: 'az-Arab',\n  80: 'vi',\n  143: 'iu',\n  21: 'hi',\n  51: 'hy',\n  81: 'id',\n  144: 'gd',\n  22: 'th',\n  52: 'ka',\n  82: 'tl',\n  145: 'gv',\n  23: 'ko',\n  53: 'mo',\n  83: 'ms',\n  146: 'ga',\n  24: 'lt',\n  54: 'ky',\n  84: 'ms-Arab',\n  147: 'to',\n  25: 'pl',\n  55: 'tg',\n  85: 'am',\n  148: 'el-polyton',\n  26: 'hu',\n  56: 'tk',\n  86: 'ti',\n  149: 'kl',\n  27: 'es',\n  57: 'mn-CN',\n  87: 'om',\n  150: 'az',\n  28: 'lv',\n  58: 'mn',\n  88: 'so',\n  151: 'nn',\n  29: 'se',\n  59: 'ps',\n  89: 'sw'\n},\n// ISO (deprecated)\n[], {\n  0x0436: 'af',\n  0x4009: 'en-IN',\n  0x0487: 'rw',\n  0x0432: 'tn',\n  0x041C: 'sq',\n  0x1809: 'en-IE',\n  0x0441: 'sw',\n  0x045B: 'si',\n  0x0484: 'gsw',\n  0x2009: 'en-JM',\n  0x0457: 'kok',\n  0x041B: 'sk',\n  0x045E: 'am',\n  0x4409: 'en-MY',\n  0x0412: 'ko',\n  0x0424: 'sl',\n  0x1401: 'ar-DZ',\n  0x1409: 'en-NZ',\n  0x0440: 'ky',\n  0x2C0A: 'es-AR',\n  0x3C01: 'ar-BH',\n  0x3409: 'en-PH',\n  0x0454: 'lo',\n  0x400A: 'es-BO',\n  0x0C01: 'ar',\n  0x4809: 'en-SG',\n  0x0426: 'lv',\n  0x340A: 'es-CL',\n  0x0801: 'ar-IQ',\n  0x1C09: 'en-ZA',\n  0x0427: 'lt',\n  0x240A: 'es-CO',\n  0x2C01: 'ar-JO',\n  0x2C09: 'en-TT',\n  0x082E: 'dsb',\n  0x140A: 'es-CR',\n  0x3401: 'ar-KW',\n  0x0809: 'en-GB',\n  0x046E: 'lb',\n  0x1C0A: 'es-DO',\n  0x3001: 'ar-LB',\n  0x0409: 'en',\n  0x042F: 'mk',\n  0x300A: 'es-EC',\n  0x1001: 'ar-LY',\n  0x3009: 'en-ZW',\n  0x083E: 'ms-BN',\n  0x440A: 'es-SV',\n  0x1801: 'ary',\n  0x0425: 'et',\n  0x043E: 'ms',\n  0x100A: 'es-GT',\n  0x2001: 'ar-OM',\n  0x0438: 'fo',\n  0x044C: 'ml',\n  0x480A: 'es-HN',\n  0x4001: 'ar-QA',\n  0x0464: 'fil',\n  0x043A: 'mt',\n  0x080A: 'es-MX',\n  0x0401: 'ar-SA',\n  0x040B: 'fi',\n  0x0481: 'mi',\n  0x4C0A: 'es-NI',\n  0x2801: 'ar-SY',\n  0x080C: 'fr-BE',\n  0x047A: 'arn',\n  0x180A: 'es-PA',\n  0x1C01: 'aeb',\n  0x0C0C: 'fr-CA',\n  0x044E: 'mr',\n  0x3C0A: 'es-PY',\n  0x3801: 'ar-AE',\n  0x040C: 'fr',\n  0x047C: 'moh',\n  0x280A: 'es-PE',\n  0x2401: 'ar-YE',\n  0x140C: 'fr-LU',\n  0x0450: 'mn',\n  0x500A: 'es-PR',\n  0x042B: 'hy',\n  0x180C: 'fr-MC',\n  0x0850: 'mn-CN',\n  0x0C0A: 'es',\n  0x044D: 'as',\n  0x100C: 'fr-CH',\n  0x0461: 'ne',\n  0x040A: 'es',\n  0x082C: 'az-Cyrl',\n  0x0462: 'fy',\n  0x0414: 'nb',\n  0x540A: 'es-US',\n  0x042C: 'az',\n  0x0456: 'gl',\n  0x0814: 'nn',\n  0x380A: 'es-UY',\n  0x046D: 'ba',\n  0x0437: 'ka',\n  0x0482: 'oc',\n  0x200A: 'es-VE',\n  0x042D: 'eu',\n  0x0C07: 'de-AT',\n  0x0448: 'or',\n  0x081D: 'sv-FI',\n  0x0423: 'be',\n  0x0407: 'de',\n  0x0463: 'ps',\n  0x041D: 'sv',\n  0x0845: 'bn',\n  0x1407: 'de-LI',\n  0x0415: 'pl',\n  0x045A: 'syr',\n  0x0445: 'bn-IN',\n  0x1007: 'de-LU',\n  0x0416: 'pt',\n  0x0428: 'tg',\n  0x201A: 'bs-Cyrl',\n  0x0807: 'de-CH',\n  0x0816: 'pt-PT',\n  0x085F: 'tzm',\n  0x141A: 'bs',\n  0x0408: 'el',\n  0x0446: 'pa',\n  0x0449: 'ta',\n  0x047E: 'br',\n  0x046F: 'kl',\n  0x046B: 'qu-BO',\n  0x0444: 'tt',\n  0x0402: 'bg',\n  0x0447: 'gu',\n  0x086B: 'qu-EC',\n  0x044A: 'te',\n  0x0403: 'ca',\n  0x0468: 'ha',\n  0x0C6B: 'qu',\n  0x041E: 'th',\n  0x0C04: 'zh-HK',\n  0x040D: 'he',\n  0x0418: 'ro',\n  0x0451: 'bo',\n  0x1404: 'zh-MO',\n  0x0439: 'hi',\n  0x0417: 'rm',\n  0x041F: 'tr',\n  0x0804: 'zh',\n  0x040E: 'hu',\n  0x0419: 'ru',\n  0x0442: 'tk',\n  0x1004: 'zh-SG',\n  0x040F: 'is',\n  0x243B: 'smn',\n  0x0480: 'ug',\n  0x0404: 'zh-TW',\n  0x0470: 'ig',\n  0x103B: 'smj-NO',\n  0x0422: 'uk',\n  0x0483: 'co',\n  0x0421: 'id',\n  0x143B: 'smj',\n  0x042E: 'hsb',\n  0x041A: 'hr',\n  0x045D: 'iu',\n  0x0C3B: 'se-FI',\n  0x0420: 'ur',\n  0x101A: 'hr-BA',\n  0x085D: 'iu-Latn',\n  0x043B: 'se',\n  0x0843: 'uz-Cyrl',\n  0x0405: 'cs',\n  0x083C: 'ga',\n  0x083B: 'se-SE',\n  0x0443: 'uz',\n  0x0406: 'da',\n  0x0434: 'xh',\n  0x203B: 'sms',\n  0x042A: 'vi',\n  0x048C: 'prs',\n  0x0435: 'zu',\n  0x183B: 'sma-NO',\n  0x0452: 'cy',\n  0x0465: 'dv',\n  0x0410: 'it',\n  0x1C3B: 'sms',\n  0x0488: 'wo',\n  0x0813: 'nl-BE',\n  0x0810: 'it-CH',\n  0x044F: 'sa',\n  0x0485: 'sah',\n  0x0413: 'nl',\n  0x0411: 'ja',\n  0x1C1A: 'sr-Cyrl-BA',\n  0x0478: 'ii',\n  0x0C09: 'en-AU',\n  0x044B: 'kn',\n  0x0C1A: 'sr',\n  0x046A: 'yo',\n  0x2809: 'en-BZ',\n  0x043F: 'kk',\n  0x181A: 'sr-Latn-BA',\n  0x1009: 'en-CA',\n  0x0453: 'km',\n  0x081A: 'sr-Latn',\n  0x2409: 'en-029',\n  0x0486: 'quc',\n  0x046C: 'nso'\n}];\nlet $2bcf221753ec8e32$var$NameRecord = new $6uUbQ$Struct({\n  platformID: $6uUbQ$uint16,\n  encodingID: $6uUbQ$uint16,\n  languageID: $6uUbQ$uint16,\n  nameID: $6uUbQ$uint16,\n  length: $6uUbQ$uint16,\n  string: new $6uUbQ$Pointer($6uUbQ$uint16, new $6uUbQ$String('length', t => (0, $e449ad78d50845fe$export$badc544e0651b6b1)(t.platformID, t.encodingID, t.languageID)), {\n    type: 'parent',\n    relativeTo: ctx => ctx.parent.stringOffset,\n    allowNull: false\n  })\n});\nlet $2bcf221753ec8e32$var$LangTagRecord = new $6uUbQ$Struct({\n  length: $6uUbQ$uint16,\n  tag: new $6uUbQ$Pointer($6uUbQ$uint16, new $6uUbQ$String('length', 'utf16be'), {\n    type: 'parent',\n    relativeTo: ctx => ctx.stringOffset\n  })\n});\nvar $2bcf221753ec8e32$var$NameTable = new $6uUbQ$VersionedStruct($6uUbQ$uint16, {\n  0: {\n    count: $6uUbQ$uint16,\n    stringOffset: $6uUbQ$uint16,\n    records: new $6uUbQ$Array($2bcf221753ec8e32$var$NameRecord, 'count')\n  },\n  1: {\n    count: $6uUbQ$uint16,\n    stringOffset: $6uUbQ$uint16,\n    records: new $6uUbQ$Array($2bcf221753ec8e32$var$NameRecord, 'count'),\n    langTagCount: $6uUbQ$uint16,\n    langTags: new $6uUbQ$Array($2bcf221753ec8e32$var$LangTagRecord, 'langTagCount')\n  }\n});\nvar $2bcf221753ec8e32$export$2e2bcd8739ae039 = $2bcf221753ec8e32$var$NameTable;\nconst $2bcf221753ec8e32$var$NAMES = ['copyright', 'fontFamily', 'fontSubfamily', 'uniqueSubfamily', 'fullName', 'version', 'postscriptName', 'trademark', 'manufacturer', 'designer', 'description', 'vendorURL', 'designerURL', 'license', 'licenseURL', null, 'preferredFamily', 'preferredSubfamily', 'compatibleFull', 'sampleText', 'postscriptCIDFontName', 'wwsFamilyName', 'wwsSubfamilyName'];\n$2bcf221753ec8e32$var$NameTable.process = function (stream) {\n  var records = {};\n  for (let record of this.records) {\n    // find out what language this is for\n    let language = (0, $e449ad78d50845fe$export$2092376fd002e13)[record.platformID][record.languageID];\n    if (language == null && this.langTags != null && record.languageID >= 0x8000) language = this.langTags[record.languageID - 0x8000].tag;\n    if (language == null) language = record.platformID + '-' + record.languageID;\n    // if the nameID is >= 256, it is a font feature record (AAT)\n    let key = record.nameID >= 256 ? 'fontFeatures' : $2bcf221753ec8e32$var$NAMES[record.nameID] || record.nameID;\n    if (records[key] == null) records[key] = {};\n    let obj = records[key];\n    if (record.nameID >= 256) obj = obj[record.nameID] || (obj[record.nameID] = {});\n    if (typeof record.string === 'string' || typeof obj[language] !== 'string') obj[language] = record.string;\n  }\n  this.records = records;\n};\n$2bcf221753ec8e32$var$NameTable.preEncode = function () {\n  if (Array.isArray(this.records)) return;\n  this.version = 0;\n  let records = [];\n  for (let key in this.records) {\n    let val = this.records[key];\n    if (key === 'fontFeatures') continue;\n    records.push({\n      platformID: 3,\n      encodingID: 1,\n      languageID: 0x409,\n      nameID: $2bcf221753ec8e32$var$NAMES.indexOf(key),\n      length: val.en.length * 2,\n      string: val.en\n    });\n    if (key === 'postscriptName') records.push({\n      platformID: 1,\n      encodingID: 0,\n      languageID: 0,\n      nameID: $2bcf221753ec8e32$var$NAMES.indexOf(key),\n      length: val.en.length,\n      string: val.en\n    });\n  }\n  this.records = records;\n  this.count = records.length;\n  this.stringOffset = $2bcf221753ec8e32$var$NameTable.size(this, null, false);\n};\nvar $84b272aa31b70606$var$OS2 = new $6uUbQ$VersionedStruct($6uUbQ$uint16, {\n  header: {\n    xAvgCharWidth: $6uUbQ$int16,\n    usWeightClass: $6uUbQ$uint16,\n    usWidthClass: $6uUbQ$uint16,\n    fsType: new $6uUbQ$Bitfield($6uUbQ$uint16, [null, 'noEmbedding', 'viewOnly', 'editable', null, null, null, null, 'noSubsetting', 'bitmapOnly']),\n    ySubscriptXSize: $6uUbQ$int16,\n    ySubscriptYSize: $6uUbQ$int16,\n    ySubscriptXOffset: $6uUbQ$int16,\n    ySubscriptYOffset: $6uUbQ$int16,\n    ySuperscriptXSize: $6uUbQ$int16,\n    ySuperscriptYSize: $6uUbQ$int16,\n    ySuperscriptXOffset: $6uUbQ$int16,\n    ySuperscriptYOffset: $6uUbQ$int16,\n    yStrikeoutSize: $6uUbQ$int16,\n    yStrikeoutPosition: $6uUbQ$int16,\n    sFamilyClass: $6uUbQ$int16,\n    panose: new $6uUbQ$Array($6uUbQ$uint8, 10),\n    ulCharRange: new $6uUbQ$Array($6uUbQ$uint32, 4),\n    vendorID: new $6uUbQ$String(4),\n    fsSelection: new $6uUbQ$Bitfield($6uUbQ$uint16, ['italic', 'underscore', 'negative', 'outlined', 'strikeout', 'bold', 'regular', 'useTypoMetrics', 'wws', 'oblique']),\n    usFirstCharIndex: $6uUbQ$uint16,\n    usLastCharIndex: $6uUbQ$uint16 // The maximum Unicode index in this font\n  },\n  // The Apple version of this table ends here, but the Microsoft one continues on...\n  0: {},\n  1: {\n    typoAscender: $6uUbQ$int16,\n    typoDescender: $6uUbQ$int16,\n    typoLineGap: $6uUbQ$int16,\n    winAscent: $6uUbQ$uint16,\n    winDescent: $6uUbQ$uint16,\n    codePageRange: new $6uUbQ$Array($6uUbQ$uint32, 2)\n  },\n  2: {\n    // these should be common with version 1 somehow\n    typoAscender: $6uUbQ$int16,\n    typoDescender: $6uUbQ$int16,\n    typoLineGap: $6uUbQ$int16,\n    winAscent: $6uUbQ$uint16,\n    winDescent: $6uUbQ$uint16,\n    codePageRange: new $6uUbQ$Array($6uUbQ$uint32, 2),\n    xHeight: $6uUbQ$int16,\n    capHeight: $6uUbQ$int16,\n    defaultChar: $6uUbQ$uint16,\n    breakChar: $6uUbQ$uint16,\n    maxContent: $6uUbQ$uint16\n  },\n  5: {\n    typoAscender: $6uUbQ$int16,\n    typoDescender: $6uUbQ$int16,\n    typoLineGap: $6uUbQ$int16,\n    winAscent: $6uUbQ$uint16,\n    winDescent: $6uUbQ$uint16,\n    codePageRange: new $6uUbQ$Array($6uUbQ$uint32, 2),\n    xHeight: $6uUbQ$int16,\n    capHeight: $6uUbQ$int16,\n    defaultChar: $6uUbQ$uint16,\n    breakChar: $6uUbQ$uint16,\n    maxContent: $6uUbQ$uint16,\n    usLowerOpticalPointSize: $6uUbQ$uint16,\n    usUpperOpticalPointSize: $6uUbQ$uint16\n  }\n});\nlet $84b272aa31b70606$var$versions = $84b272aa31b70606$var$OS2.versions;\n$84b272aa31b70606$var$versions[3] = $84b272aa31b70606$var$versions[4] = $84b272aa31b70606$var$versions[2];\nvar $84b272aa31b70606$export$2e2bcd8739ae039 = $84b272aa31b70606$var$OS2;\nvar\n// PostScript information\n$32d9e2eb9565d93c$export$2e2bcd8739ae039 = new $6uUbQ$VersionedStruct($6uUbQ$fixed32, {\n  header: {\n    italicAngle: $6uUbQ$fixed32,\n    underlinePosition: $6uUbQ$int16,\n    underlineThickness: $6uUbQ$int16,\n    isFixedPitch: $6uUbQ$uint32,\n    minMemType42: $6uUbQ$uint32,\n    maxMemType42: $6uUbQ$uint32,\n    minMemType1: $6uUbQ$uint32,\n    maxMemType1: $6uUbQ$uint32 // Maximum memory usage when a TrueType font is downloaded as a Type 1 font\n  },\n  1: {},\n  2: {\n    numberOfGlyphs: $6uUbQ$uint16,\n    glyphNameIndex: new $6uUbQ$Array($6uUbQ$uint16, 'numberOfGlyphs'),\n    names: new $6uUbQ$Array(new $6uUbQ$String($6uUbQ$uint8))\n  },\n  2.5: {\n    numberOfGlyphs: $6uUbQ$uint16,\n    offsets: new $6uUbQ$Array($6uUbQ$uint8, 'numberOfGlyphs')\n  },\n  3: {},\n  4: {\n    map: new $6uUbQ$Array($6uUbQ$uint32, t => t.parent.maxp.numGlyphs)\n  }\n});\nvar\n// An array of predefined values accessible by instructions\n$5202bd9d9ad8eaac$export$2e2bcd8739ae039 = new $6uUbQ$Struct({\n  controlValues: new $6uUbQ$Array($6uUbQ$int16)\n});\nvar\n// A list of instructions that are executed once when a font is first used.\n// These instructions are known as the font program. The main use of this table\n// is for the definition of functions that are used in many different glyph programs.\n$5c0f37ca5ffb1850$export$2e2bcd8739ae039 = new $6uUbQ$Struct({\n  instructions: new $6uUbQ$Array($6uUbQ$uint8)\n});\nlet $2b2b260902b1c57e$var$loca = new $6uUbQ$VersionedStruct('head.indexToLocFormat', {\n  0: {\n    offsets: new $6uUbQ$Array($6uUbQ$uint16)\n  },\n  1: {\n    offsets: new $6uUbQ$Array($6uUbQ$uint32)\n  }\n});\n$2b2b260902b1c57e$var$loca.process = function () {\n  if (this.version === 0 && !this._processed) {\n    for (let i = 0; i < this.offsets.length; i++) this.offsets[i] <<= 1;\n    this._processed = true;\n  }\n};\n$2b2b260902b1c57e$var$loca.preEncode = function () {\n  if (this.version === 0 && this._processed !== false) {\n    for (let i = 0; i < this.offsets.length; i++) this.offsets[i] >>>= 1;\n    this._processed = false;\n  }\n};\nvar $2b2b260902b1c57e$export$2e2bcd8739ae039 = $2b2b260902b1c57e$var$loca;\nvar\n// Set of instructions executed whenever the point size or font transformation change\n$7afb878c7bea4f66$export$2e2bcd8739ae039 = new $6uUbQ$Struct({\n  controlValueProgram: new $6uUbQ$Array($6uUbQ$uint8)\n});\nvar\n// only used for encoding\n$6c92b6371bce8bd9$export$2e2bcd8739ae039 = new $6uUbQ$Array(new $6uUbQ$Buffer());\nclass $43e9821ef3717eec$export$2e2bcd8739ae039 {\n  getCFFVersion(ctx) {\n    while (ctx && !ctx.hdrSize) ctx = ctx.parent;\n    return ctx ? ctx.version : -1;\n  }\n  decode(stream, parent) {\n    let version = this.getCFFVersion(parent);\n    let count = version >= 2 ? stream.readUInt32BE() : stream.readUInt16BE();\n    if (count === 0) return [];\n    let offSize = stream.readUInt8();\n    let offsetType;\n    if (offSize === 1) offsetType = $6uUbQ$uint8;else if (offSize === 2) offsetType = $6uUbQ$uint16;else if (offSize === 3) offsetType = $6uUbQ$uint24;else if (offSize === 4) offsetType = $6uUbQ$uint32;else throw new Error(`Bad offset size in CFFIndex: ${offSize} ${stream.pos}`);\n    let ret = [];\n    let startPos = stream.pos + (count + 1) * offSize - 1;\n    let start = offsetType.decode(stream);\n    for (let i = 0; i < count; i++) {\n      let end = offsetType.decode(stream);\n      if (this.type != null) {\n        let pos = stream.pos;\n        stream.pos = startPos + start;\n        parent.length = end - start;\n        ret.push(this.type.decode(stream, parent));\n        stream.pos = pos;\n      } else ret.push({\n        offset: startPos + start,\n        length: end - start\n      });\n      start = end;\n    }\n    stream.pos = startPos + start;\n    return ret;\n  }\n  size(arr, parent) {\n    let size = 2;\n    if (arr.length === 0) return size;\n    let type = this.type || new $6uUbQ$Buffer();\n    // find maximum offset to detminine offset type\n    let offset = 1;\n    for (let i = 0; i < arr.length; i++) {\n      let item = arr[i];\n      offset += type.size(item, parent);\n    }\n    let offsetType;\n    if (offset <= 0xff) offsetType = $6uUbQ$uint8;else if (offset <= 0xffff) offsetType = $6uUbQ$uint16;else if (offset <= 0xffffff) offsetType = $6uUbQ$uint24;else if (offset <= 0xffffffff) offsetType = $6uUbQ$uint32;else throw new Error(\"Bad offset in CFFIndex\");\n    size += 1 + offsetType.size() * (arr.length + 1);\n    size += offset - 1;\n    return size;\n  }\n  encode(stream, arr, parent) {\n    stream.writeUInt16BE(arr.length);\n    if (arr.length === 0) return;\n    let type = this.type || new $6uUbQ$Buffer();\n    // find maximum offset to detminine offset type\n    let sizes = [];\n    let offset = 1;\n    for (let item of arr) {\n      let s = type.size(item, parent);\n      sizes.push(s);\n      offset += s;\n    }\n    let offsetType;\n    if (offset <= 0xff) offsetType = $6uUbQ$uint8;else if (offset <= 0xffff) offsetType = $6uUbQ$uint16;else if (offset <= 0xffffff) offsetType = $6uUbQ$uint24;else if (offset <= 0xffffffff) offsetType = $6uUbQ$uint32;else throw new Error(\"Bad offset in CFFIndex\");\n    // write offset size\n    stream.writeUInt8(offsetType.size());\n    // write elements\n    offset = 1;\n    offsetType.encode(stream, offset);\n    for (let size of sizes) {\n      offset += size;\n      offsetType.encode(stream, offset);\n    }\n    for (let item of arr) type.encode(stream, item, parent);\n    return;\n  }\n  constructor(type) {\n    this.type = type;\n  }\n}\nconst $c2d28e92708f99da$var$FLOAT_EOF = 0xf;\nconst $c2d28e92708f99da$var$FLOAT_LOOKUP = ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '.', 'E', 'E-', null, '-'];\nconst $c2d28e92708f99da$var$FLOAT_ENCODE_LOOKUP = {\n  '.': 10,\n  'E': 11,\n  'E-': 12,\n  '-': 14\n};\nclass $c2d28e92708f99da$export$2e2bcd8739ae039 {\n  static decode(stream, value) {\n    if (32 <= value && value <= 246) return value - 139;\n    if (247 <= value && value <= 250) return (value - 247) * 256 + stream.readUInt8() + 108;\n    if (251 <= value && value <= 254) return -(value - 251) * 256 - stream.readUInt8() - 108;\n    if (value === 28) return stream.readInt16BE();\n    if (value === 29) return stream.readInt32BE();\n    if (value === 30) {\n      let str = '';\n      while (true) {\n        let b = stream.readUInt8();\n        let n1 = b >> 4;\n        if (n1 === $c2d28e92708f99da$var$FLOAT_EOF) break;\n        str += $c2d28e92708f99da$var$FLOAT_LOOKUP[n1];\n        let n2 = b & 15;\n        if (n2 === $c2d28e92708f99da$var$FLOAT_EOF) break;\n        str += $c2d28e92708f99da$var$FLOAT_LOOKUP[n2];\n      }\n      return parseFloat(str);\n    }\n    return null;\n  }\n  static size(value) {\n    // if the value needs to be forced to the largest size (32 bit)\n    // e.g. for unknown pointers, set to 32768\n    if (value.forceLarge) value = 32768;\n    if ((value | 0) !== value) {\n      let str = '' + value;\n      return 1 + Math.ceil((str.length + 1) / 2);\n    } else if (-107 <= value && value <= 107) return 1;else if (108 <= value && value <= 1131 || -1131 <= value && value <= -108) return 2;else if (-32768 <= value && value <= 32767) return 3;else return 5;\n  }\n  static encode(stream, value) {\n    // if the value needs to be forced to the largest size (32 bit)\n    // e.g. for unknown pointers, save the old value and set to 32768\n    let val = Number(value);\n    if (value.forceLarge) {\n      stream.writeUInt8(29);\n      return stream.writeInt32BE(val);\n    } else if ((val | 0) !== val) {\n      stream.writeUInt8(30);\n      let str = '' + val;\n      for (let i = 0; i < str.length; i += 2) {\n        let c1 = str[i];\n        let n1 = $c2d28e92708f99da$var$FLOAT_ENCODE_LOOKUP[c1] || +c1;\n        if (i === str.length - 1) var n2 = $c2d28e92708f99da$var$FLOAT_EOF;else {\n          let c2 = str[i + 1];\n          var n2 = $c2d28e92708f99da$var$FLOAT_ENCODE_LOOKUP[c2] || +c2;\n        }\n        stream.writeUInt8(n1 << 4 | n2 & 15);\n      }\n      if (n2 !== $c2d28e92708f99da$var$FLOAT_EOF) return stream.writeUInt8($c2d28e92708f99da$var$FLOAT_EOF << 4);\n    } else if (-107 <= val && val <= 107) return stream.writeUInt8(val + 139);else if (108 <= val && val <= 1131) {\n      val -= 108;\n      stream.writeUInt8((val >> 8) + 247);\n      return stream.writeUInt8(val & 0xff);\n    } else if (-1131 <= val && val <= -108) {\n      val = -val - 108;\n      stream.writeUInt8((val >> 8) + 251);\n      return stream.writeUInt8(val & 0xff);\n    } else if (-32768 <= val && val <= 32767) {\n      stream.writeUInt8(28);\n      return stream.writeInt16BE(val);\n    } else {\n      stream.writeUInt8(29);\n      return stream.writeInt32BE(val);\n    }\n  }\n}\nclass $61aa549f16d58b9b$export$2e2bcd8739ae039 {\n  decodeOperands(type, stream, ret, operands) {\n    if (Array.isArray(type)) return operands.map((op, i) => this.decodeOperands(type[i], stream, ret, [op]));else if (type.decode != null) return type.decode(stream, ret, operands);else switch (type) {\n      case 'number':\n      case 'offset':\n      case 'sid':\n        return operands[0];\n      case 'boolean':\n        return !!operands[0];\n      default:\n        return operands;\n    }\n  }\n  encodeOperands(type, stream, ctx, operands) {\n    if (Array.isArray(type)) return operands.map((op, i) => this.encodeOperands(type[i], stream, ctx, op)[0]);else if (type.encode != null) return type.encode(stream, operands, ctx);else if (typeof operands === 'number') return [operands];else if (typeof operands === 'boolean') return [+operands];else if (Array.isArray(operands)) return operands;else return [operands];\n  }\n  decode(stream, parent) {\n    let end = stream.pos + parent.length;\n    let ret = {};\n    let operands = [];\n    // define hidden properties\n    Object.defineProperties(ret, {\n      parent: {\n        value: parent\n      },\n      _startOffset: {\n        value: stream.pos\n      }\n    });\n    // fill in defaults\n    for (let key in this.fields) {\n      let field = this.fields[key];\n      ret[field[1]] = field[3];\n    }\n    while (stream.pos < end) {\n      let b = stream.readUInt8();\n      if (b < 28) {\n        if (b === 12) b = b << 8 | stream.readUInt8();\n        let field = this.fields[b];\n        if (!field) throw new Error(`Unknown operator ${b}`);\n        let val = this.decodeOperands(field[2], stream, ret, operands);\n        if (val != null) {\n          if (val instanceof (0, $6uUbQ$PropertyDescriptor)) Object.defineProperty(ret, field[1], val);else ret[field[1]] = val;\n        }\n        operands = [];\n      } else operands.push((0, $c2d28e92708f99da$export$2e2bcd8739ae039).decode(stream, b));\n    }\n    return ret;\n  }\n  size(dict, parent) {\n    let includePointers = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n    let ctx = {\n      parent: parent,\n      val: dict,\n      pointerSize: 0,\n      startOffset: parent.startOffset || 0\n    };\n    let len = 0;\n    for (let k in this.fields) {\n      let field = this.fields[k];\n      let val = dict[field[1]];\n      if (val == null || (0, $6uUbQ$fastdeepequal)(val, field[3])) continue;\n      let operands = this.encodeOperands(field[2], null, ctx, val);\n      for (let op of operands) len += (0, $c2d28e92708f99da$export$2e2bcd8739ae039).size(op);\n      let key = Array.isArray(field[0]) ? field[0] : [field[0]];\n      len += key.length;\n    }\n    if (includePointers) len += ctx.pointerSize;\n    return len;\n  }\n  encode(stream, dict, parent) {\n    let ctx = {\n      pointers: [],\n      startOffset: stream.pos,\n      parent: parent,\n      val: dict,\n      pointerSize: 0\n    };\n    ctx.pointerOffset = stream.pos + this.size(dict, ctx, false);\n    for (let field of this.ops) {\n      let val = dict[field[1]];\n      if (val == null || (0, $6uUbQ$fastdeepequal)(val, field[3])) continue;\n      let operands = this.encodeOperands(field[2], stream, ctx, val);\n      for (let op of operands) (0, $c2d28e92708f99da$export$2e2bcd8739ae039).encode(stream, op);\n      let key = Array.isArray(field[0]) ? field[0] : [field[0]];\n      for (let op of key) stream.writeUInt8(op);\n    }\n    let i = 0;\n    while (i < ctx.pointers.length) {\n      let ptr = ctx.pointers[i++];\n      ptr.type.encode(stream, ptr.val, ptr.parent);\n    }\n    return;\n  }\n  constructor() {\n    let ops = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n    this.ops = ops;\n    this.fields = {};\n    for (let field of ops) {\n      let key = Array.isArray(field[0]) ? field[0][0] << 8 | field[0][1] : field[0];\n      this.fields[key] = field;\n    }\n  }\n}\nclass $0e34a43d05bde82c$export$2e2bcd8739ae039 extends $6uUbQ$Pointer {\n  decode(stream, parent, operands) {\n    this.offsetType = {\n      decode: () => operands[0]\n    };\n    return super.decode(stream, parent, operands);\n  }\n  encode(stream, value, ctx) {\n    if (!stream) {\n      // compute the size (so ctx.pointerSize is correct)\n      this.offsetType = {\n        size: () => 0\n      };\n      this.size(value, ctx);\n      return [new $0e34a43d05bde82c$var$Ptr(0)];\n    }\n    let ptr = null;\n    this.offsetType = {\n      encode: (stream, val) => ptr = val\n    };\n    super.encode(stream, value, ctx);\n    return [new $0e34a43d05bde82c$var$Ptr(ptr)];\n  }\n  constructor(type) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    if (options.type == null) options.type = 'global';\n    super(null, type, options);\n  }\n}\nclass $0e34a43d05bde82c$var$Ptr {\n  valueOf() {\n    return this.val;\n  }\n  constructor(val) {\n    this.val = val;\n    this.forceLarge = true;\n  }\n}\nclass $6d59db2e29cc77b3$var$CFFBlendOp {\n  static decode(stream, parent, operands) {\n    let numBlends = operands.pop();\n    // TODO: actually blend. For now just consume the deltas\n    // since we don't use any of the values anyway.\n    while (operands.length > numBlends) operands.pop();\n  }\n}\nvar $6d59db2e29cc77b3$export$2e2bcd8739ae039 = new (0, $61aa549f16d58b9b$export$2e2bcd8739ae039)([\n// key       name                    type                                          default\n[6, 'BlueValues', 'delta', null], [7, 'OtherBlues', 'delta', null], [8, 'FamilyBlues', 'delta', null], [9, 'FamilyOtherBlues', 'delta', null], [[12, 9], 'BlueScale', 'number', 0.039625], [[12, 10], 'BlueShift', 'number', 7], [[12, 11], 'BlueFuzz', 'number', 1], [10, 'StdHW', 'number', null], [11, 'StdVW', 'number', null], [[12, 12], 'StemSnapH', 'delta', null], [[12, 13], 'StemSnapV', 'delta', null], [[12, 14], 'ForceBold', 'boolean', false], [[12, 17], 'LanguageGroup', 'number', 0], [[12, 18], 'ExpansionFactor', 'number', 0.06], [[12, 19], 'initialRandomSeed', 'number', 0], [20, 'defaultWidthX', 'number', 0], [21, 'nominalWidthX', 'number', 0], [22, 'vsindex', 'number', 0], [23, 'blend', $6d59db2e29cc77b3$var$CFFBlendOp, null], [19, 'Subrs', new (0, $0e34a43d05bde82c$export$2e2bcd8739ae039)(new (0, $43e9821ef3717eec$export$2e2bcd8739ae039)(), {\n  type: 'local'\n}), null]]);\n\n// Automatically generated from Appendix A of the CFF specification; do\n// not edit. Length should be 391.\nvar $229224aec43783c5$export$2e2bcd8739ae039 = [\".notdef\", \"space\", \"exclam\", \"quotedbl\", \"numbersign\", \"dollar\", \"percent\", \"ampersand\", \"quoteright\", \"parenleft\", \"parenright\", \"asterisk\", \"plus\", \"comma\", \"hyphen\", \"period\", \"slash\", \"zero\", \"one\", \"two\", \"three\", \"four\", \"five\", \"six\", \"seven\", \"eight\", \"nine\", \"colon\", \"semicolon\", \"less\", \"equal\", \"greater\", \"question\", \"at\", \"A\", \"B\", \"C\", \"D\", \"E\", \"F\", \"G\", \"H\", \"I\", \"J\", \"K\", \"L\", \"M\", \"N\", \"O\", \"P\", \"Q\", \"R\", \"S\", \"T\", \"U\", \"V\", \"W\", \"X\", \"Y\", \"Z\", \"bracketleft\", \"backslash\", \"bracketright\", \"asciicircum\", \"underscore\", \"quoteleft\", \"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\", \"h\", \"i\", \"j\", \"k\", \"l\", \"m\", \"n\", \"o\", \"p\", \"q\", \"r\", \"s\", \"t\", \"u\", \"v\", \"w\", \"x\", \"y\", \"z\", \"braceleft\", \"bar\", \"braceright\", \"asciitilde\", \"exclamdown\", \"cent\", \"sterling\", \"fraction\", \"yen\", \"florin\", \"section\", \"currency\", \"quotesingle\", \"quotedblleft\", \"guillemotleft\", \"guilsinglleft\", \"guilsinglright\", \"fi\", \"fl\", \"endash\", \"dagger\", \"daggerdbl\", \"periodcentered\", \"paragraph\", \"bullet\", \"quotesinglbase\", \"quotedblbase\", \"quotedblright\", \"guillemotright\", \"ellipsis\", \"perthousand\", \"questiondown\", \"grave\", \"acute\", \"circumflex\", \"tilde\", \"macron\", \"breve\", \"dotaccent\", \"dieresis\", \"ring\", \"cedilla\", \"hungarumlaut\", \"ogonek\", \"caron\", \"emdash\", \"AE\", \"ordfeminine\", \"Lslash\", \"Oslash\", \"OE\", \"ordmasculine\", \"ae\", \"dotlessi\", \"lslash\", \"oslash\", \"oe\", \"germandbls\", \"onesuperior\", \"logicalnot\", \"mu\", \"trademark\", \"Eth\", \"onehalf\", \"plusminus\", \"Thorn\", \"onequarter\", \"divide\", \"brokenbar\", \"degree\", \"thorn\", \"threequarters\", \"twosuperior\", \"registered\", \"minus\", \"eth\", \"multiply\", \"threesuperior\", \"copyright\", \"Aacute\", \"Acircumflex\", \"Adieresis\", \"Agrave\", \"Aring\", \"Atilde\", \"Ccedilla\", \"Eacute\", \"Ecircumflex\", \"Edieresis\", \"Egrave\", \"Iacute\", \"Icircumflex\", \"Idieresis\", \"Igrave\", \"Ntilde\", \"Oacute\", \"Ocircumflex\", \"Odieresis\", \"Ograve\", \"Otilde\", \"Scaron\", \"Uacute\", \"Ucircumflex\", \"Udieresis\", \"Ugrave\", \"Yacute\", \"Ydieresis\", \"Zcaron\", \"aacute\", \"acircumflex\", \"adieresis\", \"agrave\", \"aring\", \"atilde\", \"ccedilla\", \"eacute\", \"ecircumflex\", \"edieresis\", \"egrave\", \"iacute\", \"icircumflex\", \"idieresis\", \"igrave\", \"ntilde\", \"oacute\", \"ocircumflex\", \"odieresis\", \"ograve\", \"otilde\", \"scaron\", \"uacute\", \"ucircumflex\", \"udieresis\", \"ugrave\", \"yacute\", \"ydieresis\", \"zcaron\", \"exclamsmall\", \"Hungarumlautsmall\", \"dollaroldstyle\", \"dollarsuperior\", \"ampersandsmall\", \"Acutesmall\", \"parenleftsuperior\", \"parenrightsuperior\", \"twodotenleader\", \"onedotenleader\", \"zerooldstyle\", \"oneoldstyle\", \"twooldstyle\", \"threeoldstyle\", \"fouroldstyle\", \"fiveoldstyle\", \"sixoldstyle\", \"sevenoldstyle\", \"eightoldstyle\", \"nineoldstyle\", \"commasuperior\", \"threequartersemdash\", \"periodsuperior\", \"questionsmall\", \"asuperior\", \"bsuperior\", \"centsuperior\", \"dsuperior\", \"esuperior\", \"isuperior\", \"lsuperior\", \"msuperior\", \"nsuperior\", \"osuperior\", \"rsuperior\", \"ssuperior\", \"tsuperior\", \"ff\", \"ffi\", \"ffl\", \"parenleftinferior\", \"parenrightinferior\", \"Circumflexsmall\", \"hyphensuperior\", \"Gravesmall\", \"Asmall\", \"Bsmall\", \"Csmall\", \"Dsmall\", \"Esmall\", \"Fsmall\", \"Gsmall\", \"Hsmall\", \"Ismall\", \"Jsmall\", \"Ksmall\", \"Lsmall\", \"Msmall\", \"Nsmall\", \"Osmall\", \"Psmall\", \"Qsmall\", \"Rsmall\", \"Ssmall\", \"Tsmall\", \"Usmall\", \"Vsmall\", \"Wsmall\", \"Xsmall\", \"Ysmall\", \"Zsmall\", \"colonmonetary\", \"onefitted\", \"rupiah\", \"Tildesmall\", \"exclamdownsmall\", \"centoldstyle\", \"Lslashsmall\", \"Scaronsmall\", \"Zcaronsmall\", \"Dieresissmall\", \"Brevesmall\", \"Caronsmall\", \"Dotaccentsmall\", \"Macronsmall\", \"figuredash\", \"hypheninferior\", \"Ogoneksmall\", \"Ringsmall\", \"Cedillasmall\", \"questiondownsmall\", \"oneeighth\", \"threeeighths\", \"fiveeighths\", \"seveneighths\", \"onethird\", \"twothirds\", \"zerosuperior\", \"foursuperior\", \"fivesuperior\", \"sixsuperior\", \"sevensuperior\", \"eightsuperior\", \"ninesuperior\", \"zeroinferior\", \"oneinferior\", \"twoinferior\", \"threeinferior\", \"fourinferior\", \"fiveinferior\", \"sixinferior\", \"seveninferior\", \"eightinferior\", \"nineinferior\", \"centinferior\", \"dollarinferior\", \"periodinferior\", \"commainferior\", \"Agravesmall\", \"Aacutesmall\", \"Acircumflexsmall\", \"Atildesmall\", \"Adieresissmall\", \"Aringsmall\", \"AEsmall\", \"Ccedillasmall\", \"Egravesmall\", \"Eacutesmall\", \"Ecircumflexsmall\", \"Edieresissmall\", \"Igravesmall\", \"Iacutesmall\", \"Icircumflexsmall\", \"Idieresissmall\", \"Ethsmall\", \"Ntildesmall\", \"Ogravesmall\", \"Oacutesmall\", \"Ocircumflexsmall\", \"Otildesmall\", \"Odieresissmall\", \"OEsmall\", \"Oslashsmall\", \"Ugravesmall\", \"Uacutesmall\", \"Ucircumflexsmall\", \"Udieresissmall\", \"Yacutesmall\", \"Thornsmall\", \"Ydieresissmall\", \"001.000\", \"001.001\", \"001.002\", \"001.003\", \"Black\", \"Bold\", \"Book\", \"Light\", \"Medium\", \"Regular\", \"Roman\", \"Semibold\"];\nlet $bc0433d9b7e41f5f$export$dee0027060fa13bd = ['', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', 'space', 'exclam', 'quotedbl', 'numbersign', 'dollar', 'percent', 'ampersand', 'quoteright', 'parenleft', 'parenright', 'asterisk', 'plus', 'comma', 'hyphen', 'period', 'slash', 'zero', 'one', 'two', 'three', 'four', 'five', 'six', 'seven', 'eight', 'nine', 'colon', 'semicolon', 'less', 'equal', 'greater', 'question', 'at', 'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z', 'bracketleft', 'backslash', 'bracketright', 'asciicircum', 'underscore', 'quoteleft', 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z', 'braceleft', 'bar', 'braceright', 'asciitilde', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', 'exclamdown', 'cent', 'sterling', 'fraction', 'yen', 'florin', 'section', 'currency', 'quotesingle', 'quotedblleft', 'guillemotleft', 'guilsinglleft', 'guilsinglright', 'fi', 'fl', '', 'endash', 'dagger', 'daggerdbl', 'periodcentered', '', 'paragraph', 'bullet', 'quotesinglbase', 'quotedblbase', 'quotedblright', 'guillemotright', 'ellipsis', 'perthousand', '', 'questiondown', '', 'grave', 'acute', 'circumflex', 'tilde', 'macron', 'breve', 'dotaccent', 'dieresis', '', 'ring', 'cedilla', '', 'hungarumlaut', 'ogonek', 'caron', 'emdash', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', 'AE', '', 'ordfeminine', '', '', '', '', 'Lslash', 'Oslash', 'OE', 'ordmasculine', '', '', '', '', '', 'ae', '', '', '', 'dotlessi', '', '', 'lslash', 'oslash', 'oe', 'germandbls'];\nlet $bc0433d9b7e41f5f$export$4f58f497e14a53c3 = ['', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', 'space', 'exclamsmall', 'Hungarumlautsmall', '', 'dollaroldstyle', 'dollarsuperior', 'ampersandsmall', 'Acutesmall', 'parenleftsuperior', 'parenrightsuperior', 'twodotenleader', 'onedotenleader', 'comma', 'hyphen', 'period', 'fraction', 'zerooldstyle', 'oneoldstyle', 'twooldstyle', 'threeoldstyle', 'fouroldstyle', 'fiveoldstyle', 'sixoldstyle', 'sevenoldstyle', 'eightoldstyle', 'nineoldstyle', 'colon', 'semicolon', 'commasuperior', 'threequartersemdash', 'periodsuperior', 'questionsmall', '', 'asuperior', 'bsuperior', 'centsuperior', 'dsuperior', 'esuperior', '', '', 'isuperior', '', '', 'lsuperior', 'msuperior', 'nsuperior', 'osuperior', '', '', 'rsuperior', 'ssuperior', 'tsuperior', '', 'ff', 'fi', 'fl', 'ffi', 'ffl', 'parenleftinferior', '', 'parenrightinferior', 'Circumflexsmall', 'hyphensuperior', 'Gravesmall', 'Asmall', 'Bsmall', 'Csmall', 'Dsmall', 'Esmall', 'Fsmall', 'Gsmall', 'Hsmall', 'Ismall', 'Jsmall', 'Ksmall', 'Lsmall', 'Msmall', 'Nsmall', 'Osmall', 'Psmall', 'Qsmall', 'Rsmall', 'Ssmall', 'Tsmall', 'Usmall', 'Vsmall', 'Wsmall', 'Xsmall', 'Ysmall', 'Zsmall', 'colonmonetary', 'onefitted', 'rupiah', 'Tildesmall', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', 'exclamdownsmall', 'centoldstyle', 'Lslashsmall', '', '', 'Scaronsmall', 'Zcaronsmall', 'Dieresissmall', 'Brevesmall', 'Caronsmall', '', 'Dotaccentsmall', '', '', 'Macronsmall', '', '', 'figuredash', 'hypheninferior', '', '', 'Ogoneksmall', 'Ringsmall', 'Cedillasmall', '', '', '', 'onequarter', 'onehalf', 'threequarters', 'questiondownsmall', 'oneeighth', 'threeeighths', 'fiveeighths', 'seveneighths', 'onethird', 'twothirds', '', '', 'zerosuperior', 'onesuperior', 'twosuperior', 'threesuperior', 'foursuperior', 'fivesuperior', 'sixsuperior', 'sevensuperior', 'eightsuperior', 'ninesuperior', 'zeroinferior', 'oneinferior', 'twoinferior', 'threeinferior', 'fourinferior', 'fiveinferior', 'sixinferior', 'seveninferior', 'eightinferior', 'nineinferior', 'centinferior', 'dollarinferior', 'periodinferior', 'commainferior', 'Agravesmall', 'Aacutesmall', 'Acircumflexsmall', 'Atildesmall', 'Adieresissmall', 'Aringsmall', 'AEsmall', 'Ccedillasmall', 'Egravesmall', 'Eacutesmall', 'Ecircumflexsmall', 'Edieresissmall', 'Igravesmall', 'Iacutesmall', 'Icircumflexsmall', 'Idieresissmall', 'Ethsmall', 'Ntildesmall', 'Ogravesmall', 'Oacutesmall', 'Ocircumflexsmall', 'Otildesmall', 'Odieresissmall', 'OEsmall', 'Oslashsmall', 'Ugravesmall', 'Uacutesmall', 'Ucircumflexsmall', 'Udieresissmall', 'Yacutesmall', 'Thornsmall', 'Ydieresissmall'];\nlet $ef658f5c9a1488b2$export$c33b50336c234f16 = ['.notdef', 'space', 'exclam', 'quotedbl', 'numbersign', 'dollar', 'percent', 'ampersand', 'quoteright', 'parenleft', 'parenright', 'asterisk', 'plus', 'comma', 'hyphen', 'period', 'slash', 'zero', 'one', 'two', 'three', 'four', 'five', 'six', 'seven', 'eight', 'nine', 'colon', 'semicolon', 'less', 'equal', 'greater', 'question', 'at', 'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z', 'bracketleft', 'backslash', 'bracketright', 'asciicircum', 'underscore', 'quoteleft', 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z', 'braceleft', 'bar', 'braceright', 'asciitilde', 'exclamdown', 'cent', 'sterling', 'fraction', 'yen', 'florin', 'section', 'currency', 'quotesingle', 'quotedblleft', 'guillemotleft', 'guilsinglleft', 'guilsinglright', 'fi', 'fl', 'endash', 'dagger', 'daggerdbl', 'periodcentered', 'paragraph', 'bullet', 'quotesinglbase', 'quotedblbase', 'quotedblright', 'guillemotright', 'ellipsis', 'perthousand', 'questiondown', 'grave', 'acute', 'circumflex', 'tilde', 'macron', 'breve', 'dotaccent', 'dieresis', 'ring', 'cedilla', 'hungarumlaut', 'ogonek', 'caron', 'emdash', 'AE', 'ordfeminine', 'Lslash', 'Oslash', 'OE', 'ordmasculine', 'ae', 'dotlessi', 'lslash', 'oslash', 'oe', 'germandbls', 'onesuperior', 'logicalnot', 'mu', 'trademark', 'Eth', 'onehalf', 'plusminus', 'Thorn', 'onequarter', 'divide', 'brokenbar', 'degree', 'thorn', 'threequarters', 'twosuperior', 'registered', 'minus', 'eth', 'multiply', 'threesuperior', 'copyright', 'Aacute', 'Acircumflex', 'Adieresis', 'Agrave', 'Aring', 'Atilde', 'Ccedilla', 'Eacute', 'Ecircumflex', 'Edieresis', 'Egrave', 'Iacute', 'Icircumflex', 'Idieresis', 'Igrave', 'Ntilde', 'Oacute', 'Ocircumflex', 'Odieresis', 'Ograve', 'Otilde', 'Scaron', 'Uacute', 'Ucircumflex', 'Udieresis', 'Ugrave', 'Yacute', 'Ydieresis', 'Zcaron', 'aacute', 'acircumflex', 'adieresis', 'agrave', 'aring', 'atilde', 'ccedilla', 'eacute', 'ecircumflex', 'edieresis', 'egrave', 'iacute', 'icircumflex', 'idieresis', 'igrave', 'ntilde', 'oacute', 'ocircumflex', 'odieresis', 'ograve', 'otilde', 'scaron', 'uacute', 'ucircumflex', 'udieresis', 'ugrave', 'yacute', 'ydieresis', 'zcaron'];\nlet $ef658f5c9a1488b2$export$3ed0f9e1fee8d489 = ['.notdef', 'space', 'exclamsmall', 'Hungarumlautsmall', 'dollaroldstyle', 'dollarsuperior', 'ampersandsmall', 'Acutesmall', 'parenleftsuperior', 'parenrightsuperior', 'twodotenleader', 'onedotenleader', 'comma', 'hyphen', 'period', 'fraction', 'zerooldstyle', 'oneoldstyle', 'twooldstyle', 'threeoldstyle', 'fouroldstyle', 'fiveoldstyle', 'sixoldstyle', 'sevenoldstyle', 'eightoldstyle', 'nineoldstyle', 'colon', 'semicolon', 'commasuperior', 'threequartersemdash', 'periodsuperior', 'questionsmall', 'asuperior', 'bsuperior', 'centsuperior', 'dsuperior', 'esuperior', 'isuperior', 'lsuperior', 'msuperior', 'nsuperior', 'osuperior', 'rsuperior', 'ssuperior', 'tsuperior', 'ff', 'fi', 'fl', 'ffi', 'ffl', 'parenleftinferior', 'parenrightinferior', 'Circumflexsmall', 'hyphensuperior', 'Gravesmall', 'Asmall', 'Bsmall', 'Csmall', 'Dsmall', 'Esmall', 'Fsmall', 'Gsmall', 'Hsmall', 'Ismall', 'Jsmall', 'Ksmall', 'Lsmall', 'Msmall', 'Nsmall', 'Osmall', 'Psmall', 'Qsmall', 'Rsmall', 'Ssmall', 'Tsmall', 'Usmall', 'Vsmall', 'Wsmall', 'Xsmall', 'Ysmall', 'Zsmall', 'colonmonetary', 'onefitted', 'rupiah', 'Tildesmall', 'exclamdownsmall', 'centoldstyle', 'Lslashsmall', 'Scaronsmall', 'Zcaronsmall', 'Dieresissmall', 'Brevesmall', 'Caronsmall', 'Dotaccentsmall', 'Macronsmall', 'figuredash', 'hypheninferior', 'Ogoneksmall', 'Ringsmall', 'Cedillasmall', 'onequarter', 'onehalf', 'threequarters', 'questiondownsmall', 'oneeighth', 'threeeighths', 'fiveeighths', 'seveneighths', 'onethird', 'twothirds', 'zerosuperior', 'onesuperior', 'twosuperior', 'threesuperior', 'foursuperior', 'fivesuperior', 'sixsuperior', 'sevensuperior', 'eightsuperior', 'ninesuperior', 'zeroinferior', 'oneinferior', 'twoinferior', 'threeinferior', 'fourinferior', 'fiveinferior', 'sixinferior', 'seveninferior', 'eightinferior', 'nineinferior', 'centinferior', 'dollarinferior', 'periodinferior', 'commainferior', 'Agravesmall', 'Aacutesmall', 'Acircumflexsmall', 'Atildesmall', 'Adieresissmall', 'Aringsmall', 'AEsmall', 'Ccedillasmall', 'Egravesmall', 'Eacutesmall', 'Ecircumflexsmall', 'Edieresissmall', 'Igravesmall', 'Iacutesmall', 'Icircumflexsmall', 'Idieresissmall', 'Ethsmall', 'Ntildesmall', 'Ogravesmall', 'Oacutesmall', 'Ocircumflexsmall', 'Otildesmall', 'Odieresissmall', 'OEsmall', 'Oslashsmall', 'Ugravesmall', 'Uacutesmall', 'Ucircumflexsmall', 'Udieresissmall', 'Yacutesmall', 'Thornsmall', 'Ydieresissmall'];\nlet $ef658f5c9a1488b2$export$dc28be11139d4120 = ['.notdef', 'space', 'dollaroldstyle', 'dollarsuperior', 'parenleftsuperior', 'parenrightsuperior', 'twodotenleader', 'onedotenleader', 'comma', 'hyphen', 'period', 'fraction', 'zerooldstyle', 'oneoldstyle', 'twooldstyle', 'threeoldstyle', 'fouroldstyle', 'fiveoldstyle', 'sixoldstyle', 'sevenoldstyle', 'eightoldstyle', 'nineoldstyle', 'colon', 'semicolon', 'commasuperior', 'threequartersemdash', 'periodsuperior', 'asuperior', 'bsuperior', 'centsuperior', 'dsuperior', 'esuperior', 'isuperior', 'lsuperior', 'msuperior', 'nsuperior', 'osuperior', 'rsuperior', 'ssuperior', 'tsuperior', 'ff', 'fi', 'fl', 'ffi', 'ffl', 'parenleftinferior', 'parenrightinferior', 'hyphensuperior', 'colonmonetary', 'onefitted', 'rupiah', 'centoldstyle', 'figuredash', 'hypheninferior', 'onequarter', 'onehalf', 'threequarters', 'oneeighth', 'threeeighths', 'fiveeighths', 'seveneighths', 'onethird', 'twothirds', 'zerosuperior', 'onesuperior', 'twosuperior', 'threesuperior', 'foursuperior', 'fivesuperior', 'sixsuperior', 'sevensuperior', 'eightsuperior', 'ninesuperior', 'zeroinferior', 'oneinferior', 'twoinferior', 'threeinferior', 'fourinferior', 'fiveinferior', 'sixinferior', 'seveninferior', 'eightinferior', 'nineinferior', 'centinferior', 'dollarinferior', 'periodinferior', 'commainferior'];\n\n//########################\n// Scripts and Languages #\n//########################\nlet $7cbbe4e24ef3cb75$var$LangSysTable = new $6uUbQ$Struct({\n  reserved: new $6uUbQ$Reserved($6uUbQ$uint16),\n  reqFeatureIndex: $6uUbQ$uint16,\n  featureCount: $6uUbQ$uint16,\n  featureIndexes: new $6uUbQ$Array($6uUbQ$uint16, 'featureCount')\n});\nlet $7cbbe4e24ef3cb75$var$LangSysRecord = new $6uUbQ$Struct({\n  tag: new $6uUbQ$String(4),\n  langSys: new $6uUbQ$Pointer($6uUbQ$uint16, $7cbbe4e24ef3cb75$var$LangSysTable, {\n    type: 'parent'\n  })\n});\nlet $7cbbe4e24ef3cb75$var$Script = new $6uUbQ$Struct({\n  defaultLangSys: new $6uUbQ$Pointer($6uUbQ$uint16, $7cbbe4e24ef3cb75$var$LangSysTable),\n  count: $6uUbQ$uint16,\n  langSysRecords: new $6uUbQ$Array($7cbbe4e24ef3cb75$var$LangSysRecord, 'count')\n});\nlet $7cbbe4e24ef3cb75$var$ScriptRecord = new $6uUbQ$Struct({\n  tag: new $6uUbQ$String(4),\n  script: new $6uUbQ$Pointer($6uUbQ$uint16, $7cbbe4e24ef3cb75$var$Script, {\n    type: 'parent'\n  })\n});\nlet $7cbbe4e24ef3cb75$export$3e15fc05ce864229 = new $6uUbQ$Array($7cbbe4e24ef3cb75$var$ScriptRecord, $6uUbQ$uint16);\n//#######################\n// Features and Lookups #\n//#######################\nlet $7cbbe4e24ef3cb75$var$FeatureParams = new $6uUbQ$Struct({\n  version: $6uUbQ$uint16,\n  nameID: $6uUbQ$uint16\n});\nlet $7cbbe4e24ef3cb75$export$6e91cf7616333d5 = new $6uUbQ$Struct({\n  featureParams: new $6uUbQ$Pointer($6uUbQ$uint16, $7cbbe4e24ef3cb75$var$FeatureParams),\n  lookupCount: $6uUbQ$uint16,\n  lookupListIndexes: new $6uUbQ$Array($6uUbQ$uint16, 'lookupCount')\n});\nlet $7cbbe4e24ef3cb75$var$FeatureRecord = new $6uUbQ$Struct({\n  tag: new $6uUbQ$String(4),\n  feature: new $6uUbQ$Pointer($6uUbQ$uint16, $7cbbe4e24ef3cb75$export$6e91cf7616333d5, {\n    type: 'parent'\n  })\n});\nlet $7cbbe4e24ef3cb75$export$aa18130def4b6cb4 = new $6uUbQ$Array($7cbbe4e24ef3cb75$var$FeatureRecord, $6uUbQ$uint16);\nlet $7cbbe4e24ef3cb75$var$LookupFlags = new $6uUbQ$Struct({\n  markAttachmentType: $6uUbQ$uint8,\n  flags: new $6uUbQ$Bitfield($6uUbQ$uint8, ['rightToLeft', 'ignoreBaseGlyphs', 'ignoreLigatures', 'ignoreMarks', 'useMarkFilteringSet'])\n});\nfunction $7cbbe4e24ef3cb75$export$df0008c6ff2da22a(SubTable) {\n  let Lookup = new $6uUbQ$Struct({\n    lookupType: $6uUbQ$uint16,\n    flags: $7cbbe4e24ef3cb75$var$LookupFlags,\n    subTableCount: $6uUbQ$uint16,\n    subTables: new $6uUbQ$Array(new $6uUbQ$Pointer($6uUbQ$uint16, SubTable), 'subTableCount'),\n    markFilteringSet: new $6uUbQ$Optional($6uUbQ$uint16, t => t.flags.flags.useMarkFilteringSet)\n  });\n  return new $6uUbQ$LazyArray(new $6uUbQ$Pointer($6uUbQ$uint16, Lookup), $6uUbQ$uint16);\n}\n//#################\n// Coverage Table #\n//#################\nlet $7cbbe4e24ef3cb75$var$RangeRecord = new $6uUbQ$Struct({\n  start: $6uUbQ$uint16,\n  end: $6uUbQ$uint16,\n  startCoverageIndex: $6uUbQ$uint16\n});\nlet $7cbbe4e24ef3cb75$export$17608c3f81a6111 = new $6uUbQ$VersionedStruct($6uUbQ$uint16, {\n  1: {\n    glyphCount: $6uUbQ$uint16,\n    glyphs: new $6uUbQ$Array($6uUbQ$uint16, 'glyphCount')\n  },\n  2: {\n    rangeCount: $6uUbQ$uint16,\n    rangeRecords: new $6uUbQ$Array($7cbbe4e24ef3cb75$var$RangeRecord, 'rangeCount')\n  }\n});\n//#########################\n// Class Definition Table #\n//#########################\nlet $7cbbe4e24ef3cb75$var$ClassRangeRecord = new $6uUbQ$Struct({\n  start: $6uUbQ$uint16,\n  end: $6uUbQ$uint16,\n  class: $6uUbQ$uint16\n});\nlet $7cbbe4e24ef3cb75$export$843d551fbbafef71 = new $6uUbQ$VersionedStruct($6uUbQ$uint16, {\n  1: {\n    startGlyph: $6uUbQ$uint16,\n    glyphCount: $6uUbQ$uint16,\n    classValueArray: new $6uUbQ$Array($6uUbQ$uint16, 'glyphCount')\n  },\n  2: {\n    classRangeCount: $6uUbQ$uint16,\n    classRangeRecord: new $6uUbQ$Array($7cbbe4e24ef3cb75$var$ClassRangeRecord, 'classRangeCount')\n  }\n});\nlet $7cbbe4e24ef3cb75$export$8215d14a63d9fb10 = new $6uUbQ$Struct({\n  a: $6uUbQ$uint16,\n  b: $6uUbQ$uint16,\n  deltaFormat: $6uUbQ$uint16\n});\n//#############################################\n// Contextual Substitution/Positioning Tables #\n//#############################################\nlet $7cbbe4e24ef3cb75$var$LookupRecord = new $6uUbQ$Struct({\n  sequenceIndex: $6uUbQ$uint16,\n  lookupListIndex: $6uUbQ$uint16\n});\nlet $7cbbe4e24ef3cb75$var$Rule = new $6uUbQ$Struct({\n  glyphCount: $6uUbQ$uint16,\n  lookupCount: $6uUbQ$uint16,\n  input: new $6uUbQ$Array($6uUbQ$uint16, t => t.glyphCount - 1),\n  lookupRecords: new $6uUbQ$Array($7cbbe4e24ef3cb75$var$LookupRecord, 'lookupCount')\n});\nlet $7cbbe4e24ef3cb75$var$RuleSet = new $6uUbQ$Array(new $6uUbQ$Pointer($6uUbQ$uint16, $7cbbe4e24ef3cb75$var$Rule), $6uUbQ$uint16);\nlet $7cbbe4e24ef3cb75$var$ClassRule = new $6uUbQ$Struct({\n  glyphCount: $6uUbQ$uint16,\n  lookupCount: $6uUbQ$uint16,\n  classes: new $6uUbQ$Array($6uUbQ$uint16, t => t.glyphCount - 1),\n  lookupRecords: new $6uUbQ$Array($7cbbe4e24ef3cb75$var$LookupRecord, 'lookupCount')\n});\nlet $7cbbe4e24ef3cb75$var$ClassSet = new $6uUbQ$Array(new $6uUbQ$Pointer($6uUbQ$uint16, $7cbbe4e24ef3cb75$var$ClassRule), $6uUbQ$uint16);\nlet $7cbbe4e24ef3cb75$export$841858b892ce1f4c = new $6uUbQ$VersionedStruct($6uUbQ$uint16, {\n  1: {\n    coverage: new $6uUbQ$Pointer($6uUbQ$uint16, $7cbbe4e24ef3cb75$export$17608c3f81a6111),\n    ruleSetCount: $6uUbQ$uint16,\n    ruleSets: new $6uUbQ$Array(new $6uUbQ$Pointer($6uUbQ$uint16, $7cbbe4e24ef3cb75$var$RuleSet), 'ruleSetCount')\n  },\n  2: {\n    coverage: new $6uUbQ$Pointer($6uUbQ$uint16, $7cbbe4e24ef3cb75$export$17608c3f81a6111),\n    classDef: new $6uUbQ$Pointer($6uUbQ$uint16, $7cbbe4e24ef3cb75$export$843d551fbbafef71),\n    classSetCnt: $6uUbQ$uint16,\n    classSet: new $6uUbQ$Array(new $6uUbQ$Pointer($6uUbQ$uint16, $7cbbe4e24ef3cb75$var$ClassSet), 'classSetCnt')\n  },\n  3: {\n    glyphCount: $6uUbQ$uint16,\n    lookupCount: $6uUbQ$uint16,\n    coverages: new $6uUbQ$Array(new $6uUbQ$Pointer($6uUbQ$uint16, $7cbbe4e24ef3cb75$export$17608c3f81a6111), 'glyphCount'),\n    lookupRecords: new $6uUbQ$Array($7cbbe4e24ef3cb75$var$LookupRecord, 'lookupCount')\n  }\n});\n//######################################################\n// Chaining Contextual Substitution/Positioning Tables #\n//######################################################\nlet $7cbbe4e24ef3cb75$var$ChainRule = new $6uUbQ$Struct({\n  backtrackGlyphCount: $6uUbQ$uint16,\n  backtrack: new $6uUbQ$Array($6uUbQ$uint16, 'backtrackGlyphCount'),\n  inputGlyphCount: $6uUbQ$uint16,\n  input: new $6uUbQ$Array($6uUbQ$uint16, t => t.inputGlyphCount - 1),\n  lookaheadGlyphCount: $6uUbQ$uint16,\n  lookahead: new $6uUbQ$Array($6uUbQ$uint16, 'lookaheadGlyphCount'),\n  lookupCount: $6uUbQ$uint16,\n  lookupRecords: new $6uUbQ$Array($7cbbe4e24ef3cb75$var$LookupRecord, 'lookupCount')\n});\nlet $7cbbe4e24ef3cb75$var$ChainRuleSet = new $6uUbQ$Array(new $6uUbQ$Pointer($6uUbQ$uint16, $7cbbe4e24ef3cb75$var$ChainRule), $6uUbQ$uint16);\nlet $7cbbe4e24ef3cb75$export$5e6d09e6861162f6 = new $6uUbQ$VersionedStruct($6uUbQ$uint16, {\n  1: {\n    coverage: new $6uUbQ$Pointer($6uUbQ$uint16, $7cbbe4e24ef3cb75$export$17608c3f81a6111),\n    chainCount: $6uUbQ$uint16,\n    chainRuleSets: new $6uUbQ$Array(new $6uUbQ$Pointer($6uUbQ$uint16, $7cbbe4e24ef3cb75$var$ChainRuleSet), 'chainCount')\n  },\n  2: {\n    coverage: new $6uUbQ$Pointer($6uUbQ$uint16, $7cbbe4e24ef3cb75$export$17608c3f81a6111),\n    backtrackClassDef: new $6uUbQ$Pointer($6uUbQ$uint16, $7cbbe4e24ef3cb75$export$843d551fbbafef71),\n    inputClassDef: new $6uUbQ$Pointer($6uUbQ$uint16, $7cbbe4e24ef3cb75$export$843d551fbbafef71),\n    lookaheadClassDef: new $6uUbQ$Pointer($6uUbQ$uint16, $7cbbe4e24ef3cb75$export$843d551fbbafef71),\n    chainCount: $6uUbQ$uint16,\n    chainClassSet: new $6uUbQ$Array(new $6uUbQ$Pointer($6uUbQ$uint16, $7cbbe4e24ef3cb75$var$ChainRuleSet), 'chainCount')\n  },\n  3: {\n    backtrackGlyphCount: $6uUbQ$uint16,\n    backtrackCoverage: new $6uUbQ$Array(new $6uUbQ$Pointer($6uUbQ$uint16, $7cbbe4e24ef3cb75$export$17608c3f81a6111), 'backtrackGlyphCount'),\n    inputGlyphCount: $6uUbQ$uint16,\n    inputCoverage: new $6uUbQ$Array(new $6uUbQ$Pointer($6uUbQ$uint16, $7cbbe4e24ef3cb75$export$17608c3f81a6111), 'inputGlyphCount'),\n    lookaheadGlyphCount: $6uUbQ$uint16,\n    lookaheadCoverage: new $6uUbQ$Array(new $6uUbQ$Pointer($6uUbQ$uint16, $7cbbe4e24ef3cb75$export$17608c3f81a6111), 'lookaheadGlyphCount'),\n    lookupCount: $6uUbQ$uint16,\n    lookupRecords: new $6uUbQ$Array($7cbbe4e24ef3cb75$var$LookupRecord, 'lookupCount')\n  }\n});\n\n/*******************\n * Variation Store *\n *******************/\nlet $1a47b0c45c1c22fe$var$F2DOT14 = new $6uUbQ$Fixed(16, 'BE', 14);\nlet $1a47b0c45c1c22fe$var$RegionAxisCoordinates = new $6uUbQ$Struct({\n  startCoord: $1a47b0c45c1c22fe$var$F2DOT14,\n  peakCoord: $1a47b0c45c1c22fe$var$F2DOT14,\n  endCoord: $1a47b0c45c1c22fe$var$F2DOT14\n});\nlet $1a47b0c45c1c22fe$var$VariationRegionList = new $6uUbQ$Struct({\n  axisCount: $6uUbQ$uint16,\n  regionCount: $6uUbQ$uint16,\n  variationRegions: new $6uUbQ$Array(new $6uUbQ$Array($1a47b0c45c1c22fe$var$RegionAxisCoordinates, 'axisCount'), 'regionCount')\n});\nlet $1a47b0c45c1c22fe$var$DeltaSet = new $6uUbQ$Struct({\n  shortDeltas: new $6uUbQ$Array($6uUbQ$int16, t => t.parent.shortDeltaCount),\n  regionDeltas: new $6uUbQ$Array($6uUbQ$int8, t => t.parent.regionIndexCount - t.parent.shortDeltaCount),\n  deltas: t => t.shortDeltas.concat(t.regionDeltas)\n});\nlet $1a47b0c45c1c22fe$var$ItemVariationData = new $6uUbQ$Struct({\n  itemCount: $6uUbQ$uint16,\n  shortDeltaCount: $6uUbQ$uint16,\n  regionIndexCount: $6uUbQ$uint16,\n  regionIndexes: new $6uUbQ$Array($6uUbQ$uint16, 'regionIndexCount'),\n  deltaSets: new $6uUbQ$Array($1a47b0c45c1c22fe$var$DeltaSet, 'itemCount')\n});\nlet $1a47b0c45c1c22fe$export$fe1b122a2710f241 = new $6uUbQ$Struct({\n  format: $6uUbQ$uint16,\n  variationRegionList: new $6uUbQ$Pointer($6uUbQ$uint32, $1a47b0c45c1c22fe$var$VariationRegionList),\n  variationDataCount: $6uUbQ$uint16,\n  itemVariationData: new $6uUbQ$Array(new $6uUbQ$Pointer($6uUbQ$uint32, $1a47b0c45c1c22fe$var$ItemVariationData), 'variationDataCount')\n});\n/**********************\n * Feature Variations *\n **********************/\nlet $1a47b0c45c1c22fe$var$ConditionTable = new $6uUbQ$VersionedStruct($6uUbQ$uint16, {\n  1: {\n    axisIndex: $6uUbQ$uint16,\n    axisIndex: $6uUbQ$uint16,\n    filterRangeMinValue: $1a47b0c45c1c22fe$var$F2DOT14,\n    filterRangeMaxValue: $1a47b0c45c1c22fe$var$F2DOT14\n  }\n});\nlet $1a47b0c45c1c22fe$var$ConditionSet = new $6uUbQ$Struct({\n  conditionCount: $6uUbQ$uint16,\n  conditionTable: new $6uUbQ$Array(new $6uUbQ$Pointer($6uUbQ$uint32, $1a47b0c45c1c22fe$var$ConditionTable), 'conditionCount')\n});\nlet $1a47b0c45c1c22fe$var$FeatureTableSubstitutionRecord = new $6uUbQ$Struct({\n  featureIndex: $6uUbQ$uint16,\n  alternateFeatureTable: new $6uUbQ$Pointer($6uUbQ$uint32, (0, $7cbbe4e24ef3cb75$export$6e91cf7616333d5), {\n    type: 'parent'\n  })\n});\nlet $1a47b0c45c1c22fe$var$FeatureTableSubstitution = new $6uUbQ$Struct({\n  version: $6uUbQ$fixed32,\n  substitutionCount: $6uUbQ$uint16,\n  substitutions: new $6uUbQ$Array($1a47b0c45c1c22fe$var$FeatureTableSubstitutionRecord, 'substitutionCount')\n});\nlet $1a47b0c45c1c22fe$var$FeatureVariationRecord = new $6uUbQ$Struct({\n  conditionSet: new $6uUbQ$Pointer($6uUbQ$uint32, $1a47b0c45c1c22fe$var$ConditionSet, {\n    type: 'parent'\n  }),\n  featureTableSubstitution: new $6uUbQ$Pointer($6uUbQ$uint32, $1a47b0c45c1c22fe$var$FeatureTableSubstitution, {\n    type: 'parent'\n  })\n});\nlet $1a47b0c45c1c22fe$export$441b70b7971dd419 = new $6uUbQ$Struct({\n  majorVersion: $6uUbQ$uint16,\n  minorVersion: $6uUbQ$uint16,\n  featureVariationRecordCount: $6uUbQ$uint32,\n  featureVariationRecords: new $6uUbQ$Array($1a47b0c45c1c22fe$var$FeatureVariationRecord, 'featureVariationRecordCount')\n});\n\n// Checks if an operand is an index of a predefined value,\n// otherwise delegates to the provided type.\nclass $b84fd3dd9d8eddb2$var$PredefinedOp {\n  decode(stream, parent, operands) {\n    if (this.predefinedOps[operands[0]]) return this.predefinedOps[operands[0]];\n    return this.type.decode(stream, parent, operands);\n  }\n  size(value, ctx) {\n    return this.type.size(value, ctx);\n  }\n  encode(stream, value, ctx) {\n    let index = this.predefinedOps.indexOf(value);\n    if (index !== -1) return index;\n    return this.type.encode(stream, value, ctx);\n  }\n  constructor(predefinedOps, type) {\n    this.predefinedOps = predefinedOps;\n    this.type = type;\n  }\n}\nclass $b84fd3dd9d8eddb2$var$CFFEncodingVersion extends $6uUbQ$Number {\n  decode(stream) {\n    return $6uUbQ$uint8.decode(stream) & 0x7f;\n  }\n  constructor() {\n    super('UInt8');\n  }\n}\nlet $b84fd3dd9d8eddb2$var$Range1 = new $6uUbQ$Struct({\n  first: $6uUbQ$uint16,\n  nLeft: $6uUbQ$uint8\n});\nlet $b84fd3dd9d8eddb2$var$Range2 = new $6uUbQ$Struct({\n  first: $6uUbQ$uint16,\n  nLeft: $6uUbQ$uint16\n});\nlet $b84fd3dd9d8eddb2$var$CFFCustomEncoding = new $6uUbQ$VersionedStruct(new $b84fd3dd9d8eddb2$var$CFFEncodingVersion(), {\n  0: {\n    nCodes: $6uUbQ$uint8,\n    codes: new $6uUbQ$Array($6uUbQ$uint8, 'nCodes')\n  },\n  1: {\n    nRanges: $6uUbQ$uint8,\n    ranges: new $6uUbQ$Array($b84fd3dd9d8eddb2$var$Range1, 'nRanges')\n  }\n});\nlet $b84fd3dd9d8eddb2$var$CFFEncoding = new $b84fd3dd9d8eddb2$var$PredefinedOp([(0, $bc0433d9b7e41f5f$export$dee0027060fa13bd), (0, $bc0433d9b7e41f5f$export$4f58f497e14a53c3)], new (0, $0e34a43d05bde82c$export$2e2bcd8739ae039)($b84fd3dd9d8eddb2$var$CFFCustomEncoding, {\n  lazy: true\n}));\n// Decodes an array of ranges until the total\n// length is equal to the provided length.\nclass $b84fd3dd9d8eddb2$var$RangeArray extends $6uUbQ$Array {\n  decode(stream, parent) {\n    let length = (0, $6uUbQ$resolveLength)(this.length, stream, parent);\n    let count = 0;\n    let res = [];\n    while (count < length) {\n      let range = this.type.decode(stream, parent);\n      range.offset = count;\n      count += range.nLeft + 1;\n      res.push(range);\n    }\n    return res;\n  }\n}\nlet $b84fd3dd9d8eddb2$var$CFFCustomCharset = new $6uUbQ$VersionedStruct($6uUbQ$uint8, {\n  0: {\n    glyphs: new $6uUbQ$Array($6uUbQ$uint16, t => t.parent.CharStrings.length - 1)\n  },\n  1: {\n    ranges: new $b84fd3dd9d8eddb2$var$RangeArray($b84fd3dd9d8eddb2$var$Range1, t => t.parent.CharStrings.length - 1)\n  },\n  2: {\n    ranges: new $b84fd3dd9d8eddb2$var$RangeArray($b84fd3dd9d8eddb2$var$Range2, t => t.parent.CharStrings.length - 1)\n  }\n});\nlet $b84fd3dd9d8eddb2$var$CFFCharset = new $b84fd3dd9d8eddb2$var$PredefinedOp([(0, $ef658f5c9a1488b2$export$c33b50336c234f16), (0, $ef658f5c9a1488b2$export$3ed0f9e1fee8d489), (0, $ef658f5c9a1488b2$export$dc28be11139d4120)], new (0, $0e34a43d05bde82c$export$2e2bcd8739ae039)($b84fd3dd9d8eddb2$var$CFFCustomCharset, {\n  lazy: true\n}));\nlet $b84fd3dd9d8eddb2$var$FDRange3 = new $6uUbQ$Struct({\n  first: $6uUbQ$uint16,\n  fd: $6uUbQ$uint8\n});\nlet $b84fd3dd9d8eddb2$var$FDRange4 = new $6uUbQ$Struct({\n  first: $6uUbQ$uint32,\n  fd: $6uUbQ$uint16\n});\nlet $b84fd3dd9d8eddb2$var$FDSelect = new $6uUbQ$VersionedStruct($6uUbQ$uint8, {\n  0: {\n    fds: new $6uUbQ$Array($6uUbQ$uint8, t => t.parent.CharStrings.length)\n  },\n  3: {\n    nRanges: $6uUbQ$uint16,\n    ranges: new $6uUbQ$Array($b84fd3dd9d8eddb2$var$FDRange3, 'nRanges'),\n    sentinel: $6uUbQ$uint16\n  },\n  4: {\n    nRanges: $6uUbQ$uint32,\n    ranges: new $6uUbQ$Array($b84fd3dd9d8eddb2$var$FDRange4, 'nRanges'),\n    sentinel: $6uUbQ$uint32\n  }\n});\nlet $b84fd3dd9d8eddb2$var$ptr = new (0, $0e34a43d05bde82c$export$2e2bcd8739ae039)((0, $6d59db2e29cc77b3$export$2e2bcd8739ae039));\nclass $b84fd3dd9d8eddb2$var$CFFPrivateOp {\n  decode(stream, parent, operands) {\n    parent.length = operands[0];\n    return $b84fd3dd9d8eddb2$var$ptr.decode(stream, parent, [operands[1]]);\n  }\n  size(dict, ctx) {\n    return [(0, $6d59db2e29cc77b3$export$2e2bcd8739ae039).size(dict, ctx, false), $b84fd3dd9d8eddb2$var$ptr.size(dict, ctx)[0]];\n  }\n  encode(stream, dict, ctx) {\n    return [(0, $6d59db2e29cc77b3$export$2e2bcd8739ae039).size(dict, ctx, false), $b84fd3dd9d8eddb2$var$ptr.encode(stream, dict, ctx)[0]];\n  }\n}\nlet $b84fd3dd9d8eddb2$var$FontDict = new (0, $61aa549f16d58b9b$export$2e2bcd8739ae039)([\n// key       name                   type(s)                                 default\n[18, 'Private', new $b84fd3dd9d8eddb2$var$CFFPrivateOp(), null], [[12, 38], 'FontName', 'sid', null], [[12, 7], 'FontMatrix', 'array', [0.001, 0, 0, 0.001, 0, 0]], [[12, 5], 'PaintType', 'number', 0]]);\nlet $b84fd3dd9d8eddb2$var$CFFTopDict = new (0, $61aa549f16d58b9b$export$2e2bcd8739ae039)([\n// key       name                   type(s)                                 default\n[[12, 30], 'ROS', ['sid', 'sid', 'number'], null], [0, 'version', 'sid', null], [1, 'Notice', 'sid', null], [[12, 0], 'Copyright', 'sid', null], [2, 'FullName', 'sid', null], [3, 'FamilyName', 'sid', null], [4, 'Weight', 'sid', null], [[12, 1], 'isFixedPitch', 'boolean', false], [[12, 2], 'ItalicAngle', 'number', 0], [[12, 3], 'UnderlinePosition', 'number', -100], [[12, 4], 'UnderlineThickness', 'number', 50], [[12, 5], 'PaintType', 'number', 0], [[12, 6], 'CharstringType', 'number', 2], [[12, 7], 'FontMatrix', 'array', [0.001, 0, 0, 0.001, 0, 0]], [13, 'UniqueID', 'number', null], [5, 'FontBBox', 'array', [0, 0, 0, 0]], [[12, 8], 'StrokeWidth', 'number', 0], [14, 'XUID', 'array', null], [15, 'charset', $b84fd3dd9d8eddb2$var$CFFCharset, (0, $ef658f5c9a1488b2$export$c33b50336c234f16)], [16, 'Encoding', $b84fd3dd9d8eddb2$var$CFFEncoding, (0, $bc0433d9b7e41f5f$export$dee0027060fa13bd)], [17, 'CharStrings', new (0, $0e34a43d05bde82c$export$2e2bcd8739ae039)(new (0, $43e9821ef3717eec$export$2e2bcd8739ae039)()), null], [18, 'Private', new $b84fd3dd9d8eddb2$var$CFFPrivateOp(), null], [[12, 20], 'SyntheticBase', 'number', null], [[12, 21], 'PostScript', 'sid', null], [[12, 22], 'BaseFontName', 'sid', null], [[12, 23], 'BaseFontBlend', 'delta', null],\n// CID font specific\n[[12, 31], 'CIDFontVersion', 'number', 0], [[12, 32], 'CIDFontRevision', 'number', 0], [[12, 33], 'CIDFontType', 'number', 0], [[12, 34], 'CIDCount', 'number', 8720], [[12, 35], 'UIDBase', 'number', null], [[12, 37], 'FDSelect', new (0, $0e34a43d05bde82c$export$2e2bcd8739ae039)($b84fd3dd9d8eddb2$var$FDSelect), null], [[12, 36], 'FDArray', new (0, $0e34a43d05bde82c$export$2e2bcd8739ae039)(new (0, $43e9821ef3717eec$export$2e2bcd8739ae039)($b84fd3dd9d8eddb2$var$FontDict)), null], [[12, 38], 'FontName', 'sid', null]]);\nlet $b84fd3dd9d8eddb2$var$VariationStore = new $6uUbQ$Struct({\n  length: $6uUbQ$uint16,\n  itemVariationStore: (0, $1a47b0c45c1c22fe$export$fe1b122a2710f241)\n});\nlet $b84fd3dd9d8eddb2$var$CFF2TopDict = new (0, $61aa549f16d58b9b$export$2e2bcd8739ae039)([[[12, 7], 'FontMatrix', 'array', [0.001, 0, 0, 0.001, 0, 0]], [17, 'CharStrings', new (0, $0e34a43d05bde82c$export$2e2bcd8739ae039)(new (0, $43e9821ef3717eec$export$2e2bcd8739ae039)()), null], [[12, 37], 'FDSelect', new (0, $0e34a43d05bde82c$export$2e2bcd8739ae039)($b84fd3dd9d8eddb2$var$FDSelect), null], [[12, 36], 'FDArray', new (0, $0e34a43d05bde82c$export$2e2bcd8739ae039)(new (0, $43e9821ef3717eec$export$2e2bcd8739ae039)($b84fd3dd9d8eddb2$var$FontDict)), null], [24, 'vstore', new (0, $0e34a43d05bde82c$export$2e2bcd8739ae039)($b84fd3dd9d8eddb2$var$VariationStore), null], [25, 'maxstack', 'number', 193]]);\nlet $b84fd3dd9d8eddb2$var$CFFTop = new $6uUbQ$VersionedStruct($6uUbQ$fixed16, {\n  1: {\n    hdrSize: $6uUbQ$uint8,\n    offSize: $6uUbQ$uint8,\n    nameIndex: new (0, $43e9821ef3717eec$export$2e2bcd8739ae039)(new $6uUbQ$String('length')),\n    topDictIndex: new (0, $43e9821ef3717eec$export$2e2bcd8739ae039)($b84fd3dd9d8eddb2$var$CFFTopDict),\n    stringIndex: new (0, $43e9821ef3717eec$export$2e2bcd8739ae039)(new $6uUbQ$String('length')),\n    globalSubrIndex: new (0, $43e9821ef3717eec$export$2e2bcd8739ae039)()\n  },\n  2: {\n    hdrSize: $6uUbQ$uint8,\n    length: $6uUbQ$uint16,\n    topDict: $b84fd3dd9d8eddb2$var$CFF2TopDict,\n    globalSubrIndex: new (0, $43e9821ef3717eec$export$2e2bcd8739ae039)()\n  }\n});\nvar $b84fd3dd9d8eddb2$export$2e2bcd8739ae039 = $b84fd3dd9d8eddb2$var$CFFTop;\nclass $822ac0d589e4e237$var$CFFFont {\n  static decode(stream) {\n    return new $822ac0d589e4e237$var$CFFFont(stream);\n  }\n  decode() {\n    let start = this.stream.pos;\n    let top = (0, $b84fd3dd9d8eddb2$export$2e2bcd8739ae039).decode(this.stream);\n    for (let key in top) {\n      let val = top[key];\n      this[key] = val;\n    }\n    if (this.version < 2) {\n      if (this.topDictIndex.length !== 1) throw new Error(\"Only a single font is allowed in CFF\");\n      this.topDict = this.topDictIndex[0];\n    }\n    this.isCIDFont = this.topDict.ROS != null;\n    return this;\n  }\n  string(sid) {\n    if (this.version >= 2) return null;\n    if (sid < (0, $229224aec43783c5$export$2e2bcd8739ae039).length) return (0, $229224aec43783c5$export$2e2bcd8739ae039)[sid];\n    return this.stringIndex[sid - (0, $229224aec43783c5$export$2e2bcd8739ae039).length];\n  }\n  get postscriptName() {\n    if (this.version < 2) return this.nameIndex[0];\n    return null;\n  }\n  get fullName() {\n    return this.string(this.topDict.FullName);\n  }\n  get familyName() {\n    return this.string(this.topDict.FamilyName);\n  }\n  getCharString(glyph) {\n    this.stream.pos = this.topDict.CharStrings[glyph].offset;\n    return this.stream.readBuffer(this.topDict.CharStrings[glyph].length);\n  }\n  getGlyphName(gid) {\n    // CFF2 glyph names are in the post table.\n    if (this.version >= 2) return null;\n    // CID-keyed fonts don't have glyph names\n    if (this.isCIDFont) return null;\n    let {\n      charset: charset\n    } = this.topDict;\n    if (Array.isArray(charset)) return charset[gid];\n    if (gid === 0) return '.notdef';\n    gid -= 1;\n    switch (charset.version) {\n      case 0:\n        return this.string(charset.glyphs[gid]);\n      case 1:\n      case 2:\n        for (let i = 0; i < charset.ranges.length; i++) {\n          let range = charset.ranges[i];\n          if (range.offset <= gid && gid <= range.offset + range.nLeft) return this.string(range.first + (gid - range.offset));\n        }\n        break;\n    }\n    return null;\n  }\n  fdForGlyph(gid) {\n    if (!this.topDict.FDSelect) return null;\n    switch (this.topDict.FDSelect.version) {\n      case 0:\n        return this.topDict.FDSelect.fds[gid];\n      case 3:\n      case 4:\n        let {\n          ranges: ranges\n        } = this.topDict.FDSelect;\n        let low = 0;\n        let high = ranges.length - 1;\n        while (low <= high) {\n          let mid = low + high >> 1;\n          if (gid < ranges[mid].first) high = mid - 1;else if (mid < high && gid >= ranges[mid + 1].first) low = mid + 1;else return ranges[mid].fd;\n        }\n      default:\n        throw new Error(`Unknown FDSelect version: ${this.topDict.FDSelect.version}`);\n    }\n  }\n  privateDictForGlyph(gid) {\n    if (this.topDict.FDSelect) {\n      let fd = this.fdForGlyph(gid);\n      if (this.topDict.FDArray[fd]) return this.topDict.FDArray[fd].Private;\n      return null;\n    }\n    if (this.version < 2) return this.topDict.Private;\n    return this.topDict.FDArray[0].Private;\n  }\n  constructor(stream) {\n    this.stream = stream;\n    this.decode();\n  }\n}\nvar $822ac0d589e4e237$export$2e2bcd8739ae039 = $822ac0d589e4e237$var$CFFFont;\nlet $2bbf2bc1ce37cd8f$var$VerticalOrigin = new $6uUbQ$Struct({\n  glyphIndex: $6uUbQ$uint16,\n  vertOriginY: $6uUbQ$int16\n});\nvar $2bbf2bc1ce37cd8f$export$2e2bcd8739ae039 = new $6uUbQ$Struct({\n  majorVersion: $6uUbQ$uint16,\n  minorVersion: $6uUbQ$uint16,\n  defaultVertOriginY: $6uUbQ$int16,\n  numVertOriginYMetrics: $6uUbQ$uint16,\n  metrics: new $6uUbQ$Array($2bbf2bc1ce37cd8f$var$VerticalOrigin, 'numVertOriginYMetrics')\n});\nlet $0941618dc22a946d$export$16b227cb15d716a0 = new $6uUbQ$Struct({\n  height: $6uUbQ$uint8,\n  width: $6uUbQ$uint8,\n  horiBearingX: $6uUbQ$int8,\n  horiBearingY: $6uUbQ$int8,\n  horiAdvance: $6uUbQ$uint8,\n  vertBearingX: $6uUbQ$int8,\n  vertBearingY: $6uUbQ$int8,\n  vertAdvance: $6uUbQ$uint8\n});\nlet $0941618dc22a946d$export$62c53e75f69bfe12 = new $6uUbQ$Struct({\n  height: $6uUbQ$uint8,\n  width: $6uUbQ$uint8,\n  bearingX: $6uUbQ$int8,\n  bearingY: $6uUbQ$int8,\n  advance: $6uUbQ$uint8\n});\nlet $0941618dc22a946d$var$EBDTComponent = new $6uUbQ$Struct({\n  glyph: $6uUbQ$uint16,\n  xOffset: $6uUbQ$int8,\n  yOffset: $6uUbQ$int8\n});\nclass $0941618dc22a946d$var$ByteAligned {}\nclass $0941618dc22a946d$var$BitAligned {}\nlet $0941618dc22a946d$export$f1f5ddeb20d14f = new $6uUbQ$VersionedStruct('version', {\n  1: {\n    metrics: $0941618dc22a946d$export$62c53e75f69bfe12,\n    data: $0941618dc22a946d$var$ByteAligned\n  },\n  2: {\n    metrics: $0941618dc22a946d$export$62c53e75f69bfe12,\n    data: $0941618dc22a946d$var$BitAligned\n  },\n  // format 3 is deprecated\n  // format 4 is not supported by Microsoft\n  5: {\n    data: $0941618dc22a946d$var$BitAligned\n  },\n  6: {\n    metrics: $0941618dc22a946d$export$16b227cb15d716a0,\n    data: $0941618dc22a946d$var$ByteAligned\n  },\n  7: {\n    metrics: $0941618dc22a946d$export$16b227cb15d716a0,\n    data: $0941618dc22a946d$var$BitAligned\n  },\n  8: {\n    metrics: $0941618dc22a946d$export$62c53e75f69bfe12,\n    pad: new $6uUbQ$Reserved($6uUbQ$uint8),\n    numComponents: $6uUbQ$uint16,\n    components: new $6uUbQ$Array($0941618dc22a946d$var$EBDTComponent, 'numComponents')\n  },\n  9: {\n    metrics: $0941618dc22a946d$export$16b227cb15d716a0,\n    pad: new $6uUbQ$Reserved($6uUbQ$uint8),\n    numComponents: $6uUbQ$uint16,\n    components: new $6uUbQ$Array($0941618dc22a946d$var$EBDTComponent, 'numComponents')\n  },\n  17: {\n    metrics: $0941618dc22a946d$export$62c53e75f69bfe12,\n    dataLen: $6uUbQ$uint32,\n    data: new $6uUbQ$Buffer('dataLen')\n  },\n  18: {\n    metrics: $0941618dc22a946d$export$16b227cb15d716a0,\n    dataLen: $6uUbQ$uint32,\n    data: new $6uUbQ$Buffer('dataLen')\n  },\n  19: {\n    dataLen: $6uUbQ$uint32,\n    data: new $6uUbQ$Buffer('dataLen')\n  }\n});\nlet $9911c4c7201c13de$var$SBitLineMetrics = new $6uUbQ$Struct({\n  ascender: $6uUbQ$int8,\n  descender: $6uUbQ$int8,\n  widthMax: $6uUbQ$uint8,\n  caretSlopeNumerator: $6uUbQ$int8,\n  caretSlopeDenominator: $6uUbQ$int8,\n  caretOffset: $6uUbQ$int8,\n  minOriginSB: $6uUbQ$int8,\n  minAdvanceSB: $6uUbQ$int8,\n  maxBeforeBL: $6uUbQ$int8,\n  minAfterBL: $6uUbQ$int8,\n  pad: new $6uUbQ$Reserved($6uUbQ$int8, 2)\n});\nlet $9911c4c7201c13de$var$CodeOffsetPair = new $6uUbQ$Struct({\n  glyphCode: $6uUbQ$uint16,\n  offset: $6uUbQ$uint16\n});\nlet $9911c4c7201c13de$var$IndexSubtable = new $6uUbQ$VersionedStruct($6uUbQ$uint16, {\n  header: {\n    imageFormat: $6uUbQ$uint16,\n    imageDataOffset: $6uUbQ$uint32\n  },\n  1: {\n    offsetArray: new $6uUbQ$Array($6uUbQ$uint32, t => t.parent.lastGlyphIndex - t.parent.firstGlyphIndex + 1)\n  },\n  2: {\n    imageSize: $6uUbQ$uint32,\n    bigMetrics: (0, $0941618dc22a946d$export$16b227cb15d716a0)\n  },\n  3: {\n    offsetArray: new $6uUbQ$Array($6uUbQ$uint16, t => t.parent.lastGlyphIndex - t.parent.firstGlyphIndex + 1)\n  },\n  4: {\n    numGlyphs: $6uUbQ$uint32,\n    glyphArray: new $6uUbQ$Array($9911c4c7201c13de$var$CodeOffsetPair, t => t.numGlyphs + 1)\n  },\n  5: {\n    imageSize: $6uUbQ$uint32,\n    bigMetrics: (0, $0941618dc22a946d$export$16b227cb15d716a0),\n    numGlyphs: $6uUbQ$uint32,\n    glyphCodeArray: new $6uUbQ$Array($6uUbQ$uint16, 'numGlyphs')\n  }\n});\nlet $9911c4c7201c13de$var$IndexSubtableArray = new $6uUbQ$Struct({\n  firstGlyphIndex: $6uUbQ$uint16,\n  lastGlyphIndex: $6uUbQ$uint16,\n  subtable: new $6uUbQ$Pointer($6uUbQ$uint32, $9911c4c7201c13de$var$IndexSubtable)\n});\nlet $9911c4c7201c13de$var$BitmapSizeTable = new $6uUbQ$Struct({\n  indexSubTableArray: new $6uUbQ$Pointer($6uUbQ$uint32, new $6uUbQ$Array($9911c4c7201c13de$var$IndexSubtableArray, 1), {\n    type: 'parent'\n  }),\n  indexTablesSize: $6uUbQ$uint32,\n  numberOfIndexSubTables: $6uUbQ$uint32,\n  colorRef: $6uUbQ$uint32,\n  hori: $9911c4c7201c13de$var$SBitLineMetrics,\n  vert: $9911c4c7201c13de$var$SBitLineMetrics,\n  startGlyphIndex: $6uUbQ$uint16,\n  endGlyphIndex: $6uUbQ$uint16,\n  ppemX: $6uUbQ$uint8,\n  ppemY: $6uUbQ$uint8,\n  bitDepth: $6uUbQ$uint8,\n  flags: new $6uUbQ$Bitfield($6uUbQ$uint8, ['horizontal', 'vertical'])\n});\nvar $9911c4c7201c13de$export$2e2bcd8739ae039 = new $6uUbQ$Struct({\n  version: $6uUbQ$uint32,\n  numSizes: $6uUbQ$uint32,\n  sizes: new $6uUbQ$Array($9911c4c7201c13de$var$BitmapSizeTable, 'numSizes')\n});\nlet $abb847051efd51b1$var$ImageTable = new $6uUbQ$Struct({\n  ppem: $6uUbQ$uint16,\n  resolution: $6uUbQ$uint16,\n  imageOffsets: new $6uUbQ$Array(new $6uUbQ$Pointer($6uUbQ$uint32, 'void'), t => t.parent.parent.maxp.numGlyphs + 1)\n});\nvar\n// This is the Apple sbix table, used by the \"Apple Color Emoji\" font.\n// It includes several image tables with images for each bitmap glyph\n// of several different sizes.\n$abb847051efd51b1$export$2e2bcd8739ae039 = new $6uUbQ$Struct({\n  version: $6uUbQ$uint16,\n  flags: new $6uUbQ$Bitfield($6uUbQ$uint16, ['renderOutlines']),\n  numImgTables: $6uUbQ$uint32,\n  imageTables: new $6uUbQ$Array(new $6uUbQ$Pointer($6uUbQ$uint32, $abb847051efd51b1$var$ImageTable), 'numImgTables')\n});\nlet $eb629188f3dfefdd$var$LayerRecord = new $6uUbQ$Struct({\n  gid: $6uUbQ$uint16,\n  paletteIndex: $6uUbQ$uint16 // Index value to use in the appropriate palette. This value must\n}); // be less than numPaletteEntries in the CPAL table, except for\n// the special case noted below. Each palette entry is 16 bits.\n// A palette index of 0xFFFF is a special case indicating that\n// the text foreground color should be used.\nlet $eb629188f3dfefdd$var$BaseGlyphRecord = new $6uUbQ$Struct({\n  gid: $6uUbQ$uint16,\n  // and is not rendered for color.\n  firstLayerIndex: $6uUbQ$uint16,\n  // There will be numLayers consecutive entries for this base glyph.\n  numLayers: $6uUbQ$uint16\n});\nvar $eb629188f3dfefdd$export$2e2bcd8739ae039 = new $6uUbQ$Struct({\n  version: $6uUbQ$uint16,\n  numBaseGlyphRecords: $6uUbQ$uint16,\n  baseGlyphRecord: new $6uUbQ$Pointer($6uUbQ$uint32, new $6uUbQ$Array($eb629188f3dfefdd$var$BaseGlyphRecord, 'numBaseGlyphRecords')),\n  layerRecords: new $6uUbQ$Pointer($6uUbQ$uint32, new $6uUbQ$Array($eb629188f3dfefdd$var$LayerRecord, 'numLayerRecords'), {\n    lazy: true\n  }),\n  numLayerRecords: $6uUbQ$uint16\n});\nlet $08734b8e7dc64587$var$ColorRecord = new $6uUbQ$Struct({\n  blue: $6uUbQ$uint8,\n  green: $6uUbQ$uint8,\n  red: $6uUbQ$uint8,\n  alpha: $6uUbQ$uint8\n});\nvar $08734b8e7dc64587$export$2e2bcd8739ae039 = new $6uUbQ$VersionedStruct($6uUbQ$uint16, {\n  header: {\n    numPaletteEntries: $6uUbQ$uint16,\n    numPalettes: $6uUbQ$uint16,\n    numColorRecords: $6uUbQ$uint16,\n    colorRecords: new $6uUbQ$Pointer($6uUbQ$uint32, new $6uUbQ$Array($08734b8e7dc64587$var$ColorRecord, 'numColorRecords')),\n    colorRecordIndices: new $6uUbQ$Array($6uUbQ$uint16, 'numPalettes')\n  },\n  0: {},\n  1: {\n    offsetPaletteTypeArray: new $6uUbQ$Pointer($6uUbQ$uint32, new $6uUbQ$Array($6uUbQ$uint32, 'numPalettes')),\n    offsetPaletteLabelArray: new $6uUbQ$Pointer($6uUbQ$uint32, new $6uUbQ$Array($6uUbQ$uint16, 'numPalettes')),\n    offsetPaletteEntryLabelArray: new $6uUbQ$Pointer($6uUbQ$uint32, new $6uUbQ$Array($6uUbQ$uint16, 'numPaletteEntries'))\n  }\n});\nlet $497cef411d884e34$var$BaseCoord = new $6uUbQ$VersionedStruct($6uUbQ$uint16, {\n  1: {\n    coordinate: $6uUbQ$int16 // X or Y value, in design units\n  },\n  2: {\n    coordinate: $6uUbQ$int16,\n    referenceGlyph: $6uUbQ$uint16,\n    baseCoordPoint: $6uUbQ$uint16 // Index of contour point on the referenceGlyph\n  },\n  3: {\n    coordinate: $6uUbQ$int16,\n    deviceTable: new $6uUbQ$Pointer($6uUbQ$uint16, (0, $7cbbe4e24ef3cb75$export$8215d14a63d9fb10)) // Device table for X or Y value\n  }\n});\nlet $497cef411d884e34$var$BaseValues = new $6uUbQ$Struct({\n  defaultIndex: $6uUbQ$uint16,\n  baseCoordCount: $6uUbQ$uint16,\n  baseCoords: new $6uUbQ$Array(new $6uUbQ$Pointer($6uUbQ$uint16, $497cef411d884e34$var$BaseCoord), 'baseCoordCount')\n});\nlet $497cef411d884e34$var$FeatMinMaxRecord = new $6uUbQ$Struct({\n  tag: new $6uUbQ$String(4),\n  minCoord: new $6uUbQ$Pointer($6uUbQ$uint16, $497cef411d884e34$var$BaseCoord, {\n    type: 'parent'\n  }),\n  maxCoord: new $6uUbQ$Pointer($6uUbQ$uint16, $497cef411d884e34$var$BaseCoord, {\n    type: 'parent'\n  }) // May be NULL\n});\nlet $497cef411d884e34$var$MinMax = new $6uUbQ$Struct({\n  minCoord: new $6uUbQ$Pointer($6uUbQ$uint16, $497cef411d884e34$var$BaseCoord),\n  maxCoord: new $6uUbQ$Pointer($6uUbQ$uint16, $497cef411d884e34$var$BaseCoord),\n  featMinMaxCount: $6uUbQ$uint16,\n  featMinMaxRecords: new $6uUbQ$Array($497cef411d884e34$var$FeatMinMaxRecord, 'featMinMaxCount') // In alphabetical order\n});\nlet $497cef411d884e34$var$BaseLangSysRecord = new $6uUbQ$Struct({\n  tag: new $6uUbQ$String(4),\n  minMax: new $6uUbQ$Pointer($6uUbQ$uint16, $497cef411d884e34$var$MinMax, {\n    type: 'parent'\n  })\n});\nlet $497cef411d884e34$var$BaseScript = new $6uUbQ$Struct({\n  baseValues: new $6uUbQ$Pointer($6uUbQ$uint16, $497cef411d884e34$var$BaseValues),\n  defaultMinMax: new $6uUbQ$Pointer($6uUbQ$uint16, $497cef411d884e34$var$MinMax),\n  baseLangSysCount: $6uUbQ$uint16,\n  baseLangSysRecords: new $6uUbQ$Array($497cef411d884e34$var$BaseLangSysRecord, 'baseLangSysCount') // in alphabetical order by BaseLangSysTag\n});\nlet $497cef411d884e34$var$BaseScriptRecord = new $6uUbQ$Struct({\n  tag: new $6uUbQ$String(4),\n  script: new $6uUbQ$Pointer($6uUbQ$uint16, $497cef411d884e34$var$BaseScript, {\n    type: 'parent'\n  })\n});\nlet $497cef411d884e34$var$BaseScriptList = new $6uUbQ$Array($497cef411d884e34$var$BaseScriptRecord, $6uUbQ$uint16);\n// Array of 4-byte baseline identification tags-must be in alphabetical order\nlet $497cef411d884e34$var$BaseTagList = new $6uUbQ$Array(new $6uUbQ$String(4), $6uUbQ$uint16);\nlet $497cef411d884e34$var$Axis = new $6uUbQ$Struct({\n  baseTagList: new $6uUbQ$Pointer($6uUbQ$uint16, $497cef411d884e34$var$BaseTagList),\n  baseScriptList: new $6uUbQ$Pointer($6uUbQ$uint16, $497cef411d884e34$var$BaseScriptList)\n});\nvar $497cef411d884e34$export$2e2bcd8739ae039 = new $6uUbQ$VersionedStruct($6uUbQ$uint32, {\n  header: {\n    horizAxis: new $6uUbQ$Pointer($6uUbQ$uint16, $497cef411d884e34$var$Axis),\n    vertAxis: new $6uUbQ$Pointer($6uUbQ$uint16, $497cef411d884e34$var$Axis) // May be NULL\n  },\n  0x00010000: {},\n  0x00010001: {\n    itemVariationStore: new $6uUbQ$Pointer($6uUbQ$uint32, (0, $1a47b0c45c1c22fe$export$fe1b122a2710f241))\n  }\n});\nlet $cf5f33c63ef209e6$var$AttachPoint = new $6uUbQ$Array($6uUbQ$uint16, $6uUbQ$uint16);\nlet $cf5f33c63ef209e6$var$AttachList = new $6uUbQ$Struct({\n  coverage: new $6uUbQ$Pointer($6uUbQ$uint16, (0, $7cbbe4e24ef3cb75$export$17608c3f81a6111)),\n  glyphCount: $6uUbQ$uint16,\n  attachPoints: new $6uUbQ$Array(new $6uUbQ$Pointer($6uUbQ$uint16, $cf5f33c63ef209e6$var$AttachPoint), 'glyphCount')\n});\nlet $cf5f33c63ef209e6$var$CaretValue = new $6uUbQ$VersionedStruct($6uUbQ$uint16, {\n  1: {\n    coordinate: $6uUbQ$int16\n  },\n  2: {\n    caretValuePoint: $6uUbQ$uint16\n  },\n  3: {\n    coordinate: $6uUbQ$int16,\n    deviceTable: new $6uUbQ$Pointer($6uUbQ$uint16, (0, $7cbbe4e24ef3cb75$export$8215d14a63d9fb10))\n  }\n});\nlet $cf5f33c63ef209e6$var$LigGlyph = new $6uUbQ$Array(new $6uUbQ$Pointer($6uUbQ$uint16, $cf5f33c63ef209e6$var$CaretValue), $6uUbQ$uint16);\nlet $cf5f33c63ef209e6$var$LigCaretList = new $6uUbQ$Struct({\n  coverage: new $6uUbQ$Pointer($6uUbQ$uint16, (0, $7cbbe4e24ef3cb75$export$17608c3f81a6111)),\n  ligGlyphCount: $6uUbQ$uint16,\n  ligGlyphs: new $6uUbQ$Array(new $6uUbQ$Pointer($6uUbQ$uint16, $cf5f33c63ef209e6$var$LigGlyph), 'ligGlyphCount')\n});\nlet $cf5f33c63ef209e6$var$MarkGlyphSetsDef = new $6uUbQ$Struct({\n  markSetTableFormat: $6uUbQ$uint16,\n  markSetCount: $6uUbQ$uint16,\n  coverage: new $6uUbQ$Array(new $6uUbQ$Pointer($6uUbQ$uint32, (0, $7cbbe4e24ef3cb75$export$17608c3f81a6111)), 'markSetCount')\n});\nvar $cf5f33c63ef209e6$export$2e2bcd8739ae039 = new $6uUbQ$VersionedStruct($6uUbQ$uint32, {\n  header: {\n    glyphClassDef: new $6uUbQ$Pointer($6uUbQ$uint16, (0, $7cbbe4e24ef3cb75$export$843d551fbbafef71)),\n    attachList: new $6uUbQ$Pointer($6uUbQ$uint16, $cf5f33c63ef209e6$var$AttachList),\n    ligCaretList: new $6uUbQ$Pointer($6uUbQ$uint16, $cf5f33c63ef209e6$var$LigCaretList),\n    markAttachClassDef: new $6uUbQ$Pointer($6uUbQ$uint16, (0, $7cbbe4e24ef3cb75$export$843d551fbbafef71))\n  },\n  0x00010000: {},\n  0x00010002: {\n    markGlyphSetsDef: new $6uUbQ$Pointer($6uUbQ$uint16, $cf5f33c63ef209e6$var$MarkGlyphSetsDef)\n  },\n  0x00010003: {\n    markGlyphSetsDef: new $6uUbQ$Pointer($6uUbQ$uint16, $cf5f33c63ef209e6$var$MarkGlyphSetsDef),\n    itemVariationStore: new $6uUbQ$Pointer($6uUbQ$uint32, (0, $1a47b0c45c1c22fe$export$fe1b122a2710f241))\n  }\n});\nlet $47e0e8ef515d9903$var$ValueFormat = new $6uUbQ$Bitfield($6uUbQ$uint16, ['xPlacement', 'yPlacement', 'xAdvance', 'yAdvance', 'xPlaDevice', 'yPlaDevice', 'xAdvDevice', 'yAdvDevice']);\nlet $47e0e8ef515d9903$var$types = {\n  xPlacement: $6uUbQ$int16,\n  yPlacement: $6uUbQ$int16,\n  xAdvance: $6uUbQ$int16,\n  yAdvance: $6uUbQ$int16,\n  xPlaDevice: new $6uUbQ$Pointer($6uUbQ$uint16, (0, $7cbbe4e24ef3cb75$export$8215d14a63d9fb10), {\n    type: 'global',\n    relativeTo: ctx => ctx.rel\n  }),\n  yPlaDevice: new $6uUbQ$Pointer($6uUbQ$uint16, (0, $7cbbe4e24ef3cb75$export$8215d14a63d9fb10), {\n    type: 'global',\n    relativeTo: ctx => ctx.rel\n  }),\n  xAdvDevice: new $6uUbQ$Pointer($6uUbQ$uint16, (0, $7cbbe4e24ef3cb75$export$8215d14a63d9fb10), {\n    type: 'global',\n    relativeTo: ctx => ctx.rel\n  }),\n  yAdvDevice: new $6uUbQ$Pointer($6uUbQ$uint16, (0, $7cbbe4e24ef3cb75$export$8215d14a63d9fb10), {\n    type: 'global',\n    relativeTo: ctx => ctx.rel\n  })\n};\nclass $47e0e8ef515d9903$var$ValueRecord {\n  buildStruct(parent) {\n    let struct = parent;\n    while (!struct[this.key] && struct.parent) struct = struct.parent;\n    if (!struct[this.key]) return;\n    let fields = {};\n    fields.rel = () => struct._startOffset;\n    let format = struct[this.key];\n    for (let key in format) if (format[key]) fields[key] = $47e0e8ef515d9903$var$types[key];\n    return new $6uUbQ$Struct(fields);\n  }\n  size(val, ctx) {\n    return this.buildStruct(ctx).size(val, ctx);\n  }\n  decode(stream, parent) {\n    let res = this.buildStruct(parent).decode(stream, parent);\n    delete res.rel;\n    return res;\n  }\n  constructor() {\n    let key = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'valueFormat';\n    this.key = key;\n  }\n}\nlet $47e0e8ef515d9903$var$PairValueRecord = new $6uUbQ$Struct({\n  secondGlyph: $6uUbQ$uint16,\n  value1: new $47e0e8ef515d9903$var$ValueRecord('valueFormat1'),\n  value2: new $47e0e8ef515d9903$var$ValueRecord('valueFormat2')\n});\nlet $47e0e8ef515d9903$var$PairSet = new $6uUbQ$Array($47e0e8ef515d9903$var$PairValueRecord, $6uUbQ$uint16);\nlet $47e0e8ef515d9903$var$Class2Record = new $6uUbQ$Struct({\n  value1: new $47e0e8ef515d9903$var$ValueRecord('valueFormat1'),\n  value2: new $47e0e8ef515d9903$var$ValueRecord('valueFormat2')\n});\nlet $47e0e8ef515d9903$var$Anchor = new $6uUbQ$VersionedStruct($6uUbQ$uint16, {\n  1: {\n    xCoordinate: $6uUbQ$int16,\n    yCoordinate: $6uUbQ$int16\n  },\n  2: {\n    xCoordinate: $6uUbQ$int16,\n    yCoordinate: $6uUbQ$int16,\n    anchorPoint: $6uUbQ$uint16\n  },\n  3: {\n    xCoordinate: $6uUbQ$int16,\n    yCoordinate: $6uUbQ$int16,\n    xDeviceTable: new $6uUbQ$Pointer($6uUbQ$uint16, (0, $7cbbe4e24ef3cb75$export$8215d14a63d9fb10)),\n    yDeviceTable: new $6uUbQ$Pointer($6uUbQ$uint16, (0, $7cbbe4e24ef3cb75$export$8215d14a63d9fb10))\n  }\n});\nlet $47e0e8ef515d9903$var$EntryExitRecord = new $6uUbQ$Struct({\n  entryAnchor: new $6uUbQ$Pointer($6uUbQ$uint16, $47e0e8ef515d9903$var$Anchor, {\n    type: 'parent'\n  }),\n  exitAnchor: new $6uUbQ$Pointer($6uUbQ$uint16, $47e0e8ef515d9903$var$Anchor, {\n    type: 'parent'\n  })\n});\nlet $47e0e8ef515d9903$var$MarkRecord = new $6uUbQ$Struct({\n  class: $6uUbQ$uint16,\n  markAnchor: new $6uUbQ$Pointer($6uUbQ$uint16, $47e0e8ef515d9903$var$Anchor, {\n    type: 'parent'\n  })\n});\nlet $47e0e8ef515d9903$var$MarkArray = new $6uUbQ$Array($47e0e8ef515d9903$var$MarkRecord, $6uUbQ$uint16);\nlet $47e0e8ef515d9903$var$BaseRecord = new $6uUbQ$Array(new $6uUbQ$Pointer($6uUbQ$uint16, $47e0e8ef515d9903$var$Anchor), t => t.parent.classCount);\nlet $47e0e8ef515d9903$var$BaseArray = new $6uUbQ$Array($47e0e8ef515d9903$var$BaseRecord, $6uUbQ$uint16);\nlet $47e0e8ef515d9903$var$ComponentRecord = new $6uUbQ$Array(new $6uUbQ$Pointer($6uUbQ$uint16, $47e0e8ef515d9903$var$Anchor), t => t.parent.parent.classCount);\nlet $47e0e8ef515d9903$var$LigatureAttach = new $6uUbQ$Array($47e0e8ef515d9903$var$ComponentRecord, $6uUbQ$uint16);\nlet $47e0e8ef515d9903$var$LigatureArray = new $6uUbQ$Array(new $6uUbQ$Pointer($6uUbQ$uint16, $47e0e8ef515d9903$var$LigatureAttach), $6uUbQ$uint16);\nlet $47e0e8ef515d9903$export$73a8cfb19cd43a0f = new $6uUbQ$VersionedStruct('lookupType', {\n  1: new $6uUbQ$VersionedStruct($6uUbQ$uint16, {\n    1: {\n      coverage: new $6uUbQ$Pointer($6uUbQ$uint16, (0, $7cbbe4e24ef3cb75$export$17608c3f81a6111)),\n      valueFormat: $47e0e8ef515d9903$var$ValueFormat,\n      value: new $47e0e8ef515d9903$var$ValueRecord()\n    },\n    2: {\n      coverage: new $6uUbQ$Pointer($6uUbQ$uint16, (0, $7cbbe4e24ef3cb75$export$17608c3f81a6111)),\n      valueFormat: $47e0e8ef515d9903$var$ValueFormat,\n      valueCount: $6uUbQ$uint16,\n      values: new $6uUbQ$LazyArray(new $47e0e8ef515d9903$var$ValueRecord(), 'valueCount')\n    }\n  }),\n  2: new $6uUbQ$VersionedStruct($6uUbQ$uint16, {\n    1: {\n      coverage: new $6uUbQ$Pointer($6uUbQ$uint16, (0, $7cbbe4e24ef3cb75$export$17608c3f81a6111)),\n      valueFormat1: $47e0e8ef515d9903$var$ValueFormat,\n      valueFormat2: $47e0e8ef515d9903$var$ValueFormat,\n      pairSetCount: $6uUbQ$uint16,\n      pairSets: new $6uUbQ$LazyArray(new $6uUbQ$Pointer($6uUbQ$uint16, $47e0e8ef515d9903$var$PairSet), 'pairSetCount')\n    },\n    2: {\n      coverage: new $6uUbQ$Pointer($6uUbQ$uint16, (0, $7cbbe4e24ef3cb75$export$17608c3f81a6111)),\n      valueFormat1: $47e0e8ef515d9903$var$ValueFormat,\n      valueFormat2: $47e0e8ef515d9903$var$ValueFormat,\n      classDef1: new $6uUbQ$Pointer($6uUbQ$uint16, (0, $7cbbe4e24ef3cb75$export$843d551fbbafef71)),\n      classDef2: new $6uUbQ$Pointer($6uUbQ$uint16, (0, $7cbbe4e24ef3cb75$export$843d551fbbafef71)),\n      class1Count: $6uUbQ$uint16,\n      class2Count: $6uUbQ$uint16,\n      classRecords: new $6uUbQ$LazyArray(new $6uUbQ$LazyArray($47e0e8ef515d9903$var$Class2Record, 'class2Count'), 'class1Count')\n    }\n  }),\n  3: {\n    format: $6uUbQ$uint16,\n    coverage: new $6uUbQ$Pointer($6uUbQ$uint16, (0, $7cbbe4e24ef3cb75$export$17608c3f81a6111)),\n    entryExitCount: $6uUbQ$uint16,\n    entryExitRecords: new $6uUbQ$Array($47e0e8ef515d9903$var$EntryExitRecord, 'entryExitCount')\n  },\n  4: {\n    format: $6uUbQ$uint16,\n    markCoverage: new $6uUbQ$Pointer($6uUbQ$uint16, (0, $7cbbe4e24ef3cb75$export$17608c3f81a6111)),\n    baseCoverage: new $6uUbQ$Pointer($6uUbQ$uint16, (0, $7cbbe4e24ef3cb75$export$17608c3f81a6111)),\n    classCount: $6uUbQ$uint16,\n    markArray: new $6uUbQ$Pointer($6uUbQ$uint16, $47e0e8ef515d9903$var$MarkArray),\n    baseArray: new $6uUbQ$Pointer($6uUbQ$uint16, $47e0e8ef515d9903$var$BaseArray)\n  },\n  5: {\n    format: $6uUbQ$uint16,\n    markCoverage: new $6uUbQ$Pointer($6uUbQ$uint16, (0, $7cbbe4e24ef3cb75$export$17608c3f81a6111)),\n    ligatureCoverage: new $6uUbQ$Pointer($6uUbQ$uint16, (0, $7cbbe4e24ef3cb75$export$17608c3f81a6111)),\n    classCount: $6uUbQ$uint16,\n    markArray: new $6uUbQ$Pointer($6uUbQ$uint16, $47e0e8ef515d9903$var$MarkArray),\n    ligatureArray: new $6uUbQ$Pointer($6uUbQ$uint16, $47e0e8ef515d9903$var$LigatureArray)\n  },\n  6: {\n    format: $6uUbQ$uint16,\n    mark1Coverage: new $6uUbQ$Pointer($6uUbQ$uint16, (0, $7cbbe4e24ef3cb75$export$17608c3f81a6111)),\n    mark2Coverage: new $6uUbQ$Pointer($6uUbQ$uint16, (0, $7cbbe4e24ef3cb75$export$17608c3f81a6111)),\n    classCount: $6uUbQ$uint16,\n    mark1Array: new $6uUbQ$Pointer($6uUbQ$uint16, $47e0e8ef515d9903$var$MarkArray),\n    mark2Array: new $6uUbQ$Pointer($6uUbQ$uint16, $47e0e8ef515d9903$var$BaseArray)\n  },\n  7: (0, $7cbbe4e24ef3cb75$export$841858b892ce1f4c),\n  8: (0, $7cbbe4e24ef3cb75$export$5e6d09e6861162f6),\n  9: {\n    posFormat: $6uUbQ$uint16,\n    lookupType: $6uUbQ$uint16,\n    extension: new $6uUbQ$Pointer($6uUbQ$uint32, null)\n  }\n});\n// Fix circular reference\n$47e0e8ef515d9903$export$73a8cfb19cd43a0f.versions[9].extension.type = $47e0e8ef515d9903$export$73a8cfb19cd43a0f;\nvar $47e0e8ef515d9903$export$2e2bcd8739ae039 = new $6uUbQ$VersionedStruct($6uUbQ$uint32, {\n  header: {\n    scriptList: new $6uUbQ$Pointer($6uUbQ$uint16, (0, $7cbbe4e24ef3cb75$export$3e15fc05ce864229)),\n    featureList: new $6uUbQ$Pointer($6uUbQ$uint16, (0, $7cbbe4e24ef3cb75$export$aa18130def4b6cb4)),\n    lookupList: new $6uUbQ$Pointer($6uUbQ$uint16, new (0, $7cbbe4e24ef3cb75$export$df0008c6ff2da22a)($47e0e8ef515d9903$export$73a8cfb19cd43a0f))\n  },\n  0x00010000: {},\n  0x00010001: {\n    featureVariations: new $6uUbQ$Pointer($6uUbQ$uint32, (0, $1a47b0c45c1c22fe$export$441b70b7971dd419))\n  }\n});\nlet $d3f442064af66e06$var$Sequence = new $6uUbQ$Array($6uUbQ$uint16, $6uUbQ$uint16);\nlet $d3f442064af66e06$var$AlternateSet = $d3f442064af66e06$var$Sequence;\nlet $d3f442064af66e06$var$Ligature = new $6uUbQ$Struct({\n  glyph: $6uUbQ$uint16,\n  compCount: $6uUbQ$uint16,\n  components: new $6uUbQ$Array($6uUbQ$uint16, t => t.compCount - 1)\n});\nlet $d3f442064af66e06$var$LigatureSet = new $6uUbQ$Array(new $6uUbQ$Pointer($6uUbQ$uint16, $d3f442064af66e06$var$Ligature), $6uUbQ$uint16);\nlet $d3f442064af66e06$var$GSUBLookup = new $6uUbQ$VersionedStruct('lookupType', {\n  1: new $6uUbQ$VersionedStruct($6uUbQ$uint16, {\n    1: {\n      coverage: new $6uUbQ$Pointer($6uUbQ$uint16, (0, $7cbbe4e24ef3cb75$export$17608c3f81a6111)),\n      deltaGlyphID: $6uUbQ$int16\n    },\n    2: {\n      coverage: new $6uUbQ$Pointer($6uUbQ$uint16, (0, $7cbbe4e24ef3cb75$export$17608c3f81a6111)),\n      glyphCount: $6uUbQ$uint16,\n      substitute: new $6uUbQ$LazyArray($6uUbQ$uint16, 'glyphCount')\n    }\n  }),\n  2: {\n    substFormat: $6uUbQ$uint16,\n    coverage: new $6uUbQ$Pointer($6uUbQ$uint16, (0, $7cbbe4e24ef3cb75$export$17608c3f81a6111)),\n    count: $6uUbQ$uint16,\n    sequences: new $6uUbQ$LazyArray(new $6uUbQ$Pointer($6uUbQ$uint16, $d3f442064af66e06$var$Sequence), 'count')\n  },\n  3: {\n    substFormat: $6uUbQ$uint16,\n    coverage: new $6uUbQ$Pointer($6uUbQ$uint16, (0, $7cbbe4e24ef3cb75$export$17608c3f81a6111)),\n    count: $6uUbQ$uint16,\n    alternateSet: new $6uUbQ$LazyArray(new $6uUbQ$Pointer($6uUbQ$uint16, $d3f442064af66e06$var$AlternateSet), 'count')\n  },\n  4: {\n    substFormat: $6uUbQ$uint16,\n    coverage: new $6uUbQ$Pointer($6uUbQ$uint16, (0, $7cbbe4e24ef3cb75$export$17608c3f81a6111)),\n    count: $6uUbQ$uint16,\n    ligatureSets: new $6uUbQ$LazyArray(new $6uUbQ$Pointer($6uUbQ$uint16, $d3f442064af66e06$var$LigatureSet), 'count')\n  },\n  5: (0, $7cbbe4e24ef3cb75$export$841858b892ce1f4c),\n  6: (0, $7cbbe4e24ef3cb75$export$5e6d09e6861162f6),\n  7: {\n    substFormat: $6uUbQ$uint16,\n    lookupType: $6uUbQ$uint16,\n    extension: new $6uUbQ$Pointer($6uUbQ$uint32, null)\n  },\n  8: {\n    substFormat: $6uUbQ$uint16,\n    coverage: new $6uUbQ$Pointer($6uUbQ$uint16, (0, $7cbbe4e24ef3cb75$export$17608c3f81a6111)),\n    backtrackCoverage: new $6uUbQ$Array(new $6uUbQ$Pointer($6uUbQ$uint16, (0, $7cbbe4e24ef3cb75$export$17608c3f81a6111)), 'backtrackGlyphCount'),\n    lookaheadGlyphCount: $6uUbQ$uint16,\n    lookaheadCoverage: new $6uUbQ$Array(new $6uUbQ$Pointer($6uUbQ$uint16, (0, $7cbbe4e24ef3cb75$export$17608c3f81a6111)), 'lookaheadGlyphCount'),\n    glyphCount: $6uUbQ$uint16,\n    substitutes: new $6uUbQ$Array($6uUbQ$uint16, 'glyphCount')\n  }\n});\n// Fix circular reference\n$d3f442064af66e06$var$GSUBLookup.versions[7].extension.type = $d3f442064af66e06$var$GSUBLookup;\nvar $d3f442064af66e06$export$2e2bcd8739ae039 = new $6uUbQ$VersionedStruct($6uUbQ$uint32, {\n  header: {\n    scriptList: new $6uUbQ$Pointer($6uUbQ$uint16, (0, $7cbbe4e24ef3cb75$export$3e15fc05ce864229)),\n    featureList: new $6uUbQ$Pointer($6uUbQ$uint16, (0, $7cbbe4e24ef3cb75$export$aa18130def4b6cb4)),\n    lookupList: new $6uUbQ$Pointer($6uUbQ$uint16, new (0, $7cbbe4e24ef3cb75$export$df0008c6ff2da22a)($d3f442064af66e06$var$GSUBLookup))\n  },\n  0x00010000: {},\n  0x00010001: {\n    featureVariations: new $6uUbQ$Pointer($6uUbQ$uint32, (0, $1a47b0c45c1c22fe$export$441b70b7971dd419))\n  }\n});\nlet $71cfb3c4767fbd0c$var$JstfGSUBModList = new $6uUbQ$Array($6uUbQ$uint16, $6uUbQ$uint16);\nlet $71cfb3c4767fbd0c$var$JstfPriority = new $6uUbQ$Struct({\n  shrinkageEnableGSUB: new $6uUbQ$Pointer($6uUbQ$uint16, $71cfb3c4767fbd0c$var$JstfGSUBModList),\n  shrinkageDisableGSUB: new $6uUbQ$Pointer($6uUbQ$uint16, $71cfb3c4767fbd0c$var$JstfGSUBModList),\n  shrinkageEnableGPOS: new $6uUbQ$Pointer($6uUbQ$uint16, $71cfb3c4767fbd0c$var$JstfGSUBModList),\n  shrinkageDisableGPOS: new $6uUbQ$Pointer($6uUbQ$uint16, $71cfb3c4767fbd0c$var$JstfGSUBModList),\n  shrinkageJstfMax: new $6uUbQ$Pointer($6uUbQ$uint16, new (0, $7cbbe4e24ef3cb75$export$df0008c6ff2da22a)((0, $47e0e8ef515d9903$export$73a8cfb19cd43a0f))),\n  extensionEnableGSUB: new $6uUbQ$Pointer($6uUbQ$uint16, $71cfb3c4767fbd0c$var$JstfGSUBModList),\n  extensionDisableGSUB: new $6uUbQ$Pointer($6uUbQ$uint16, $71cfb3c4767fbd0c$var$JstfGSUBModList),\n  extensionEnableGPOS: new $6uUbQ$Pointer($6uUbQ$uint16, $71cfb3c4767fbd0c$var$JstfGSUBModList),\n  extensionDisableGPOS: new $6uUbQ$Pointer($6uUbQ$uint16, $71cfb3c4767fbd0c$var$JstfGSUBModList),\n  extensionJstfMax: new $6uUbQ$Pointer($6uUbQ$uint16, new (0, $7cbbe4e24ef3cb75$export$df0008c6ff2da22a)((0, $47e0e8ef515d9903$export$73a8cfb19cd43a0f)))\n});\nlet $71cfb3c4767fbd0c$var$JstfLangSys = new $6uUbQ$Array(new $6uUbQ$Pointer($6uUbQ$uint16, $71cfb3c4767fbd0c$var$JstfPriority), $6uUbQ$uint16);\nlet $71cfb3c4767fbd0c$var$JstfLangSysRecord = new $6uUbQ$Struct({\n  tag: new $6uUbQ$String(4),\n  jstfLangSys: new $6uUbQ$Pointer($6uUbQ$uint16, $71cfb3c4767fbd0c$var$JstfLangSys)\n});\nlet $71cfb3c4767fbd0c$var$JstfScript = new $6uUbQ$Struct({\n  extenderGlyphs: new $6uUbQ$Pointer($6uUbQ$uint16, new $6uUbQ$Array($6uUbQ$uint16, $6uUbQ$uint16)),\n  defaultLangSys: new $6uUbQ$Pointer($6uUbQ$uint16, $71cfb3c4767fbd0c$var$JstfLangSys),\n  langSysCount: $6uUbQ$uint16,\n  langSysRecords: new $6uUbQ$Array($71cfb3c4767fbd0c$var$JstfLangSysRecord, 'langSysCount')\n});\nlet $71cfb3c4767fbd0c$var$JstfScriptRecord = new $6uUbQ$Struct({\n  tag: new $6uUbQ$String(4),\n  script: new $6uUbQ$Pointer($6uUbQ$uint16, $71cfb3c4767fbd0c$var$JstfScript, {\n    type: 'parent'\n  })\n});\nvar $71cfb3c4767fbd0c$export$2e2bcd8739ae039 = new $6uUbQ$Struct({\n  version: $6uUbQ$uint32,\n  scriptCount: $6uUbQ$uint16,\n  scriptList: new $6uUbQ$Array($71cfb3c4767fbd0c$var$JstfScriptRecord, 'scriptCount')\n});\n\n// TODO: add this to restructure\nclass $d059a6bd2d3b5b63$var$VariableSizeNumber {\n  decode(stream, parent) {\n    switch (this.size(0, parent)) {\n      case 1:\n        return stream.readUInt8();\n      case 2:\n        return stream.readUInt16BE();\n      case 3:\n        return stream.readUInt24BE();\n      case 4:\n        return stream.readUInt32BE();\n    }\n  }\n  size(val, parent) {\n    return (0, $6uUbQ$resolveLength)(this._size, null, parent);\n  }\n  constructor(size) {\n    this._size = size;\n  }\n}\nlet $d059a6bd2d3b5b63$var$MapDataEntry = new $6uUbQ$Struct({\n  entry: new $d059a6bd2d3b5b63$var$VariableSizeNumber(t => ((t.parent.entryFormat & 0x0030) >> 4) + 1),\n  outerIndex: t => t.entry >> (t.parent.entryFormat & 0x000F) + 1,\n  innerIndex: t => t.entry & (1 << (t.parent.entryFormat & 0x000F) + 1) - 1\n});\nlet $d059a6bd2d3b5b63$var$DeltaSetIndexMap = new $6uUbQ$Struct({\n  entryFormat: $6uUbQ$uint16,\n  mapCount: $6uUbQ$uint16,\n  mapData: new $6uUbQ$Array($d059a6bd2d3b5b63$var$MapDataEntry, 'mapCount')\n});\nvar $d059a6bd2d3b5b63$export$2e2bcd8739ae039 = new $6uUbQ$Struct({\n  majorVersion: $6uUbQ$uint16,\n  minorVersion: $6uUbQ$uint16,\n  itemVariationStore: new $6uUbQ$Pointer($6uUbQ$uint32, (0, $1a47b0c45c1c22fe$export$fe1b122a2710f241)),\n  advanceWidthMapping: new $6uUbQ$Pointer($6uUbQ$uint32, $d059a6bd2d3b5b63$var$DeltaSetIndexMap),\n  LSBMapping: new $6uUbQ$Pointer($6uUbQ$uint32, $d059a6bd2d3b5b63$var$DeltaSetIndexMap),\n  RSBMapping: new $6uUbQ$Pointer($6uUbQ$uint32, $d059a6bd2d3b5b63$var$DeltaSetIndexMap)\n});\nlet $dceeca3e1977ce30$var$Signature = new $6uUbQ$Struct({\n  format: $6uUbQ$uint32,\n  length: $6uUbQ$uint32,\n  offset: $6uUbQ$uint32\n});\nlet $dceeca3e1977ce30$var$SignatureBlock = new $6uUbQ$Struct({\n  reserved: new $6uUbQ$Reserved($6uUbQ$uint16, 2),\n  cbSignature: $6uUbQ$uint32,\n  signature: new $6uUbQ$Buffer('cbSignature')\n});\nvar $dceeca3e1977ce30$export$2e2bcd8739ae039 = new $6uUbQ$Struct({\n  ulVersion: $6uUbQ$uint32,\n  usNumSigs: $6uUbQ$uint16,\n  usFlag: $6uUbQ$uint16,\n  signatures: new $6uUbQ$Array($dceeca3e1977ce30$var$Signature, 'usNumSigs'),\n  signatureBlocks: new $6uUbQ$Array($dceeca3e1977ce30$var$SignatureBlock, 'usNumSigs')\n});\nlet $8acd740a9435aad0$var$GaspRange = new $6uUbQ$Struct({\n  rangeMaxPPEM: $6uUbQ$uint16,\n  rangeGaspBehavior: new $6uUbQ$Bitfield($6uUbQ$uint16, ['grayscale', 'gridfit', 'symmetricSmoothing', 'symmetricGridfit' // only in version 1, for ClearType\n  ])\n});\nvar $8acd740a9435aad0$export$2e2bcd8739ae039 = new $6uUbQ$Struct({\n  version: $6uUbQ$uint16,\n  numRanges: $6uUbQ$uint16,\n  gaspRanges: new $6uUbQ$Array($8acd740a9435aad0$var$GaspRange, 'numRanges') // Sorted by ppem\n});\nlet $b5f380243c34d6a0$var$DeviceRecord = new $6uUbQ$Struct({\n  pixelSize: $6uUbQ$uint8,\n  maximumWidth: $6uUbQ$uint8,\n  widths: new $6uUbQ$Array($6uUbQ$uint8, t => t.parent.parent.maxp.numGlyphs)\n});\nvar\n// The Horizontal Device Metrics table stores integer advance widths scaled to particular pixel sizes\n$b5f380243c34d6a0$export$2e2bcd8739ae039 = new $6uUbQ$Struct({\n  version: $6uUbQ$uint16,\n  numRecords: $6uUbQ$int16,\n  sizeDeviceRecord: $6uUbQ$int32,\n  records: new $6uUbQ$Array($b5f380243c34d6a0$var$DeviceRecord, 'numRecords')\n});\nlet $ca2df1256966e313$var$KernPair = new $6uUbQ$Struct({\n  left: $6uUbQ$uint16,\n  right: $6uUbQ$uint16,\n  value: $6uUbQ$int16\n});\nlet $ca2df1256966e313$var$ClassTable = new $6uUbQ$Struct({\n  firstGlyph: $6uUbQ$uint16,\n  nGlyphs: $6uUbQ$uint16,\n  offsets: new $6uUbQ$Array($6uUbQ$uint16, 'nGlyphs'),\n  max: t => t.offsets.length && Math.max.apply(Math, t.offsets)\n});\nlet $ca2df1256966e313$var$Kern2Array = new $6uUbQ$Struct({\n  off: t => t._startOffset - t.parent.parent._startOffset,\n  len: t => ((t.parent.leftTable.max - t.off) / t.parent.rowWidth + 1) * (t.parent.rowWidth / 2),\n  values: new $6uUbQ$LazyArray($6uUbQ$int16, 'len')\n});\nlet $ca2df1256966e313$var$KernSubtable = new $6uUbQ$VersionedStruct('format', {\n  0: {\n    nPairs: $6uUbQ$uint16,\n    searchRange: $6uUbQ$uint16,\n    entrySelector: $6uUbQ$uint16,\n    rangeShift: $6uUbQ$uint16,\n    pairs: new $6uUbQ$Array($ca2df1256966e313$var$KernPair, 'nPairs')\n  },\n  2: {\n    rowWidth: $6uUbQ$uint16,\n    leftTable: new $6uUbQ$Pointer($6uUbQ$uint16, $ca2df1256966e313$var$ClassTable, {\n      type: 'parent'\n    }),\n    rightTable: new $6uUbQ$Pointer($6uUbQ$uint16, $ca2df1256966e313$var$ClassTable, {\n      type: 'parent'\n    }),\n    array: new $6uUbQ$Pointer($6uUbQ$uint16, $ca2df1256966e313$var$Kern2Array, {\n      type: 'parent'\n    })\n  },\n  3: {\n    glyphCount: $6uUbQ$uint16,\n    kernValueCount: $6uUbQ$uint8,\n    leftClassCount: $6uUbQ$uint8,\n    rightClassCount: $6uUbQ$uint8,\n    flags: $6uUbQ$uint8,\n    kernValue: new $6uUbQ$Array($6uUbQ$int16, 'kernValueCount'),\n    leftClass: new $6uUbQ$Array($6uUbQ$uint8, 'glyphCount'),\n    rightClass: new $6uUbQ$Array($6uUbQ$uint8, 'glyphCount'),\n    kernIndex: new $6uUbQ$Array($6uUbQ$uint8, t => t.leftClassCount * t.rightClassCount)\n  }\n});\nlet $ca2df1256966e313$var$KernTable = new $6uUbQ$VersionedStruct('version', {\n  0: {\n    subVersion: $6uUbQ$uint16,\n    length: $6uUbQ$uint16,\n    format: $6uUbQ$uint8,\n    coverage: new $6uUbQ$Bitfield($6uUbQ$uint8, ['horizontal', 'minimum', 'crossStream', 'override' // If set to 1 the value in this table replaces the accumulated value\n    ]),\n    subtable: $ca2df1256966e313$var$KernSubtable,\n    padding: new $6uUbQ$Reserved($6uUbQ$uint8, t => t.length - t._currentOffset)\n  },\n  1: {\n    length: $6uUbQ$uint32,\n    coverage: new $6uUbQ$Bitfield($6uUbQ$uint8, [null, null, null, null, null, 'variation', 'crossStream', 'vertical' // Set if table has vertical kerning values\n    ]),\n    format: $6uUbQ$uint8,\n    tupleIndex: $6uUbQ$uint16,\n    subtable: $ca2df1256966e313$var$KernSubtable,\n    padding: new $6uUbQ$Reserved($6uUbQ$uint8, t => t.length - t._currentOffset)\n  }\n});\nvar $ca2df1256966e313$export$2e2bcd8739ae039 = new $6uUbQ$VersionedStruct($6uUbQ$uint16, {\n  0: {\n    nTables: $6uUbQ$uint16,\n    tables: new $6uUbQ$Array($ca2df1256966e313$var$KernTable, 'nTables')\n  },\n  1: {\n    reserved: new $6uUbQ$Reserved($6uUbQ$uint16),\n    nTables: $6uUbQ$uint32,\n    tables: new $6uUbQ$Array($ca2df1256966e313$var$KernTable, 'nTables')\n  }\n});\nvar\n// Linear Threshold table\n// Records the ppem for each glyph at which the scaling becomes linear again,\n// despite instructions effecting the advance width\n$7a9f92b0c46ebe33$export$2e2bcd8739ae039 = new $6uUbQ$Struct({\n  version: $6uUbQ$uint16,\n  numGlyphs: $6uUbQ$uint16,\n  yPels: new $6uUbQ$Array($6uUbQ$uint8, 'numGlyphs')\n});\nvar\n// PCL 5 Table\n// NOTE: The PCLT table is strongly discouraged for OpenType fonts with TrueType outlines\n$2b2ccc419d152631$export$2e2bcd8739ae039 = new $6uUbQ$Struct({\n  version: $6uUbQ$uint16,\n  fontNumber: $6uUbQ$uint32,\n  pitch: $6uUbQ$uint16,\n  xHeight: $6uUbQ$uint16,\n  style: $6uUbQ$uint16,\n  typeFamily: $6uUbQ$uint16,\n  capHeight: $6uUbQ$uint16,\n  symbolSet: $6uUbQ$uint16,\n  typeface: new $6uUbQ$String(16),\n  characterComplement: new $6uUbQ$String(8),\n  fileName: new $6uUbQ$String(6),\n  strokeWeight: new $6uUbQ$String(1),\n  widthType: new $6uUbQ$String(1),\n  serifStyle: $6uUbQ$uint8,\n  reserved: new $6uUbQ$Reserved($6uUbQ$uint8)\n});\n\n// VDMX tables contain ascender/descender overrides for certain (usually small)\n// sizes. This is needed in order to match font metrics on Windows.\nlet $ca5b40b9bcda9c9b$var$Ratio = new $6uUbQ$Struct({\n  bCharSet: $6uUbQ$uint8,\n  xRatio: $6uUbQ$uint8,\n  yStartRatio: $6uUbQ$uint8,\n  yEndRatio: $6uUbQ$uint8 // Ending y-Ratio value\n});\nlet $ca5b40b9bcda9c9b$var$vTable = new $6uUbQ$Struct({\n  yPelHeight: $6uUbQ$uint16,\n  yMax: $6uUbQ$int16,\n  yMin: $6uUbQ$int16 // Minimum value (in pels) for this yPelHeight\n});\nlet $ca5b40b9bcda9c9b$var$VdmxGroup = new $6uUbQ$Struct({\n  recs: $6uUbQ$uint16,\n  startsz: $6uUbQ$uint8,\n  endsz: $6uUbQ$uint8,\n  entries: new $6uUbQ$Array($ca5b40b9bcda9c9b$var$vTable, 'recs') // The VDMX records\n});\nvar $ca5b40b9bcda9c9b$export$2e2bcd8739ae039 = new $6uUbQ$Struct({\n  version: $6uUbQ$uint16,\n  numRecs: $6uUbQ$uint16,\n  numRatios: $6uUbQ$uint16,\n  ratioRanges: new $6uUbQ$Array($ca5b40b9bcda9c9b$var$Ratio, 'numRatios'),\n  offsets: new $6uUbQ$Array($6uUbQ$uint16, 'numRatios'),\n  groups: new $6uUbQ$Array($ca5b40b9bcda9c9b$var$VdmxGroup, 'numRecs') // The actual VDMX groupings\n});\nvar\n// Vertical Header Table\n$69530a3c40755af0$export$2e2bcd8739ae039 = new $6uUbQ$Struct({\n  version: $6uUbQ$uint16,\n  ascent: $6uUbQ$int16,\n  descent: $6uUbQ$int16,\n  lineGap: $6uUbQ$int16,\n  advanceHeightMax: $6uUbQ$int16,\n  minTopSideBearing: $6uUbQ$int16,\n  minBottomSideBearing: $6uUbQ$int16,\n  yMaxExtent: $6uUbQ$int16,\n  caretSlopeRise: $6uUbQ$int16,\n  caretSlopeRun: $6uUbQ$int16,\n  caretOffset: $6uUbQ$int16,\n  reserved: new $6uUbQ$Reserved($6uUbQ$int16, 4),\n  metricDataFormat: $6uUbQ$int16,\n  numberOfMetrics: $6uUbQ$uint16 // Number of advance heights in the Vertical Metrics table\n});\nlet $344073dd270f0e62$var$VmtxEntry = new $6uUbQ$Struct({\n  advance: $6uUbQ$uint16,\n  bearing: $6uUbQ$int16 // The top sidebearing of the glyph\n});\nvar\n// Vertical Metrics Table\n$344073dd270f0e62$export$2e2bcd8739ae039 = new $6uUbQ$Struct({\n  metrics: new $6uUbQ$LazyArray($344073dd270f0e62$var$VmtxEntry, t => t.parent.vhea.numberOfMetrics),\n  bearings: new $6uUbQ$LazyArray($6uUbQ$int16, t => t.parent.maxp.numGlyphs - t.parent.vhea.numberOfMetrics)\n});\nlet $3793b781918cfced$var$shortFrac = new $6uUbQ$Fixed(16, 'BE', 14);\nlet $3793b781918cfced$var$Correspondence = new $6uUbQ$Struct({\n  fromCoord: $3793b781918cfced$var$shortFrac,\n  toCoord: $3793b781918cfced$var$shortFrac\n});\nlet $3793b781918cfced$var$Segment = new $6uUbQ$Struct({\n  pairCount: $6uUbQ$uint16,\n  correspondence: new $6uUbQ$Array($3793b781918cfced$var$Correspondence, 'pairCount')\n});\nvar $3793b781918cfced$export$2e2bcd8739ae039 = new $6uUbQ$Struct({\n  version: $6uUbQ$fixed32,\n  axisCount: $6uUbQ$uint32,\n  segment: new $6uUbQ$Array($3793b781918cfced$var$Segment, 'axisCount')\n});\nclass $6cb7dd5f47d82580$var$UnboundedArrayAccessor {\n  getItem(index) {\n    if (this._items[index] == null) {\n      let pos = this.stream.pos;\n      this.stream.pos = this.base + this.type.size(null, this.parent) * index;\n      this._items[index] = this.type.decode(this.stream, this.parent);\n      this.stream.pos = pos;\n    }\n    return this._items[index];\n  }\n  inspect() {\n    return `[UnboundedArray ${this.type.constructor.name}]`;\n  }\n  constructor(type, stream, parent) {\n    this.type = type;\n    this.stream = stream;\n    this.parent = parent;\n    this.base = this.stream.pos;\n    this._items = [];\n  }\n}\nclass $6cb7dd5f47d82580$export$c5af1eebc882e39a extends $6uUbQ$Array {\n  decode(stream, parent) {\n    return new $6cb7dd5f47d82580$var$UnboundedArrayAccessor(this.type, stream, parent);\n  }\n  constructor(type) {\n    super(type, 0);\n  }\n}\nlet $6cb7dd5f47d82580$export$8351f8c2ae2f103c = function () {\n  let ValueType = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : $6uUbQ$uint16;\n  // Helper class that makes internal structures invisible to pointers\n  class Shadow {\n    decode(stream, ctx) {\n      ctx = ctx.parent.parent;\n      return this.type.decode(stream, ctx);\n    }\n    size(val, ctx) {\n      ctx = ctx.parent.parent;\n      return this.type.size(val, ctx);\n    }\n    encode(stream, val, ctx) {\n      ctx = ctx.parent.parent;\n      return this.type.encode(stream, val, ctx);\n    }\n    constructor(type) {\n      this.type = type;\n    }\n  }\n  ValueType = new Shadow(ValueType);\n  let BinarySearchHeader = new $6uUbQ$Struct({\n    unitSize: $6uUbQ$uint16,\n    nUnits: $6uUbQ$uint16,\n    searchRange: $6uUbQ$uint16,\n    entrySelector: $6uUbQ$uint16,\n    rangeShift: $6uUbQ$uint16\n  });\n  let LookupSegmentSingle = new $6uUbQ$Struct({\n    lastGlyph: $6uUbQ$uint16,\n    firstGlyph: $6uUbQ$uint16,\n    value: ValueType\n  });\n  let LookupSegmentArray = new $6uUbQ$Struct({\n    lastGlyph: $6uUbQ$uint16,\n    firstGlyph: $6uUbQ$uint16,\n    values: new $6uUbQ$Pointer($6uUbQ$uint16, new $6uUbQ$Array(ValueType, t => t.lastGlyph - t.firstGlyph + 1), {\n      type: 'parent'\n    })\n  });\n  let LookupSingle = new $6uUbQ$Struct({\n    glyph: $6uUbQ$uint16,\n    value: ValueType\n  });\n  return new $6uUbQ$VersionedStruct($6uUbQ$uint16, {\n    0: {\n      values: new $6cb7dd5f47d82580$export$c5af1eebc882e39a(ValueType) // length == number of glyphs maybe?\n    },\n    2: {\n      binarySearchHeader: BinarySearchHeader,\n      segments: new $6uUbQ$Array(LookupSegmentSingle, t => t.binarySearchHeader.nUnits)\n    },\n    4: {\n      binarySearchHeader: BinarySearchHeader,\n      segments: new $6uUbQ$Array(LookupSegmentArray, t => t.binarySearchHeader.nUnits)\n    },\n    6: {\n      binarySearchHeader: BinarySearchHeader,\n      segments: new $6uUbQ$Array(LookupSingle, t => t.binarySearchHeader.nUnits)\n    },\n    8: {\n      firstGlyph: $6uUbQ$uint16,\n      count: $6uUbQ$uint16,\n      values: new $6uUbQ$Array(ValueType, 'count')\n    }\n  });\n};\nfunction $6cb7dd5f47d82580$export$79f7d93d790934ba() {\n  let entryData = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  let lookupType = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : $6uUbQ$uint16;\n  let entry = Object.assign({\n    newState: $6uUbQ$uint16,\n    flags: $6uUbQ$uint16\n  }, entryData);\n  let Entry = new $6uUbQ$Struct(entry);\n  let StateArray = new $6cb7dd5f47d82580$export$c5af1eebc882e39a(new $6uUbQ$Array($6uUbQ$uint16, t => t.nClasses));\n  let StateHeader = new $6uUbQ$Struct({\n    nClasses: $6uUbQ$uint32,\n    classTable: new $6uUbQ$Pointer($6uUbQ$uint32, new $6cb7dd5f47d82580$export$8351f8c2ae2f103c(lookupType)),\n    stateArray: new $6uUbQ$Pointer($6uUbQ$uint32, StateArray),\n    entryTable: new $6uUbQ$Pointer($6uUbQ$uint32, new $6cb7dd5f47d82580$export$c5af1eebc882e39a(Entry))\n  });\n  return StateHeader;\n}\nfunction $6cb7dd5f47d82580$export$105027425199cc51() {\n  let entryData = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  let lookupType = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : $6uUbQ$uint16;\n  let ClassLookupTable = new $6uUbQ$Struct({\n    version() {\n      return 8;\n    },\n    firstGlyph: $6uUbQ$uint16,\n    values: new $6uUbQ$Array($6uUbQ$uint8, $6uUbQ$uint16)\n  });\n  let entry = Object.assign({\n    newStateOffset: $6uUbQ$uint16,\n    // convert offset to stateArray index\n    newState: t => (t.newStateOffset - (t.parent.stateArray.base - t.parent._startOffset)) / t.parent.nClasses,\n    flags: $6uUbQ$uint16\n  }, entryData);\n  let Entry = new $6uUbQ$Struct(entry);\n  let StateArray = new $6cb7dd5f47d82580$export$c5af1eebc882e39a(new $6uUbQ$Array($6uUbQ$uint8, t => t.nClasses));\n  let StateHeader1 = new $6uUbQ$Struct({\n    nClasses: $6uUbQ$uint16,\n    classTable: new $6uUbQ$Pointer($6uUbQ$uint16, ClassLookupTable),\n    stateArray: new $6uUbQ$Pointer($6uUbQ$uint16, StateArray),\n    entryTable: new $6uUbQ$Pointer($6uUbQ$uint16, new $6cb7dd5f47d82580$export$c5af1eebc882e39a(Entry))\n  });\n  return StateHeader1;\n}\nlet $6a3746e8c708f5a3$var$BslnSubtable = new $6uUbQ$VersionedStruct('format', {\n  0: {\n    deltas: new $6uUbQ$Array($6uUbQ$int16, 32)\n  },\n  1: {\n    deltas: new $6uUbQ$Array($6uUbQ$int16, 32),\n    mappingData: new (0, $6cb7dd5f47d82580$export$8351f8c2ae2f103c)($6uUbQ$uint16)\n  },\n  2: {\n    standardGlyph: $6uUbQ$uint16,\n    controlPoints: new $6uUbQ$Array($6uUbQ$uint16, 32)\n  },\n  3: {\n    standardGlyph: $6uUbQ$uint16,\n    controlPoints: new $6uUbQ$Array($6uUbQ$uint16, 32),\n    mappingData: new (0, $6cb7dd5f47d82580$export$8351f8c2ae2f103c)($6uUbQ$uint16)\n  }\n});\nvar $6a3746e8c708f5a3$export$2e2bcd8739ae039 = new $6uUbQ$Struct({\n  version: $6uUbQ$fixed32,\n  format: $6uUbQ$uint16,\n  defaultBaseline: $6uUbQ$uint16,\n  subtable: $6a3746e8c708f5a3$var$BslnSubtable\n});\nlet $d0c76fac617b308a$var$Setting = new $6uUbQ$Struct({\n  setting: $6uUbQ$uint16,\n  nameIndex: $6uUbQ$int16,\n  name: t => t.parent.parent.parent.name.records.fontFeatures[t.nameIndex]\n});\nlet $d0c76fac617b308a$var$FeatureName = new $6uUbQ$Struct({\n  feature: $6uUbQ$uint16,\n  nSettings: $6uUbQ$uint16,\n  settingTable: new $6uUbQ$Pointer($6uUbQ$uint32, new $6uUbQ$Array($d0c76fac617b308a$var$Setting, 'nSettings'), {\n    type: 'parent'\n  }),\n  featureFlags: new $6uUbQ$Bitfield($6uUbQ$uint8, [null, null, null, null, null, null, 'hasDefault', 'exclusive']),\n  defaultSetting: $6uUbQ$uint8,\n  nameIndex: $6uUbQ$int16,\n  name: t => t.parent.parent.name.records.fontFeatures[t.nameIndex]\n});\nvar $d0c76fac617b308a$export$2e2bcd8739ae039 = new $6uUbQ$Struct({\n  version: $6uUbQ$fixed32,\n  featureNameCount: $6uUbQ$uint16,\n  reserved1: new $6uUbQ$Reserved($6uUbQ$uint16),\n  reserved2: new $6uUbQ$Reserved($6uUbQ$uint32),\n  featureNames: new $6uUbQ$Array($d0c76fac617b308a$var$FeatureName, 'featureNameCount')\n});\nlet $e83fd065f00fcd01$var$Axis = new $6uUbQ$Struct({\n  axisTag: new $6uUbQ$String(4),\n  minValue: $6uUbQ$fixed32,\n  defaultValue: $6uUbQ$fixed32,\n  maxValue: $6uUbQ$fixed32,\n  flags: $6uUbQ$uint16,\n  nameID: $6uUbQ$uint16,\n  name: t => t.parent.parent.name.records.fontFeatures[t.nameID]\n});\nlet $e83fd065f00fcd01$var$Instance = new $6uUbQ$Struct({\n  nameID: $6uUbQ$uint16,\n  name: t => t.parent.parent.name.records.fontFeatures[t.nameID],\n  flags: $6uUbQ$uint16,\n  coord: new $6uUbQ$Array($6uUbQ$fixed32, t => t.parent.axisCount),\n  postscriptNameID: new $6uUbQ$Optional($6uUbQ$uint16, t => t.parent.instanceSize - t._currentOffset > 0)\n});\nvar $e83fd065f00fcd01$export$2e2bcd8739ae039 = new $6uUbQ$Struct({\n  version: $6uUbQ$fixed32,\n  offsetToData: $6uUbQ$uint16,\n  countSizePairs: $6uUbQ$uint16,\n  axisCount: $6uUbQ$uint16,\n  axisSize: $6uUbQ$uint16,\n  instanceCount: $6uUbQ$uint16,\n  instanceSize: $6uUbQ$uint16,\n  axis: new $6uUbQ$Array($e83fd065f00fcd01$var$Axis, 'axisCount'),\n  instance: new $6uUbQ$Array($e83fd065f00fcd01$var$Instance, 'instanceCount')\n});\nlet $dbe33c8d3a7f131c$var$shortFrac = new $6uUbQ$Fixed(16, 'BE', 14);\nclass $dbe33c8d3a7f131c$var$Offset {\n  static decode(stream, parent) {\n    // In short format, offsets are multiplied by 2.\n    // This doesn't seem to be documented by Apple, but it\n    // is implemented this way in Freetype.\n    return parent.flags ? stream.readUInt32BE() : stream.readUInt16BE() * 2;\n  }\n}\nlet $dbe33c8d3a7f131c$var$gvar = new $6uUbQ$Struct({\n  version: $6uUbQ$uint16,\n  reserved: new $6uUbQ$Reserved($6uUbQ$uint16),\n  axisCount: $6uUbQ$uint16,\n  globalCoordCount: $6uUbQ$uint16,\n  globalCoords: new $6uUbQ$Pointer($6uUbQ$uint32, new $6uUbQ$Array(new $6uUbQ$Array($dbe33c8d3a7f131c$var$shortFrac, 'axisCount'), 'globalCoordCount')),\n  glyphCount: $6uUbQ$uint16,\n  flags: $6uUbQ$uint16,\n  offsetToData: $6uUbQ$uint32,\n  offsets: new $6uUbQ$Array(new $6uUbQ$Pointer($dbe33c8d3a7f131c$var$Offset, 'void', {\n    relativeTo: ctx => ctx.offsetToData,\n    allowNull: false\n  }), t => t.glyphCount + 1)\n});\nvar $dbe33c8d3a7f131c$export$2e2bcd8739ae039 = $dbe33c8d3a7f131c$var$gvar;\nlet $05b01887df96c4ee$var$ClassTable = new $6uUbQ$Struct({\n  length: $6uUbQ$uint16,\n  coverage: $6uUbQ$uint16,\n  subFeatureFlags: $6uUbQ$uint32,\n  stateTable: new (0, $6cb7dd5f47d82580$export$105027425199cc51)()\n});\nlet $05b01887df96c4ee$var$WidthDeltaRecord = new $6uUbQ$Struct({\n  justClass: $6uUbQ$uint32,\n  beforeGrowLimit: $6uUbQ$fixed32,\n  beforeShrinkLimit: $6uUbQ$fixed32,\n  afterGrowLimit: $6uUbQ$fixed32,\n  afterShrinkLimit: $6uUbQ$fixed32,\n  growFlags: $6uUbQ$uint16,\n  shrinkFlags: $6uUbQ$uint16\n});\nlet $05b01887df96c4ee$var$WidthDeltaCluster = new $6uUbQ$Array($05b01887df96c4ee$var$WidthDeltaRecord, $6uUbQ$uint32);\nlet $05b01887df96c4ee$var$ActionData = new $6uUbQ$VersionedStruct('actionType', {\n  0: {\n    lowerLimit: $6uUbQ$fixed32,\n    upperLimit: $6uUbQ$fixed32,\n    order: $6uUbQ$uint16,\n    glyphs: new $6uUbQ$Array($6uUbQ$uint16, $6uUbQ$uint16)\n  },\n  1: {\n    addGlyph: $6uUbQ$uint16\n  },\n  2: {\n    substThreshold: $6uUbQ$fixed32,\n    addGlyph: $6uUbQ$uint16,\n    substGlyph: $6uUbQ$uint16\n  },\n  3: {},\n  4: {\n    variationAxis: $6uUbQ$uint32,\n    minimumLimit: $6uUbQ$fixed32,\n    noStretchValue: $6uUbQ$fixed32,\n    maximumLimit: $6uUbQ$fixed32\n  },\n  5: {\n    flags: $6uUbQ$uint16,\n    glyph: $6uUbQ$uint16\n  }\n});\nlet $05b01887df96c4ee$var$Action = new $6uUbQ$Struct({\n  actionClass: $6uUbQ$uint16,\n  actionType: $6uUbQ$uint16,\n  actionLength: $6uUbQ$uint32,\n  actionData: $05b01887df96c4ee$var$ActionData,\n  padding: new $6uUbQ$Reserved($6uUbQ$uint8, t => t.actionLength - t._currentOffset)\n});\nlet $05b01887df96c4ee$var$PostcompensationAction = new $6uUbQ$Array($05b01887df96c4ee$var$Action, $6uUbQ$uint32);\nlet $05b01887df96c4ee$var$PostCompensationTable = new $6uUbQ$Struct({\n  lookupTable: new (0, $6cb7dd5f47d82580$export$8351f8c2ae2f103c)(new $6uUbQ$Pointer($6uUbQ$uint16, $05b01887df96c4ee$var$PostcompensationAction))\n});\nlet $05b01887df96c4ee$var$JustificationTable = new $6uUbQ$Struct({\n  classTable: new $6uUbQ$Pointer($6uUbQ$uint16, $05b01887df96c4ee$var$ClassTable, {\n    type: 'parent'\n  }),\n  wdcOffset: $6uUbQ$uint16,\n  postCompensationTable: new $6uUbQ$Pointer($6uUbQ$uint16, $05b01887df96c4ee$var$PostCompensationTable, {\n    type: 'parent'\n  }),\n  widthDeltaClusters: new (0, $6cb7dd5f47d82580$export$8351f8c2ae2f103c)(new $6uUbQ$Pointer($6uUbQ$uint16, $05b01887df96c4ee$var$WidthDeltaCluster, {\n    type: 'parent',\n    relativeTo: ctx => ctx.wdcOffset\n  }))\n});\nvar $05b01887df96c4ee$export$2e2bcd8739ae039 = new $6uUbQ$Struct({\n  version: $6uUbQ$uint32,\n  format: $6uUbQ$uint16,\n  horizontal: new $6uUbQ$Pointer($6uUbQ$uint16, $05b01887df96c4ee$var$JustificationTable),\n  vertical: new $6uUbQ$Pointer($6uUbQ$uint16, $05b01887df96c4ee$var$JustificationTable)\n});\nlet $03ee6ebd54db1053$var$LigatureData = {\n  action: $6uUbQ$uint16\n};\nlet $03ee6ebd54db1053$var$ContextualData = {\n  markIndex: $6uUbQ$uint16,\n  currentIndex: $6uUbQ$uint16\n};\nlet $03ee6ebd54db1053$var$InsertionData = {\n  currentInsertIndex: $6uUbQ$uint16,\n  markedInsertIndex: $6uUbQ$uint16\n};\nlet $03ee6ebd54db1053$var$SubstitutionTable = new $6uUbQ$Struct({\n  items: new (0, $6cb7dd5f47d82580$export$c5af1eebc882e39a)(new $6uUbQ$Pointer($6uUbQ$uint32, new (0, $6cb7dd5f47d82580$export$8351f8c2ae2f103c)()))\n});\nlet $03ee6ebd54db1053$var$SubtableData = new $6uUbQ$VersionedStruct('type', {\n  0: {\n    stateTable: new (0, $6cb7dd5f47d82580$export$79f7d93d790934ba)()\n  },\n  1: {\n    stateTable: new (0, $6cb7dd5f47d82580$export$79f7d93d790934ba)($03ee6ebd54db1053$var$ContextualData),\n    substitutionTable: new $6uUbQ$Pointer($6uUbQ$uint32, $03ee6ebd54db1053$var$SubstitutionTable)\n  },\n  2: {\n    stateTable: new (0, $6cb7dd5f47d82580$export$79f7d93d790934ba)($03ee6ebd54db1053$var$LigatureData),\n    ligatureActions: new $6uUbQ$Pointer($6uUbQ$uint32, new (0, $6cb7dd5f47d82580$export$c5af1eebc882e39a)($6uUbQ$uint32)),\n    components: new $6uUbQ$Pointer($6uUbQ$uint32, new (0, $6cb7dd5f47d82580$export$c5af1eebc882e39a)($6uUbQ$uint16)),\n    ligatureList: new $6uUbQ$Pointer($6uUbQ$uint32, new (0, $6cb7dd5f47d82580$export$c5af1eebc882e39a)($6uUbQ$uint16))\n  },\n  4: {\n    lookupTable: new (0, $6cb7dd5f47d82580$export$8351f8c2ae2f103c)()\n  },\n  5: {\n    stateTable: new (0, $6cb7dd5f47d82580$export$79f7d93d790934ba)($03ee6ebd54db1053$var$InsertionData),\n    insertionActions: new $6uUbQ$Pointer($6uUbQ$uint32, new (0, $6cb7dd5f47d82580$export$c5af1eebc882e39a)($6uUbQ$uint16))\n  }\n});\nlet $03ee6ebd54db1053$var$Subtable = new $6uUbQ$Struct({\n  length: $6uUbQ$uint32,\n  coverage: $6uUbQ$uint24,\n  type: $6uUbQ$uint8,\n  subFeatureFlags: $6uUbQ$uint32,\n  table: $03ee6ebd54db1053$var$SubtableData,\n  padding: new $6uUbQ$Reserved($6uUbQ$uint8, t => t.length - t._currentOffset)\n});\nlet $03ee6ebd54db1053$var$FeatureEntry = new $6uUbQ$Struct({\n  featureType: $6uUbQ$uint16,\n  featureSetting: $6uUbQ$uint16,\n  enableFlags: $6uUbQ$uint32,\n  disableFlags: $6uUbQ$uint32\n});\nlet $03ee6ebd54db1053$var$MorxChain = new $6uUbQ$Struct({\n  defaultFlags: $6uUbQ$uint32,\n  chainLength: $6uUbQ$uint32,\n  nFeatureEntries: $6uUbQ$uint32,\n  nSubtables: $6uUbQ$uint32,\n  features: new $6uUbQ$Array($03ee6ebd54db1053$var$FeatureEntry, 'nFeatureEntries'),\n  subtables: new $6uUbQ$Array($03ee6ebd54db1053$var$Subtable, 'nSubtables')\n});\nvar $03ee6ebd54db1053$export$2e2bcd8739ae039 = new $6uUbQ$Struct({\n  version: $6uUbQ$uint16,\n  unused: new $6uUbQ$Reserved($6uUbQ$uint16),\n  nChains: $6uUbQ$uint32,\n  chains: new $6uUbQ$Array($03ee6ebd54db1053$var$MorxChain, 'nChains')\n});\nlet $b7492a80b0d1a056$var$OpticalBounds = new $6uUbQ$Struct({\n  left: $6uUbQ$int16,\n  top: $6uUbQ$int16,\n  right: $6uUbQ$int16,\n  bottom: $6uUbQ$int16\n});\nvar $b7492a80b0d1a056$export$2e2bcd8739ae039 = new $6uUbQ$Struct({\n  version: $6uUbQ$fixed32,\n  format: $6uUbQ$uint16,\n  lookupTable: new (0, $6cb7dd5f47d82580$export$8351f8c2ae2f103c)($b7492a80b0d1a056$var$OpticalBounds)\n});\nlet $c3395722bea751e2$var$tables = {};\nvar $c3395722bea751e2$export$2e2bcd8739ae039 = $c3395722bea751e2$var$tables;\n$c3395722bea751e2$var$tables.cmap = (0, $26a62205ad06574e$export$2e2bcd8739ae039);\n$c3395722bea751e2$var$tables.head = (0, $f2612a29f92ac062$export$2e2bcd8739ae039);\n$c3395722bea751e2$var$tables.hhea = (0, $2c179dd593583073$export$2e2bcd8739ae039);\n$c3395722bea751e2$var$tables.hmtx = (0, $bdc9060542264b85$export$2e2bcd8739ae039);\n$c3395722bea751e2$var$tables.maxp = (0, $dbf51cb3d3fe409d$export$2e2bcd8739ae039);\n$c3395722bea751e2$var$tables.name = (0, $2bcf221753ec8e32$export$2e2bcd8739ae039);\n$c3395722bea751e2$var$tables['OS/2'] = (0, $84b272aa31b70606$export$2e2bcd8739ae039);\n$c3395722bea751e2$var$tables.post = (0, $32d9e2eb9565d93c$export$2e2bcd8739ae039);\n$c3395722bea751e2$var$tables.fpgm = (0, $5c0f37ca5ffb1850$export$2e2bcd8739ae039);\n$c3395722bea751e2$var$tables.loca = (0, $2b2b260902b1c57e$export$2e2bcd8739ae039);\n$c3395722bea751e2$var$tables.prep = (0, $7afb878c7bea4f66$export$2e2bcd8739ae039);\n$c3395722bea751e2$var$tables['cvt '] = (0, $5202bd9d9ad8eaac$export$2e2bcd8739ae039);\n$c3395722bea751e2$var$tables.glyf = (0, $6c92b6371bce8bd9$export$2e2bcd8739ae039);\n$c3395722bea751e2$var$tables['CFF '] = (0, $822ac0d589e4e237$export$2e2bcd8739ae039);\n$c3395722bea751e2$var$tables['CFF2'] = (0, $822ac0d589e4e237$export$2e2bcd8739ae039);\n$c3395722bea751e2$var$tables.VORG = (0, $2bbf2bc1ce37cd8f$export$2e2bcd8739ae039);\n$c3395722bea751e2$var$tables.EBLC = (0, $9911c4c7201c13de$export$2e2bcd8739ae039);\n$c3395722bea751e2$var$tables.CBLC = $c3395722bea751e2$var$tables.EBLC;\n$c3395722bea751e2$var$tables.sbix = (0, $abb847051efd51b1$export$2e2bcd8739ae039);\n$c3395722bea751e2$var$tables.COLR = (0, $eb629188f3dfefdd$export$2e2bcd8739ae039);\n$c3395722bea751e2$var$tables.CPAL = (0, $08734b8e7dc64587$export$2e2bcd8739ae039);\n$c3395722bea751e2$var$tables.BASE = (0, $497cef411d884e34$export$2e2bcd8739ae039);\n$c3395722bea751e2$var$tables.GDEF = (0, $cf5f33c63ef209e6$export$2e2bcd8739ae039);\n$c3395722bea751e2$var$tables.GPOS = (0, $47e0e8ef515d9903$export$2e2bcd8739ae039);\n$c3395722bea751e2$var$tables.GSUB = (0, $d3f442064af66e06$export$2e2bcd8739ae039);\n$c3395722bea751e2$var$tables.JSTF = (0, $71cfb3c4767fbd0c$export$2e2bcd8739ae039);\n$c3395722bea751e2$var$tables.HVAR = (0, $d059a6bd2d3b5b63$export$2e2bcd8739ae039);\n$c3395722bea751e2$var$tables.DSIG = (0, $dceeca3e1977ce30$export$2e2bcd8739ae039);\n$c3395722bea751e2$var$tables.gasp = (0, $8acd740a9435aad0$export$2e2bcd8739ae039);\n$c3395722bea751e2$var$tables.hdmx = (0, $b5f380243c34d6a0$export$2e2bcd8739ae039);\n$c3395722bea751e2$var$tables.kern = (0, $ca2df1256966e313$export$2e2bcd8739ae039);\n$c3395722bea751e2$var$tables.LTSH = (0, $7a9f92b0c46ebe33$export$2e2bcd8739ae039);\n$c3395722bea751e2$var$tables.PCLT = (0, $2b2ccc419d152631$export$2e2bcd8739ae039);\n$c3395722bea751e2$var$tables.VDMX = (0, $ca5b40b9bcda9c9b$export$2e2bcd8739ae039);\n$c3395722bea751e2$var$tables.vhea = (0, $69530a3c40755af0$export$2e2bcd8739ae039);\n$c3395722bea751e2$var$tables.vmtx = (0, $344073dd270f0e62$export$2e2bcd8739ae039);\n$c3395722bea751e2$var$tables.avar = (0, $3793b781918cfced$export$2e2bcd8739ae039);\n$c3395722bea751e2$var$tables.bsln = (0, $6a3746e8c708f5a3$export$2e2bcd8739ae039);\n$c3395722bea751e2$var$tables.feat = (0, $d0c76fac617b308a$export$2e2bcd8739ae039);\n$c3395722bea751e2$var$tables.fvar = (0, $e83fd065f00fcd01$export$2e2bcd8739ae039);\n$c3395722bea751e2$var$tables.gvar = (0, $dbe33c8d3a7f131c$export$2e2bcd8739ae039);\n$c3395722bea751e2$var$tables.just = (0, $05b01887df96c4ee$export$2e2bcd8739ae039);\n$c3395722bea751e2$var$tables.morx = (0, $03ee6ebd54db1053$export$2e2bcd8739ae039);\n$c3395722bea751e2$var$tables.opbd = (0, $b7492a80b0d1a056$export$2e2bcd8739ae039);\nlet $816c07a04b6dba87$var$TableEntry = new $6uUbQ$Struct({\n  tag: new $6uUbQ$String(4),\n  checkSum: $6uUbQ$uint32,\n  offset: new $6uUbQ$Pointer($6uUbQ$uint32, 'void', {\n    type: 'global'\n  }),\n  length: $6uUbQ$uint32\n});\nlet $816c07a04b6dba87$var$Directory = new $6uUbQ$Struct({\n  tag: new $6uUbQ$String(4),\n  numTables: $6uUbQ$uint16,\n  searchRange: $6uUbQ$uint16,\n  entrySelector: $6uUbQ$uint16,\n  rangeShift: $6uUbQ$uint16,\n  tables: new $6uUbQ$Array($816c07a04b6dba87$var$TableEntry, 'numTables')\n});\n$816c07a04b6dba87$var$Directory.process = function () {\n  let tables = {};\n  for (let table of this.tables) tables[table.tag] = table;\n  this.tables = tables;\n};\n$816c07a04b6dba87$var$Directory.preEncode = function () {\n  if (!Array.isArray(this.tables)) {\n    let tables = [];\n    for (let tag in this.tables) {\n      let table = this.tables[tag];\n      if (table) tables.push({\n        tag: tag,\n        checkSum: 0,\n        offset: new $6uUbQ$VoidPointer((0, $c3395722bea751e2$export$2e2bcd8739ae039)[tag], table),\n        length: (0, $c3395722bea751e2$export$2e2bcd8739ae039)[tag].size(table)\n      });\n    }\n    this.tables = tables;\n  }\n  this.tag = 'true';\n  this.numTables = this.tables.length;\n  let maxExponentFor2 = Math.floor(Math.log(this.numTables) / Math.LN2);\n  let maxPowerOf2 = Math.pow(2, maxExponentFor2);\n  this.searchRange = maxPowerOf2 * 16;\n  this.entrySelector = Math.log(maxPowerOf2) / Math.LN2;\n  this.rangeShift = this.numTables * 16 - this.searchRange;\n};\nvar $816c07a04b6dba87$export$2e2bcd8739ae039 = $816c07a04b6dba87$var$Directory;\nfunction $12727730ddfc8bfe$export$2e0ae67339d5f1ac(arr, cmp) {\n  let min = 0;\n  let max = arr.length - 1;\n  while (min <= max) {\n    let mid = min + max >> 1;\n    let res = cmp(arr[mid]);\n    if (res < 0) max = mid - 1;else if (res > 0) min = mid + 1;else return mid;\n  }\n  return -1;\n}\nfunction $12727730ddfc8bfe$export$d02631cccf789723(index, end) {\n  let range = [];\n  while (index < end) range.push(index++);\n  return range;\n}\nconst $12727730ddfc8bfe$export$3d28c1996ced1f14 = new TextDecoder('ascii');\n// Based on https://github.com/niklasvh/base64-arraybuffer. MIT license.\nconst $12727730ddfc8bfe$var$CHARS = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';\nconst $12727730ddfc8bfe$var$LOOKUP = new Uint8Array(256);\nfor (let i = 0; i < $12727730ddfc8bfe$var$CHARS.length; i++) $12727730ddfc8bfe$var$LOOKUP[$12727730ddfc8bfe$var$CHARS.charCodeAt(i)] = i;\nfunction $12727730ddfc8bfe$export$94fdf11bafc8de6b(base64) {\n  let bufferLength = base64.length * 0.75;\n  if (base64[base64.length - 1] === '=') {\n    bufferLength--;\n    if (base64[base64.length - 2] === '=') bufferLength--;\n  }\n  let bytes = new Uint8Array(bufferLength);\n  let p = 0;\n  for (let i = 0, len = base64.length; i < len; i += 4) {\n    let encoded1 = $12727730ddfc8bfe$var$LOOKUP[base64.charCodeAt(i)];\n    let encoded2 = $12727730ddfc8bfe$var$LOOKUP[base64.charCodeAt(i + 1)];\n    let encoded3 = $12727730ddfc8bfe$var$LOOKUP[base64.charCodeAt(i + 2)];\n    let encoded4 = $12727730ddfc8bfe$var$LOOKUP[base64.charCodeAt(i + 3)];\n    bytes[p++] = encoded1 << 2 | encoded2 >> 4;\n    bytes[p++] = (encoded2 & 15) << 4 | encoded3 >> 2;\n    bytes[p++] = (encoded3 & 3) << 6 | encoded4 & 63;\n  }\n  return bytes;\n}\nclass $f08dd41ef10b694c$export$2e2bcd8739ae039 {\n  findSubtable(cmapTable, pairs) {\n    for (let [platformID, encodingID] of pairs) for (let cmap of cmapTable.tables) {\n      if (cmap.platformID === platformID && cmap.encodingID === encodingID) return cmap.table;\n    }\n    return null;\n  }\n  lookup(codepoint, variationSelector) {\n    // If there is no Unicode cmap in this font, we need to re-encode\n    // the codepoint in the encoding that the cmap supports.\n    if (this.encoding) codepoint = this.encoding.get(codepoint) || codepoint;else if (variationSelector) {\n      let gid = this.getVariationSelector(codepoint, variationSelector);\n      if (gid) return gid;\n    }\n    let cmap = this.cmap;\n    switch (cmap.version) {\n      case 0:\n        return cmap.codeMap.get(codepoint) || 0;\n      case 4:\n        {\n          let min = 0;\n          let max = cmap.segCount - 1;\n          while (min <= max) {\n            let mid = min + max >> 1;\n            if (codepoint < cmap.startCode.get(mid)) max = mid - 1;else if (codepoint > cmap.endCode.get(mid)) min = mid + 1;else {\n              let rangeOffset = cmap.idRangeOffset.get(mid);\n              let gid;\n              if (rangeOffset === 0) gid = codepoint + cmap.idDelta.get(mid);else {\n                let index = rangeOffset / 2 + (codepoint - cmap.startCode.get(mid)) - (cmap.segCount - mid);\n                gid = cmap.glyphIndexArray.get(index) || 0;\n                if (gid !== 0) gid += cmap.idDelta.get(mid);\n              }\n              return gid & 0xffff;\n            }\n          }\n          return 0;\n        }\n      case 8:\n        throw new Error('TODO: cmap format 8');\n      case 6:\n      case 10:\n        return cmap.glyphIndices.get(codepoint - cmap.firstCode) || 0;\n      case 12:\n      case 13:\n        {\n          let min = 0;\n          let max = cmap.nGroups - 1;\n          while (min <= max) {\n            let mid = min + max >> 1;\n            let group = cmap.groups.get(mid);\n            if (codepoint < group.startCharCode) max = mid - 1;else if (codepoint > group.endCharCode) min = mid + 1;else {\n              if (cmap.version === 12) return group.glyphID + (codepoint - group.startCharCode);else return group.glyphID;\n            }\n          }\n          return 0;\n        }\n      case 14:\n        throw new Error('TODO: cmap format 14');\n      default:\n        throw new Error(`Unknown cmap format ${cmap.version}`);\n    }\n  }\n  getVariationSelector(codepoint, variationSelector) {\n    if (!this.uvs) return 0;\n    let selectors = this.uvs.varSelectors.toArray();\n    let i = (0, $12727730ddfc8bfe$export$2e0ae67339d5f1ac)(selectors, x => variationSelector - x.varSelector);\n    let sel = selectors[i];\n    if (i !== -1 && sel.defaultUVS) i = (0, $12727730ddfc8bfe$export$2e0ae67339d5f1ac)(sel.defaultUVS, x => codepoint < x.startUnicodeValue ? -1 : codepoint > x.startUnicodeValue + x.additionalCount ? 1 : 0);\n    if (i !== -1 && sel.nonDefaultUVS) {\n      i = (0, $12727730ddfc8bfe$export$2e0ae67339d5f1ac)(sel.nonDefaultUVS, x => codepoint - x.unicodeValue);\n      if (i !== -1) return sel.nonDefaultUVS[i].glyphID;\n    }\n    return 0;\n  }\n  getCharacterSet() {\n    let cmap = this.cmap;\n    switch (cmap.version) {\n      case 0:\n        return (0, $12727730ddfc8bfe$export$d02631cccf789723)(0, cmap.codeMap.length);\n      case 4:\n        {\n          let res = [];\n          let endCodes = cmap.endCode.toArray();\n          for (let i = 0; i < endCodes.length; i++) {\n            let tail = endCodes[i] + 1;\n            let start = cmap.startCode.get(i);\n            res.push(...(0, $12727730ddfc8bfe$export$d02631cccf789723)(start, tail));\n          }\n          return res;\n        }\n      case 8:\n        throw new Error('TODO: cmap format 8');\n      case 6:\n      case 10:\n        return (0, $12727730ddfc8bfe$export$d02631cccf789723)(cmap.firstCode, cmap.firstCode + cmap.glyphIndices.length);\n      case 12:\n      case 13:\n        {\n          let res = [];\n          for (let group of cmap.groups.toArray()) res.push(...(0, $12727730ddfc8bfe$export$d02631cccf789723)(group.startCharCode, group.endCharCode + 1));\n          return res;\n        }\n      case 14:\n        throw new Error('TODO: cmap format 14');\n      default:\n        throw new Error(`Unknown cmap format ${cmap.version}`);\n    }\n  }\n  codePointsForGlyph(gid) {\n    let cmap = this.cmap;\n    switch (cmap.version) {\n      case 0:\n        {\n          let res = [];\n          for (let i = 0; i < 256; i++) if (cmap.codeMap.get(i) === gid) res.push(i);\n          return res;\n        }\n      case 4:\n        {\n          let res = [];\n          for (let i = 0; i < cmap.segCount; i++) {\n            let end = cmap.endCode.get(i);\n            let start = cmap.startCode.get(i);\n            let rangeOffset = cmap.idRangeOffset.get(i);\n            let delta = cmap.idDelta.get(i);\n            for (var c = start; c <= end; c++) {\n              let g = 0;\n              if (rangeOffset === 0) g = c + delta;else {\n                let index = rangeOffset / 2 + (c - start) - (cmap.segCount - i);\n                g = cmap.glyphIndexArray.get(index) || 0;\n                if (g !== 0) g += delta;\n              }\n              if (g === gid) res.push(c);\n            }\n          }\n          return res;\n        }\n      case 12:\n        {\n          let res = [];\n          for (let group of cmap.groups.toArray()) if (gid >= group.glyphID && gid <= group.glyphID + (group.endCharCode - group.startCharCode)) res.push(group.startCharCode + (gid - group.glyphID));\n          return res;\n        }\n      case 13:\n        {\n          let res = [];\n          for (let group of cmap.groups.toArray()) if (gid === group.glyphID) res.push(...(0, $12727730ddfc8bfe$export$d02631cccf789723)(group.startCharCode, group.endCharCode + 1));\n          return res;\n        }\n      default:\n        throw new Error(`Unknown cmap format ${cmap.version}`);\n    }\n  }\n  constructor(cmapTable) {\n    // Attempt to find a Unicode cmap first\n    this.encoding = null;\n    this.cmap = this.findSubtable(cmapTable, [\n    // 32-bit subtables\n    [3, 10], [0, 6], [0, 4],\n    // 16-bit subtables\n    [3, 1], [0, 3], [0, 2], [0, 1], [0, 0]]);\n    // If not unicode cmap was found, take the first table with a supported encoding.\n    if (!this.cmap) for (let cmap of cmapTable.tables) {\n      let encoding = (0, $e449ad78d50845fe$export$badc544e0651b6b1)(cmap.platformID, cmap.encodingID, cmap.table.language - 1);\n      let mapping = (0, $e449ad78d50845fe$export$1dceb3c14ed68bee)(encoding);\n      if (mapping) {\n        this.cmap = cmap.table;\n        this.encoding = mapping;\n      }\n    }\n    if (!this.cmap) throw new Error(\"Could not find a supported cmap table\");\n    this.uvs = this.findSubtable(cmapTable, [[0, 5]]);\n    if (this.uvs && this.uvs.version !== 14) this.uvs = null;\n  }\n}\n(0, $6uUbQ$_1)([(0, $e71565f2ce09cb6b$export$69a3209f1a06c04d)], $f08dd41ef10b694c$export$2e2bcd8739ae039.prototype, \"getCharacterSet\", null);\n(0, $6uUbQ$_1)([(0, $e71565f2ce09cb6b$export$69a3209f1a06c04d)], $f08dd41ef10b694c$export$2e2bcd8739ae039.prototype, \"codePointsForGlyph\", null);\nclass $0bba3a9db57637f3$export$2e2bcd8739ae039 {\n  process(glyphs, positions) {\n    for (let glyphIndex = 0; glyphIndex < glyphs.length - 1; glyphIndex++) {\n      let left = glyphs[glyphIndex].id;\n      let right = glyphs[glyphIndex + 1].id;\n      positions[glyphIndex].xAdvance += this.getKerning(left, right);\n    }\n  }\n  getKerning(left, right) {\n    let res = 0;\n    for (let table of this.kern.tables) {\n      if (table.coverage.crossStream) continue;\n      switch (table.version) {\n        case 0:\n          if (!table.coverage.horizontal) continue;\n          break;\n        case 1:\n          if (table.coverage.vertical || table.coverage.variation) continue;\n          break;\n        default:\n          throw new Error(`Unsupported kerning table version ${table.version}`);\n      }\n      let val = 0;\n      let s = table.subtable;\n      switch (table.format) {\n        case 0:\n          let pairIdx = (0, $12727730ddfc8bfe$export$2e0ae67339d5f1ac)(s.pairs, function (pair) {\n            return left - pair.left || right - pair.right;\n          });\n          if (pairIdx >= 0) val = s.pairs[pairIdx].value;\n          break;\n        case 2:\n          let leftOffset = 0,\n            rightOffset = 0;\n          if (left >= s.leftTable.firstGlyph && left < s.leftTable.firstGlyph + s.leftTable.nGlyphs) leftOffset = s.leftTable.offsets[left - s.leftTable.firstGlyph];else leftOffset = s.array.off;\n          if (right >= s.rightTable.firstGlyph && right < s.rightTable.firstGlyph + s.rightTable.nGlyphs) rightOffset = s.rightTable.offsets[right - s.rightTable.firstGlyph];\n          let index = (leftOffset + rightOffset - s.array.off) / 2;\n          val = s.array.values.get(index);\n          break;\n        case 3:\n          if (left >= s.glyphCount || right >= s.glyphCount) return 0;\n          val = s.kernValue[s.kernIndex[s.leftClass[left] * s.rightClassCount + s.rightClass[right]]];\n          break;\n        default:\n          throw new Error(`Unsupported kerning sub-table format ${table.format}`);\n      }\n      // Microsoft supports the override flag, which resets the result\n      // Otherwise, the sum of the results from all subtables is returned\n      if (table.coverage.override) res = val;else res += val;\n    }\n    return res;\n  }\n  constructor(font) {\n    this.kern = font.kern;\n  }\n}\nclass $0a4bdfeb6dfd6f5e$export$2e2bcd8739ae039 {\n  positionGlyphs(glyphs, positions) {\n    // find each base + mark cluster, and position the marks relative to the base\n    let clusterStart = 0;\n    let clusterEnd = 0;\n    for (let index = 0; index < glyphs.length; index++) {\n      let glyph = glyphs[index];\n      if (glyph.isMark) clusterEnd = index;else {\n        if (clusterStart !== clusterEnd) this.positionCluster(glyphs, positions, clusterStart, clusterEnd);\n        clusterStart = clusterEnd = index;\n      }\n    }\n    if (clusterStart !== clusterEnd) this.positionCluster(glyphs, positions, clusterStart, clusterEnd);\n    return positions;\n  }\n  positionCluster(glyphs, positions, clusterStart, clusterEnd) {\n    let base = glyphs[clusterStart];\n    let baseBox = base.cbox.copy();\n    // adjust bounding box for ligature glyphs\n    if (base.codePoints.length > 1)\n      // LTR. TODO: RTL support.\n      baseBox.minX += (base.codePoints.length - 1) * baseBox.width / base.codePoints.length;\n    let xOffset = -positions[clusterStart].xAdvance;\n    let yOffset = 0;\n    let yGap = this.font.unitsPerEm / 16;\n    // position each of the mark glyphs relative to the base glyph\n    for (let index = clusterStart + 1; index <= clusterEnd; index++) {\n      let mark = glyphs[index];\n      let markBox = mark.cbox;\n      let position = positions[index];\n      let combiningClass = this.getCombiningClass(mark.codePoints[0]);\n      if (combiningClass !== 'Not_Reordered') {\n        position.xOffset = position.yOffset = 0;\n        // x positioning\n        switch (combiningClass) {\n          case 'Double_Above':\n          case 'Double_Below':\n            // LTR. TODO: RTL support.\n            position.xOffset += baseBox.minX - markBox.width / 2 - markBox.minX;\n            break;\n          case 'Attached_Below_Left':\n          case 'Below_Left':\n          case 'Above_Left':\n            // left align\n            position.xOffset += baseBox.minX - markBox.minX;\n            break;\n          case 'Attached_Above_Right':\n          case 'Below_Right':\n          case 'Above_Right':\n            // right align\n            position.xOffset += baseBox.maxX - markBox.width - markBox.minX;\n            break;\n          default:\n            // center align\n            position.xOffset += baseBox.minX + (baseBox.width - markBox.width) / 2 - markBox.minX;\n        }\n        // y positioning\n        switch (combiningClass) {\n          case 'Double_Below':\n          case 'Below_Left':\n          case 'Below':\n          case 'Below_Right':\n          case 'Attached_Below_Left':\n          case 'Attached_Below':\n            // add a small gap between the glyphs if they are not attached\n            if (combiningClass === 'Attached_Below_Left' || combiningClass === 'Attached_Below') baseBox.minY += yGap;\n            position.yOffset = -baseBox.minY - markBox.maxY;\n            baseBox.minY += markBox.height;\n            break;\n          case 'Double_Above':\n          case 'Above_Left':\n          case 'Above':\n          case 'Above_Right':\n          case 'Attached_Above':\n          case 'Attached_Above_Right':\n            // add a small gap between the glyphs if they are not attached\n            if (combiningClass === 'Attached_Above' || combiningClass === 'Attached_Above_Right') baseBox.maxY += yGap;\n            position.yOffset = baseBox.maxY - markBox.minY;\n            baseBox.maxY += markBox.height;\n            break;\n        }\n        position.xAdvance = position.yAdvance = 0;\n        position.xOffset += xOffset;\n        position.yOffset += yOffset;\n      } else {\n        xOffset -= position.xAdvance;\n        yOffset -= position.yAdvance;\n      }\n    }\n    return;\n  }\n  getCombiningClass(codePoint) {\n    let combiningClass = (0, $6uUbQ$getCombiningClass)(codePoint);\n    // Thai / Lao need some per-character work\n    if ((codePoint & -256) === 0x0e00) {\n      if (combiningClass === 'Not_Reordered') switch (codePoint) {\n        case 0x0e31:\n        case 0x0e34:\n        case 0x0e35:\n        case 0x0e36:\n        case 0x0e37:\n        case 0x0e47:\n        case 0x0e4c:\n        case 0x0e3d:\n        case 0x0e4e:\n          return 'Above_Right';\n        case 0x0eb1:\n        case 0x0eb4:\n        case 0x0eb5:\n        case 0x0eb6:\n        case 0x0eb7:\n        case 0x0ebb:\n        case 0x0ecc:\n        case 0x0ecd:\n          return 'Above';\n        case 0x0ebc:\n          return 'Below';\n      } else if (codePoint === 0x0e3a) return 'Below_Right';\n    }\n    switch (combiningClass) {\n      // Hebrew\n      case 'CCC10':\n      case 'CCC11':\n      case 'CCC12':\n      case 'CCC13':\n      case 'CCC14':\n      case 'CCC15':\n      case 'CCC16':\n      case 'CCC17':\n      case 'CCC18':\n      case 'CCC20':\n      case 'CCC22':\n        return 'Below';\n      case 'CCC23':\n        return 'Attached_Above';\n      case 'CCC24':\n        return 'Above_Right';\n      case 'CCC25':\n      case 'CCC19':\n        return 'Above_Left';\n      case 'CCC26':\n        return 'Above';\n      case 'CCC21':\n        break;\n      // Arabic and Syriac\n      case 'CCC27':\n      case 'CCC28':\n      case 'CCC30':\n      case 'CCC31':\n      case 'CCC33':\n      case 'CCC34':\n      case 'CCC35':\n      case 'CCC36':\n        return 'Above';\n      case 'CCC29':\n      case 'CCC32':\n        return 'Below';\n      // Thai\n      case 'CCC103':\n        return 'Below_Right';\n      case 'CCC107':\n        return 'Above_Right';\n      // Lao\n      case 'CCC118':\n        return 'Below';\n      case 'CCC122':\n        return 'Above';\n      // Tibetan\n      case 'CCC129':\n      case 'CCC132':\n        return 'Below';\n      case 'CCC130':\n        return 'Above';\n    }\n    return combiningClass;\n  }\n  constructor(font) {\n    this.font = font;\n  }\n}\n\n/**\n * Represents a glyph bounding box\n */\nclass $f34600ab9d7f70d8$export$2e2bcd8739ae039 {\n  /**\n  * The width of the bounding box\n  * @type {number}\n  */\n  get width() {\n    return this.maxX - this.minX;\n  }\n  /**\n  * The height of the bounding box\n  * @type {number}\n  */\n  get height() {\n    return this.maxY - this.minY;\n  }\n  addPoint(x, y) {\n    if (Math.abs(x) !== Infinity) {\n      if (x < this.minX) this.minX = x;\n      if (x > this.maxX) this.maxX = x;\n    }\n    if (Math.abs(y) !== Infinity) {\n      if (y < this.minY) this.minY = y;\n      if (y > this.maxY) this.maxY = y;\n    }\n  }\n  copy() {\n    return new $f34600ab9d7f70d8$export$2e2bcd8739ae039(this.minX, this.minY, this.maxX, this.maxY);\n  }\n  constructor() {\n    let minX = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : Infinity;\n    let minY = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : Infinity;\n    let maxX = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : -Infinity;\n    let maxY = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : -Infinity;\n    /**\n    * The minimum X position in the bounding box\n    * @type {number}\n    */\n    this.minX = minX;\n    /**\n    * The minimum Y position in the bounding box\n    * @type {number}\n    */\n    this.minY = minY;\n    /**\n    * The maxmimum X position in the bounding box\n    * @type {number}\n    */\n    this.maxX = maxX;\n    /**\n    * The maxmimum Y position in the bounding box\n    * @type {number}\n    */\n    this.maxY = maxY;\n  }\n}\n\n// This maps the Unicode Script property to an OpenType script tag\n// Data from http://www.microsoft.com/typography/otspec/scripttags.htm\n// and http://www.unicode.org/Public/UNIDATA/PropertyValueAliases.txt.\nconst $130d1a642ebcd2b7$var$UNICODE_SCRIPTS = {\n  Caucasian_Albanian: 'aghb',\n  Arabic: 'arab',\n  Imperial_Aramaic: 'armi',\n  Armenian: 'armn',\n  Avestan: 'avst',\n  Balinese: 'bali',\n  Bamum: 'bamu',\n  Bassa_Vah: 'bass',\n  Batak: 'batk',\n  Bengali: ['bng2', 'beng'],\n  Bopomofo: 'bopo',\n  Brahmi: 'brah',\n  Braille: 'brai',\n  Buginese: 'bugi',\n  Buhid: 'buhd',\n  Chakma: 'cakm',\n  Canadian_Aboriginal: 'cans',\n  Carian: 'cari',\n  Cham: 'cham',\n  Cherokee: 'cher',\n  Coptic: 'copt',\n  Cypriot: 'cprt',\n  Cyrillic: 'cyrl',\n  Devanagari: ['dev2', 'deva'],\n  Deseret: 'dsrt',\n  Duployan: 'dupl',\n  Egyptian_Hieroglyphs: 'egyp',\n  Elbasan: 'elba',\n  Ethiopic: 'ethi',\n  Georgian: 'geor',\n  Glagolitic: 'glag',\n  Gothic: 'goth',\n  Grantha: 'gran',\n  Greek: 'grek',\n  Gujarati: ['gjr2', 'gujr'],\n  Gurmukhi: ['gur2', 'guru'],\n  Hangul: 'hang',\n  Han: 'hani',\n  Hanunoo: 'hano',\n  Hebrew: 'hebr',\n  Hiragana: 'hira',\n  Pahawh_Hmong: 'hmng',\n  Katakana_Or_Hiragana: 'hrkt',\n  Old_Italic: 'ital',\n  Javanese: 'java',\n  Kayah_Li: 'kali',\n  Katakana: 'kana',\n  Kharoshthi: 'khar',\n  Khmer: 'khmr',\n  Khojki: 'khoj',\n  Kannada: ['knd2', 'knda'],\n  Kaithi: 'kthi',\n  Tai_Tham: 'lana',\n  Lao: 'lao ',\n  Latin: 'latn',\n  Lepcha: 'lepc',\n  Limbu: 'limb',\n  Linear_A: 'lina',\n  Linear_B: 'linb',\n  Lisu: 'lisu',\n  Lycian: 'lyci',\n  Lydian: 'lydi',\n  Mahajani: 'mahj',\n  Mandaic: 'mand',\n  Manichaean: 'mani',\n  Mende_Kikakui: 'mend',\n  Meroitic_Cursive: 'merc',\n  Meroitic_Hieroglyphs: 'mero',\n  Malayalam: ['mlm2', 'mlym'],\n  Modi: 'modi',\n  Mongolian: 'mong',\n  Mro: 'mroo',\n  Meetei_Mayek: 'mtei',\n  Myanmar: ['mym2', 'mymr'],\n  Old_North_Arabian: 'narb',\n  Nabataean: 'nbat',\n  Nko: 'nko ',\n  Ogham: 'ogam',\n  Ol_Chiki: 'olck',\n  Old_Turkic: 'orkh',\n  Oriya: ['ory2', 'orya'],\n  Osmanya: 'osma',\n  Palmyrene: 'palm',\n  Pau_Cin_Hau: 'pauc',\n  Old_Permic: 'perm',\n  Phags_Pa: 'phag',\n  Inscriptional_Pahlavi: 'phli',\n  Psalter_Pahlavi: 'phlp',\n  Phoenician: 'phnx',\n  Miao: 'plrd',\n  Inscriptional_Parthian: 'prti',\n  Rejang: 'rjng',\n  Runic: 'runr',\n  Samaritan: 'samr',\n  Old_South_Arabian: 'sarb',\n  Saurashtra: 'saur',\n  Shavian: 'shaw',\n  Sharada: 'shrd',\n  Siddham: 'sidd',\n  Khudawadi: 'sind',\n  Sinhala: 'sinh',\n  Sora_Sompeng: 'sora',\n  Sundanese: 'sund',\n  Syloti_Nagri: 'sylo',\n  Syriac: 'syrc',\n  Tagbanwa: 'tagb',\n  Takri: 'takr',\n  Tai_Le: 'tale',\n  New_Tai_Lue: 'talu',\n  Tamil: ['tml2', 'taml'],\n  Tai_Viet: 'tavt',\n  Telugu: ['tel2', 'telu'],\n  Tifinagh: 'tfng',\n  Tagalog: 'tglg',\n  Thaana: 'thaa',\n  Thai: 'thai',\n  Tibetan: 'tibt',\n  Tirhuta: 'tirh',\n  Ugaritic: 'ugar',\n  Vai: 'vai ',\n  Warang_Citi: 'wara',\n  Old_Persian: 'xpeo',\n  Cuneiform: 'xsux',\n  Yi: 'yi  ',\n  Inherited: 'zinh',\n  Common: 'zyyy',\n  Unknown: 'zzzz'\n};\nconst $130d1a642ebcd2b7$var$OPENTYPE_SCRIPTS = {};\nfor (let script in $130d1a642ebcd2b7$var$UNICODE_SCRIPTS) {\n  let tag = $130d1a642ebcd2b7$var$UNICODE_SCRIPTS[script];\n  if (Array.isArray(tag)) for (let t of tag) $130d1a642ebcd2b7$var$OPENTYPE_SCRIPTS[t] = script;else $130d1a642ebcd2b7$var$OPENTYPE_SCRIPTS[tag] = script;\n}\nfunction $130d1a642ebcd2b7$export$b32f0b5f69d65e51(script) {\n  return $130d1a642ebcd2b7$var$UNICODE_SCRIPTS[script];\n}\nfunction $130d1a642ebcd2b7$export$ce50e82f12a827a4(tag) {\n  return $130d1a642ebcd2b7$var$OPENTYPE_SCRIPTS[tag];\n}\nfunction $130d1a642ebcd2b7$export$e5cb25e204fb8450(string) {\n  let len = string.length;\n  let idx = 0;\n  while (idx < len) {\n    let code = string.charCodeAt(idx++);\n    // Check if this is a high surrogate\n    if (0xd800 <= code && code <= 0xdbff && idx < len) {\n      let next = string.charCodeAt(idx);\n      // Check if this is a low surrogate\n      if (0xdc00 <= next && next <= 0xdfff) {\n        idx++;\n        code = ((code & 0x3FF) << 10) + (next & 0x3FF) + 0x10000;\n      }\n    }\n    let script = (0, $6uUbQ$getScript)(code);\n    if (script !== 'Common' && script !== 'Inherited' && script !== 'Unknown') return $130d1a642ebcd2b7$var$UNICODE_SCRIPTS[script];\n  }\n  return $130d1a642ebcd2b7$var$UNICODE_SCRIPTS.Unknown;\n}\nfunction $130d1a642ebcd2b7$export$16fab0757cfc223d(codePoints) {\n  for (let i = 0; i < codePoints.length; i++) {\n    let codePoint = codePoints[i];\n    let script = (0, $6uUbQ$getScript)(codePoint);\n    if (script !== 'Common' && script !== 'Inherited' && script !== 'Unknown') return $130d1a642ebcd2b7$var$UNICODE_SCRIPTS[script];\n  }\n  return $130d1a642ebcd2b7$var$UNICODE_SCRIPTS.Unknown;\n}\n// The scripts in this map are written from right to left\nconst $130d1a642ebcd2b7$var$RTL = {\n  arab: true,\n  hebr: true,\n  syrc: true,\n  thaa: true,\n  cprt: true,\n  khar: true,\n  phnx: true,\n  'nko ': true,\n  lydi: true,\n  avst: true,\n  armi: true,\n  phli: true,\n  prti: true,\n  sarb: true,\n  orkh: true,\n  samr: true,\n  mand: true,\n  merc: true,\n  mero: true,\n  // Unicode 7.0 (not listed on http://www.microsoft.com/typography/otspec/scripttags.htm)\n  mani: true,\n  mend: true,\n  nbat: true,\n  narb: true,\n  palm: true,\n  phlp: true // Psalter Pahlavi\n};\nfunction $130d1a642ebcd2b7$export$9fddb9d0dd7d8a54(script) {\n  if ($130d1a642ebcd2b7$var$RTL[script]) return 'rtl';\n  return 'ltr';\n}\nclass $be07b3e97a42687a$export$2e2bcd8739ae039 {\n  /**\n  * The total advance width of the run.\n  * @type {number}\n  */\n  get advanceWidth() {\n    let width = 0;\n    for (let position of this.positions) width += position.xAdvance;\n    return width;\n  }\n  /**\n  * The total advance height of the run.\n  * @type {number}\n  */\n  get advanceHeight() {\n    let height = 0;\n    for (let position of this.positions) height += position.yAdvance;\n    return height;\n  }\n  /**\n  * The bounding box containing all glyphs in the run.\n  * @type {BBox}\n  */\n  get bbox() {\n    let bbox = new (0, $f34600ab9d7f70d8$export$2e2bcd8739ae039)();\n    let x = 0;\n    let y = 0;\n    for (let index = 0; index < this.glyphs.length; index++) {\n      let glyph = this.glyphs[index];\n      let p = this.positions[index];\n      let b = glyph.bbox;\n      bbox.addPoint(b.minX + x + p.xOffset, b.minY + y + p.yOffset);\n      bbox.addPoint(b.maxX + x + p.xOffset, b.maxY + y + p.yOffset);\n      x += p.xAdvance;\n      y += p.yAdvance;\n    }\n    return bbox;\n  }\n  constructor(glyphs, features, script, language, direction) {\n    /**\n    * An array of Glyph objects in the run\n    * @type {Glyph[]}\n    */\n    this.glyphs = glyphs;\n    /**\n    * An array of GlyphPosition objects for each glyph in the run\n    * @type {GlyphPosition[]}\n    */\n    this.positions = null;\n    /**\n    * The script that was requested for shaping. This was either passed in or detected automatically.\n    * @type {string}\n    */\n    this.script = script;\n    /**\n    * The language requested for shaping, as passed in. If `null`, the default language for the\n    * script was used.\n    * @type {string}\n    */\n    this.language = language || null;\n    /**\n    * The direction requested for shaping, as passed in (either ltr or rtl).\n    * If `null`, the default direction of the script is used.\n    * @type {string}\n    */\n    this.direction = direction || $130d1a642ebcd2b7$export$9fddb9d0dd7d8a54(script);\n    /**\n    * The features requested during shaping. This is a combination of user\n    * specified features and features chosen by the shaper.\n    * @type {object}\n    */\n    this.features = {};\n    // Convert features to an object\n    if (Array.isArray(features)) for (let tag of features) this.features[tag] = true;else if (typeof features === 'object') this.features = features;\n  }\n}\n\n/**\n * Represents positioning information for a glyph in a GlyphRun.\n */\nclass $1ac75d9a55b67f01$export$2e2bcd8739ae039 {\n  constructor() {\n    let xAdvance = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n    let yAdvance = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n    let xOffset = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n    let yOffset = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;\n    /**\n    * The amount to move the virtual pen in the X direction after rendering this glyph.\n    * @type {number}\n    */\n    this.xAdvance = xAdvance;\n    /**\n    * The amount to move the virtual pen in the Y direction after rendering this glyph.\n    * @type {number}\n    */\n    this.yAdvance = yAdvance;\n    /**\n    * The offset from the pen position in the X direction at which to render this glyph.\n    * @type {number}\n    */\n    this.xOffset = xOffset;\n    /**\n    * The offset from the pen position in the Y direction at which to render this glyph.\n    * @type {number}\n    */\n    this.yOffset = yOffset;\n  }\n}\n\n// see https://developer.apple.com/fonts/TrueType-Reference-Manual/RM09/AppendixF.html\n// and /System/Library/Frameworks/CoreText.framework/Versions/A/Headers/SFNTLayoutTypes.h on a Mac\nconst $3b6302b64eccc32c$var$features = {\n  allTypographicFeatures: {\n    code: 0,\n    exclusive: false,\n    allTypeFeatures: 0\n  },\n  ligatures: {\n    code: 1,\n    exclusive: false,\n    requiredLigatures: 0,\n    commonLigatures: 2,\n    rareLigatures: 4,\n    // logos: 6\n    rebusPictures: 8,\n    diphthongLigatures: 10,\n    squaredLigatures: 12,\n    abbrevSquaredLigatures: 14,\n    symbolLigatures: 16,\n    contextualLigatures: 18,\n    historicalLigatures: 20\n  },\n  cursiveConnection: {\n    code: 2,\n    exclusive: true,\n    unconnected: 0,\n    partiallyConnected: 1,\n    cursive: 2\n  },\n  letterCase: {\n    code: 3,\n    exclusive: true\n  },\n  // upperAndLowerCase: 0          # deprecated\n  // allCaps: 1                    # deprecated\n  // allLowerCase: 2               # deprecated\n  // smallCaps: 3                  # deprecated\n  // initialCaps: 4                # deprecated\n  // initialCapsAndSmallCaps: 5    # deprecated\n  verticalSubstitution: {\n    code: 4,\n    exclusive: false,\n    substituteVerticalForms: 0\n  },\n  linguisticRearrangement: {\n    code: 5,\n    exclusive: false,\n    linguisticRearrangement: 0\n  },\n  numberSpacing: {\n    code: 6,\n    exclusive: true,\n    monospacedNumbers: 0,\n    proportionalNumbers: 1,\n    thirdWidthNumbers: 2,\n    quarterWidthNumbers: 3\n  },\n  smartSwash: {\n    code: 8,\n    exclusive: false,\n    wordInitialSwashes: 0,\n    wordFinalSwashes: 2,\n    // lineInitialSwashes: 4\n    // lineFinalSwashes: 6\n    nonFinalSwashes: 8\n  },\n  diacritics: {\n    code: 9,\n    exclusive: true,\n    showDiacritics: 0,\n    hideDiacritics: 1,\n    decomposeDiacritics: 2\n  },\n  verticalPosition: {\n    code: 10,\n    exclusive: true,\n    normalPosition: 0,\n    superiors: 1,\n    inferiors: 2,\n    ordinals: 3,\n    scientificInferiors: 4\n  },\n  fractions: {\n    code: 11,\n    exclusive: true,\n    noFractions: 0,\n    verticalFractions: 1,\n    diagonalFractions: 2\n  },\n  overlappingCharacters: {\n    code: 13,\n    exclusive: false,\n    preventOverlap: 0\n  },\n  typographicExtras: {\n    code: 14,\n    exclusive: false,\n    // hyphensToEmDash: 0\n    // hyphenToEnDash: 2\n    slashedZero: 4\n  },\n  // formInterrobang: 6\n  // smartQuotes: 8\n  // periodsToEllipsis: 10\n  mathematicalExtras: {\n    code: 15,\n    exclusive: false,\n    // hyphenToMinus: 0\n    // asteristoMultiply: 2\n    // slashToDivide: 4\n    // inequalityLigatures: 6\n    // exponents: 8\n    mathematicalGreek: 10\n  },\n  ornamentSets: {\n    code: 16,\n    exclusive: true,\n    noOrnaments: 0,\n    dingbats: 1,\n    piCharacters: 2,\n    fleurons: 3,\n    decorativeBorders: 4,\n    internationalSymbols: 5,\n    mathSymbols: 6\n  },\n  characterAlternatives: {\n    code: 17,\n    exclusive: true,\n    noAlternates: 0\n  },\n  // user defined options\n  designComplexity: {\n    code: 18,\n    exclusive: true,\n    designLevel1: 0,\n    designLevel2: 1,\n    designLevel3: 2,\n    designLevel4: 3,\n    designLevel5: 4\n  },\n  styleOptions: {\n    code: 19,\n    exclusive: true,\n    noStyleOptions: 0,\n    displayText: 1,\n    engravedText: 2,\n    illuminatedCaps: 3,\n    titlingCaps: 4,\n    tallCaps: 5\n  },\n  characterShape: {\n    code: 20,\n    exclusive: true,\n    traditionalCharacters: 0,\n    simplifiedCharacters: 1,\n    JIS1978Characters: 2,\n    JIS1983Characters: 3,\n    JIS1990Characters: 4,\n    traditionalAltOne: 5,\n    traditionalAltTwo: 6,\n    traditionalAltThree: 7,\n    traditionalAltFour: 8,\n    traditionalAltFive: 9,\n    expertCharacters: 10,\n    JIS2004Characters: 11,\n    hojoCharacters: 12,\n    NLCCharacters: 13,\n    traditionalNamesCharacters: 14\n  },\n  numberCase: {\n    code: 21,\n    exclusive: true,\n    lowerCaseNumbers: 0,\n    upperCaseNumbers: 1\n  },\n  textSpacing: {\n    code: 22,\n    exclusive: true,\n    proportionalText: 0,\n    monospacedText: 1,\n    halfWidthText: 2,\n    thirdWidthText: 3,\n    quarterWidthText: 4,\n    altProportionalText: 5,\n    altHalfWidthText: 6\n  },\n  transliteration: {\n    code: 23,\n    exclusive: true,\n    noTransliteration: 0\n  },\n  // hanjaToHangul: 1\n  // hiraganaToKatakana: 2\n  // katakanaToHiragana: 3\n  // kanaToRomanization: 4\n  // romanizationToHiragana: 5\n  // romanizationToKatakana: 6\n  // hanjaToHangulAltOne: 7\n  // hanjaToHangulAltTwo: 8\n  // hanjaToHangulAltThree: 9\n  annotation: {\n    code: 24,\n    exclusive: true,\n    noAnnotation: 0,\n    boxAnnotation: 1,\n    roundedBoxAnnotation: 2,\n    circleAnnotation: 3,\n    invertedCircleAnnotation: 4,\n    parenthesisAnnotation: 5,\n    periodAnnotation: 6,\n    romanNumeralAnnotation: 7,\n    diamondAnnotation: 8,\n    invertedBoxAnnotation: 9,\n    invertedRoundedBoxAnnotation: 10\n  },\n  kanaSpacing: {\n    code: 25,\n    exclusive: true,\n    fullWidthKana: 0,\n    proportionalKana: 1\n  },\n  ideographicSpacing: {\n    code: 26,\n    exclusive: true,\n    fullWidthIdeographs: 0,\n    proportionalIdeographs: 1,\n    halfWidthIdeographs: 2\n  },\n  unicodeDecomposition: {\n    code: 27,\n    exclusive: false,\n    canonicalComposition: 0,\n    compatibilityComposition: 2,\n    transcodingComposition: 4\n  },\n  rubyKana: {\n    code: 28,\n    exclusive: false,\n    // noRubyKana: 0     # deprecated - use rubyKanaOff instead\n    // rubyKana: 1     # deprecated - use rubyKanaOn instead\n    rubyKana: 2\n  },\n  CJKSymbolAlternatives: {\n    code: 29,\n    exclusive: true,\n    noCJKSymbolAlternatives: 0,\n    CJKSymbolAltOne: 1,\n    CJKSymbolAltTwo: 2,\n    CJKSymbolAltThree: 3,\n    CJKSymbolAltFour: 4,\n    CJKSymbolAltFive: 5\n  },\n  ideographicAlternatives: {\n    code: 30,\n    exclusive: true,\n    noIdeographicAlternatives: 0,\n    ideographicAltOne: 1,\n    ideographicAltTwo: 2,\n    ideographicAltThree: 3,\n    ideographicAltFour: 4,\n    ideographicAltFive: 5\n  },\n  CJKVerticalRomanPlacement: {\n    code: 31,\n    exclusive: true,\n    CJKVerticalRomanCentered: 0,\n    CJKVerticalRomanHBaseline: 1\n  },\n  italicCJKRoman: {\n    code: 32,\n    exclusive: false,\n    // noCJKItalicRoman: 0     # deprecated - use CJKItalicRomanOff instead\n    // CJKItalicRoman: 1     # deprecated - use CJKItalicRomanOn instead\n    CJKItalicRoman: 2\n  },\n  caseSensitiveLayout: {\n    code: 33,\n    exclusive: false,\n    caseSensitiveLayout: 0,\n    caseSensitiveSpacing: 2\n  },\n  alternateKana: {\n    code: 34,\n    exclusive: false,\n    alternateHorizKana: 0,\n    alternateVertKana: 2\n  },\n  stylisticAlternatives: {\n    code: 35,\n    exclusive: false,\n    noStylisticAlternates: 0,\n    stylisticAltOne: 2,\n    stylisticAltTwo: 4,\n    stylisticAltThree: 6,\n    stylisticAltFour: 8,\n    stylisticAltFive: 10,\n    stylisticAltSix: 12,\n    stylisticAltSeven: 14,\n    stylisticAltEight: 16,\n    stylisticAltNine: 18,\n    stylisticAltTen: 20,\n    stylisticAltEleven: 22,\n    stylisticAltTwelve: 24,\n    stylisticAltThirteen: 26,\n    stylisticAltFourteen: 28,\n    stylisticAltFifteen: 30,\n    stylisticAltSixteen: 32,\n    stylisticAltSeventeen: 34,\n    stylisticAltEighteen: 36,\n    stylisticAltNineteen: 38,\n    stylisticAltTwenty: 40\n  },\n  contextualAlternates: {\n    code: 36,\n    exclusive: false,\n    contextualAlternates: 0,\n    swashAlternates: 2,\n    contextualSwashAlternates: 4\n  },\n  lowerCase: {\n    code: 37,\n    exclusive: true,\n    defaultLowerCase: 0,\n    lowerCaseSmallCaps: 1,\n    lowerCasePetiteCaps: 2\n  },\n  upperCase: {\n    code: 38,\n    exclusive: true,\n    defaultUpperCase: 0,\n    upperCaseSmallCaps: 1,\n    upperCasePetiteCaps: 2\n  },\n  languageTag: {\n    code: 39,\n    exclusive: true\n  },\n  CJKRomanSpacing: {\n    code: 103,\n    exclusive: true,\n    halfWidthCJKRoman: 0,\n    proportionalCJKRoman: 1,\n    defaultCJKRoman: 2,\n    fullWidthCJKRoman: 3\n  }\n};\nconst $3b6302b64eccc32c$var$feature = (name, selector) => [$3b6302b64eccc32c$var$features[name].code, $3b6302b64eccc32c$var$features[name][selector]];\nconst $3b6302b64eccc32c$var$OTMapping = {\n  rlig: $3b6302b64eccc32c$var$feature('ligatures', 'requiredLigatures'),\n  clig: $3b6302b64eccc32c$var$feature('ligatures', 'contextualLigatures'),\n  dlig: $3b6302b64eccc32c$var$feature('ligatures', 'rareLigatures'),\n  hlig: $3b6302b64eccc32c$var$feature('ligatures', 'historicalLigatures'),\n  liga: $3b6302b64eccc32c$var$feature('ligatures', 'commonLigatures'),\n  hist: $3b6302b64eccc32c$var$feature('ligatures', 'historicalLigatures'),\n  smcp: $3b6302b64eccc32c$var$feature('lowerCase', 'lowerCaseSmallCaps'),\n  pcap: $3b6302b64eccc32c$var$feature('lowerCase', 'lowerCasePetiteCaps'),\n  frac: $3b6302b64eccc32c$var$feature('fractions', 'diagonalFractions'),\n  dnom: $3b6302b64eccc32c$var$feature('fractions', 'diagonalFractions'),\n  numr: $3b6302b64eccc32c$var$feature('fractions', 'diagonalFractions'),\n  afrc: $3b6302b64eccc32c$var$feature('fractions', 'verticalFractions'),\n  // aalt\n  // abvf, abvm, abvs, akhn, blwf, blwm, blws, cfar, cjct, cpsp, falt, isol, jalt, ljmo, mset?\n  // ltra, ltrm, nukt, pref, pres, pstf, psts, rand, rkrf, rphf, rtla, rtlm, size, tjmo, tnum?\n  // unic, vatu, vhal, vjmo, vpal, vrt2\n  // dist -> trak table?\n  // kern, vkrn -> kern table\n  // lfbd + opbd + rtbd -> opbd table?\n  // mark, mkmk -> acnt table?\n  // locl -> languageTag + ltag table\n  case: $3b6302b64eccc32c$var$feature('caseSensitiveLayout', 'caseSensitiveLayout'),\n  ccmp: $3b6302b64eccc32c$var$feature('unicodeDecomposition', 'canonicalComposition'),\n  cpct: $3b6302b64eccc32c$var$feature('CJKVerticalRomanPlacement', 'CJKVerticalRomanCentered'),\n  valt: $3b6302b64eccc32c$var$feature('CJKVerticalRomanPlacement', 'CJKVerticalRomanCentered'),\n  swsh: $3b6302b64eccc32c$var$feature('contextualAlternates', 'swashAlternates'),\n  cswh: $3b6302b64eccc32c$var$feature('contextualAlternates', 'contextualSwashAlternates'),\n  curs: $3b6302b64eccc32c$var$feature('cursiveConnection', 'cursive'),\n  c2pc: $3b6302b64eccc32c$var$feature('upperCase', 'upperCasePetiteCaps'),\n  c2sc: $3b6302b64eccc32c$var$feature('upperCase', 'upperCaseSmallCaps'),\n  init: $3b6302b64eccc32c$var$feature('smartSwash', 'wordInitialSwashes'),\n  fin2: $3b6302b64eccc32c$var$feature('smartSwash', 'wordFinalSwashes'),\n  medi: $3b6302b64eccc32c$var$feature('smartSwash', 'nonFinalSwashes'),\n  med2: $3b6302b64eccc32c$var$feature('smartSwash', 'nonFinalSwashes'),\n  fin3: $3b6302b64eccc32c$var$feature('smartSwash', 'wordFinalSwashes'),\n  fina: $3b6302b64eccc32c$var$feature('smartSwash', 'wordFinalSwashes'),\n  pkna: $3b6302b64eccc32c$var$feature('kanaSpacing', 'proportionalKana'),\n  half: $3b6302b64eccc32c$var$feature('textSpacing', 'halfWidthText'),\n  halt: $3b6302b64eccc32c$var$feature('textSpacing', 'altHalfWidthText'),\n  hkna: $3b6302b64eccc32c$var$feature('alternateKana', 'alternateHorizKana'),\n  vkna: $3b6302b64eccc32c$var$feature('alternateKana', 'alternateVertKana'),\n  // hngl: feature 'transliteration', 'hanjaToHangulSelector' # deprecated\n  ital: $3b6302b64eccc32c$var$feature('italicCJKRoman', 'CJKItalicRoman'),\n  lnum: $3b6302b64eccc32c$var$feature('numberCase', 'upperCaseNumbers'),\n  onum: $3b6302b64eccc32c$var$feature('numberCase', 'lowerCaseNumbers'),\n  mgrk: $3b6302b64eccc32c$var$feature('mathematicalExtras', 'mathematicalGreek'),\n  // nalt: not enough info. what type of annotation?\n  // ornm: ditto, which ornament style?\n  calt: $3b6302b64eccc32c$var$feature('contextualAlternates', 'contextualAlternates'),\n  vrt2: $3b6302b64eccc32c$var$feature('verticalSubstitution', 'substituteVerticalForms'),\n  vert: $3b6302b64eccc32c$var$feature('verticalSubstitution', 'substituteVerticalForms'),\n  tnum: $3b6302b64eccc32c$var$feature('numberSpacing', 'monospacedNumbers'),\n  pnum: $3b6302b64eccc32c$var$feature('numberSpacing', 'proportionalNumbers'),\n  sups: $3b6302b64eccc32c$var$feature('verticalPosition', 'superiors'),\n  subs: $3b6302b64eccc32c$var$feature('verticalPosition', 'inferiors'),\n  ordn: $3b6302b64eccc32c$var$feature('verticalPosition', 'ordinals'),\n  pwid: $3b6302b64eccc32c$var$feature('textSpacing', 'proportionalText'),\n  hwid: $3b6302b64eccc32c$var$feature('textSpacing', 'halfWidthText'),\n  qwid: $3b6302b64eccc32c$var$feature('textSpacing', 'quarterWidthText'),\n  twid: $3b6302b64eccc32c$var$feature('textSpacing', 'thirdWidthText'),\n  fwid: $3b6302b64eccc32c$var$feature('textSpacing', 'proportionalText'),\n  palt: $3b6302b64eccc32c$var$feature('textSpacing', 'altProportionalText'),\n  trad: $3b6302b64eccc32c$var$feature('characterShape', 'traditionalCharacters'),\n  smpl: $3b6302b64eccc32c$var$feature('characterShape', 'simplifiedCharacters'),\n  jp78: $3b6302b64eccc32c$var$feature('characterShape', 'JIS1978Characters'),\n  jp83: $3b6302b64eccc32c$var$feature('characterShape', 'JIS1983Characters'),\n  jp90: $3b6302b64eccc32c$var$feature('characterShape', 'JIS1990Characters'),\n  jp04: $3b6302b64eccc32c$var$feature('characterShape', 'JIS2004Characters'),\n  expt: $3b6302b64eccc32c$var$feature('characterShape', 'expertCharacters'),\n  hojo: $3b6302b64eccc32c$var$feature('characterShape', 'hojoCharacters'),\n  nlck: $3b6302b64eccc32c$var$feature('characterShape', 'NLCCharacters'),\n  tnam: $3b6302b64eccc32c$var$feature('characterShape', 'traditionalNamesCharacters'),\n  ruby: $3b6302b64eccc32c$var$feature('rubyKana', 'rubyKana'),\n  titl: $3b6302b64eccc32c$var$feature('styleOptions', 'titlingCaps'),\n  zero: $3b6302b64eccc32c$var$feature('typographicExtras', 'slashedZero'),\n  ss01: $3b6302b64eccc32c$var$feature('stylisticAlternatives', 'stylisticAltOne'),\n  ss02: $3b6302b64eccc32c$var$feature('stylisticAlternatives', 'stylisticAltTwo'),\n  ss03: $3b6302b64eccc32c$var$feature('stylisticAlternatives', 'stylisticAltThree'),\n  ss04: $3b6302b64eccc32c$var$feature('stylisticAlternatives', 'stylisticAltFour'),\n  ss05: $3b6302b64eccc32c$var$feature('stylisticAlternatives', 'stylisticAltFive'),\n  ss06: $3b6302b64eccc32c$var$feature('stylisticAlternatives', 'stylisticAltSix'),\n  ss07: $3b6302b64eccc32c$var$feature('stylisticAlternatives', 'stylisticAltSeven'),\n  ss08: $3b6302b64eccc32c$var$feature('stylisticAlternatives', 'stylisticAltEight'),\n  ss09: $3b6302b64eccc32c$var$feature('stylisticAlternatives', 'stylisticAltNine'),\n  ss10: $3b6302b64eccc32c$var$feature('stylisticAlternatives', 'stylisticAltTen'),\n  ss11: $3b6302b64eccc32c$var$feature('stylisticAlternatives', 'stylisticAltEleven'),\n  ss12: $3b6302b64eccc32c$var$feature('stylisticAlternatives', 'stylisticAltTwelve'),\n  ss13: $3b6302b64eccc32c$var$feature('stylisticAlternatives', 'stylisticAltThirteen'),\n  ss14: $3b6302b64eccc32c$var$feature('stylisticAlternatives', 'stylisticAltFourteen'),\n  ss15: $3b6302b64eccc32c$var$feature('stylisticAlternatives', 'stylisticAltFifteen'),\n  ss16: $3b6302b64eccc32c$var$feature('stylisticAlternatives', 'stylisticAltSixteen'),\n  ss17: $3b6302b64eccc32c$var$feature('stylisticAlternatives', 'stylisticAltSeventeen'),\n  ss18: $3b6302b64eccc32c$var$feature('stylisticAlternatives', 'stylisticAltEighteen'),\n  ss19: $3b6302b64eccc32c$var$feature('stylisticAlternatives', 'stylisticAltNineteen'),\n  ss20: $3b6302b64eccc32c$var$feature('stylisticAlternatives', 'stylisticAltTwenty')\n};\n// salt: feature 'stylisticAlternatives', 'stylisticAltOne' # hmm, which one to choose\n// Add cv01-cv99 features\nfor (let i = 1; i <= 99; i++) $3b6302b64eccc32c$var$OTMapping[`cv${`00${i}`.slice(-2)}`] = [$3b6302b64eccc32c$var$features.characterAlternatives.code, i];\n// create inverse mapping\nlet $3b6302b64eccc32c$var$AATMapping = {};\nfor (let ot in $3b6302b64eccc32c$var$OTMapping) {\n  let aat = $3b6302b64eccc32c$var$OTMapping[ot];\n  if ($3b6302b64eccc32c$var$AATMapping[aat[0]] == null) $3b6302b64eccc32c$var$AATMapping[aat[0]] = {};\n  $3b6302b64eccc32c$var$AATMapping[aat[0]][aat[1]] = ot;\n}\nfunction $3b6302b64eccc32c$export$b813f7d2a1677c16(features) {\n  let res = {};\n  for (let k in features) {\n    let r;\n    if (r = $3b6302b64eccc32c$var$OTMapping[k]) {\n      if (res[r[0]] == null) res[r[0]] = {};\n      res[r[0]][r[1]] = features[k];\n    }\n  }\n  return res;\n}\n// Maps strings in a [featureType, featureSetting]\n// to their equivalent number codes\nfunction $3b6302b64eccc32c$var$mapFeatureStrings(f) {\n  let [type, setting] = f;\n  if (isNaN(type)) var typeCode = $3b6302b64eccc32c$var$features[type] && $3b6302b64eccc32c$var$features[type].code;else var typeCode = type;\n  if (isNaN(setting)) var settingCode = $3b6302b64eccc32c$var$features[type] && $3b6302b64eccc32c$var$features[type][setting];else var settingCode = setting;\n  return [typeCode, settingCode];\n}\nfunction $3b6302b64eccc32c$export$bd6df347a4f391c4(features) {\n  let res = {};\n  if (Array.isArray(features)) for (let k = 0; k < features.length; k++) {\n    let r;\n    let f = $3b6302b64eccc32c$var$mapFeatureStrings(features[k]);\n    if (r = $3b6302b64eccc32c$var$AATMapping[f[0]] && $3b6302b64eccc32c$var$AATMapping[f[0]][f[1]]) res[r] = true;\n  } else if (typeof features === 'object') for (let type in features) {\n    let feature = features[type];\n    for (let setting in feature) {\n      let r;\n      let f = $3b6302b64eccc32c$var$mapFeatureStrings([type, setting]);\n      if (feature[setting] && (r = $3b6302b64eccc32c$var$AATMapping[f[0]] && $3b6302b64eccc32c$var$AATMapping[f[0]][f[1]])) res[r] = true;\n    }\n  }\n  return Object.keys(res);\n}\nclass $ff5ce077dae0f144$export$2e2bcd8739ae039 {\n  lookup(glyph) {\n    switch (this.table.version) {\n      case 0:\n        return this.table.values.getItem(glyph);\n      case 2:\n      case 4:\n        {\n          let min = 0;\n          let max = this.table.binarySearchHeader.nUnits - 1;\n          while (min <= max) {\n            var mid = min + max >> 1;\n            var seg = this.table.segments[mid];\n            // special end of search value\n            if (seg.firstGlyph === 0xffff) return null;\n            if (glyph < seg.firstGlyph) max = mid - 1;else if (glyph > seg.lastGlyph) min = mid + 1;else {\n              if (this.table.version === 2) return seg.value;else return seg.values[glyph - seg.firstGlyph];\n            }\n          }\n          return null;\n        }\n      case 6:\n        {\n          let min = 0;\n          let max = this.table.binarySearchHeader.nUnits - 1;\n          while (min <= max) {\n            var mid = min + max >> 1;\n            var seg = this.table.segments[mid];\n            // special end of search value\n            if (seg.glyph === 0xffff) return null;\n            if (glyph < seg.glyph) max = mid - 1;else if (glyph > seg.glyph) min = mid + 1;else return seg.value;\n          }\n          return null;\n        }\n      case 8:\n        return this.table.values[glyph - this.table.firstGlyph];\n      default:\n        throw new Error(`Unknown lookup table format: ${this.table.version}`);\n    }\n  }\n  glyphsForValue(classValue) {\n    let res = [];\n    switch (this.table.version) {\n      case 2:\n      case 4:\n        for (let segment of this.table.segments) if (this.table.version === 2 && segment.value === classValue) res.push(...(0, $12727730ddfc8bfe$export$d02631cccf789723)(segment.firstGlyph, segment.lastGlyph + 1));else {\n          for (let index = 0; index < segment.values.length; index++) if (segment.values[index] === classValue) res.push(segment.firstGlyph + index);\n        }\n        break;\n      case 6:\n        for (let segment of this.table.segments) if (segment.value === classValue) res.push(segment.glyph);\n        break;\n      case 8:\n        for (let i = 0; i < this.table.values.length; i++) if (this.table.values[i] === classValue) res.push(this.table.firstGlyph + i);\n        break;\n      default:\n        throw new Error(`Unknown lookup table format: ${this.table.version}`);\n    }\n    return res;\n  }\n  constructor(table) {\n    this.table = table;\n  }\n}\n(0, $6uUbQ$_1)([(0, $e71565f2ce09cb6b$export$69a3209f1a06c04d)], $ff5ce077dae0f144$export$2e2bcd8739ae039.prototype, \"glyphsForValue\", null);\nconst $50c7aac9316f2948$var$START_OF_TEXT_STATE = 0;\nconst $50c7aac9316f2948$var$START_OF_LINE_STATE = 1;\nconst $50c7aac9316f2948$var$END_OF_TEXT_CLASS = 0;\nconst $50c7aac9316f2948$var$OUT_OF_BOUNDS_CLASS = 1;\nconst $50c7aac9316f2948$var$DELETED_GLYPH_CLASS = 2;\nconst $50c7aac9316f2948$var$END_OF_LINE_CLASS = 3;\nconst $50c7aac9316f2948$var$DONT_ADVANCE = 0x4000;\nclass $50c7aac9316f2948$export$2e2bcd8739ae039 {\n  process(glyphs, reverse, processEntry) {\n    let currentState = $50c7aac9316f2948$var$START_OF_TEXT_STATE; // START_OF_LINE_STATE is used for kashida glyph insertions sometimes I think?\n    let index = reverse ? glyphs.length - 1 : 0;\n    let dir = reverse ? -1 : 1;\n    while (dir === 1 && index <= glyphs.length || dir === -1 && index >= -1) {\n      let glyph = null;\n      let classCode = $50c7aac9316f2948$var$OUT_OF_BOUNDS_CLASS;\n      let shouldAdvance = true;\n      if (index === glyphs.length || index === -1) classCode = $50c7aac9316f2948$var$END_OF_TEXT_CLASS;else {\n        glyph = glyphs[index];\n        if (glyph.id === 0xffff) classCode = $50c7aac9316f2948$var$DELETED_GLYPH_CLASS;else {\n          classCode = this.lookupTable.lookup(glyph.id);\n          if (classCode == null) classCode = $50c7aac9316f2948$var$OUT_OF_BOUNDS_CLASS;\n        }\n      }\n      let row = this.stateTable.stateArray.getItem(currentState);\n      let entryIndex = row[classCode];\n      let entry = this.stateTable.entryTable.getItem(entryIndex);\n      if (classCode !== $50c7aac9316f2948$var$END_OF_TEXT_CLASS && classCode !== $50c7aac9316f2948$var$DELETED_GLYPH_CLASS) {\n        processEntry(glyph, entry, index);\n        shouldAdvance = !(entry.flags & $50c7aac9316f2948$var$DONT_ADVANCE);\n      }\n      currentState = entry.newState;\n      if (shouldAdvance) index += dir;\n    }\n    return glyphs;\n  }\n  /**\n  * Performs a depth-first traversal of the glyph strings\n  * represented by the state machine.\n  */\n  traverse(opts) {\n    let state = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n    let visited = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : new Set();\n    if (visited.has(state)) return;\n    visited.add(state);\n    let {\n      nClasses: nClasses,\n      stateArray: stateArray,\n      entryTable: entryTable\n    } = this.stateTable;\n    let row = stateArray.getItem(state);\n    // Skip predefined classes\n    for (let classCode = 4; classCode < nClasses; classCode++) {\n      let entryIndex = row[classCode];\n      let entry = entryTable.getItem(entryIndex);\n      // Try all glyphs in the class\n      for (let glyph of this.lookupTable.glyphsForValue(classCode)) {\n        if (opts.enter) opts.enter(glyph, entry);\n        if (entry.newState !== 0) this.traverse(opts, entry.newState, visited);\n        if (opts.exit) opts.exit(glyph, entry);\n      }\n    }\n  }\n  constructor(stateTable) {\n    this.stateTable = stateTable;\n    this.lookupTable = new (0, $ff5ce077dae0f144$export$2e2bcd8739ae039)(stateTable.classTable);\n  }\n}\n\n// indic replacement flags\nconst $55f71433a605c87d$var$MARK_FIRST = 0x8000;\nconst $55f71433a605c87d$var$MARK_LAST = 0x2000;\nconst $55f71433a605c87d$var$VERB = 0x000F;\n// contextual substitution and glyph insertion flag\nconst $55f71433a605c87d$var$SET_MARK = 0x8000;\n// ligature entry flags\nconst $55f71433a605c87d$var$SET_COMPONENT = 0x8000;\nconst $55f71433a605c87d$var$PERFORM_ACTION = 0x2000;\n// ligature action masks\nconst $55f71433a605c87d$var$LAST_MASK = 0x80000000;\nconst $55f71433a605c87d$var$STORE_MASK = 0x40000000;\nconst $55f71433a605c87d$var$OFFSET_MASK = 0x3FFFFFFF;\nconst $55f71433a605c87d$var$VERTICAL_ONLY = 0x800000;\nconst $55f71433a605c87d$var$REVERSE_DIRECTION = 0x400000;\nconst $55f71433a605c87d$var$HORIZONTAL_AND_VERTICAL = 0x200000;\n// glyph insertion flags\nconst $55f71433a605c87d$var$CURRENT_IS_KASHIDA_LIKE = 0x2000;\nconst $55f71433a605c87d$var$MARKED_IS_KASHIDA_LIKE = 0x1000;\nconst $55f71433a605c87d$var$CURRENT_INSERT_BEFORE = 0x0800;\nconst $55f71433a605c87d$var$MARKED_INSERT_BEFORE = 0x0400;\nconst $55f71433a605c87d$var$CURRENT_INSERT_COUNT = 0x03E0;\nconst $55f71433a605c87d$var$MARKED_INSERT_COUNT = 0x001F;\nclass $55f71433a605c87d$export$2e2bcd8739ae039 {\n  // Processes an array of glyphs and applies the specified features\n  // Features should be in the form of {featureType:{featureSetting:boolean}}\n  process(glyphs) {\n    let features = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    for (let chain of this.morx.chains) {\n      let flags = chain.defaultFlags;\n      // enable/disable the requested features\n      for (let feature of chain.features) {\n        let f;\n        if (f = features[feature.featureType]) {\n          if (f[feature.featureSetting]) {\n            flags &= feature.disableFlags;\n            flags |= feature.enableFlags;\n          } else if (f[feature.featureSetting] === false) {\n            flags |= ~feature.disableFlags;\n            flags &= ~feature.enableFlags;\n          }\n        }\n      }\n      for (let subtable of chain.subtables) if (subtable.subFeatureFlags & flags) this.processSubtable(subtable, glyphs);\n    }\n    // remove deleted glyphs\n    let index = glyphs.length - 1;\n    while (index >= 0) {\n      if (glyphs[index].id === 0xffff) glyphs.splice(index, 1);\n      index--;\n    }\n    return glyphs;\n  }\n  processSubtable(subtable, glyphs) {\n    this.subtable = subtable;\n    this.glyphs = glyphs;\n    if (this.subtable.type === 4) {\n      this.processNoncontextualSubstitutions(this.subtable, this.glyphs);\n      return;\n    }\n    this.ligatureStack = [];\n    this.markedGlyph = null;\n    this.firstGlyph = null;\n    this.lastGlyph = null;\n    this.markedIndex = null;\n    let stateMachine = this.getStateMachine(subtable);\n    let process = this.getProcessor();\n    let reverse = !!(this.subtable.coverage & $55f71433a605c87d$var$REVERSE_DIRECTION);\n    return stateMachine.process(this.glyphs, reverse, process);\n  }\n  getStateMachine(subtable) {\n    return new (0, $50c7aac9316f2948$export$2e2bcd8739ae039)(subtable.table.stateTable);\n  }\n  getProcessor() {\n    switch (this.subtable.type) {\n      case 0:\n        return this.processIndicRearragement;\n      case 1:\n        return this.processContextualSubstitution;\n      case 2:\n        return this.processLigature;\n      case 4:\n        return this.processNoncontextualSubstitutions;\n      case 5:\n        return this.processGlyphInsertion;\n      default:\n        throw new Error(`Invalid morx subtable type: ${this.subtable.type}`);\n    }\n  }\n  processIndicRearragement(glyph, entry, index) {\n    if (entry.flags & $55f71433a605c87d$var$MARK_FIRST) this.firstGlyph = index;\n    if (entry.flags & $55f71433a605c87d$var$MARK_LAST) this.lastGlyph = index;\n    $55f71433a605c87d$var$reorderGlyphs(this.glyphs, entry.flags & $55f71433a605c87d$var$VERB, this.firstGlyph, this.lastGlyph);\n  }\n  processContextualSubstitution(glyph, entry, index) {\n    let subsitutions = this.subtable.table.substitutionTable.items;\n    if (entry.markIndex !== 0xffff) {\n      let lookup = subsitutions.getItem(entry.markIndex);\n      let lookupTable = new (0, $ff5ce077dae0f144$export$2e2bcd8739ae039)(lookup);\n      glyph = this.glyphs[this.markedGlyph];\n      var gid = lookupTable.lookup(glyph.id);\n      if (gid) this.glyphs[this.markedGlyph] = this.font.getGlyph(gid, glyph.codePoints);\n    }\n    if (entry.currentIndex !== 0xffff) {\n      let lookup = subsitutions.getItem(entry.currentIndex);\n      let lookupTable = new (0, $ff5ce077dae0f144$export$2e2bcd8739ae039)(lookup);\n      glyph = this.glyphs[index];\n      var gid = lookupTable.lookup(glyph.id);\n      if (gid) this.glyphs[index] = this.font.getGlyph(gid, glyph.codePoints);\n    }\n    if (entry.flags & $55f71433a605c87d$var$SET_MARK) this.markedGlyph = index;\n  }\n  processLigature(glyph, entry, index) {\n    if (entry.flags & $55f71433a605c87d$var$SET_COMPONENT) this.ligatureStack.push(index);\n    if (entry.flags & $55f71433a605c87d$var$PERFORM_ACTION) {\n      let actions = this.subtable.table.ligatureActions;\n      let components = this.subtable.table.components;\n      let ligatureList = this.subtable.table.ligatureList;\n      let actionIndex = entry.action;\n      let last = false;\n      let ligatureIndex = 0;\n      let codePoints = [];\n      let ligatureGlyphs = [];\n      while (!last) {\n        let componentGlyph = this.ligatureStack.pop();\n        codePoints.unshift(...this.glyphs[componentGlyph].codePoints);\n        let action = actions.getItem(actionIndex++);\n        last = !!(action & $55f71433a605c87d$var$LAST_MASK);\n        let store = !!(action & $55f71433a605c87d$var$STORE_MASK);\n        let offset = (action & $55f71433a605c87d$var$OFFSET_MASK) << 2 >> 2; // sign extend 30 to 32 bits\n        offset += this.glyphs[componentGlyph].id;\n        let component = components.getItem(offset);\n        ligatureIndex += component;\n        if (last || store) {\n          let ligatureEntry = ligatureList.getItem(ligatureIndex);\n          this.glyphs[componentGlyph] = this.font.getGlyph(ligatureEntry, codePoints);\n          ligatureGlyphs.push(componentGlyph);\n          ligatureIndex = 0;\n          codePoints = [];\n        } else this.glyphs[componentGlyph] = this.font.getGlyph(0xffff);\n      }\n      // Put ligature glyph indexes back on the stack\n      this.ligatureStack.push(...ligatureGlyphs);\n    }\n  }\n  processNoncontextualSubstitutions(subtable, glyphs, index) {\n    let lookupTable = new (0, $ff5ce077dae0f144$export$2e2bcd8739ae039)(subtable.table.lookupTable);\n    for (index = 0; index < glyphs.length; index++) {\n      let glyph = glyphs[index];\n      if (glyph.id !== 0xffff) {\n        let gid = lookupTable.lookup(glyph.id);\n        if (gid) glyphs[index] = this.font.getGlyph(gid, glyph.codePoints);\n      }\n    }\n  }\n  _insertGlyphs(glyphIndex, insertionActionIndex, count, isBefore) {\n    let insertions = [];\n    while (count--) {\n      let gid = this.subtable.table.insertionActions.getItem(insertionActionIndex++);\n      insertions.push(this.font.getGlyph(gid));\n    }\n    if (!isBefore) glyphIndex++;\n    this.glyphs.splice(glyphIndex, 0, ...insertions);\n  }\n  processGlyphInsertion(glyph, entry, index) {\n    if (entry.flags & $55f71433a605c87d$var$SET_MARK) this.markedIndex = index;\n    if (entry.markedInsertIndex !== 0xffff) {\n      let count = (entry.flags & $55f71433a605c87d$var$MARKED_INSERT_COUNT) >>> 5;\n      let isBefore = !!(entry.flags & $55f71433a605c87d$var$MARKED_INSERT_BEFORE);\n      this._insertGlyphs(this.markedIndex, entry.markedInsertIndex, count, isBefore);\n    }\n    if (entry.currentInsertIndex !== 0xffff) {\n      let count = (entry.flags & $55f71433a605c87d$var$CURRENT_INSERT_COUNT) >>> 5;\n      let isBefore = !!(entry.flags & $55f71433a605c87d$var$CURRENT_INSERT_BEFORE);\n      this._insertGlyphs(index, entry.currentInsertIndex, count, isBefore);\n    }\n  }\n  getSupportedFeatures() {\n    let features = [];\n    for (let chain of this.morx.chains) for (let feature of chain.features) features.push([feature.featureType, feature.featureSetting]);\n    return features;\n  }\n  generateInputs(gid) {\n    if (!this.inputCache) this.generateInputCache();\n    return this.inputCache[gid] || [];\n  }\n  generateInputCache() {\n    this.inputCache = {};\n    for (let chain of this.morx.chains) {\n      let flags = chain.defaultFlags;\n      for (let subtable of chain.subtables) if (subtable.subFeatureFlags & flags) this.generateInputsForSubtable(subtable);\n    }\n  }\n  generateInputsForSubtable(subtable) {\n    // Currently, only supporting ligature subtables.\n    if (subtable.type !== 2) return;\n    let reverse = !!(subtable.coverage & $55f71433a605c87d$var$REVERSE_DIRECTION);\n    if (reverse) throw new Error('Reverse subtable, not supported.');\n    this.subtable = subtable;\n    this.ligatureStack = [];\n    let stateMachine = this.getStateMachine(subtable);\n    let process = this.getProcessor();\n    let input = [];\n    let stack = [];\n    this.glyphs = [];\n    stateMachine.traverse({\n      enter: (glyph, entry) => {\n        let glyphs = this.glyphs;\n        stack.push({\n          glyphs: glyphs.slice(),\n          ligatureStack: this.ligatureStack.slice()\n        });\n        // Add glyph to input and glyphs to process.\n        let g = this.font.getGlyph(glyph);\n        input.push(g);\n        glyphs.push(input[input.length - 1]);\n        // Process ligature substitution\n        process(glyphs[glyphs.length - 1], entry, glyphs.length - 1);\n        // Add input to result if only one matching (non-deleted) glyph remains.\n        let count = 0;\n        let found = 0;\n        for (let i = 0; i < glyphs.length && count <= 1; i++) if (glyphs[i].id !== 0xffff) {\n          count++;\n          found = glyphs[i].id;\n        }\n        if (count === 1) {\n          let result = input.map(g => g.id);\n          let cache = this.inputCache[found];\n          if (cache) cache.push(result);else this.inputCache[found] = [result];\n        }\n      },\n      exit: () => {\n        ({\n          glyphs: this.glyphs,\n          ligatureStack: this.ligatureStack\n        } = stack.pop());\n        input.pop();\n      }\n    });\n  }\n  constructor(font) {\n    this.processIndicRearragement = this.processIndicRearragement.bind(this);\n    this.processContextualSubstitution = this.processContextualSubstitution.bind(this);\n    this.processLigature = this.processLigature.bind(this);\n    this.processNoncontextualSubstitutions = this.processNoncontextualSubstitutions.bind(this);\n    this.processGlyphInsertion = this.processGlyphInsertion.bind(this);\n    this.font = font;\n    this.morx = font.morx;\n    this.inputCache = null;\n  }\n}\n(0, $6uUbQ$_1)([(0, $e71565f2ce09cb6b$export$69a3209f1a06c04d)], $55f71433a605c87d$export$2e2bcd8739ae039.prototype, \"getStateMachine\", null);\n// swaps the glyphs in rangeA with those in rangeB\n// reverse the glyphs inside those ranges if specified\n// ranges are in [offset, length] format\nfunction $55f71433a605c87d$var$swap(glyphs, rangeA, rangeB) {\n  let reverseA = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n  let reverseB = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;\n  let end = glyphs.splice(rangeB[0] - (rangeB[1] - 1), rangeB[1]);\n  if (reverseB) end.reverse();\n  let start = glyphs.splice(rangeA[0], rangeA[1], ...end);\n  if (reverseA) start.reverse();\n  glyphs.splice(rangeB[0] - (rangeA[1] - 1), 0, ...start);\n  return glyphs;\n}\nfunction $55f71433a605c87d$var$reorderGlyphs(glyphs, verb, firstGlyph, lastGlyph) {\n  let length = lastGlyph - firstGlyph + 1;\n  switch (verb) {\n    case 0:\n      return glyphs;\n    case 1:\n      return $55f71433a605c87d$var$swap(glyphs, [firstGlyph, 1], [lastGlyph, 0]);\n    case 2:\n      return $55f71433a605c87d$var$swap(glyphs, [firstGlyph, 0], [lastGlyph, 1]);\n    case 3:\n      return $55f71433a605c87d$var$swap(glyphs, [firstGlyph, 1], [lastGlyph, 1]);\n    case 4:\n      return $55f71433a605c87d$var$swap(glyphs, [firstGlyph, 2], [lastGlyph, 0]);\n    case 5:\n      return $55f71433a605c87d$var$swap(glyphs, [firstGlyph, 2], [lastGlyph, 0], true, false);\n    case 6:\n      return $55f71433a605c87d$var$swap(glyphs, [firstGlyph, 0], [lastGlyph, 2]);\n    case 7:\n      return $55f71433a605c87d$var$swap(glyphs, [firstGlyph, 0], [lastGlyph, 2], false, true);\n    case 8:\n      return $55f71433a605c87d$var$swap(glyphs, [firstGlyph, 1], [lastGlyph, 2]);\n    case 9:\n      return $55f71433a605c87d$var$swap(glyphs, [firstGlyph, 1], [lastGlyph, 2], false, true);\n    case 10:\n      return $55f71433a605c87d$var$swap(glyphs, [firstGlyph, 2], [lastGlyph, 1]);\n    case 11:\n      return $55f71433a605c87d$var$swap(glyphs, [firstGlyph, 2], [lastGlyph, 1], true, false);\n    case 12:\n      return $55f71433a605c87d$var$swap(glyphs, [firstGlyph, 2], [lastGlyph, 2]);\n    case 13:\n      return $55f71433a605c87d$var$swap(glyphs, [firstGlyph, 2], [lastGlyph, 2], true, false);\n    case 14:\n      return $55f71433a605c87d$var$swap(glyphs, [firstGlyph, 2], [lastGlyph, 2], false, true);\n    case 15:\n      return $55f71433a605c87d$var$swap(glyphs, [firstGlyph, 2], [lastGlyph, 2], true, true);\n    default:\n      throw new Error(`Unknown verb: ${verb}`);\n  }\n}\nclass $ba6dd74203be8728$export$2e2bcd8739ae039 {\n  substitute(glyphRun) {\n    // AAT expects the glyphs to be in visual order prior to morx processing,\n    // so reverse the glyphs if the script is right-to-left.\n    if (glyphRun.direction === 'rtl') glyphRun.glyphs.reverse();\n    this.morxProcessor.process(glyphRun.glyphs, $3b6302b64eccc32c$export$b813f7d2a1677c16(glyphRun.features));\n  }\n  getAvailableFeatures(script, language) {\n    return $3b6302b64eccc32c$export$bd6df347a4f391c4(this.morxProcessor.getSupportedFeatures());\n  }\n  stringsForGlyph(gid) {\n    let glyphStrings = this.morxProcessor.generateInputs(gid);\n    let result = new Set();\n    for (let glyphs of glyphStrings) this._addStrings(glyphs, 0, result, '');\n    return result;\n  }\n  _addStrings(glyphs, index, strings, string) {\n    let codePoints = this.font._cmapProcessor.codePointsForGlyph(glyphs[index]);\n    for (let codePoint of codePoints) {\n      let s = string + String.fromCodePoint(codePoint);\n      if (index < glyphs.length - 1) this._addStrings(glyphs, index + 1, strings, s);else strings.add(s);\n    }\n  }\n  constructor(font) {\n    this.font = font;\n    this.morxProcessor = new (0, $55f71433a605c87d$export$2e2bcd8739ae039)(font);\n    this.fallbackPosition = false;\n  }\n}\nclass $94d7a73bd2edfc9a$export$2e2bcd8739ae039 {\n  /**\n  * Adds the given features to the last stage.\n  * Ignores features that have already been applied.\n  */\n  _addFeatures(features, global) {\n    let stageIndex = this.stages.length - 1;\n    let stage = this.stages[stageIndex];\n    for (let feature of features) if (this.allFeatures[feature] == null) {\n      stage.push(feature);\n      this.allFeatures[feature] = stageIndex;\n      if (global) this.globalFeatures[feature] = true;\n    }\n  }\n  /**\n  * Add features to the last stage\n  */\n  add(arg) {\n    let global = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n    if (this.stages.length === 0) this.stages.push([]);\n    if (typeof arg === 'string') arg = [arg];\n    if (Array.isArray(arg)) this._addFeatures(arg, global);else if (typeof arg === 'object') {\n      this._addFeatures(arg.global || [], true);\n      this._addFeatures(arg.local || [], false);\n    } else throw new Error(\"Unsupported argument to ShapingPlan#add\");\n  }\n  /**\n  * Add a new stage\n  */\n  addStage(arg, global) {\n    if (typeof arg === 'function') this.stages.push(arg, []);else {\n      this.stages.push([]);\n      this.add(arg, global);\n    }\n  }\n  setFeatureOverrides(features) {\n    if (Array.isArray(features)) this.add(features);else if (typeof features === 'object') for (let tag in features) {\n      if (features[tag]) this.add(tag);else if (this.allFeatures[tag] != null) {\n        let stage = this.stages[this.allFeatures[tag]];\n        stage.splice(stage.indexOf(tag), 1);\n        delete this.allFeatures[tag];\n        delete this.globalFeatures[tag];\n      }\n    }\n  }\n  /**\n  * Assigns the global features to the given glyphs\n  */\n  assignGlobalFeatures(glyphs) {\n    for (let glyph of glyphs) for (let feature in this.globalFeatures) glyph.features[feature] = true;\n  }\n  /**\n  * Executes the planned stages using the given OTProcessor\n  */\n  process(processor, glyphs, positions) {\n    for (let stage of this.stages) {\n      if (typeof stage === 'function') {\n        if (!positions) stage(this.font, glyphs, this);\n      } else if (stage.length > 0) processor.applyFeatures(stage, glyphs, positions);\n    }\n  }\n  constructor(font, script, direction) {\n    this.font = font;\n    this.script = script;\n    this.direction = direction;\n    this.stages = [];\n    this.globalFeatures = {};\n    this.allFeatures = {};\n  }\n}\nconst $649970d87335b30f$var$VARIATION_FEATURES = ['rvrn'];\nconst $649970d87335b30f$var$COMMON_FEATURES = ['ccmp', 'locl', 'rlig', 'mark', 'mkmk'];\nconst $649970d87335b30f$var$FRACTIONAL_FEATURES = ['frac', 'numr', 'dnom'];\nconst $649970d87335b30f$var$HORIZONTAL_FEATURES = ['calt', 'clig', 'liga', 'rclt', 'curs', 'kern'];\nconst $649970d87335b30f$var$VERTICAL_FEATURES = ['vert'];\nconst $649970d87335b30f$var$DIRECTIONAL_FEATURES = {\n  ltr: ['ltra', 'ltrm'],\n  rtl: ['rtla', 'rtlm']\n};\nclass $649970d87335b30f$export$2e2bcd8739ae039 {\n  static plan(plan, glyphs, features) {\n    // Plan the features we want to apply\n    this.planPreprocessing(plan);\n    this.planFeatures(plan);\n    this.planPostprocessing(plan, features);\n    // Assign the global features to all the glyphs\n    plan.assignGlobalFeatures(glyphs);\n    // Assign local features to glyphs\n    this.assignFeatures(plan, glyphs);\n  }\n  static planPreprocessing(plan) {\n    plan.add({\n      global: [...$649970d87335b30f$var$VARIATION_FEATURES, ...$649970d87335b30f$var$DIRECTIONAL_FEATURES[plan.direction]],\n      local: $649970d87335b30f$var$FRACTIONAL_FEATURES\n    });\n  }\n  static planFeatures(plan) {\n    // Do nothing by default. Let subclasses override this.\n  }\n  static planPostprocessing(plan, userFeatures) {\n    plan.add([...$649970d87335b30f$var$COMMON_FEATURES, ...$649970d87335b30f$var$HORIZONTAL_FEATURES]);\n    plan.setFeatureOverrides(userFeatures);\n  }\n  static assignFeatures(plan, glyphs) {\n    // Enable contextual fractions\n    for (let i = 0; i < glyphs.length; i++) {\n      let glyph = glyphs[i];\n      if (glyph.codePoints[0] === 0x2044) {\n        let start = i;\n        let end = i + 1;\n        // Apply numerator\n        while (start > 0 && (0, $6uUbQ$isDigit)(glyphs[start - 1].codePoints[0])) {\n          glyphs[start - 1].features.numr = true;\n          glyphs[start - 1].features.frac = true;\n          start--;\n        }\n        // Apply denominator\n        while (end < glyphs.length && (0, $6uUbQ$isDigit)(glyphs[end].codePoints[0])) {\n          glyphs[end].features.dnom = true;\n          glyphs[end].features.frac = true;\n          end++;\n        }\n        // Apply fraction slash\n        glyph.features.frac = true;\n        i = end - 1;\n      }\n    }\n  }\n}\n(0, $6uUbQ$_)($649970d87335b30f$export$2e2bcd8739ae039, \"zeroMarkWidths\", 'AFTER_GPOS');\nconst $764eb544bbe1ccf0$var$trie = new (0, $6uUbQ$unicodetrie)((0, $12727730ddfc8bfe$export$94fdf11bafc8de6b)(\"APABAAAAAAAAOAAAAf0BAv7tmi1MxDAUx7vtvjhAgcDgkEgEAnmXEBIMCYaEcygEiqBQ4FAkCE4ikUgMiiBJSAgSiUQSDMn9L9eSl6bddddug9t7yS/trevre+3r27pcNxZiG+yCfdCVv/9LeQxOwRm4AJegD27ALbgD9+ABPJF+z+BN/h7yDj5k/VOWX6SdmU5+wLWknggxDxaS8u0qiiX4uiz9XamQ3wzDMAzDMAzDMAzDVI/h959V/v7BMAzDMAzDMLlyNTNiMSdewVxbiA44B4/guz1qW58VYlMI0WsJ0W+N6kXw0spvPtdwhtkwnGM6uLaV4Xyzg3v3PM9DPfQ/sOg4xPWjipy31P8LTqbU304c/cLCUmWJLNB2Uz2U1KTeRKNmKHVMfbJC+/0loTZRH/W5cvEvBJPMbREkWt3FD1NcqXZBSpuE2Ad0PBehPtNrPtIEdYP+hiRt/V1jIiE69X4NT/uVZI3PUHE9bm5M7ePGdZWy951v7Nn6j8v1WWKP3mt6ttnsigx6VN7Vc0VomSSGqW2mGNP1muZPl7LfjNUaKNFtDGVf2fvE9O7VlBS5j333c5p/eeoOqcs1R/hIqDWLJ7TTlksirVT1SI7l8k4Yp+g3jafGcrU1RM6l9th80XOpnlN97bDNY4i4s61B0Si/ipa0uHMl6zqEjlFfCZm/TM8KmzQDjmuTAQ==\"));\nconst $764eb544bbe1ccf0$var$FEATURES = ['isol', 'fina', 'fin2', 'fin3', 'medi', 'med2', 'init'];\nconst $764eb544bbe1ccf0$var$ShapingClasses = {\n  Non_Joining: 0,\n  Left_Joining: 1,\n  Right_Joining: 2,\n  Dual_Joining: 3,\n  Join_Causing: 3,\n  ALAPH: 4,\n  'DALATH RISH': 5,\n  Transparent: 6\n};\nconst $764eb544bbe1ccf0$var$ISOL = 'isol';\nconst $764eb544bbe1ccf0$var$FINA = 'fina';\nconst $764eb544bbe1ccf0$var$FIN2 = 'fin2';\nconst $764eb544bbe1ccf0$var$FIN3 = 'fin3';\nconst $764eb544bbe1ccf0$var$MEDI = 'medi';\nconst $764eb544bbe1ccf0$var$MED2 = 'med2';\nconst $764eb544bbe1ccf0$var$INIT = 'init';\nconst $764eb544bbe1ccf0$var$NONE = null;\n// Each entry is [prevAction, curAction, nextState]\nconst $764eb544bbe1ccf0$var$STATE_TABLE = [\n//   Non_Joining,        Left_Joining,       Right_Joining,     Dual_Joining,           ALAPH,            DALATH RISH\n// State 0: prev was U,  not willing to join.\n[[$764eb544bbe1ccf0$var$NONE, $764eb544bbe1ccf0$var$NONE, 0], [$764eb544bbe1ccf0$var$NONE, $764eb544bbe1ccf0$var$ISOL, 2], [$764eb544bbe1ccf0$var$NONE, $764eb544bbe1ccf0$var$ISOL, 1], [$764eb544bbe1ccf0$var$NONE, $764eb544bbe1ccf0$var$ISOL, 2], [$764eb544bbe1ccf0$var$NONE, $764eb544bbe1ccf0$var$ISOL, 1], [$764eb544bbe1ccf0$var$NONE, $764eb544bbe1ccf0$var$ISOL, 6]],\n// State 1: prev was R or ISOL/ALAPH,  not willing to join.\n[[$764eb544bbe1ccf0$var$NONE, $764eb544bbe1ccf0$var$NONE, 0], [$764eb544bbe1ccf0$var$NONE, $764eb544bbe1ccf0$var$ISOL, 2], [$764eb544bbe1ccf0$var$NONE, $764eb544bbe1ccf0$var$ISOL, 1], [$764eb544bbe1ccf0$var$NONE, $764eb544bbe1ccf0$var$ISOL, 2], [$764eb544bbe1ccf0$var$NONE, $764eb544bbe1ccf0$var$FIN2, 5], [$764eb544bbe1ccf0$var$NONE, $764eb544bbe1ccf0$var$ISOL, 6]],\n// State 2: prev was D/L in ISOL form,  willing to join.\n[[$764eb544bbe1ccf0$var$NONE, $764eb544bbe1ccf0$var$NONE, 0], [$764eb544bbe1ccf0$var$NONE, $764eb544bbe1ccf0$var$ISOL, 2], [$764eb544bbe1ccf0$var$INIT, $764eb544bbe1ccf0$var$FINA, 1], [$764eb544bbe1ccf0$var$INIT, $764eb544bbe1ccf0$var$FINA, 3], [$764eb544bbe1ccf0$var$INIT, $764eb544bbe1ccf0$var$FINA, 4], [$764eb544bbe1ccf0$var$INIT, $764eb544bbe1ccf0$var$FINA, 6]],\n// State 3: prev was D in FINA form,  willing to join.\n[[$764eb544bbe1ccf0$var$NONE, $764eb544bbe1ccf0$var$NONE, 0], [$764eb544bbe1ccf0$var$NONE, $764eb544bbe1ccf0$var$ISOL, 2], [$764eb544bbe1ccf0$var$MEDI, $764eb544bbe1ccf0$var$FINA, 1], [$764eb544bbe1ccf0$var$MEDI, $764eb544bbe1ccf0$var$FINA, 3], [$764eb544bbe1ccf0$var$MEDI, $764eb544bbe1ccf0$var$FINA, 4], [$764eb544bbe1ccf0$var$MEDI, $764eb544bbe1ccf0$var$FINA, 6]],\n// State 4: prev was FINA ALAPH,  not willing to join.\n[[$764eb544bbe1ccf0$var$NONE, $764eb544bbe1ccf0$var$NONE, 0], [$764eb544bbe1ccf0$var$NONE, $764eb544bbe1ccf0$var$ISOL, 2], [$764eb544bbe1ccf0$var$MED2, $764eb544bbe1ccf0$var$ISOL, 1], [$764eb544bbe1ccf0$var$MED2, $764eb544bbe1ccf0$var$ISOL, 2], [$764eb544bbe1ccf0$var$MED2, $764eb544bbe1ccf0$var$FIN2, 5], [$764eb544bbe1ccf0$var$MED2, $764eb544bbe1ccf0$var$ISOL, 6]],\n// State 5: prev was FIN2/FIN3 ALAPH,  not willing to join.\n[[$764eb544bbe1ccf0$var$NONE, $764eb544bbe1ccf0$var$NONE, 0], [$764eb544bbe1ccf0$var$NONE, $764eb544bbe1ccf0$var$ISOL, 2], [$764eb544bbe1ccf0$var$ISOL, $764eb544bbe1ccf0$var$ISOL, 1], [$764eb544bbe1ccf0$var$ISOL, $764eb544bbe1ccf0$var$ISOL, 2], [$764eb544bbe1ccf0$var$ISOL, $764eb544bbe1ccf0$var$FIN2, 5], [$764eb544bbe1ccf0$var$ISOL, $764eb544bbe1ccf0$var$ISOL, 6]],\n// State 6: prev was DALATH/RISH,  not willing to join.\n[[$764eb544bbe1ccf0$var$NONE, $764eb544bbe1ccf0$var$NONE, 0], [$764eb544bbe1ccf0$var$NONE, $764eb544bbe1ccf0$var$ISOL, 2], [$764eb544bbe1ccf0$var$NONE, $764eb544bbe1ccf0$var$ISOL, 1], [$764eb544bbe1ccf0$var$NONE, $764eb544bbe1ccf0$var$ISOL, 2], [$764eb544bbe1ccf0$var$NONE, $764eb544bbe1ccf0$var$FIN3, 5], [$764eb544bbe1ccf0$var$NONE, $764eb544bbe1ccf0$var$ISOL, 6]]];\nclass $764eb544bbe1ccf0$export$2e2bcd8739ae039 extends (0, $649970d87335b30f$export$2e2bcd8739ae039) {\n  static planFeatures(plan) {\n    plan.add(['ccmp', 'locl']);\n    for (let i = 0; i < $764eb544bbe1ccf0$var$FEATURES.length; i++) {\n      let feature = $764eb544bbe1ccf0$var$FEATURES[i];\n      plan.addStage(feature, false);\n    }\n    plan.addStage('mset');\n  }\n  static assignFeatures(plan, glyphs) {\n    super.assignFeatures(plan, glyphs);\n    let prev = -1;\n    let state = 0;\n    let actions = [];\n    // Apply the state machine to map glyphs to features\n    for (let i = 0; i < glyphs.length; i++) {\n      let curAction, prevAction;\n      var glyph = glyphs[i];\n      let type = $764eb544bbe1ccf0$var$getShapingClass(glyph.codePoints[0]);\n      if (type === $764eb544bbe1ccf0$var$ShapingClasses.Transparent) {\n        actions[i] = $764eb544bbe1ccf0$var$NONE;\n        continue;\n      }\n      [prevAction, curAction, state] = $764eb544bbe1ccf0$var$STATE_TABLE[state][type];\n      if (prevAction !== $764eb544bbe1ccf0$var$NONE && prev !== -1) actions[prev] = prevAction;\n      actions[i] = curAction;\n      prev = i;\n    }\n    // Apply the chosen features to their respective glyphs\n    for (let index = 0; index < glyphs.length; index++) {\n      let feature;\n      var glyph = glyphs[index];\n      if (feature = actions[index]) glyph.features[feature] = true;\n    }\n  }\n}\nfunction $764eb544bbe1ccf0$var$getShapingClass(codePoint) {\n  let res = $764eb544bbe1ccf0$var$trie.get(codePoint);\n  if (res) return res - 1;\n  let category = (0, $6uUbQ$getCategory)(codePoint);\n  if (category === 'Mn' || category === 'Me' || category === 'Cf') return $764eb544bbe1ccf0$var$ShapingClasses.Transparent;\n  return $764eb544bbe1ccf0$var$ShapingClasses.Non_Joining;\n}\nclass $85d408632270248b$export$2e2bcd8739ae039 {\n  reset() {\n    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    let index = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n    this.options = options;\n    this.flags = options.flags || {};\n    this.markAttachmentType = options.markAttachmentType || 0;\n    this.index = index;\n  }\n  get cur() {\n    return this.glyphs[this.index] || null;\n  }\n  shouldIgnore(glyph) {\n    return this.flags.ignoreMarks && glyph.isMark || this.flags.ignoreBaseGlyphs && glyph.isBase || this.flags.ignoreLigatures && glyph.isLigature || this.markAttachmentType && glyph.isMark && glyph.markAttachmentType !== this.markAttachmentType;\n  }\n  move(dir) {\n    this.index += dir;\n    while (0 <= this.index && this.index < this.glyphs.length && this.shouldIgnore(this.glyphs[this.index])) this.index += dir;\n    if (0 > this.index || this.index >= this.glyphs.length) return null;\n    return this.glyphs[this.index];\n  }\n  next() {\n    return this.move(1);\n  }\n  prev() {\n    return this.move(-1);\n  }\n  peek() {\n    let count = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;\n    let idx = this.index;\n    let res = this.increment(count);\n    this.index = idx;\n    return res;\n  }\n  peekIndex() {\n    let count = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;\n    let idx = this.index;\n    this.increment(count);\n    let res = this.index;\n    this.index = idx;\n    return res;\n  }\n  increment() {\n    let count = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;\n    let dir = count < 0 ? -1 : 1;\n    count = Math.abs(count);\n    while (count--) this.move(dir);\n    return this.glyphs[this.index];\n  }\n  constructor(glyphs, options) {\n    this.glyphs = glyphs;\n    this.reset(options);\n  }\n}\nconst $a83b9c36aaa94fd3$var$DEFAULT_SCRIPTS = ['DFLT', 'dflt', 'latn'];\nclass $a83b9c36aaa94fd3$export$2e2bcd8739ae039 {\n  findScript(script) {\n    if (this.table.scriptList == null) return null;\n    if (!Array.isArray(script)) script = [script];\n    for (let s of script) for (let entry of this.table.scriptList) {\n      if (entry.tag === s) return entry;\n    }\n    return null;\n  }\n  selectScript(script, language, direction) {\n    let changed = false;\n    let entry;\n    if (!this.script || script !== this.scriptTag) {\n      entry = this.findScript(script);\n      if (!entry) entry = this.findScript($a83b9c36aaa94fd3$var$DEFAULT_SCRIPTS);\n      if (!entry) return this.scriptTag;\n      this.scriptTag = entry.tag;\n      this.script = entry.script;\n      this.language = null;\n      this.languageTag = null;\n      changed = true;\n    }\n    if (!direction || direction !== this.direction) this.direction = direction || $130d1a642ebcd2b7$export$9fddb9d0dd7d8a54(script);\n    if (language && language.length < 4) language += ' '.repeat(4 - language.length);\n    if (!language || language !== this.languageTag) {\n      this.language = null;\n      for (let lang of this.script.langSysRecords) if (lang.tag === language) {\n        this.language = lang.langSys;\n        this.languageTag = lang.tag;\n        break;\n      }\n      if (!this.language) {\n        this.language = this.script.defaultLangSys;\n        this.languageTag = null;\n      }\n      changed = true;\n    }\n    // Build a feature lookup table\n    if (changed) {\n      this.features = {};\n      if (this.language) for (let featureIndex of this.language.featureIndexes) {\n        let record = this.table.featureList[featureIndex];\n        let substituteFeature = this.substituteFeatureForVariations(featureIndex);\n        this.features[record.tag] = substituteFeature || record.feature;\n      }\n    }\n    return this.scriptTag;\n  }\n  lookupsForFeatures() {\n    let userFeatures = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n    let exclude = arguments.length > 1 ? arguments[1] : undefined;\n    let lookups = [];\n    for (let tag of userFeatures) {\n      let feature = this.features[tag];\n      if (!feature) continue;\n      for (let lookupIndex of feature.lookupListIndexes) {\n        if (exclude && exclude.indexOf(lookupIndex) !== -1) continue;\n        lookups.push({\n          feature: tag,\n          index: lookupIndex,\n          lookup: this.table.lookupList.get(lookupIndex)\n        });\n      }\n    }\n    lookups.sort((a, b) => a.index - b.index);\n    return lookups;\n  }\n  substituteFeatureForVariations(featureIndex) {\n    if (this.variationsIndex === -1) return null;\n    let record = this.table.featureVariations.featureVariationRecords[this.variationsIndex];\n    let substitutions = record.featureTableSubstitution.substitutions;\n    for (let substitution of substitutions) {\n      if (substitution.featureIndex === featureIndex) return substitution.alternateFeatureTable;\n    }\n    return null;\n  }\n  findVariationsIndex(coords) {\n    let variations = this.table.featureVariations;\n    if (!variations) return -1;\n    let records = variations.featureVariationRecords;\n    for (let i = 0; i < records.length; i++) {\n      let conditions = records[i].conditionSet.conditionTable;\n      if (this.variationConditionsMatch(conditions, coords)) return i;\n    }\n    return -1;\n  }\n  variationConditionsMatch(conditions, coords) {\n    return conditions.every(condition => {\n      let coord = condition.axisIndex < coords.length ? coords[condition.axisIndex] : 0;\n      return condition.filterRangeMinValue <= coord && coord <= condition.filterRangeMaxValue;\n    });\n  }\n  applyFeatures(userFeatures, glyphs, advances) {\n    let lookups = this.lookupsForFeatures(userFeatures);\n    this.applyLookups(lookups, glyphs, advances);\n  }\n  applyLookups(lookups, glyphs, positions) {\n    this.glyphs = glyphs;\n    this.positions = positions;\n    this.glyphIterator = new (0, $85d408632270248b$export$2e2bcd8739ae039)(glyphs);\n    for (let {\n      feature: feature,\n      lookup: lookup\n    } of lookups) {\n      this.currentFeature = feature;\n      this.glyphIterator.reset(lookup.flags);\n      while (this.glyphIterator.index < glyphs.length) {\n        if (!(feature in this.glyphIterator.cur.features)) {\n          this.glyphIterator.next();\n          continue;\n        }\n        for (let table of lookup.subTables) {\n          let res = this.applyLookup(lookup.lookupType, table);\n          if (res) break;\n        }\n        this.glyphIterator.next();\n      }\n    }\n  }\n  applyLookup(lookup, table) {\n    throw new Error(\"applyLookup must be implemented by subclasses\");\n  }\n  applyLookupList(lookupRecords) {\n    let options = this.glyphIterator.options;\n    let glyphIndex = this.glyphIterator.index;\n    for (let lookupRecord of lookupRecords) {\n      // Reset flags and find glyph index for this lookup record\n      this.glyphIterator.reset(options, glyphIndex);\n      this.glyphIterator.increment(lookupRecord.sequenceIndex);\n      // Get the lookup and setup flags for subtables\n      let lookup = this.table.lookupList.get(lookupRecord.lookupListIndex);\n      this.glyphIterator.reset(lookup.flags, this.glyphIterator.index);\n      // Apply lookup subtables until one matches\n      for (let table of lookup.subTables) {\n        if (this.applyLookup(lookup.lookupType, table)) break;\n      }\n    }\n    this.glyphIterator.reset(options, glyphIndex);\n    return true;\n  }\n  coverageIndex(coverage, glyph) {\n    if (glyph == null) glyph = this.glyphIterator.cur.id;\n    switch (coverage.version) {\n      case 1:\n        return coverage.glyphs.indexOf(glyph);\n      case 2:\n        for (let range of coverage.rangeRecords) {\n          if (range.start <= glyph && glyph <= range.end) return range.startCoverageIndex + glyph - range.start;\n        }\n        break;\n    }\n    return -1;\n  }\n  match(sequenceIndex, sequence, fn, matched) {\n    let pos = this.glyphIterator.index;\n    let glyph = this.glyphIterator.increment(sequenceIndex);\n    let idx = 0;\n    while (idx < sequence.length && glyph && fn(sequence[idx], glyph)) {\n      if (matched) matched.push(this.glyphIterator.index);\n      idx++;\n      glyph = this.glyphIterator.next();\n    }\n    this.glyphIterator.index = pos;\n    if (idx < sequence.length) return false;\n    return matched || true;\n  }\n  sequenceMatches(sequenceIndex, sequence) {\n    return this.match(sequenceIndex, sequence, (component, glyph) => component === glyph.id);\n  }\n  sequenceMatchIndices(sequenceIndex, sequence) {\n    return this.match(sequenceIndex, sequence, (component, glyph) => {\n      // If the current feature doesn't apply to this glyph,\n      if (!(this.currentFeature in glyph.features)) return false;\n      return component === glyph.id;\n    }, []);\n  }\n  coverageSequenceMatches(sequenceIndex, sequence) {\n    return this.match(sequenceIndex, sequence, (coverage, glyph) => this.coverageIndex(coverage, glyph.id) >= 0);\n  }\n  getClassID(glyph, classDef) {\n    switch (classDef.version) {\n      case 1:\n        let i = glyph - classDef.startGlyph;\n        if (i >= 0 && i < classDef.classValueArray.length) return classDef.classValueArray[i];\n        break;\n      case 2:\n        for (let range of classDef.classRangeRecord) {\n          if (range.start <= glyph && glyph <= range.end) return range.class;\n        }\n        break;\n    }\n    return 0;\n  }\n  classSequenceMatches(sequenceIndex, sequence, classDef) {\n    return this.match(sequenceIndex, sequence, (classID, glyph) => classID === this.getClassID(glyph.id, classDef));\n  }\n  applyContext(table) {\n    let index, set;\n    switch (table.version) {\n      case 1:\n        index = this.coverageIndex(table.coverage);\n        if (index === -1) return false;\n        set = table.ruleSets[index];\n        for (let rule of set) {\n          if (this.sequenceMatches(1, rule.input)) return this.applyLookupList(rule.lookupRecords);\n        }\n        break;\n      case 2:\n        if (this.coverageIndex(table.coverage) === -1) return false;\n        index = this.getClassID(this.glyphIterator.cur.id, table.classDef);\n        if (index === -1) return false;\n        set = table.classSet[index];\n        for (let rule of set) {\n          if (this.classSequenceMatches(1, rule.classes, table.classDef)) return this.applyLookupList(rule.lookupRecords);\n        }\n        break;\n      case 3:\n        if (this.coverageSequenceMatches(0, table.coverages)) return this.applyLookupList(table.lookupRecords);\n        break;\n    }\n    return false;\n  }\n  applyChainingContext(table) {\n    let index;\n    switch (table.version) {\n      case 1:\n        index = this.coverageIndex(table.coverage);\n        if (index === -1) return false;\n        let set = table.chainRuleSets[index];\n        for (let rule of set) {\n          if (this.sequenceMatches(-rule.backtrack.length, rule.backtrack) && this.sequenceMatches(1, rule.input) && this.sequenceMatches(1 + rule.input.length, rule.lookahead)) return this.applyLookupList(rule.lookupRecords);\n        }\n        break;\n      case 2:\n        if (this.coverageIndex(table.coverage) === -1) return false;\n        index = this.getClassID(this.glyphIterator.cur.id, table.inputClassDef);\n        let rules = table.chainClassSet[index];\n        if (!rules) return false;\n        for (let rule of rules) {\n          if (this.classSequenceMatches(-rule.backtrack.length, rule.backtrack, table.backtrackClassDef) && this.classSequenceMatches(1, rule.input, table.inputClassDef) && this.classSequenceMatches(1 + rule.input.length, rule.lookahead, table.lookaheadClassDef)) return this.applyLookupList(rule.lookupRecords);\n        }\n        break;\n      case 3:\n        if (this.coverageSequenceMatches(-table.backtrackGlyphCount, table.backtrackCoverage) && this.coverageSequenceMatches(0, table.inputCoverage) && this.coverageSequenceMatches(table.inputGlyphCount, table.lookaheadCoverage)) return this.applyLookupList(table.lookupRecords);\n        break;\n    }\n    return false;\n  }\n  constructor(font, table) {\n    this.font = font;\n    this.table = table;\n    this.script = null;\n    this.scriptTag = null;\n    this.language = null;\n    this.languageTag = null;\n    this.features = {};\n    this.lookups = {};\n    // Setup variation substitutions\n    this.variationsIndex = font._variationProcessor ? this.findVariationsIndex(font._variationProcessor.normalizedCoords) : -1;\n    // initialize to default script + language\n    this.selectScript();\n    // current context (set by applyFeatures)\n    this.glyphs = [];\n    this.positions = []; // only used by GPOS\n    this.ligatureID = 1;\n    this.currentFeature = null;\n  }\n}\nclass $10e7b257e1a9a756$export$2e2bcd8739ae039 {\n  get id() {\n    return this._id;\n  }\n  set id(id) {\n    this._id = id;\n    this.substituted = true;\n    let GDEF = this._font.GDEF;\n    if (GDEF && GDEF.glyphClassDef) {\n      // TODO: clean this up\n      let classID = (0, $a83b9c36aaa94fd3$export$2e2bcd8739ae039).prototype.getClassID(id, GDEF.glyphClassDef);\n      this.isBase = classID === 1;\n      this.isLigature = classID === 2;\n      this.isMark = classID === 3;\n      this.markAttachmentType = GDEF.markAttachClassDef ? (0, $a83b9c36aaa94fd3$export$2e2bcd8739ae039).prototype.getClassID(id, GDEF.markAttachClassDef) : 0;\n    } else {\n      this.isMark = this.codePoints.length > 0 && this.codePoints.every((0, $6uUbQ$isMark));\n      this.isBase = !this.isMark;\n      this.isLigature = this.codePoints.length > 1;\n      this.markAttachmentType = 0;\n    }\n  }\n  copy() {\n    return new $10e7b257e1a9a756$export$2e2bcd8739ae039(this._font, this.id, this.codePoints, this.features);\n  }\n  constructor(font, id) {\n    let codePoints = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];\n    let features = arguments.length > 3 ? arguments[3] : undefined;\n    this._font = font;\n    this.codePoints = codePoints;\n    this.id = id;\n    this.features = {};\n    if (Array.isArray(features)) for (let i = 0; i < features.length; i++) {\n      let feature = features[i];\n      this.features[feature] = true;\n    } else if (typeof features === 'object') Object.assign(this.features, features);\n    this.ligatureID = null;\n    this.ligatureComponent = null;\n    this.isLigated = false;\n    this.cursiveAttachment = null;\n    this.markAttachment = null;\n    this.shaperInfo = null;\n    this.substituted = false;\n    this.isMultiplied = false;\n  }\n}\nclass $e1c6bbc8cb416f8c$export$2e2bcd8739ae039 extends (0, $649970d87335b30f$export$2e2bcd8739ae039) {\n  static planFeatures(plan) {\n    plan.add(['ljmo', 'vjmo', 'tjmo'], false);\n  }\n  static assignFeatures(plan, glyphs) {\n    let state = 0;\n    let i = 0;\n    while (i < glyphs.length) {\n      let action;\n      let glyph = glyphs[i];\n      let code = glyph.codePoints[0];\n      let type = $e1c6bbc8cb416f8c$var$getType(code);\n      [action, state] = $e1c6bbc8cb416f8c$var$STATE_TABLE[state][type];\n      switch (action) {\n        case $e1c6bbc8cb416f8c$var$DECOMPOSE:\n          // Decompose the composed syllable if it is not supported by the font.\n          if (!plan.font.hasGlyphForCodePoint(code)) i = $e1c6bbc8cb416f8c$var$decompose(glyphs, i, plan.font);\n          break;\n        case $e1c6bbc8cb416f8c$var$COMPOSE:\n          // Found a decomposed syllable. Try to compose if supported by the font.\n          i = $e1c6bbc8cb416f8c$var$compose(glyphs, i, plan.font);\n          break;\n        case $e1c6bbc8cb416f8c$var$TONE_MARK:\n          // Got a valid syllable, followed by a tone mark. Move the tone mark to the beginning of the syllable.\n          $e1c6bbc8cb416f8c$var$reorderToneMark(glyphs, i, plan.font);\n          break;\n        case $e1c6bbc8cb416f8c$var$INVALID:\n          // Tone mark has no valid syllable to attach to, so insert a dotted circle\n          i = $e1c6bbc8cb416f8c$var$insertDottedCircle(glyphs, i, plan.font);\n          break;\n      }\n      i++;\n    }\n  }\n}\n(0, $6uUbQ$_)($e1c6bbc8cb416f8c$export$2e2bcd8739ae039, \"zeroMarkWidths\", 'NONE');\nconst $e1c6bbc8cb416f8c$var$HANGUL_BASE = 0xac00;\nconst $e1c6bbc8cb416f8c$var$HANGUL_END = 0xd7a4;\nconst $e1c6bbc8cb416f8c$var$HANGUL_COUNT = $e1c6bbc8cb416f8c$var$HANGUL_END - $e1c6bbc8cb416f8c$var$HANGUL_BASE + 1;\nconst $e1c6bbc8cb416f8c$var$L_BASE = 0x1100; // lead\nconst $e1c6bbc8cb416f8c$var$V_BASE = 0x1161; // vowel\nconst $e1c6bbc8cb416f8c$var$T_BASE = 0x11a7; // trail\nconst $e1c6bbc8cb416f8c$var$L_COUNT = 19;\nconst $e1c6bbc8cb416f8c$var$V_COUNT = 21;\nconst $e1c6bbc8cb416f8c$var$T_COUNT = 28;\nconst $e1c6bbc8cb416f8c$var$L_END = $e1c6bbc8cb416f8c$var$L_BASE + $e1c6bbc8cb416f8c$var$L_COUNT - 1;\nconst $e1c6bbc8cb416f8c$var$V_END = $e1c6bbc8cb416f8c$var$V_BASE + $e1c6bbc8cb416f8c$var$V_COUNT - 1;\nconst $e1c6bbc8cb416f8c$var$T_END = $e1c6bbc8cb416f8c$var$T_BASE + $e1c6bbc8cb416f8c$var$T_COUNT - 1;\nconst $e1c6bbc8cb416f8c$var$DOTTED_CIRCLE = 0x25cc;\nconst $e1c6bbc8cb416f8c$var$isL = code => 0x1100 <= code && code <= 0x115f || 0xa960 <= code && code <= 0xa97c;\nconst $e1c6bbc8cb416f8c$var$isV = code => 0x1160 <= code && code <= 0x11a7 || 0xd7b0 <= code && code <= 0xd7c6;\nconst $e1c6bbc8cb416f8c$var$isT = code => 0x11a8 <= code && code <= 0x11ff || 0xd7cb <= code && code <= 0xd7fb;\nconst $e1c6bbc8cb416f8c$var$isTone = code => 0x302e <= code && code <= 0x302f;\nconst $e1c6bbc8cb416f8c$var$isLVT = code => $e1c6bbc8cb416f8c$var$HANGUL_BASE <= code && code <= $e1c6bbc8cb416f8c$var$HANGUL_END;\nconst $e1c6bbc8cb416f8c$var$isLV = code => code - $e1c6bbc8cb416f8c$var$HANGUL_BASE < $e1c6bbc8cb416f8c$var$HANGUL_COUNT && (code - $e1c6bbc8cb416f8c$var$HANGUL_BASE) % $e1c6bbc8cb416f8c$var$T_COUNT === 0;\nconst $e1c6bbc8cb416f8c$var$isCombiningL = code => $e1c6bbc8cb416f8c$var$L_BASE <= code && code <= $e1c6bbc8cb416f8c$var$L_END;\nconst $e1c6bbc8cb416f8c$var$isCombiningV = code => $e1c6bbc8cb416f8c$var$V_BASE <= code && code <= $e1c6bbc8cb416f8c$var$V_END;\nconst $e1c6bbc8cb416f8c$var$isCombiningT = code => $e1c6bbc8cb416f8c$var$T_BASE + 1 && 1 <= code && code <= $e1c6bbc8cb416f8c$var$T_END;\n// Character categories\nconst $e1c6bbc8cb416f8c$var$X = 0; // Other character\nconst $e1c6bbc8cb416f8c$var$L = 1; // Leading consonant\nconst $e1c6bbc8cb416f8c$var$V = 2; // Medial vowel\nconst $e1c6bbc8cb416f8c$var$T = 3; // Trailing consonant\nconst $e1c6bbc8cb416f8c$var$LV = 4; // Composed <LV> syllable\nconst $e1c6bbc8cb416f8c$var$LVT = 5; // Composed <LVT> syllable\nconst $e1c6bbc8cb416f8c$var$M = 6; // Tone mark\n// This function classifies a character using the above categories.\nfunction $e1c6bbc8cb416f8c$var$getType(code) {\n  if ($e1c6bbc8cb416f8c$var$isL(code)) return $e1c6bbc8cb416f8c$var$L;\n  if ($e1c6bbc8cb416f8c$var$isV(code)) return $e1c6bbc8cb416f8c$var$V;\n  if ($e1c6bbc8cb416f8c$var$isT(code)) return $e1c6bbc8cb416f8c$var$T;\n  if ($e1c6bbc8cb416f8c$var$isLV(code)) return $e1c6bbc8cb416f8c$var$LV;\n  if ($e1c6bbc8cb416f8c$var$isLVT(code)) return $e1c6bbc8cb416f8c$var$LVT;\n  if ($e1c6bbc8cb416f8c$var$isTone(code)) return $e1c6bbc8cb416f8c$var$M;\n  return $e1c6bbc8cb416f8c$var$X;\n}\n// State machine actions\nconst $e1c6bbc8cb416f8c$var$NO_ACTION = 0;\nconst $e1c6bbc8cb416f8c$var$DECOMPOSE = 1;\nconst $e1c6bbc8cb416f8c$var$COMPOSE = 2;\nconst $e1c6bbc8cb416f8c$var$TONE_MARK = 4;\nconst $e1c6bbc8cb416f8c$var$INVALID = 5;\n// Build a state machine that accepts valid syllables, and applies actions along the way.\n// The logic this is implementing is documented at the top of the file.\nconst $e1c6bbc8cb416f8c$var$STATE_TABLE = [\n//       X                 L                 V                T                  LV                LVT               M\n// State 0: start state\n[[$e1c6bbc8cb416f8c$var$NO_ACTION, 0], [$e1c6bbc8cb416f8c$var$NO_ACTION, 1], [$e1c6bbc8cb416f8c$var$NO_ACTION, 0], [$e1c6bbc8cb416f8c$var$NO_ACTION, 0], [$e1c6bbc8cb416f8c$var$DECOMPOSE, 2], [$e1c6bbc8cb416f8c$var$DECOMPOSE, 3], [$e1c6bbc8cb416f8c$var$INVALID, 0]],\n// State 1: <L>\n[[$e1c6bbc8cb416f8c$var$NO_ACTION, 0], [$e1c6bbc8cb416f8c$var$NO_ACTION, 1], [$e1c6bbc8cb416f8c$var$COMPOSE, 2], [$e1c6bbc8cb416f8c$var$NO_ACTION, 0], [$e1c6bbc8cb416f8c$var$DECOMPOSE, 2], [$e1c6bbc8cb416f8c$var$DECOMPOSE, 3], [$e1c6bbc8cb416f8c$var$INVALID, 0]],\n// State 2: <L,V> or <LV>\n[[$e1c6bbc8cb416f8c$var$NO_ACTION, 0], [$e1c6bbc8cb416f8c$var$NO_ACTION, 1], [$e1c6bbc8cb416f8c$var$NO_ACTION, 0], [$e1c6bbc8cb416f8c$var$COMPOSE, 3], [$e1c6bbc8cb416f8c$var$DECOMPOSE, 2], [$e1c6bbc8cb416f8c$var$DECOMPOSE, 3], [$e1c6bbc8cb416f8c$var$TONE_MARK, 0]],\n// State 3: <L,V,T> or <LVT>\n[[$e1c6bbc8cb416f8c$var$NO_ACTION, 0], [$e1c6bbc8cb416f8c$var$NO_ACTION, 1], [$e1c6bbc8cb416f8c$var$NO_ACTION, 0], [$e1c6bbc8cb416f8c$var$NO_ACTION, 0], [$e1c6bbc8cb416f8c$var$DECOMPOSE, 2], [$e1c6bbc8cb416f8c$var$DECOMPOSE, 3], [$e1c6bbc8cb416f8c$var$TONE_MARK, 0]]];\nfunction $e1c6bbc8cb416f8c$var$getGlyph(font, code, features) {\n  return new (0, $10e7b257e1a9a756$export$2e2bcd8739ae039)(font, font.glyphForCodePoint(code).id, [code], features);\n}\nfunction $e1c6bbc8cb416f8c$var$decompose(glyphs, i, font) {\n  let glyph = glyphs[i];\n  let code = glyph.codePoints[0];\n  let s = code - $e1c6bbc8cb416f8c$var$HANGUL_BASE;\n  let t = $e1c6bbc8cb416f8c$var$T_BASE + s % $e1c6bbc8cb416f8c$var$T_COUNT;\n  s = s / $e1c6bbc8cb416f8c$var$T_COUNT | 0;\n  let l = $e1c6bbc8cb416f8c$var$L_BASE + s / $e1c6bbc8cb416f8c$var$V_COUNT | 0;\n  let v = $e1c6bbc8cb416f8c$var$V_BASE + s % $e1c6bbc8cb416f8c$var$V_COUNT;\n  // Don't decompose if all of the components are not available\n  if (!font.hasGlyphForCodePoint(l) || !font.hasGlyphForCodePoint(v) || t !== $e1c6bbc8cb416f8c$var$T_BASE && !font.hasGlyphForCodePoint(t)) return i;\n  // Replace the current glyph with decomposed L, V, and T glyphs,\n  // and apply the proper OpenType features to each component.\n  let ljmo = $e1c6bbc8cb416f8c$var$getGlyph(font, l, glyph.features);\n  ljmo.features.ljmo = true;\n  let vjmo = $e1c6bbc8cb416f8c$var$getGlyph(font, v, glyph.features);\n  vjmo.features.vjmo = true;\n  let insert = [ljmo, vjmo];\n  if (t > $e1c6bbc8cb416f8c$var$T_BASE) {\n    let tjmo = $e1c6bbc8cb416f8c$var$getGlyph(font, t, glyph.features);\n    tjmo.features.tjmo = true;\n    insert.push(tjmo);\n  }\n  glyphs.splice(i, 1, ...insert);\n  return i + insert.length - 1;\n}\nfunction $e1c6bbc8cb416f8c$var$compose(glyphs, i, font) {\n  let glyph = glyphs[i];\n  let code = glyphs[i].codePoints[0];\n  let type = $e1c6bbc8cb416f8c$var$getType(code);\n  let prev = glyphs[i - 1].codePoints[0];\n  let prevType = $e1c6bbc8cb416f8c$var$getType(prev);\n  // Figure out what type of syllable we're dealing with\n  let lv, ljmo, vjmo, tjmo;\n  if (prevType === $e1c6bbc8cb416f8c$var$LV && type === $e1c6bbc8cb416f8c$var$T) {\n    // <LV,T>\n    lv = prev;\n    tjmo = glyph;\n  } else {\n    if (type === $e1c6bbc8cb416f8c$var$V) {\n      // <L,V>\n      ljmo = glyphs[i - 1];\n      vjmo = glyph;\n    } else {\n      // <L,V,T>\n      ljmo = glyphs[i - 2];\n      vjmo = glyphs[i - 1];\n      tjmo = glyph;\n    }\n    let l = ljmo.codePoints[0];\n    let v = vjmo.codePoints[0];\n    // Make sure L and V are combining characters\n    if ($e1c6bbc8cb416f8c$var$isCombiningL(l) && $e1c6bbc8cb416f8c$var$isCombiningV(v)) lv = $e1c6bbc8cb416f8c$var$HANGUL_BASE + ((l - $e1c6bbc8cb416f8c$var$L_BASE) * $e1c6bbc8cb416f8c$var$V_COUNT + (v - $e1c6bbc8cb416f8c$var$V_BASE)) * $e1c6bbc8cb416f8c$var$T_COUNT;\n  }\n  let t = tjmo && tjmo.codePoints[0] || $e1c6bbc8cb416f8c$var$T_BASE;\n  if (lv != null && (t === $e1c6bbc8cb416f8c$var$T_BASE || $e1c6bbc8cb416f8c$var$isCombiningT(t))) {\n    let s = lv + (t - $e1c6bbc8cb416f8c$var$T_BASE);\n    // Replace with a composed glyph if supported by the font,\n    // otherwise apply the proper OpenType features to each component.\n    if (font.hasGlyphForCodePoint(s)) {\n      let del = prevType === $e1c6bbc8cb416f8c$var$V ? 3 : 2;\n      glyphs.splice(i - del + 1, del, $e1c6bbc8cb416f8c$var$getGlyph(font, s, glyph.features));\n      return i - del + 1;\n    }\n  }\n  // Didn't compose (either a non-combining component or unsupported by font).\n  if (ljmo) ljmo.features.ljmo = true;\n  if (vjmo) vjmo.features.vjmo = true;\n  if (tjmo) tjmo.features.tjmo = true;\n  if (prevType === $e1c6bbc8cb416f8c$var$LV) {\n    // Sequence was originally <L,V>, which got combined earlier.\n    // Either the T was non-combining, or the LVT glyph wasn't supported.\n    // Decompose the glyph again and apply OT features.\n    $e1c6bbc8cb416f8c$var$decompose(glyphs, i - 1, font);\n    return i + 1;\n  }\n  return i;\n}\nfunction $e1c6bbc8cb416f8c$var$getLength(code) {\n  switch ($e1c6bbc8cb416f8c$var$getType(code)) {\n    case $e1c6bbc8cb416f8c$var$LV:\n    case $e1c6bbc8cb416f8c$var$LVT:\n      return 1;\n    case $e1c6bbc8cb416f8c$var$V:\n      return 2;\n    case $e1c6bbc8cb416f8c$var$T:\n      return 3;\n  }\n}\nfunction $e1c6bbc8cb416f8c$var$reorderToneMark(glyphs, i, font) {\n  let glyph = glyphs[i];\n  let code = glyphs[i].codePoints[0];\n  // Move tone mark to the beginning of the previous syllable, unless it is zero width\n  if (font.glyphForCodePoint(code).advanceWidth === 0) return;\n  let prev = glyphs[i - 1].codePoints[0];\n  let len = $e1c6bbc8cb416f8c$var$getLength(prev);\n  glyphs.splice(i, 1);\n  return glyphs.splice(i - len, 0, glyph);\n}\nfunction $e1c6bbc8cb416f8c$var$insertDottedCircle(glyphs, i, font) {\n  let glyph = glyphs[i];\n  let code = glyphs[i].codePoints[0];\n  if (font.hasGlyphForCodePoint($e1c6bbc8cb416f8c$var$DOTTED_CIRCLE)) {\n    let dottedCircle = $e1c6bbc8cb416f8c$var$getGlyph(font, $e1c6bbc8cb416f8c$var$DOTTED_CIRCLE, glyph.features);\n    // If the tone mark is zero width, insert the dotted circle before, otherwise after\n    let idx = font.glyphForCodePoint(code).advanceWidth === 0 ? i : i + 1;\n    glyphs.splice(idx, 0, dottedCircle);\n    i++;\n  }\n  return i;\n}\nvar $4b0735ca6c692ea5$exports = {};\n$4b0735ca6c692ea5$exports = JSON.parse(\"{\\\"stateTable\\\":[[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,2,3,4,5,6,7,8,9,0,10,11,11,12,13,14,15,16,17],[0,0,0,18,19,20,21,22,23,0,24,0,0,25,26,0,0,27,0],[0,0,0,28,29,30,31,32,33,0,34,0,0,35,36,0,0,37,0],[0,0,0,38,5,7,7,8,9,0,10,0,0,0,13,0,0,16,0],[0,39,0,0,0,40,41,0,9,0,10,0,0,0,42,0,39,0,0],[0,0,0,0,43,44,44,8,9,0,0,0,0,12,43,0,0,0,0],[0,0,0,0,43,44,44,8,9,0,0,0,0,0,43,0,0,0,0],[0,0,0,45,46,47,48,49,9,0,10,0,0,0,42,0,0,0,0],[0,0,0,0,0,50,0,0,51,0,10,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,52,0,0,0,0,0,0,0,0],[0,0,0,53,54,55,56,57,58,0,59,0,0,60,61,0,0,62,0],[0,0,0,4,5,7,7,8,9,0,10,0,0,0,13,0,0,16,0],[0,63,64,0,0,40,41,0,9,0,10,0,0,0,42,0,63,0,0],[0,2,3,4,5,6,7,8,9,0,10,11,11,12,13,0,2,16,0],[0,0,0,18,65,20,21,22,23,0,24,0,0,25,26,0,0,27,0],[0,0,0,0,66,67,67,8,9,0,10,0,0,0,68,0,0,0,0],[0,0,0,69,0,70,70,0,71,0,72,0,0,0,0,0,0,0,0],[0,0,0,73,19,74,74,22,23,0,24,0,0,0,26,0,0,27,0],[0,75,0,0,0,76,77,0,23,0,24,0,0,0,78,0,75,0,0],[0,0,0,0,79,80,80,22,23,0,0,0,0,25,79,0,0,0,0],[0,0,0,18,19,20,74,22,23,0,24,0,0,25,26,0,0,27,0],[0,0,0,81,82,83,84,85,23,0,24,0,0,0,78,0,0,0,0],[0,0,0,0,0,86,0,0,87,0,24,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,88,0,0,0,0,0,0,0,0],[0,0,0,18,19,74,74,22,23,0,24,0,0,0,26,0,0,27,0],[0,89,90,0,0,76,77,0,23,0,24,0,0,0,78,0,89,0,0],[0,0,0,0,91,92,92,22,23,0,24,0,0,0,93,0,0,0,0],[0,0,0,94,29,95,31,32,33,0,34,0,0,0,36,0,0,37,0],[0,96,0,0,0,97,98,0,33,0,34,0,0,0,99,0,96,0,0],[0,0,0,0,100,101,101,32,33,0,0,0,0,35,100,0,0,0,0],[0,0,0,0,100,101,101,32,33,0,0,0,0,0,100,0,0,0,0],[0,0,0,102,103,104,105,106,33,0,34,0,0,0,99,0,0,0,0],[0,0,0,0,0,107,0,0,108,0,34,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,109,0,0,0,0,0,0,0,0],[0,0,0,28,29,95,31,32,33,0,34,0,0,0,36,0,0,37,0],[0,110,111,0,0,97,98,0,33,0,34,0,0,0,99,0,110,0,0],[0,0,0,0,112,113,113,32,33,0,34,0,0,0,114,0,0,0,0],[0,0,0,0,5,7,7,8,9,0,10,0,0,0,13,0,0,16,0],[0,0,0,115,116,117,118,8,9,0,10,0,0,119,120,0,0,16,0],[0,0,0,0,0,121,121,0,9,0,10,0,0,0,42,0,0,0,0],[0,39,0,122,0,123,123,8,9,0,10,0,0,0,42,0,39,0,0],[0,124,64,0,0,0,0,0,0,0,0,0,0,0,0,0,124,0,0],[0,39,0,0,0,121,125,0,9,0,10,0,0,0,42,0,39,0,0],[0,0,0,0,0,126,126,8,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,46,47,48,49,9,0,10,0,0,0,42,0,0,0,0],[0,0,0,0,0,47,47,49,9,0,10,0,0,0,42,0,0,0,0],[0,0,0,0,0,127,127,49,9,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,128,127,127,49,9,0,0,0,0,0,0,0,0,0,0],[0,0,0,129,130,131,132,133,9,0,10,0,0,0,42,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,10,0,0,0,0,0,0,0,0],[0,0,0,0,0,50,0,0,0,0,10,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,134,0,0,0,0,0,0,0,0],[0,0,0,135,54,56,56,57,58,0,59,0,0,0,61,0,0,62,0],[0,136,0,0,0,137,138,0,58,0,59,0,0,0,139,0,136,0,0],[0,0,0,0,140,141,141,57,58,0,0,0,0,60,140,0,0,0,0],[0,0,0,0,140,141,141,57,58,0,0,0,0,0,140,0,0,0,0],[0,0,0,142,143,144,145,146,58,0,59,0,0,0,139,0,0,0,0],[0,0,0,0,0,147,0,0,148,0,59,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,149,0,0,0,0,0,0,0,0],[0,0,0,53,54,56,56,57,58,0,59,0,0,0,61,0,0,62,0],[0,150,151,0,0,137,138,0,58,0,59,0,0,0,139,0,150,0,0],[0,0,0,0,152,153,153,57,58,0,59,0,0,0,154,0,0,0,0],[0,0,0,155,116,156,157,8,9,0,10,0,0,158,120,0,0,16,0],[0,0,0,0,0,121,121,0,9,0,10,0,0,0,0,0,0,0,0],[0,75,3,4,5,159,160,8,161,0,162,0,11,12,163,0,75,16,0],[0,0,0,0,0,40,164,0,9,0,10,0,0,0,42,0,0,0,0],[0,0,0,0,165,44,44,8,9,0,0,0,0,0,165,0,0,0,0],[0,124,64,0,0,40,164,0,9,0,10,0,0,0,42,0,124,0,0],[0,0,0,0,0,70,70,0,71,0,72,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,71,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,166,0,0,167,0,72,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,168,0,0,0,0,0,0,0,0],[0,0,0,0,19,74,74,22,23,0,24,0,0,0,26,0,0,27,0],[0,0,0,0,79,80,80,22,23,0,0,0,0,0,79,0,0,0,0],[0,0,0,169,170,171,172,22,23,0,24,0,0,173,174,0,0,27,0],[0,0,0,0,0,175,175,0,23,0,24,0,0,0,78,0,0,0,0],[0,75,0,176,0,177,177,22,23,0,24,0,0,0,78,0,75,0,0],[0,178,90,0,0,0,0,0,0,0,0,0,0,0,0,0,178,0,0],[0,75,0,0,0,175,179,0,23,0,24,0,0,0,78,0,75,0,0],[0,0,0,0,0,180,180,22,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,82,83,84,85,23,0,24,0,0,0,78,0,0,0,0],[0,0,0,0,0,83,83,85,23,0,24,0,0,0,78,0,0,0,0],[0,0,0,0,0,181,181,85,23,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,182,181,181,85,23,0,0,0,0,0,0,0,0,0,0],[0,0,0,183,184,185,186,187,23,0,24,0,0,0,78,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,24,0,0,0,0,0,0,0,0],[0,0,0,0,0,86,0,0,0,0,24,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,188,0,0,0,0,0,0,0,0],[0,0,0,189,170,190,191,22,23,0,24,0,0,192,174,0,0,27,0],[0,0,0,0,0,175,175,0,23,0,24,0,0,0,0,0,0,0,0],[0,0,0,0,0,76,193,0,23,0,24,0,0,0,78,0,0,0,0],[0,0,0,0,194,80,80,22,23,0,0,0,0,0,194,0,0,0,0],[0,178,90,0,0,76,193,0,23,0,24,0,0,0,78,0,178,0,0],[0,0,0,0,29,95,31,32,33,0,34,0,0,0,36,0,0,37,0],[0,0,0,0,100,101,101,32,33,0,0,0,0,0,100,0,0,0,0],[0,0,0,195,196,197,198,32,33,0,34,0,0,199,200,0,0,37,0],[0,0,0,0,0,201,201,0,33,0,34,0,0,0,99,0,0,0,0],[0,96,0,202,0,203,203,32,33,0,34,0,0,0,99,0,96,0,0],[0,204,111,0,0,0,0,0,0,0,0,0,0,0,0,0,204,0,0],[0,96,0,0,0,201,205,0,33,0,34,0,0,0,99,0,96,0,0],[0,0,0,0,0,206,206,32,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,103,104,105,106,33,0,34,0,0,0,99,0,0,0,0],[0,0,0,0,0,104,104,106,33,0,34,0,0,0,99,0,0,0,0],[0,0,0,0,0,207,207,106,33,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,208,207,207,106,33,0,0,0,0,0,0,0,0,0,0],[0,0,0,209,210,211,212,213,33,0,34,0,0,0,99,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,34,0,0,0,0,0,0,0,0],[0,0,0,0,0,107,0,0,0,0,34,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,214,0,0,0,0,0,0,0,0],[0,0,0,215,196,216,217,32,33,0,34,0,0,218,200,0,0,37,0],[0,0,0,0,0,201,201,0,33,0,34,0,0,0,0,0,0,0,0],[0,0,0,0,0,97,219,0,33,0,34,0,0,0,99,0,0,0,0],[0,0,0,0,220,101,101,32,33,0,0,0,0,0,220,0,0,0,0],[0,204,111,0,0,97,219,0,33,0,34,0,0,0,99,0,204,0,0],[0,0,0,221,116,222,222,8,9,0,10,0,0,0,120,0,0,16,0],[0,223,0,0,0,40,224,0,9,0,10,0,0,0,42,0,223,0,0],[0,0,0,0,225,44,44,8,9,0,0,0,0,119,225,0,0,0,0],[0,0,0,115,116,117,222,8,9,0,10,0,0,119,120,0,0,16,0],[0,0,0,115,116,222,222,8,9,0,10,0,0,0,120,0,0,16,0],[0,226,64,0,0,40,224,0,9,0,10,0,0,0,42,0,226,0,0],[0,0,0,0,0,0,0,0,9,0,0,0,0,0,0,0,0,0,0],[0,39,0,0,0,121,121,0,9,0,10,0,0,0,42,0,39,0,0],[0,0,0,0,0,44,44,8,9,0,0,0,0,0,0,0,0,0,0],[0,0,0,227,0,228,229,0,9,0,10,0,0,230,0,0,0,0,0],[0,39,0,122,0,121,121,0,9,0,10,0,0,0,42,0,39,0,0],[0,0,0,0,0,0,0,8,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,231,231,49,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,232,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,130,131,132,133,9,0,10,0,0,0,42,0,0,0,0],[0,0,0,0,0,131,131,133,9,0,10,0,0,0,42,0,0,0,0],[0,0,0,0,0,233,233,133,9,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,234,233,233,133,9,0,0,0,0,0,0,0,0,0,0],[0,0,0,235,236,237,238,239,9,0,10,0,0,0,42,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,54,56,56,57,58,0,59,0,0,0,61,0,0,62,0],[0,0,0,240,241,242,243,57,58,0,59,0,0,244,245,0,0,62,0],[0,0,0,0,0,246,246,0,58,0,59,0,0,0,139,0,0,0,0],[0,136,0,247,0,248,248,57,58,0,59,0,0,0,139,0,136,0,0],[0,249,151,0,0,0,0,0,0,0,0,0,0,0,0,0,249,0,0],[0,136,0,0,0,246,250,0,58,0,59,0,0,0,139,0,136,0,0],[0,0,0,0,0,251,251,57,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,143,144,145,146,58,0,59,0,0,0,139,0,0,0,0],[0,0,0,0,0,144,144,146,58,0,59,0,0,0,139,0,0,0,0],[0,0,0,0,0,252,252,146,58,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,253,252,252,146,58,0,0,0,0,0,0,0,0,0,0],[0,0,0,254,255,256,257,258,58,0,59,0,0,0,139,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,59,0,0,0,0,0,0,0,0],[0,0,0,0,0,147,0,0,0,0,59,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,259,0,0,0,0,0,0,0,0],[0,0,0,260,241,261,262,57,58,0,59,0,0,263,245,0,0,62,0],[0,0,0,0,0,246,246,0,58,0,59,0,0,0,0,0,0,0,0],[0,0,0,0,0,137,264,0,58,0,59,0,0,0,139,0,0,0,0],[0,0,0,0,265,141,141,57,58,0,0,0,0,0,265,0,0,0,0],[0,249,151,0,0,137,264,0,58,0,59,0,0,0,139,0,249,0,0],[0,0,0,221,116,222,222,8,9,0,10,0,0,0,120,0,0,16,0],[0,0,0,0,225,44,44,8,9,0,0,0,0,158,225,0,0,0,0],[0,0,0,155,116,156,222,8,9,0,10,0,0,158,120,0,0,16,0],[0,0,0,155,116,222,222,8,9,0,10,0,0,0,120,0,0,16,0],[0,0,0,0,43,266,266,8,161,0,24,0,0,12,267,0,0,0,0],[0,75,0,176,43,268,268,269,161,0,24,0,0,0,267,0,75,0,0],[0,0,0,0,0,270,0,0,271,0,162,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,272,0,0,0,0,0,0,0,0],[0,273,274,0,0,40,41,0,9,0,10,0,0,0,42,0,273,0,0],[0,0,0,40,0,123,123,8,9,0,10,0,0,0,42,0,0,0,0],[0,0,0,0,0,121,275,0,9,0,10,0,0,0,42,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,72,0,0,0,0,0,0,0,0],[0,0,0,0,0,166,0,0,0,0,72,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,276,0,0,0,0,0,0,0,0],[0,0,0,277,170,278,278,22,23,0,24,0,0,0,174,0,0,27,0],[0,279,0,0,0,76,280,0,23,0,24,0,0,0,78,0,279,0,0],[0,0,0,0,281,80,80,22,23,0,0,0,0,173,281,0,0,0,0],[0,0,0,169,170,171,278,22,23,0,24,0,0,173,174,0,0,27,0],[0,0,0,169,170,278,278,22,23,0,24,0,0,0,174,0,0,27,0],[0,282,90,0,0,76,280,0,23,0,24,0,0,0,78,0,282,0,0],[0,0,0,0,0,0,0,0,23,0,0,0,0,0,0,0,0,0,0],[0,75,0,0,0,175,175,0,23,0,24,0,0,0,78,0,75,0,0],[0,0,0,0,0,80,80,22,23,0,0,0,0,0,0,0,0,0,0],[0,0,0,283,0,284,285,0,23,0,24,0,0,286,0,0,0,0,0],[0,75,0,176,0,175,175,0,23,0,24,0,0,0,78,0,75,0,0],[0,0,0,0,0,0,0,22,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,287,287,85,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,288,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,184,185,186,187,23,0,24,0,0,0,78,0,0,0,0],[0,0,0,0,0,185,185,187,23,0,24,0,0,0,78,0,0,0,0],[0,0,0,0,0,289,289,187,23,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,290,289,289,187,23,0,0,0,0,0,0,0,0,0,0],[0,0,0,291,292,293,294,295,23,0,24,0,0,0,78,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,277,170,278,278,22,23,0,24,0,0,0,174,0,0,27,0],[0,0,0,0,281,80,80,22,23,0,0,0,0,192,281,0,0,0,0],[0,0,0,189,170,190,278,22,23,0,24,0,0,192,174,0,0,27,0],[0,0,0,189,170,278,278,22,23,0,24,0,0,0,174,0,0,27,0],[0,0,0,76,0,177,177,22,23,0,24,0,0,0,78,0,0,0,0],[0,0,0,0,0,175,296,0,23,0,24,0,0,0,78,0,0,0,0],[0,0,0,297,196,298,298,32,33,0,34,0,0,0,200,0,0,37,0],[0,299,0,0,0,97,300,0,33,0,34,0,0,0,99,0,299,0,0],[0,0,0,0,301,101,101,32,33,0,0,0,0,199,301,0,0,0,0],[0,0,0,195,196,197,298,32,33,0,34,0,0,199,200,0,0,37,0],[0,0,0,195,196,298,298,32,33,0,34,0,0,0,200,0,0,37,0],[0,302,111,0,0,97,300,0,33,0,34,0,0,0,99,0,302,0,0],[0,0,0,0,0,0,0,0,33,0,0,0,0,0,0,0,0,0,0],[0,96,0,0,0,201,201,0,33,0,34,0,0,0,99,0,96,0,0],[0,0,0,0,0,101,101,32,33,0,0,0,0,0,0,0,0,0,0],[0,0,0,303,0,304,305,0,33,0,34,0,0,306,0,0,0,0,0],[0,96,0,202,0,201,201,0,33,0,34,0,0,0,99,0,96,0,0],[0,0,0,0,0,0,0,32,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,307,307,106,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,308,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,210,211,212,213,33,0,34,0,0,0,99,0,0,0,0],[0,0,0,0,0,211,211,213,33,0,34,0,0,0,99,0,0,0,0],[0,0,0,0,0,309,309,213,33,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,310,309,309,213,33,0,0,0,0,0,0,0,0,0,0],[0,0,0,311,312,313,314,315,33,0,34,0,0,0,99,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,297,196,298,298,32,33,0,34,0,0,0,200,0,0,37,0],[0,0,0,0,301,101,101,32,33,0,0,0,0,218,301,0,0,0,0],[0,0,0,215,196,216,298,32,33,0,34,0,0,218,200,0,0,37,0],[0,0,0,215,196,298,298,32,33,0,34,0,0,0,200,0,0,37,0],[0,0,0,97,0,203,203,32,33,0,34,0,0,0,99,0,0,0,0],[0,0,0,0,0,201,316,0,33,0,34,0,0,0,99,0,0,0,0],[0,0,0,0,116,222,222,8,9,0,10,0,0,0,120,0,0,16,0],[0,0,0,0,225,44,44,8,9,0,0,0,0,0,225,0,0,0,0],[0,0,0,317,318,319,320,8,9,0,10,0,0,321,322,0,0,16,0],[0,223,0,323,0,123,123,8,9,0,10,0,0,0,42,0,223,0,0],[0,223,0,0,0,121,324,0,9,0,10,0,0,0,42,0,223,0,0],[0,0,0,325,318,326,327,8,9,0,10,0,0,328,322,0,0,16,0],[0,0,0,64,0,121,121,0,9,0,10,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,9,0,0,0,0,230,0,0,0,0,0],[0,0,0,227,0,228,121,0,9,0,10,0,0,230,0,0,0,0,0],[0,0,0,227,0,121,121,0,9,0,10,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,49,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,46,0,0],[0,0,0,0,0,329,329,133,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,330,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,236,237,238,239,9,0,10,0,0,0,42,0,0,0,0],[0,0,0,0,0,237,237,239,9,0,10,0,0,0,42,0,0,0,0],[0,0,0,0,0,331,331,239,9,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,332,331,331,239,9,0,0,0,0,0,0,0,0,0,0],[0,0,0,333,40,121,334,0,9,0,10,0,0,0,42,0,0,0,0],[0,0,0,335,241,336,336,57,58,0,59,0,0,0,245,0,0,62,0],[0,337,0,0,0,137,338,0,58,0,59,0,0,0,139,0,337,0,0],[0,0,0,0,339,141,141,57,58,0,0,0,0,244,339,0,0,0,0],[0,0,0,240,241,242,336,57,58,0,59,0,0,244,245,0,0,62,0],[0,0,0,240,241,336,336,57,58,0,59,0,0,0,245,0,0,62,0],[0,340,151,0,0,137,338,0,58,0,59,0,0,0,139,0,340,0,0],[0,0,0,0,0,0,0,0,58,0,0,0,0,0,0,0,0,0,0],[0,136,0,0,0,246,246,0,58,0,59,0,0,0,139,0,136,0,0],[0,0,0,0,0,141,141,57,58,0,0,0,0,0,0,0,0,0,0],[0,0,0,341,0,342,343,0,58,0,59,0,0,344,0,0,0,0,0],[0,136,0,247,0,246,246,0,58,0,59,0,0,0,139,0,136,0,0],[0,0,0,0,0,0,0,57,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,345,345,146,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,346,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,255,256,257,258,58,0,59,0,0,0,139,0,0,0,0],[0,0,0,0,0,256,256,258,58,0,59,0,0,0,139,0,0,0,0],[0,0,0,0,0,347,347,258,58,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,348,347,347,258,58,0,0,0,0,0,0,0,0,0,0],[0,0,0,349,350,351,352,353,58,0,59,0,0,0,139,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,335,241,336,336,57,58,0,59,0,0,0,245,0,0,62,0],[0,0,0,0,339,141,141,57,58,0,0,0,0,263,339,0,0,0,0],[0,0,0,260,241,261,336,57,58,0,59,0,0,263,245,0,0,62,0],[0,0,0,260,241,336,336,57,58,0,59,0,0,0,245,0,0,62,0],[0,0,0,137,0,248,248,57,58,0,59,0,0,0,139,0,0,0,0],[0,0,0,0,0,246,354,0,58,0,59,0,0,0,139,0,0,0,0],[0,0,0,0,0,126,126,8,23,0,0,0,0,0,0,0,0,0,0],[0,355,90,0,0,121,125,0,9,0,10,0,0,0,42,0,355,0,0],[0,0,0,0,0,356,356,269,23,0,0,0,0,0,0,0,0,0,0],[0,0,0,357,358,359,360,361,161,0,162,0,0,0,362,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,162,0,0,0,0,0,0,0,0],[0,0,0,0,0,270,0,0,0,0,162,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,363,0,0,0,0,0,0,0,0],[0,0,0,364,116,365,366,8,161,0,162,0,0,367,120,0,0,16,0],[0,0,0,0,0,368,368,0,161,0,162,0,0,0,0,0,0,0,0],[0,0,0,40,0,121,121,0,9,0,10,0,0,0,42,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,170,278,278,22,23,0,24,0,0,0,174,0,0,27,0],[0,0,0,0,281,80,80,22,23,0,0,0,0,0,281,0,0,0,0],[0,0,0,369,370,371,372,22,23,0,24,0,0,373,374,0,0,27,0],[0,279,0,375,0,177,177,22,23,0,24,0,0,0,78,0,279,0,0],[0,279,0,0,0,175,376,0,23,0,24,0,0,0,78,0,279,0,0],[0,0,0,377,370,378,379,22,23,0,24,0,0,380,374,0,0,27,0],[0,0,0,90,0,175,175,0,23,0,24,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,23,0,0,0,0,286,0,0,0,0,0],[0,0,0,283,0,284,175,0,23,0,24,0,0,286,0,0,0,0,0],[0,0,0,283,0,175,175,0,23,0,24,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,85,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,82,0,0],[0,0,0,0,0,381,381,187,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,382,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,292,293,294,295,23,0,24,0,0,0,78,0,0,0,0],[0,0,0,0,0,293,293,295,23,0,24,0,0,0,78,0,0,0,0],[0,0,0,0,0,383,383,295,23,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,384,383,383,295,23,0,0,0,0,0,0,0,0,0,0],[0,0,0,385,76,175,386,0,23,0,24,0,0,0,78,0,0,0,0],[0,0,0,76,0,175,175,0,23,0,24,0,0,0,78,0,0,0,0],[0,0,0,0,196,298,298,32,33,0,34,0,0,0,200,0,0,37,0],[0,0,0,0,301,101,101,32,33,0,0,0,0,0,301,0,0,0,0],[0,0,0,387,388,389,390,32,33,0,34,0,0,391,392,0,0,37,0],[0,299,0,393,0,203,203,32,33,0,34,0,0,0,99,0,299,0,0],[0,299,0,0,0,201,394,0,33,0,34,0,0,0,99,0,299,0,0],[0,0,0,395,388,396,397,32,33,0,34,0,0,398,392,0,0,37,0],[0,0,0,111,0,201,201,0,33,0,34,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,33,0,0,0,0,306,0,0,0,0,0],[0,0,0,303,0,304,201,0,33,0,34,0,0,306,0,0,0,0,0],[0,0,0,303,0,201,201,0,33,0,34,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,106,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,103,0,0],[0,0,0,0,0,399,399,213,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,400,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,312,313,314,315,33,0,34,0,0,0,99,0,0,0,0],[0,0,0,0,0,313,313,315,33,0,34,0,0,0,99,0,0,0,0],[0,0,0,0,0,401,401,315,33,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,402,401,401,315,33,0,0,0,0,0,0,0,0,0,0],[0,0,0,403,97,201,404,0,33,0,34,0,0,0,99,0,0,0,0],[0,0,0,97,0,201,201,0,33,0,34,0,0,0,99,0,0,0,0],[0,0,0,405,318,406,406,8,9,0,10,0,0,0,322,0,0,16,0],[0,407,0,0,0,40,408,0,9,0,10,0,0,0,42,0,407,0,0],[0,0,0,0,409,44,44,8,9,0,0,0,0,321,409,0,0,0,0],[0,0,0,317,318,319,406,8,9,0,10,0,0,321,322,0,0,16,0],[0,0,0,317,318,406,406,8,9,0,10,0,0,0,322,0,0,16,0],[0,410,64,0,0,40,408,0,9,0,10,0,0,0,42,0,410,0,0],[0,223,0,0,0,121,121,0,9,0,10,0,0,0,42,0,223,0,0],[0,223,0,323,0,121,121,0,9,0,10,0,0,0,42,0,223,0,0],[0,0,0,405,318,406,406,8,9,0,10,0,0,0,322,0,0,16,0],[0,0,0,0,409,44,44,8,9,0,0,0,0,328,409,0,0,0,0],[0,0,0,325,318,326,406,8,9,0,10,0,0,328,322,0,0,16,0],[0,0,0,325,318,406,406,8,9,0,10,0,0,0,322,0,0,16,0],[0,0,0,0,0,0,0,133,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,130,0,0],[0,0,0,0,0,411,411,239,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,412,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,40,121,334,0,9,0,10,0,0,0,42,0,0,0,0],[0,0,0,0,413,0,0,0,9,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,241,336,336,57,58,0,59,0,0,0,245,0,0,62,0],[0,0,0,0,339,141,141,57,58,0,0,0,0,0,339,0,0,0,0],[0,0,0,414,415,416,417,57,58,0,59,0,0,418,419,0,0,62,0],[0,337,0,420,0,248,248,57,58,0,59,0,0,0,139,0,337,0,0],[0,337,0,0,0,246,421,0,58,0,59,0,0,0,139,0,337,0,0],[0,0,0,422,415,423,424,57,58,0,59,0,0,425,419,0,0,62,0],[0,0,0,151,0,246,246,0,58,0,59,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,58,0,0,0,0,344,0,0,0,0,0],[0,0,0,341,0,342,246,0,58,0,59,0,0,344,0,0,0,0,0],[0,0,0,341,0,246,246,0,58,0,59,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,146,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,143,0,0],[0,0,0,0,0,426,426,258,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,427,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,350,351,352,353,58,0,59,0,0,0,139,0,0,0,0],[0,0,0,0,0,351,351,353,58,0,59,0,0,0,139,0,0,0,0],[0,0,0,0,0,428,428,353,58,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,429,428,428,353,58,0,0,0,0,0,0,0,0,0,0],[0,0,0,430,137,246,431,0,58,0,59,0,0,0,139,0,0,0,0],[0,0,0,137,0,246,246,0,58,0,59,0,0,0,139,0,0,0,0],[0,0,0,432,116,433,434,8,161,0,162,0,0,435,120,0,0,16,0],[0,0,0,0,0,180,180,269,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,358,359,360,361,161,0,162,0,0,0,362,0,0,0,0],[0,0,0,0,0,359,359,361,161,0,162,0,0,0,362,0,0,0,0],[0,0,0,0,0,436,436,361,161,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,437,436,436,361,161,0,0,0,0,0,0,0,0,0,0],[0,0,0,438,439,440,441,442,161,0,162,0,0,0,362,0,0,0,0],[0,443,274,0,0,0,0,0,0,0,0,0,0,0,0,0,443,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,444,116,445,445,8,161,0,162,0,0,0,120,0,0,16,0],[0,0,0,0,225,44,44,8,161,0,0,0,0,367,225,0,0,0,0],[0,0,0,364,116,365,445,8,161,0,162,0,0,367,120,0,0,16,0],[0,0,0,364,116,445,445,8,161,0,162,0,0,0,120,0,0,16,0],[0,0,0,0,0,0,0,0,161,0,0,0,0,0,0,0,0,0,0],[0,0,0,446,370,447,447,22,23,0,24,0,0,0,374,0,0,27,0],[0,448,0,0,0,76,449,0,23,0,24,0,0,0,78,0,448,0,0],[0,0,0,0,450,80,80,22,23,0,0,0,0,373,450,0,0,0,0],[0,0,0,369,370,371,447,22,23,0,24,0,0,373,374,0,0,27,0],[0,0,0,369,370,447,447,22,23,0,24,0,0,0,374,0,0,27,0],[0,451,90,0,0,76,449,0,23,0,24,0,0,0,78,0,451,0,0],[0,279,0,0,0,175,175,0,23,0,24,0,0,0,78,0,279,0,0],[0,279,0,375,0,175,175,0,23,0,24,0,0,0,78,0,279,0,0],[0,0,0,446,370,447,447,22,23,0,24,0,0,0,374,0,0,27,0],[0,0,0,0,450,80,80,22,23,0,0,0,0,380,450,0,0,0,0],[0,0,0,377,370,378,447,22,23,0,24,0,0,380,374,0,0,27,0],[0,0,0,377,370,447,447,22,23,0,24,0,0,0,374,0,0,27,0],[0,0,0,0,0,0,0,187,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,184,0,0],[0,0,0,0,0,452,452,295,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,453,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,76,175,386,0,23,0,24,0,0,0,78,0,0,0,0],[0,0,0,0,454,0,0,0,23,0,0,0,0,0,0,0,0,0,0],[0,0,0,455,388,456,456,32,33,0,34,0,0,0,392,0,0,37,0],[0,457,0,0,0,97,458,0,33,0,34,0,0,0,99,0,457,0,0],[0,0,0,0,459,101,101,32,33,0,0,0,0,391,459,0,0,0,0],[0,0,0,387,388,389,456,32,33,0,34,0,0,391,392,0,0,37,0],[0,0,0,387,388,456,456,32,33,0,34,0,0,0,392,0,0,37,0],[0,460,111,0,0,97,458,0,33,0,34,0,0,0,99,0,460,0,0],[0,299,0,0,0,201,201,0,33,0,34,0,0,0,99,0,299,0,0],[0,299,0,393,0,201,201,0,33,0,34,0,0,0,99,0,299,0,0],[0,0,0,455,388,456,456,32,33,0,34,0,0,0,392,0,0,37,0],[0,0,0,0,459,101,101,32,33,0,0,0,0,398,459,0,0,0,0],[0,0,0,395,388,396,456,32,33,0,34,0,0,398,392,0,0,37,0],[0,0,0,395,388,456,456,32,33,0,34,0,0,0,392,0,0,37,0],[0,0,0,0,0,0,0,213,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,210,0,0],[0,0,0,0,0,461,461,315,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,462,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,97,201,404,0,33,0,34,0,0,0,99,0,0,0,0],[0,0,0,0,463,0,0,0,33,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,318,406,406,8,9,0,10,0,0,0,322,0,0,16,0],[0,0,0,0,409,44,44,8,9,0,0,0,0,0,409,0,0,0,0],[0,0,0,464,465,466,467,8,9,0,10,0,0,468,469,0,0,16,0],[0,407,0,470,0,123,123,8,9,0,10,0,0,0,42,0,407,0,0],[0,407,0,0,0,121,471,0,9,0,10,0,0,0,42,0,407,0,0],[0,0,0,472,465,473,474,8,9,0,10,0,0,475,469,0,0,16,0],[0,0,0,0,0,0,0,239,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,236,0,0],[0,0,0,0,0,0,476,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,477,415,478,478,57,58,0,59,0,0,0,419,0,0,62,0],[0,479,0,0,0,137,480,0,58,0,59,0,0,0,139,0,479,0,0],[0,0,0,0,481,141,141,57,58,0,0,0,0,418,481,0,0,0,0],[0,0,0,414,415,416,478,57,58,0,59,0,0,418,419,0,0,62,0],[0,0,0,414,415,478,478,57,58,0,59,0,0,0,419,0,0,62,0],[0,482,151,0,0,137,480,0,58,0,59,0,0,0,139,0,482,0,0],[0,337,0,0,0,246,246,0,58,0,59,0,0,0,139,0,337,0,0],[0,337,0,420,0,246,246,0,58,0,59,0,0,0,139,0,337,0,0],[0,0,0,477,415,478,478,57,58,0,59,0,0,0,419,0,0,62,0],[0,0,0,0,481,141,141,57,58,0,0,0,0,425,481,0,0,0,0],[0,0,0,422,415,423,478,57,58,0,59,0,0,425,419,0,0,62,0],[0,0,0,422,415,478,478,57,58,0,59,0,0,0,419,0,0,62,0],[0,0,0,0,0,0,0,258,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,255,0,0],[0,0,0,0,0,483,483,353,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,484,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,137,246,431,0,58,0,59,0,0,0,139,0,0,0,0],[0,0,0,0,485,0,0,0,58,0,0,0,0,0,0,0,0,0,0],[0,0,0,444,116,445,445,8,161,0,162,0,0,0,120,0,0,16,0],[0,0,0,0,225,44,44,8,161,0,0,0,0,435,225,0,0,0,0],[0,0,0,432,116,433,445,8,161,0,162,0,0,435,120,0,0,16,0],[0,0,0,432,116,445,445,8,161,0,162,0,0,0,120,0,0,16,0],[0,0,0,0,0,486,486,361,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,487,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,439,440,441,442,161,0,162,0,0,0,362,0,0,0,0],[0,0,0,0,0,440,440,442,161,0,162,0,0,0,362,0,0,0,0],[0,0,0,0,0,488,488,442,161,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,489,488,488,442,161,0,0,0,0,0,0,0,0,0,0],[0,0,0,490,491,492,493,494,161,0,162,0,0,0,362,0,0,0,0],[0,0,0,495,0,496,497,0,161,0,162,0,0,498,0,0,0,0,0],[0,0,0,0,116,445,445,8,161,0,162,0,0,0,120,0,0,16,0],[0,0,0,0,225,44,44,8,161,0,0,0,0,0,225,0,0,0,0],[0,0,0,0,370,447,447,22,23,0,24,0,0,0,374,0,0,27,0],[0,0,0,0,450,80,80,22,23,0,0,0,0,0,450,0,0,0,0],[0,0,0,499,500,501,502,22,23,0,24,0,0,503,504,0,0,27,0],[0,448,0,505,0,177,177,22,23,0,24,0,0,0,78,0,448,0,0],[0,448,0,0,0,175,506,0,23,0,24,0,0,0,78,0,448,0,0],[0,0,0,507,500,508,509,22,23,0,24,0,0,510,504,0,0,27,0],[0,0,0,0,0,0,0,295,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,292,0,0],[0,0,0,0,0,0,511,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,388,456,456,32,33,0,34,0,0,0,392,0,0,37,0],[0,0,0,0,459,101,101,32,33,0,0,0,0,0,459,0,0,0,0],[0,0,0,512,513,514,515,32,33,0,34,0,0,516,517,0,0,37,0],[0,457,0,518,0,203,203,32,33,0,34,0,0,0,99,0,457,0,0],[0,457,0,0,0,201,519,0,33,0,34,0,0,0,99,0,457,0,0],[0,0,0,520,513,521,522,32,33,0,34,0,0,523,517,0,0,37,0],[0,0,0,0,0,0,0,315,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,312,0,0],[0,0,0,0,0,0,524,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,525,465,526,526,8,9,0,10,0,0,0,469,0,0,16,0],[0,527,0,0,0,40,528,0,9,0,10,0,0,0,42,0,527,0,0],[0,0,0,0,529,44,44,8,9,0,0,0,0,468,529,0,0,0,0],[0,0,0,464,465,466,526,8,9,0,10,0,0,468,469,0,0,16,0],[0,0,0,464,465,526,526,8,9,0,10,0,0,0,469,0,0,16,0],[0,530,64,0,0,40,528,0,9,0,10,0,0,0,42,0,530,0,0],[0,407,0,0,0,121,121,0,9,0,10,0,0,0,42,0,407,0,0],[0,407,0,470,0,121,121,0,9,0,10,0,0,0,42,0,407,0,0],[0,0,0,525,465,526,526,8,9,0,10,0,0,0,469,0,0,16,0],[0,0,0,0,529,44,44,8,9,0,0,0,0,475,529,0,0,0,0],[0,0,0,472,465,473,526,8,9,0,10,0,0,475,469,0,0,16,0],[0,0,0,472,465,526,526,8,9,0,10,0,0,0,469,0,0,16,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,40,0,0],[0,0,0,0,415,478,478,57,58,0,59,0,0,0,419,0,0,62,0],[0,0,0,0,481,141,141,57,58,0,0,0,0,0,481,0,0,0,0],[0,0,0,531,532,533,534,57,58,0,59,0,0,535,536,0,0,62,0],[0,479,0,537,0,248,248,57,58,0,59,0,0,0,139,0,479,0,0],[0,479,0,0,0,246,538,0,58,0,59,0,0,0,139,0,479,0,0],[0,0,0,539,532,540,541,57,58,0,59,0,0,542,536,0,0,62,0],[0,0,0,0,0,0,0,353,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,350,0,0],[0,0,0,0,0,0,543,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,361,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,358,0,0],[0,0,0,0,0,544,544,442,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,545,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,491,492,493,494,161,0,162,0,0,0,362,0,0,0,0],[0,0,0,0,0,492,492,494,161,0,162,0,0,0,362,0,0,0,0],[0,0,0,0,0,546,546,494,161,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,547,546,546,494,161,0,0,0,0,0,0,0,0,0,0],[0,0,0,548,549,368,550,0,161,0,162,0,0,0,362,0,0,0,0],[0,0,0,274,0,368,368,0,161,0,162,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,161,0,0,0,0,498,0,0,0,0,0],[0,0,0,495,0,496,368,0,161,0,162,0,0,498,0,0,0,0,0],[0,0,0,495,0,368,368,0,161,0,162,0,0,0,0,0,0,0,0],[0,0,0,551,500,552,552,22,23,0,24,0,0,0,504,0,0,27,0],[0,553,0,0,0,76,554,0,23,0,24,0,0,0,78,0,553,0,0],[0,0,0,0,555,80,80,22,23,0,0,0,0,503,555,0,0,0,0],[0,0,0,499,500,501,552,22,23,0,24,0,0,503,504,0,0,27,0],[0,0,0,499,500,552,552,22,23,0,24,0,0,0,504,0,0,27,0],[0,556,90,0,0,76,554,0,23,0,24,0,0,0,78,0,556,0,0],[0,448,0,0,0,175,175,0,23,0,24,0,0,0,78,0,448,0,0],[0,448,0,505,0,175,175,0,23,0,24,0,0,0,78,0,448,0,0],[0,0,0,551,500,552,552,22,23,0,24,0,0,0,504,0,0,27,0],[0,0,0,0,555,80,80,22,23,0,0,0,0,510,555,0,0,0,0],[0,0,0,507,500,508,552,22,23,0,24,0,0,510,504,0,0,27,0],[0,0,0,507,500,552,552,22,23,0,24,0,0,0,504,0,0,27,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,76,0,0],[0,0,0,557,513,558,558,32,33,0,34,0,0,0,517,0,0,37,0],[0,559,0,0,0,97,560,0,33,0,34,0,0,0,99,0,559,0,0],[0,0,0,0,561,101,101,32,33,0,0,0,0,516,561,0,0,0,0],[0,0,0,512,513,514,558,32,33,0,34,0,0,516,517,0,0,37,0],[0,0,0,512,513,558,558,32,33,0,34,0,0,0,517,0,0,37,0],[0,562,111,0,0,97,560,0,33,0,34,0,0,0,99,0,562,0,0],[0,457,0,0,0,201,201,0,33,0,34,0,0,0,99,0,457,0,0],[0,457,0,518,0,201,201,0,33,0,34,0,0,0,99,0,457,0,0],[0,0,0,557,513,558,558,32,33,0,34,0,0,0,517,0,0,37,0],[0,0,0,0,561,101,101,32,33,0,0,0,0,523,561,0,0,0,0],[0,0,0,520,513,521,558,32,33,0,34,0,0,523,517,0,0,37,0],[0,0,0,520,513,558,558,32,33,0,34,0,0,0,517,0,0,37,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,97,0,0],[0,0,0,0,465,526,526,8,9,0,10,0,0,0,469,0,0,16,0],[0,0,0,0,529,44,44,8,9,0,0,0,0,0,529,0,0,0,0],[0,0,0,563,66,564,565,8,9,0,10,0,0,566,68,0,0,16,0],[0,527,0,567,0,123,123,8,9,0,10,0,0,0,42,0,527,0,0],[0,527,0,0,0,121,568,0,9,0,10,0,0,0,42,0,527,0,0],[0,0,0,569,66,570,571,8,9,0,10,0,0,572,68,0,0,16,0],[0,0,0,573,532,574,574,57,58,0,59,0,0,0,536,0,0,62,0],[0,575,0,0,0,137,576,0,58,0,59,0,0,0,139,0,575,0,0],[0,0,0,0,577,141,141,57,58,0,0,0,0,535,577,0,0,0,0],[0,0,0,531,532,533,574,57,58,0,59,0,0,535,536,0,0,62,0],[0,0,0,531,532,574,574,57,58,0,59,0,0,0,536,0,0,62,0],[0,578,151,0,0,137,576,0,58,0,59,0,0,0,139,0,578,0,0],[0,479,0,0,0,246,246,0,58,0,59,0,0,0,139,0,479,0,0],[0,479,0,537,0,246,246,0,58,0,59,0,0,0,139,0,479,0,0],[0,0,0,573,532,574,574,57,58,0,59,0,0,0,536,0,0,62,0],[0,0,0,0,577,141,141,57,58,0,0,0,0,542,577,0,0,0,0],[0,0,0,539,532,540,574,57,58,0,59,0,0,542,536,0,0,62,0],[0,0,0,539,532,574,574,57,58,0,59,0,0,0,536,0,0,62,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,137,0,0],[0,0,0,0,0,0,0,442,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,439,0,0],[0,0,0,0,0,579,579,494,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,580,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,549,368,550,0,161,0,162,0,0,0,362,0,0,0,0],[0,0,0,0,0,368,368,0,161,0,162,0,0,0,362,0,0,0,0],[0,0,0,0,581,0,0,0,161,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,500,552,552,22,23,0,24,0,0,0,504,0,0,27,0],[0,0,0,0,555,80,80,22,23,0,0,0,0,0,555,0,0,0,0],[0,0,0,582,91,583,584,22,23,0,24,0,0,585,93,0,0,27,0],[0,553,0,586,0,177,177,22,23,0,24,0,0,0,78,0,553,0,0],[0,553,0,0,0,175,587,0,23,0,24,0,0,0,78,0,553,0,0],[0,0,0,588,91,589,590,22,23,0,24,0,0,591,93,0,0,27,0],[0,0,0,0,513,558,558,32,33,0,34,0,0,0,517,0,0,37,0],[0,0,0,0,561,101,101,32,33,0,0,0,0,0,561,0,0,0,0],[0,0,0,592,112,593,594,32,33,0,34,0,0,595,114,0,0,37,0],[0,559,0,596,0,203,203,32,33,0,34,0,0,0,99,0,559,0,0],[0,559,0,0,0,201,597,0,33,0,34,0,0,0,99,0,559,0,0],[0,0,0,598,112,599,600,32,33,0,34,0,0,601,114,0,0,37,0],[0,0,0,602,66,67,67,8,9,0,10,0,0,0,68,0,0,16,0],[0,0,0,0,165,44,44,8,9,0,0,0,0,566,165,0,0,0,0],[0,0,0,563,66,564,67,8,9,0,10,0,0,566,68,0,0,16,0],[0,0,0,563,66,67,67,8,9,0,10,0,0,0,68,0,0,16,0],[0,527,0,0,0,121,121,0,9,0,10,0,0,0,42,0,527,0,0],[0,527,0,567,0,121,121,0,9,0,10,0,0,0,42,0,527,0,0],[0,0,0,602,66,67,67,8,9,0,10,0,0,0,68,0,0,16,0],[0,0,0,0,165,44,44,8,9,0,0,0,0,572,165,0,0,0,0],[0,0,0,569,66,570,67,8,9,0,10,0,0,572,68,0,0,16,0],[0,0,0,569,66,67,67,8,9,0,10,0,0,0,68,0,0,16,0],[0,0,0,0,532,574,574,57,58,0,59,0,0,0,536,0,0,62,0],[0,0,0,0,577,141,141,57,58,0,0,0,0,0,577,0,0,0,0],[0,0,0,603,152,604,605,57,58,0,59,0,0,606,154,0,0,62,0],[0,575,0,607,0,248,248,57,58,0,59,0,0,0,139,0,575,0,0],[0,575,0,0,0,246,608,0,58,0,59,0,0,0,139,0,575,0,0],[0,0,0,609,152,610,611,57,58,0,59,0,0,612,154,0,0,62,0],[0,0,0,0,0,0,0,494,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,491,0,0],[0,0,0,0,0,0,613,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,614,91,92,92,22,23,0,24,0,0,0,93,0,0,27,0],[0,0,0,0,194,80,80,22,23,0,0,0,0,585,194,0,0,0,0],[0,0,0,582,91,583,92,22,23,0,24,0,0,585,93,0,0,27,0],[0,0,0,582,91,92,92,22,23,0,24,0,0,0,93,0,0,27,0],[0,553,0,0,0,175,175,0,23,0,24,0,0,0,78,0,553,0,0],[0,553,0,586,0,175,175,0,23,0,24,0,0,0,78,0,553,0,0],[0,0,0,614,91,92,92,22,23,0,24,0,0,0,93,0,0,27,0],[0,0,0,0,194,80,80,22,23,0,0,0,0,591,194,0,0,0,0],[0,0,0,588,91,589,92,22,23,0,24,0,0,591,93,0,0,27,0],[0,0,0,588,91,92,92,22,23,0,24,0,0,0,93,0,0,27,0],[0,0,0,615,112,113,113,32,33,0,34,0,0,0,114,0,0,37,0],[0,0,0,0,220,101,101,32,33,0,0,0,0,595,220,0,0,0,0],[0,0,0,592,112,593,113,32,33,0,34,0,0,595,114,0,0,37,0],[0,0,0,592,112,113,113,32,33,0,34,0,0,0,114,0,0,37,0],[0,559,0,0,0,201,201,0,33,0,34,0,0,0,99,0,559,0,0],[0,559,0,596,0,201,201,0,33,0,34,0,0,0,99,0,559,0,0],[0,0,0,615,112,113,113,32,33,0,34,0,0,0,114,0,0,37,0],[0,0,0,0,220,101,101,32,33,0,0,0,0,601,220,0,0,0,0],[0,0,0,598,112,599,113,32,33,0,34,0,0,601,114,0,0,37,0],[0,0,0,598,112,113,113,32,33,0,34,0,0,0,114,0,0,37,0],[0,0,0,0,66,67,67,8,9,0,10,0,0,0,68,0,0,16,0],[0,0,0,616,152,153,153,57,58,0,59,0,0,0,154,0,0,62,0],[0,0,0,0,265,141,141,57,58,0,0,0,0,606,265,0,0,0,0],[0,0,0,603,152,604,153,57,58,0,59,0,0,606,154,0,0,62,0],[0,0,0,603,152,153,153,57,58,0,59,0,0,0,154,0,0,62,0],[0,575,0,0,0,246,246,0,58,0,59,0,0,0,139,0,575,0,0],[0,575,0,607,0,246,246,0,58,0,59,0,0,0,139,0,575,0,0],[0,0,0,616,152,153,153,57,58,0,59,0,0,0,154,0,0,62,0],[0,0,0,0,265,141,141,57,58,0,0,0,0,612,265,0,0,0,0],[0,0,0,609,152,610,153,57,58,0,59,0,0,612,154,0,0,62,0],[0,0,0,609,152,153,153,57,58,0,59,0,0,0,154,0,0,62,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,549,0,0],[0,0,0,0,91,92,92,22,23,0,24,0,0,0,93,0,0,27,0],[0,0,0,0,112,113,113,32,33,0,34,0,0,0,114,0,0,37,0],[0,0,0,0,152,153,153,57,58,0,59,0,0,0,154,0,0,62,0]],\\\"accepting\\\":[false,true,true,true,true,true,false,false,true,true,true,true,true,true,true,true,true,true,true,true,false,true,true,true,true,true,true,true,true,true,false,true,true,true,true,true,true,true,true,true,true,true,false,true,false,true,true,false,false,true,true,true,true,true,true,false,false,true,true,true,true,true,true,true,true,true,true,false,true,true,false,true,true,true,false,true,true,true,false,true,false,true,true,false,false,true,true,true,true,true,true,true,false,true,true,false,true,true,true,false,true,false,true,true,false,false,true,true,true,true,true,true,true,false,true,true,true,false,true,true,true,false,true,false,true,true,false,false,false,true,true,false,false,true,true,true,true,true,true,false,true,false,true,true,false,false,true,true,true,true,true,true,true,false,true,true,false,true,true,true,true,true,true,true,true,true,true,true,true,true,true,false,true,true,true,false,true,false,true,true,false,false,false,true,true,false,false,true,true,true,false,true,true,true,true,true,true,false,true,true,true,false,true,false,true,true,false,false,false,true,true,false,false,true,true,true,false,true,true,true,true,true,false,true,true,true,true,true,false,true,true,false,false,false,false,true,true,false,false,true,true,true,false,true,true,true,false,true,false,true,true,false,false,false,true,true,false,false,true,true,true,false,true,true,true,true,false,true,false,true,true,true,true,true,true,true,true,true,false,true,true,true,true,true,false,true,true,false,false,false,false,true,true,false,false,true,true,true,false,true,true,true,true,true,false,true,true,false,false,false,false,true,true,false,false,true,true,true,true,false,true,true,true,true,true,true,false,true,true,false,false,false,false,true,false,true,false,true,true,true,true,true,false,true,true,false,false,false,false,true,true,false,false,true,true,true,false,true,true,false,false,true,false,true,true,false,true,true,false,true,true,false,true,true,true,true,true,true,false,true,true,false,false,false,false,true,false,true,true,false,true,true,true,true,true,true,false,true,true,false,false,false,false,true,false,true,false,true,true,true,true,false,false,false,true,true,false,true,true,true,true,true,true,false,true,true,false,false,false,false,true,false,true,false,true,true,false,false,true,true,false,false,true,true,true,false,true,false,true,true,true,true,false,false,false,true,false,true,true,true,true,false,false,false,true,true,false,true,true,true,true,true,true,false,true,true,false,true,false,true,true,true,true,false,false,false,false,false,false,false,true,true,false,false,true,true,false,true,true,true,true,false,true,true,true,true,true,true,false,true,true,false,true,true,false,true,true,true,true,true,true,false,true,true,false,true,false,true,true,true,true,true,true,false,true,true,true,true,true,true,false,true,true,false,false,false,false,false,true,true,false,true,false,true,true,true,true,true,false,true,true,true,true,true,false,true,true,true,true,true,false,true,true,true,false,true,true,true,true,false,false,false,true,false,true,true,true,true,true,false,true,true,true,false,true,true,true,true,true,false,true,true,true,true,false,true,true,true,true,true,false,true,true,false,true,true,true],\\\"tags\\\":[[],[\\\"broken_cluster\\\"],[\\\"consonant_syllable\\\"],[\\\"vowel_syllable\\\"],[\\\"broken_cluster\\\"],[\\\"broken_cluster\\\"],[],[],[\\\"broken_cluster\\\"],[\\\"broken_cluster\\\"],[\\\"broken_cluster\\\"],[\\\"standalone_cluster\\\"],[\\\"broken_cluster\\\"],[\\\"broken_cluster\\\"],[\\\"broken_cluster\\\"],[\\\"consonant_syllable\\\"],[\\\"broken_cluster\\\"],[\\\"symbol_cluster\\\"],[\\\"consonant_syllable\\\"],[\\\"consonant_syllable\\\"],[],[\\\"consonant_syllable\\\"],[\\\"consonant_syllable\\\"],[\\\"consonant_syllable\\\"],[\\\"consonant_syllable\\\"],[\\\"consonant_syllable\\\"],[\\\"consonant_syllable\\\"],[\\\"consonant_syllable\\\"],[\\\"vowel_syllable\\\"],[\\\"vowel_syllable\\\"],[],[\\\"vowel_syllable\\\"],[\\\"vowel_syllable\\\"],[\\\"vowel_syllable\\\"],[\\\"vowel_syllable\\\"],[\\\"vowel_syllable\\\"],[\\\"vowel_syllable\\\"],[\\\"vowel_syllable\\\"],[\\\"broken_cluster\\\"],[\\\"broken_cluster\\\"],[\\\"broken_cluster\\\"],[\\\"broken_cluster\\\"],[],[\\\"broken_cluster\\\"],[],[\\\"broken_cluster\\\"],[\\\"broken_cluster\\\"],[],[],[\\\"broken_cluster\\\"],[\\\"broken_cluster\\\"],[\\\"broken_cluster\\\"],[\\\"broken_cluster\\\"],[\\\"standalone_cluster\\\"],[\\\"standalone_cluster\\\"],[],[],[\\\"standalone_cluster\\\"],[\\\"standalone_cluster\\\"],[\\\"standalone_cluster\\\"],[\\\"standalone_cluster\\\"],[\\\"standalone_cluster\\\"],[\\\"standalone_cluster\\\"],[\\\"broken_cluster\\\"],[\\\"broken_cluster\\\"],[\\\"consonant_syllable\\\",\\\"broken_cluster\\\"],[\\\"broken_cluster\\\"],[],[\\\"broken_cluster\\\"],[\\\"symbol_cluster\\\"],[],[\\\"symbol_cluster\\\"],[\\\"symbol_cluster\\\"],[\\\"consonant_syllable\\\"],[],[\\\"consonant_syllable\\\"],[\\\"consonant_syllable\\\"],[\\\"consonant_syllable\\\"],[],[\\\"consonant_syllable\\\"],[],[\\\"consonant_syllable\\\"],[\\\"consonant_syllable\\\"],[],[],[\\\"consonant_syllable\\\"],[\\\"consonant_syllable\\\"],[\\\"consonant_syllable\\\"],[\\\"consonant_syllable\\\"],[\\\"consonant_syllable\\\"],[\\\"consonant_syllable\\\"],[\\\"consonant_syllable\\\"],[],[\\\"consonant_syllable\\\"],[\\\"vowel_syllable\\\"],[],[\\\"vowel_syllable\\\"],[\\\"vowel_syllable\\\"],[\\\"vowel_syllable\\\"],[],[\\\"vowel_syllable\\\"],[],[\\\"vowel_syllable\\\"],[\\\"vowel_syllable\\\"],[],[],[\\\"vowel_syllable\\\"],[\\\"vowel_syllable\\\"],[\\\"vowel_syllable\\\"],[\\\"vowel_syllable\\\"],[\\\"vowel_syllable\\\"],[\\\"vowel_syllable\\\"],[\\\"vowel_syllable\\\"],[],[\\\"vowel_syllable\\\"],[\\\"broken_cluster\\\"],[\\\"broken_cluster\\\"],[],[\\\"broken_cluster\\\"],[\\\"broken_cluster\\\"],[\\\"broken_cluster\\\"],[],[\\\"broken_cluster\\\"],[],[\\\"broken_cluster\\\"],[\\\"broken_cluster\\\"],[],[],[],[\\\"broken_cluster\\\"],[\\\"broken_cluster\\\"],[],[],[\\\"broken_cluster\\\"],[\\\"broken_cluster\\\"],[\\\"standalone_cluster\\\"],[\\\"standalone_cluster\\\"],[\\\"standalone_cluster\\\"],[\\\"standalone_cluster\\\"],[],[\\\"standalone_cluster\\\"],[],[\\\"standalone_cluster\\\"],[\\\"standalone_cluster\\\"],[],[],[\\\"standalone_cluster\\\"],[\\\"standalone_cluster\\\"],[\\\"standalone_cluster\\\"],[\\\"standalone_cluster\\\"],[\\\"standalone_cluster\\\"],[\\\"standalone_cluster\\\"],[\\\"standalone_cluster\\\"],[],[\\\"standalone_cluster\\\"],[\\\"broken_cluster\\\"],[],[\\\"broken_cluster\\\"],[\\\"broken_cluster\\\"],[\\\"consonant_syllable\\\"],[\\\"consonant_syllable\\\"],[\\\"consonant_syllable\\\",\\\"broken_cluster\\\"],[\\\"consonant_syllable\\\",\\\"broken_cluster\\\"],[\\\"broken_cluster\\\"],[\\\"broken_cluster\\\"],[\\\"broken_cluster\\\"],[\\\"symbol_cluster\\\"],[\\\"symbol_cluster\\\"],[\\\"symbol_cluster\\\"],[\\\"consonant_syllable\\\"],[\\\"consonant_syllable\\\"],[],[\\\"consonant_syllable\\\"],[\\\"consonant_syllable\\\"],[\\\"consonant_syllable\\\"],[],[\\\"consonant_syllable\\\"],[],[\\\"consonant_syllable\\\"],[\\\"consonant_syllable\\\"],[],[],[],[\\\"consonant_syllable\\\"],[\\\"consonant_syllable\\\"],[],[],[\\\"consonant_syllable\\\"],[\\\"consonant_syllable\\\"],[\\\"consonant_syllable\\\"],[],[\\\"consonant_syllable\\\"],[\\\"consonant_syllable\\\"],[\\\"consonant_syllable\\\"],[\\\"consonant_syllable\\\"],[\\\"vowel_syllable\\\"],[\\\"vowel_syllable\\\"],[],[\\\"vowel_syllable\\\"],[\\\"vowel_syllable\\\"],[\\\"vowel_syllable\\\"],[],[\\\"vowel_syllable\\\"],[],[\\\"vowel_syllable\\\"],[\\\"vowel_syllable\\\"],[],[],[],[\\\"vowel_syllable\\\"],[\\\"vowel_syllable\\\"],[],[],[\\\"vowel_syllable\\\"],[\\\"vowel_syllable\\\"],[\\\"vowel_syllable\\\"],[],[\\\"vowel_syllable\\\"],[\\\"vowel_syllable\\\"],[\\\"vowel_syllable\\\"],[\\\"vowel_syllable\\\"],[\\\"broken_cluster\\\"],[],[\\\"broken_cluster\\\"],[\\\"broken_cluster\\\"],[\\\"broken_cluster\\\"],[\\\"broken_cluster\\\"],[\\\"broken_cluster\\\"],[],[\\\"broken_cluster\\\"],[\\\"broken_cluster\\\"],[],[],[],[],[\\\"broken_cluster\\\"],[\\\"broken_cluster\\\"],[],[],[\\\"broken_cluster\\\"],[\\\"standalone_cluster\\\"],[\\\"standalone_cluster\\\"],[],[\\\"standalone_cluster\\\"],[\\\"standalone_cluster\\\"],[\\\"standalone_cluster\\\"],[],[\\\"standalone_cluster\\\"],[],[\\\"standalone_cluster\\\"],[\\\"standalone_cluster\\\"],[],[],[],[\\\"standalone_cluster\\\"],[\\\"standalone_cluster\\\"],[],[],[\\\"standalone_cluster\\\"],[\\\"standalone_cluster\\\"],[\\\"standalone_cluster\\\"],[],[\\\"standalone_cluster\\\"],[\\\"standalone_cluster\\\"],[\\\"standalone_cluster\\\"],[\\\"standalone_cluster\\\"],[],[\\\"broken_cluster\\\"],[],[\\\"consonant_syllable\\\",\\\"broken_cluster\\\"],[\\\"consonant_syllable\\\",\\\"broken_cluster\\\"],[\\\"consonant_syllable\\\",\\\"broken_cluster\\\"],[\\\"consonant_syllable\\\",\\\"broken_cluster\\\"],[\\\"consonant_syllable\\\",\\\"broken_cluster\\\"],[\\\"consonant_syllable\\\",\\\"broken_cluster\\\"],[\\\"broken_cluster\\\"],[\\\"symbol_cluster\\\"],[\\\"consonant_syllable\\\"],[],[\\\"consonant_syllable\\\"],[\\\"consonant_syllable\\\"],[\\\"consonant_syllable\\\"],[\\\"consonant_syllable\\\"],[\\\"consonant_syllable\\\"],[],[\\\"consonant_syllable\\\"],[\\\"consonant_syllable\\\"],[],[],[],[],[\\\"consonant_syllable\\\"],[\\\"consonant_syllable\\\"],[],[],[\\\"consonant_syllable\\\"],[\\\"consonant_syllable\\\"],[\\\"vowel_syllable\\\"],[],[\\\"vowel_syllable\\\"],[\\\"vowel_syllable\\\"],[\\\"vowel_syllable\\\"],[\\\"vowel_syllable\\\"],[\\\"vowel_syllable\\\"],[],[\\\"vowel_syllable\\\"],[\\\"vowel_syllable\\\"],[],[],[],[],[\\\"vowel_syllable\\\"],[\\\"vowel_syllable\\\"],[],[],[\\\"vowel_syllable\\\"],[\\\"vowel_syllable\\\"],[\\\"broken_cluster\\\"],[\\\"broken_cluster\\\"],[],[\\\"broken_cluster\\\"],[\\\"broken_cluster\\\"],[\\\"broken_cluster\\\"],[\\\"broken_cluster\\\"],[\\\"broken_cluster\\\"],[\\\"broken_cluster\\\"],[],[\\\"broken_cluster\\\"],[\\\"broken_cluster\\\"],[],[],[],[],[\\\"broken_cluster\\\"],[],[\\\"standalone_cluster\\\"],[],[\\\"standalone_cluster\\\"],[\\\"standalone_cluster\\\"],[\\\"standalone_cluster\\\"],[\\\"standalone_cluster\\\"],[\\\"standalone_cluster\\\"],[],[\\\"standalone_cluster\\\"],[\\\"standalone_cluster\\\"],[],[],[],[],[\\\"standalone_cluster\\\"],[\\\"standalone_cluster\\\"],[],[],[\\\"standalone_cluster\\\"],[\\\"standalone_cluster\\\"],[\\\"consonant_syllable\\\",\\\"broken_cluster\\\"],[],[\\\"consonant_syllable\\\",\\\"broken_cluster\\\"],[\\\"consonant_syllable\\\",\\\"broken_cluster\\\"],[],[],[\\\"consonant_syllable\\\",\\\"broken_cluster\\\"],[],[\\\"consonant_syllable\\\",\\\"broken_cluster\\\"],[\\\"consonant_syllable\\\",\\\"broken_cluster\\\"],[],[\\\"consonant_syllable\\\",\\\"broken_cluster\\\"],[\\\"consonant_syllable\\\",\\\"broken_cluster\\\"],[],[\\\"consonant_syllable\\\"],[\\\"consonant_syllable\\\"],[],[\\\"consonant_syllable\\\"],[\\\"consonant_syllable\\\"],[\\\"consonant_syllable\\\"],[\\\"consonant_syllable\\\"],[\\\"consonant_syllable\\\"],[\\\"consonant_syllable\\\"],[],[\\\"consonant_syllable\\\"],[\\\"consonant_syllable\\\"],[],[],[],[],[\\\"consonant_syllable\\\"],[],[\\\"vowel_syllable\\\"],[\\\"vowel_syllable\\\"],[],[\\\"vowel_syllable\\\"],[\\\"vowel_syllable\\\"],[\\\"vowel_syllable\\\"],[\\\"vowel_syllable\\\"],[\\\"vowel_syllable\\\"],[\\\"vowel_syllable\\\"],[],[\\\"vowel_syllable\\\"],[\\\"vowel_syllable\\\"],[],[],[],[],[\\\"vowel_syllable\\\"],[],[\\\"broken_cluster\\\"],[],[\\\"broken_cluster\\\"],[\\\"broken_cluster\\\"],[\\\"broken_cluster\\\"],[\\\"broken_cluster\\\"],[],[],[],[\\\"standalone_cluster\\\"],[\\\"standalone_cluster\\\"],[],[\\\"standalone_cluster\\\"],[\\\"standalone_cluster\\\"],[\\\"standalone_cluster\\\"],[\\\"standalone_cluster\\\"],[\\\"standalone_cluster\\\"],[\\\"standalone_cluster\\\"],[],[\\\"standalone_cluster\\\"],[\\\"standalone_cluster\\\"],[],[],[],[],[\\\"standalone_cluster\\\"],[],[\\\"consonant_syllable\\\",\\\"broken_cluster\\\"],[],[\\\"consonant_syllable\\\",\\\"broken_cluster\\\"],[\\\"consonant_syllable\\\",\\\"broken_cluster\\\"],[],[],[\\\"consonant_syllable\\\",\\\"broken_cluster\\\"],[\\\"consonant_syllable\\\",\\\"broken_cluster\\\"],[],[],[\\\"consonant_syllable\\\",\\\"broken_cluster\\\"],[\\\"consonant_syllable\\\",\\\"broken_cluster\\\"],[\\\"consonant_syllable\\\",\\\"broken_cluster\\\"],[],[\\\"consonant_syllable\\\"],[],[\\\"consonant_syllable\\\"],[\\\"consonant_syllable\\\"],[\\\"consonant_syllable\\\"],[\\\"consonant_syllable\\\"],[],[],[],[\\\"vowel_syllable\\\"],[],[\\\"vowel_syllable\\\"],[\\\"vowel_syllable\\\"],[\\\"vowel_syllable\\\"],[\\\"vowel_syllable\\\"],[],[],[],[\\\"broken_cluster\\\"],[\\\"broken_cluster\\\"],[],[\\\"broken_cluster\\\"],[\\\"broken_cluster\\\"],[\\\"broken_cluster\\\"],[\\\"broken_cluster\\\"],[\\\"broken_cluster\\\"],[\\\"broken_cluster\\\"],[],[\\\"broken_cluster\\\"],[\\\"broken_cluster\\\"],[],[\\\"standalone_cluster\\\"],[],[\\\"standalone_cluster\\\"],[\\\"standalone_cluster\\\"],[\\\"standalone_cluster\\\"],[\\\"standalone_cluster\\\"],[],[],[],[],[],[],[],[\\\"consonant_syllable\\\",\\\"broken_cluster\\\"],[\\\"consonant_syllable\\\",\\\"broken_cluster\\\"],[],[],[\\\"consonant_syllable\\\",\\\"broken_cluster\\\"],[\\\"consonant_syllable\\\",\\\"broken_cluster\\\"],[],[\\\"consonant_syllable\\\",\\\"broken_cluster\\\"],[\\\"consonant_syllable\\\",\\\"broken_cluster\\\"],[\\\"consonant_syllable\\\"],[\\\"consonant_syllable\\\"],[],[\\\"consonant_syllable\\\"],[\\\"consonant_syllable\\\"],[\\\"consonant_syllable\\\"],[\\\"consonant_syllable\\\"],[\\\"consonant_syllable\\\"],[\\\"consonant_syllable\\\"],[],[\\\"consonant_syllable\\\"],[\\\"consonant_syllable\\\"],[],[\\\"vowel_syllable\\\"],[\\\"vowel_syllable\\\"],[],[\\\"vowel_syllable\\\"],[\\\"vowel_syllable\\\"],[\\\"vowel_syllable\\\"],[\\\"vowel_syllable\\\"],[\\\"vowel_syllable\\\"],[\\\"vowel_syllable\\\"],[],[\\\"vowel_syllable\\\"],[\\\"vowel_syllable\\\"],[],[\\\"broken_cluster\\\"],[],[\\\"broken_cluster\\\"],[\\\"broken_cluster\\\"],[\\\"broken_cluster\\\"],[\\\"broken_cluster\\\"],[\\\"standalone_cluster\\\"],[\\\"standalone_cluster\\\"],[],[\\\"standalone_cluster\\\"],[\\\"standalone_cluster\\\"],[\\\"standalone_cluster\\\"],[\\\"standalone_cluster\\\"],[\\\"standalone_cluster\\\"],[\\\"standalone_cluster\\\"],[],[\\\"standalone_cluster\\\"],[\\\"standalone_cluster\\\"],[],[],[],[],[],[\\\"consonant_syllable\\\",\\\"broken_cluster\\\"],[\\\"consonant_syllable\\\",\\\"broken_cluster\\\"],[],[\\\"consonant_syllable\\\"],[],[\\\"consonant_syllable\\\"],[\\\"consonant_syllable\\\"],[\\\"consonant_syllable\\\"],[\\\"consonant_syllable\\\"],[\\\"vowel_syllable\\\"],[],[\\\"vowel_syllable\\\"],[\\\"vowel_syllable\\\"],[\\\"vowel_syllable\\\"],[\\\"vowel_syllable\\\"],[\\\"broken_cluster\\\"],[],[\\\"broken_cluster\\\"],[\\\"broken_cluster\\\"],[\\\"broken_cluster\\\"],[\\\"broken_cluster\\\"],[\\\"broken_cluster\\\"],[],[\\\"broken_cluster\\\"],[\\\"broken_cluster\\\"],[\\\"standalone_cluster\\\"],[],[\\\"standalone_cluster\\\"],[\\\"standalone_cluster\\\"],[\\\"standalone_cluster\\\"],[\\\"standalone_cluster\\\"],[],[],[],[\\\"consonant_syllable\\\"],[],[\\\"consonant_syllable\\\"],[\\\"consonant_syllable\\\"],[\\\"consonant_syllable\\\"],[\\\"consonant_syllable\\\"],[\\\"consonant_syllable\\\"],[],[\\\"consonant_syllable\\\"],[\\\"consonant_syllable\\\"],[\\\"vowel_syllable\\\"],[],[\\\"vowel_syllable\\\"],[\\\"vowel_syllable\\\"],[\\\"vowel_syllable\\\"],[\\\"vowel_syllable\\\"],[\\\"vowel_syllable\\\"],[],[\\\"vowel_syllable\\\"],[\\\"vowel_syllable\\\"],[\\\"broken_cluster\\\"],[\\\"standalone_cluster\\\"],[],[\\\"standalone_cluster\\\"],[\\\"standalone_cluster\\\"],[\\\"standalone_cluster\\\"],[\\\"standalone_cluster\\\"],[\\\"standalone_cluster\\\"],[],[\\\"standalone_cluster\\\"],[\\\"standalone_cluster\\\"],[],[\\\"consonant_syllable\\\"],[\\\"vowel_syllable\\\"],[\\\"standalone_cluster\\\"]]}\");\nvar $aa333a9607471296$exports = {};\n$aa333a9607471296$exports = JSON.parse(\"{\\\"categories\\\":[\\\"O\\\",\\\"IND\\\",\\\"S\\\",\\\"GB\\\",\\\"B\\\",\\\"FM\\\",\\\"CGJ\\\",\\\"VMAbv\\\",\\\"VMPst\\\",\\\"VAbv\\\",\\\"VPst\\\",\\\"CMBlw\\\",\\\"VPre\\\",\\\"VBlw\\\",\\\"H\\\",\\\"VMBlw\\\",\\\"CMAbv\\\",\\\"MBlw\\\",\\\"CS\\\",\\\"R\\\",\\\"SUB\\\",\\\"MPst\\\",\\\"MPre\\\",\\\"FAbv\\\",\\\"FPst\\\",\\\"FBlw\\\",\\\"null\\\",\\\"SMAbv\\\",\\\"SMBlw\\\",\\\"VMPre\\\",\\\"ZWNJ\\\",\\\"ZWJ\\\",\\\"WJ\\\",\\\"M\\\",\\\"VS\\\",\\\"N\\\",\\\"HN\\\",\\\"MAbv\\\"],\\\"decompositions\\\":{\\\"2507\\\":[2503,2494],\\\"2508\\\":[2503,2519],\\\"2888\\\":[2887,2902],\\\"2891\\\":[2887,2878],\\\"2892\\\":[2887,2903],\\\"3018\\\":[3014,3006],\\\"3019\\\":[3015,3006],\\\"3020\\\":[3014,3031],\\\"3144\\\":[3142,3158],\\\"3264\\\":[3263,3285],\\\"3271\\\":[3270,3285],\\\"3272\\\":[3270,3286],\\\"3274\\\":[3270,3266],\\\"3275\\\":[3270,3266,3285],\\\"3402\\\":[3398,3390],\\\"3403\\\":[3399,3390],\\\"3404\\\":[3398,3415],\\\"3546\\\":[3545,3530],\\\"3548\\\":[3545,3535],\\\"3549\\\":[3545,3535,3530],\\\"3550\\\":[3545,3551],\\\"3635\\\":[3661,3634],\\\"3763\\\":[3789,3762],\\\"3955\\\":[3953,3954],\\\"3957\\\":[3953,3956],\\\"3958\\\":[4018,3968],\\\"3959\\\":[4018,3953,3968],\\\"3960\\\":[4019,3968],\\\"3961\\\":[4019,3953,3968],\\\"3969\\\":[3953,3968],\\\"6971\\\":[6970,6965],\\\"6973\\\":[6972,6965],\\\"6976\\\":[6974,6965],\\\"6977\\\":[6975,6965],\\\"6979\\\":[6978,6965],\\\"69934\\\":[69937,69927],\\\"69935\\\":[69938,69927],\\\"70475\\\":[70471,70462],\\\"70476\\\":[70471,70487],\\\"70843\\\":[70841,70842],\\\"70844\\\":[70841,70832],\\\"70846\\\":[70841,70845],\\\"71098\\\":[71096,71087],\\\"71099\\\":[71097,71087]},\\\"stateTable\\\":[[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[2,2,3,4,4,5,0,6,7,8,9,10,11,12,13,14,15,16,0,17,18,11,19,20,21,22,0,0,0,23,0,0,2,0,0,24,0,25],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,26,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,27,28,0,0,0,0,0,27,0,0,0],[0,0,0,0,0,29,0,30,31,32,33,34,35,36,37,38,39,40,0,0,41,35,42,43,44,45,0,0,0,46,0,0,0,0,39,0,0,47],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,5,0,6,7,0,0,0,0,0,0,14,0,0,0,0,0,0,0,20,21,22,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,5,0,0,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,20,21,22,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,5,0,6,7,8,9,0,0,12,0,14,0,0,0,0,0,0,0,20,21,22,0,0,0,23,0,0,0,0,0,0,0,0],[0,0,0,0,0,5,0,6,7,0,9,0,0,0,0,14,0,0,0,0,0,0,0,20,21,22,0,0,0,23,0,0,0,0,0,0,0,0],[0,0,0,0,0,5,0,6,7,8,9,10,11,12,13,14,0,16,0,0,18,11,19,20,21,22,0,0,0,23,0,0,0,0,0,0,0,25],[0,0,0,0,0,5,0,6,7,8,9,0,11,12,0,14,0,0,0,0,0,0,0,20,21,22,0,0,0,23,0,0,0,0,0,0,0,0],[0,0,0,0,0,5,0,6,7,0,9,0,0,12,0,14,0,0,0,0,0,0,0,20,21,22,0,0,0,23,0,0,0,0,0,0,0,0],[0,0,0,0,18,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,5,0,0,7,0,0,0,0,0,0,14,0,0,0,0,0,0,0,20,21,22,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,5,0,6,7,8,9,10,11,12,13,14,15,16,0,0,18,11,19,20,21,22,0,0,0,23,0,0,0,0,0,0,0,25],[0,0,0,0,0,5,0,6,7,8,9,0,11,12,0,14,0,0,0,0,0,11,0,20,21,22,0,0,0,23,0,0,0,0,0,0,0,0],[0,0,0,4,4,5,0,6,7,8,9,10,11,12,13,14,15,16,0,0,18,11,19,20,21,22,0,0,0,23,0,0,0,0,0,0,0,25],[0,0,0,0,0,5,0,6,7,8,9,48,11,12,13,14,48,16,0,0,18,11,19,20,21,22,0,0,0,23,0,0,0,0,49,0,0,25],[0,0,0,0,0,5,0,6,7,8,9,0,11,12,0,14,0,16,0,0,0,11,0,20,21,22,0,0,0,23,0,0,0,0,0,0,0,25],[0,0,0,0,0,5,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,20,21,22,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,5,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,21,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,5,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,21,22,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,5,0,6,7,0,0,0,0,0,0,14,0,0,0,0,0,0,0,20,21,22,0,0,0,23,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,50,0,51,0],[0,0,0,0,0,5,0,6,7,8,9,0,11,12,0,14,0,16,0,0,0,11,0,20,21,22,0,0,0,23,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,27,28,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,28,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,29,0,30,31,0,0,0,0,0,0,38,0,0,0,0,0,0,0,43,44,45,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,29,0,0,31,0,0,0,0,0,0,0,0,0,0,0,0,0,0,43,44,45,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,29,0,30,31,32,33,0,0,36,0,38,0,0,0,0,0,0,0,43,44,45,0,0,0,46,0,0,0,0,0,0,0,0],[0,0,0,0,0,29,0,30,31,0,33,0,0,0,0,38,0,0,0,0,0,0,0,43,44,45,0,0,0,46,0,0,0,0,0,0,0,0],[0,0,0,0,0,29,0,30,31,32,33,34,35,36,37,38,0,40,0,0,41,35,42,43,44,45,0,0,0,46,0,0,0,0,0,0,0,47],[0,0,0,0,0,29,0,30,31,32,33,0,35,36,0,38,0,0,0,0,0,0,0,43,44,45,0,0,0,46,0,0,0,0,0,0,0,0],[0,0,0,0,0,29,0,30,31,0,33,0,0,36,0,38,0,0,0,0,0,0,0,43,44,45,0,0,0,46,0,0,0,0,0,0,0,0],[0,0,0,0,41,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,29,0,0,31,0,0,0,0,0,0,38,0,0,0,0,0,0,0,43,44,45,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,29,0,30,31,32,33,34,35,36,37,38,39,40,0,0,41,35,42,43,44,45,0,0,0,46,0,0,0,0,0,0,0,47],[0,0,0,0,0,29,0,30,31,32,33,0,35,36,0,38,0,0,0,0,0,35,0,43,44,45,0,0,0,46,0,0,0,0,0,0,0,0],[0,0,0,0,0,29,0,30,31,32,33,52,35,36,37,38,52,40,0,0,41,35,42,43,44,45,0,0,0,46,0,0,0,0,53,0,0,47],[0,0,0,0,0,29,0,30,31,32,33,0,35,36,0,38,0,40,0,0,0,35,0,43,44,45,0,0,0,46,0,0,0,0,0,0,0,47],[0,0,0,0,0,29,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,43,44,45,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,29,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,44,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,29,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,44,45,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,29,0,30,31,0,0,0,0,0,0,38,0,0,0,0,0,0,0,43,44,45,0,0,0,46,0,0,0,0,0,0,0,0],[0,0,0,0,0,29,0,30,31,32,33,0,35,36,0,38,0,40,0,0,0,35,0,43,44,45,0,0,0,46,0,0,0,0,0,0,0,0],[0,0,0,0,0,5,0,6,7,8,9,48,11,12,13,14,0,16,0,0,18,11,19,20,21,22,0,0,0,23,0,0,0,0,0,0,0,25],[0,0,0,0,0,5,0,6,7,8,9,48,11,12,13,14,48,16,0,0,18,11,19,20,21,22,0,0,0,23,0,0,0,0,0,0,0,25],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,51,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,54,0,0],[0,0,0,0,0,29,0,30,31,32,33,52,35,36,37,38,0,40,0,0,41,35,42,43,44,45,0,0,0,46,0,0,0,0,0,0,0,47],[0,0,0,0,0,29,0,30,31,32,33,52,35,36,37,38,52,40,0,0,41,35,42,43,44,45,0,0,0,46,0,0,0,0,0,0,0,47],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,50,0,51,0]],\\\"accepting\\\":[false,true,true,true,true,true,true,true,true,true,true,true,true,false,true,true,true,true,true,true,true,true,true,true,true,true,true,true,true,true,true,true,true,true,true,true,true,true,true,true,true,true,true,true,true,true,true,true,true,true,true,true,true,true,true],\\\"tags\\\":[[],[\\\"broken_cluster\\\"],[\\\"independent_cluster\\\"],[\\\"symbol_cluster\\\"],[\\\"standard_cluster\\\"],[\\\"broken_cluster\\\"],[\\\"broken_cluster\\\"],[\\\"broken_cluster\\\"],[\\\"broken_cluster\\\"],[\\\"broken_cluster\\\"],[\\\"broken_cluster\\\"],[\\\"broken_cluster\\\"],[\\\"broken_cluster\\\"],[],[\\\"broken_cluster\\\"],[\\\"broken_cluster\\\"],[\\\"broken_cluster\\\"],[\\\"broken_cluster\\\"],[\\\"broken_cluster\\\"],[\\\"broken_cluster\\\"],[\\\"broken_cluster\\\"],[\\\"broken_cluster\\\"],[\\\"broken_cluster\\\"],[\\\"broken_cluster\\\"],[\\\"numeral_cluster\\\"],[\\\"broken_cluster\\\"],[\\\"independent_cluster\\\"],[\\\"symbol_cluster\\\"],[\\\"symbol_cluster\\\"],[\\\"standard_cluster\\\"],[\\\"standard_cluster\\\"],[\\\"standard_cluster\\\"],[\\\"standard_cluster\\\"],[\\\"standard_cluster\\\"],[\\\"standard_cluster\\\"],[\\\"standard_cluster\\\"],[\\\"standard_cluster\\\"],[\\\"virama_terminated_cluster\\\"],[\\\"standard_cluster\\\"],[\\\"standard_cluster\\\"],[\\\"standard_cluster\\\"],[\\\"standard_cluster\\\"],[\\\"standard_cluster\\\"],[\\\"standard_cluster\\\"],[\\\"standard_cluster\\\"],[\\\"standard_cluster\\\"],[\\\"standard_cluster\\\"],[\\\"standard_cluster\\\"],[\\\"broken_cluster\\\"],[\\\"broken_cluster\\\"],[\\\"numeral_cluster\\\"],[\\\"number_joiner_terminated_cluster\\\"],[\\\"standard_cluster\\\"],[\\\"standard_cluster\\\"],[\\\"numeral_cluster\\\"]]}\");\n\n// Cateories used in the OpenType spec:\n// https://www.microsoft.com/typography/otfntdev/devanot/shaping.aspx\nconst $90a9d3398ee54fe5$export$a513ea61a7bee91c = {\n  X: 1,\n  C: 2,\n  V: 4,\n  N: 8,\n  H: 16,\n  ZWNJ: 32,\n  ZWJ: 64,\n  M: 128,\n  SM: 256,\n  VD: 512,\n  A: 1024,\n  Placeholder: 2048,\n  Dotted_Circle: 4096,\n  RS: 8192,\n  Coeng: 16384,\n  Repha: 32768,\n  Ra: 65536,\n  CM: 131072,\n  Symbol: 262144 // Avagraha, etc that take marks (SM,A,VD).\n};\nconst $90a9d3398ee54fe5$export$1a1f61c9c4dd9df0 = {\n  Start: 1,\n  Ra_To_Become_Reph: 2,\n  Pre_M: 4,\n  Pre_C: 8,\n  Base_C: 16,\n  After_Main: 32,\n  Above_C: 64,\n  Before_Sub: 128,\n  Below_C: 256,\n  After_Sub: 512,\n  Before_Post: 1024,\n  Post_C: 2048,\n  After_Post: 4096,\n  Final_C: 8192,\n  SMVD: 16384,\n  End: 32768\n};\nconst $90a9d3398ee54fe5$export$8519deaa7de2b07 = $90a9d3398ee54fe5$export$a513ea61a7bee91c.C | $90a9d3398ee54fe5$export$a513ea61a7bee91c.Ra | $90a9d3398ee54fe5$export$a513ea61a7bee91c.CM | $90a9d3398ee54fe5$export$a513ea61a7bee91c.V | $90a9d3398ee54fe5$export$a513ea61a7bee91c.Placeholder | $90a9d3398ee54fe5$export$a513ea61a7bee91c.Dotted_Circle;\nconst $90a9d3398ee54fe5$export$bbcd928767338e0d = $90a9d3398ee54fe5$export$a513ea61a7bee91c.ZWJ | $90a9d3398ee54fe5$export$a513ea61a7bee91c.ZWNJ;\nconst $90a9d3398ee54fe5$export$ca9599b2a300afc = $90a9d3398ee54fe5$export$a513ea61a7bee91c.H | $90a9d3398ee54fe5$export$a513ea61a7bee91c.Coeng;\nconst $90a9d3398ee54fe5$export$e99d119da76a0fc5 = {\n  Default: {\n    hasOldSpec: false,\n    virama: 0,\n    basePos: 'Last',\n    rephPos: $90a9d3398ee54fe5$export$1a1f61c9c4dd9df0.Before_Post,\n    rephMode: 'Implicit',\n    blwfMode: 'Pre_And_Post'\n  },\n  Devanagari: {\n    hasOldSpec: true,\n    virama: 0x094D,\n    basePos: 'Last',\n    rephPos: $90a9d3398ee54fe5$export$1a1f61c9c4dd9df0.Before_Post,\n    rephMode: 'Implicit',\n    blwfMode: 'Pre_And_Post'\n  },\n  Bengali: {\n    hasOldSpec: true,\n    virama: 0x09CD,\n    basePos: 'Last',\n    rephPos: $90a9d3398ee54fe5$export$1a1f61c9c4dd9df0.After_Sub,\n    rephMode: 'Implicit',\n    blwfMode: 'Pre_And_Post'\n  },\n  Gurmukhi: {\n    hasOldSpec: true,\n    virama: 0x0A4D,\n    basePos: 'Last',\n    rephPos: $90a9d3398ee54fe5$export$1a1f61c9c4dd9df0.Before_Sub,\n    rephMode: 'Implicit',\n    blwfMode: 'Pre_And_Post'\n  },\n  Gujarati: {\n    hasOldSpec: true,\n    virama: 0x0ACD,\n    basePos: 'Last',\n    rephPos: $90a9d3398ee54fe5$export$1a1f61c9c4dd9df0.Before_Post,\n    rephMode: 'Implicit',\n    blwfMode: 'Pre_And_Post'\n  },\n  Oriya: {\n    hasOldSpec: true,\n    virama: 0x0B4D,\n    basePos: 'Last',\n    rephPos: $90a9d3398ee54fe5$export$1a1f61c9c4dd9df0.After_Main,\n    rephMode: 'Implicit',\n    blwfMode: 'Pre_And_Post'\n  },\n  Tamil: {\n    hasOldSpec: true,\n    virama: 0x0BCD,\n    basePos: 'Last',\n    rephPos: $90a9d3398ee54fe5$export$1a1f61c9c4dd9df0.After_Post,\n    rephMode: 'Implicit',\n    blwfMode: 'Pre_And_Post'\n  },\n  Telugu: {\n    hasOldSpec: true,\n    virama: 0x0C4D,\n    basePos: 'Last',\n    rephPos: $90a9d3398ee54fe5$export$1a1f61c9c4dd9df0.After_Post,\n    rephMode: 'Explicit',\n    blwfMode: 'Post_Only'\n  },\n  Kannada: {\n    hasOldSpec: true,\n    virama: 0x0CCD,\n    basePos: 'Last',\n    rephPos: $90a9d3398ee54fe5$export$1a1f61c9c4dd9df0.After_Post,\n    rephMode: 'Implicit',\n    blwfMode: 'Post_Only'\n  },\n  Malayalam: {\n    hasOldSpec: true,\n    virama: 0x0D4D,\n    basePos: 'Last',\n    rephPos: $90a9d3398ee54fe5$export$1a1f61c9c4dd9df0.After_Main,\n    rephMode: 'Log_Repha',\n    blwfMode: 'Pre_And_Post'\n  },\n  // Handled by UniversalShaper\n  // Sinhala: {\n  //   hasOldSpec: false,\n  //   virama: 0x0DCA,\n  //   basePos: 'Last_Sinhala',\n  //   rephPos: POSITIONS.After_Main,\n  //   rephMode: 'Explicit',\n  //   blwfMode: 'Pre_And_Post'\n  // },\n  Khmer: {\n    hasOldSpec: false,\n    virama: 0x17D2,\n    basePos: 'First',\n    rephPos: $90a9d3398ee54fe5$export$1a1f61c9c4dd9df0.Ra_To_Become_Reph,\n    rephMode: 'Vis_Repha',\n    blwfMode: 'Pre_And_Post'\n  }\n};\nconst $90a9d3398ee54fe5$export$f647c9cfdd77d95a = {\n  // Khmer\n  0x17BE: [0x17C1, 0x17BE],\n  0x17BF: [0x17C1, 0x17BF],\n  0x17C0: [0x17C1, 0x17C0],\n  0x17C4: [0x17C1, 0x17C4],\n  0x17C5: [0x17C1, 0x17C5]\n};\nconst {\n  decompositions: $7826f90f6f0cecc9$var$decompositions\n} = (0, (/*@__PURE__*/$parcel$interopDefault($aa333a9607471296$exports)));\nconst $7826f90f6f0cecc9$var$trie = new (0, $6uUbQ$unicodetrie)((0, $12727730ddfc8bfe$export$94fdf11bafc8de6b)(\"AAARAAAAAABg2AAAAWYPmfDtnXuMXFUdx+/uzs7M7szudAtECGJRIMRQbUAithQWkGAKiVhNpFVRRAmIQVCDkDYICGotIA9BTCz8IeUviv7BQ2PBtBIRLBBQIWAUsKg1BKxRAqIgfs/cc+aeOXPej3tnZX7JJ/dxzj3nd36/8753Z5fUsuxgsAwcAU4Gp4BPgM+Cd4P3RjieDs4GXwLrHJ5bDy4DG8A14LvgZrAZbAF3gns0z18ALgY/B78C94NHwBPgabAE/AX8DbwM5sF/QX0yD5vFcU/wVnAgWAoOAyvAceBE8CGwBpwGzgJfAF8BXwXfAFeC68EmsBlsAXeCreA+8CB4DDwF/gh2gd3gFfAGmKxn2QzYC+wHDgRLweFgJTgWrKrnuq/GcQ04jV6fheN54EJwEbgcXAG+Q8O/j+Mt4DZwB9haz8t9Hz3a8iCN/xiOvwRP0evH6fE68AzOH+Ke2eWYhw3PcGnuxvkr4A3QaGRZB7wFLAEHg2XgiEZ/fHKcp/ceBh/A+cngFPCpRm6vM3E8l8a5gN67GMdvgqsbeX2ap9yI601gM7gN3AG20mfuo8cdOP6GpvdUg9oKxz839GV90RDO2/glxN1B790NXsN1rZll7WYRdw+c70uvTwIHNAfTO0RyL5TDmnnbc3lmRQI9UnM0dD5eovfz4FpJ/BNpXNYWV+N6Lfg0hY97JK1vn+Pur9DoQur2F7m436bHDUK8C5t5/8vruo4+97WmXG+GLmzEiBF+PDwEOowYMWLEiBEjRoxYeBw5BDqIPEfXut9yWN+vVNxfrnnmWqR/PdgENoMt4E5wD9gOHgCPgifBs2BXM99b2o3jP8F/wMRUlrXAHNgHvH0q3895J46HguXgWHAGLctmLv9VuL96qnp7jxgxYsSbCbJvuRZ97/tqxT59VVRtixEjRsThBG7OSt5zzoPT0M+cBc4T5noXOs79TqLHeZrHUeCSqeJ96gacXy2kecNU8V6Hh7yXuQlhtw7B/PO1RTkr52Aj8JNFZjYg3gOKuC/g/v6Ls2wNuAY8urg//PcIb+6RZXuDNeCS6SzbBrJWlh0DLiFHco8ed9IjzzvaWfa9sZzTcf6D9mCcnbg3PlNcH4fzS8F2MDaLdQG4dLZIJxbbaZqv4ri8k58f3+mPs66T6/TTzqDeI0aMGDGiHP5dcR8ce/xxYcWi6vOfr725uRzcjnngXVOD61Hync+9uL+Nmyfej/NHpvL56A5Jeuz7uyfo+pqcPz2Vf1NH0ttJ03pekt8SmuY/EPYy9zzbN319ym/9TL6ZIt9MHCXRdxJtoAkWTRdz472n87D9cTwYLJvuz++I6WIePo/zE8AHp4v8WLyP0nufnM6/+zoDx8+DL08P6r9+urheRtO+jD6/cdrsx3mqu8w+xH4PScKIXa5D2jeCm8Et4DbwI/BjcC/4BXgI/Bb8DuwEu8Bu8Ap4A9RaRZptnO8J9gUHgEPAoWA5OLY1qMO90GEV7q+mYWtxPBWcIYnL4p+DsPNbxfVFOP86uAr8DNc34HgTDb8Vx9sVaRFI/LtagzYjnCqpb908EX87eBA8Bh4Hf2jle/9/wvGFVv787rrZZy8h7qtgDOuFOmiBuXYRvg/O9wMHgXeB97SLspk4sq0OI/q9v13+ek+sh3zYSRp9jrYorw9ll1/GRzR+KotYZSHf8laVP2lvpA/8OGdPMk59hqtXZ+L8nHbxvWwqO65ryu+fT3VZz+l4dET7L0R072ljsMyzTpaJqQxsbL8M9WajY789DO85XMp/Dcp3Qztdn+9qf/a97ZWK8PXc3G+TpC/nv8Mncy7ZvICF302P5O+aNiOtLdTXd+D4Q7DVwfcvWvx9zTEJ/o5iG3R8YAjGNFseha5PGuZKz7b7xxXbOrXMcu5eJSo//rXdH/73Enz6L1q/X+fyIu8wZGtNBmkjkzNZNgP2AvuBg2bysKUzduXn/66JtNeN4PCZvO0/x7Ujdn4VnYOvRJzjZ/I+9sQZeftX2Tc1RPcPz/Tf4/si0g+t5Mq+kfZjZL34Mc5ul3PPnE7TOxvHK2qDaZ+L++db2HyYqMo/qVnb/P8uH8/rmnFxR0k6DCu/rjj/RxT7KGUSWgbd+LMQuEgYB1zsk2qtvJD8v5AhdfdttbEunSxbcJD9Zf7chqp1Hlbe7FK1/aPVTfp7FgtC1yGGiSncFK/DhZvi+epZta0WWjlsfDZMyPRdSPrryqSSKnXx1bkq/Ye9TlRpk7Lrjq1UrfdC9X+MtKqwP6+3a/4pJFUZF0pZZpv91MYjMBaRRXbxpho5zQmUY3F+Pt4o7rvQrBXPdm00TaE24uMadaM2meLSI7iu071t3er3b6ZLi8JEde3qw+6zGv+ycF5kaRBh/m1T/7Yl/mMyTuMwadP4xL9ifjJpNwbvDZRJ8G8vnqV/Wf12aa/kyOdl69+BspTsXzGueE6E+JfZnvmXIfNPW+FfXkjb1YmqPNpnLP3b61fHCj/X5tzGANf2y3yqvC7Jv7btV4TVbdammI9l/g0dS5lNxLrk2j9r8xjjxhBQnygg0lgg/bOrfyct+udJi/Yrk0lFnxC7f+5kRbsNmcexfrubt0X/rGvLqrGSnYv3ZPHEe8r7lvMvUfi2LOu/2dg8LrRtQt2yfcv8r5IU70VkIs6nbebUXf0M/o7Znl39Sdoz+X1oEb5N8ffF67qhPfPP6eoUbxf+GRf/6sRnvaSdmw+Bf1VxmbD+2sa//DU7t/Gv2PfKpKdrBP92Ojk+IvqX16ks/2qxbL8EZnc2HqsgYuqPuzZV+I3RbujbDm+T0PmWCVO/5jqftp1zy+wSA6s0JWtp2z5e1oZV+yMsjB3ZXolsv0Ulrv01v3/iKrF94Qtbt9siCnmeb6fjjf59KnLk1xaEbvtvFnFirGvEOqmycQrbm/IMsXd3P28uh4nM3swXRER717OiX8kc7K2qqyn2p3maFGU/aruP5VCv+PraoTYU8yUmmbDwcYo6pusnM486xdoga4dkPCb1pK7Sfc6ebvkd4qeAtQcd/N63bB3lU3dlUnUf38VyvqCqK7JxlNSd7lydrDlm+/uqHiRvl30Nrp/n9zpkZRjoJ3V1diyP05rIYXHYs+w+D5+WMS8b5gZtKcuX0KT5d/WwtB97VnyvY6rjMukI56HI0rFJPwt8PjT/1OXzSbcMeEmdh294qvKK4rNu7j4n3LNZg8TKXwafv025U+XvKjHsT8Q7/7LGaJt9lAh7Asz3uv0XEX6t0duDoWN/93wmh92XpUHmCKb9GALbG+rZP3AfNbQPKKv/jpF/bP0JXfuW1QYk7dhljcyvk5mw+933Hpo1g26PQ2ZP6zVmTJt47P25jncD9vPwGS+q9QS/V6RaY8j8K8LmvUr9HfYCpH5OWL9lZY+Sv6pesHCJHbtrf9k6etZvf0G1L0ja4cAe1UT/s3zdCe3/Q5/n372wMc97/E1Qh0Tbmfwh3m/V9On72tNnrCF1sJkVe1EyXMdBa7+lHMsk44zMF6St9e2djNnbm8ybpHkq+gbbemMaH0UZmD8obKGrk7r+nt+3bE7o83YZp/vqOKdv6PzJNN6mTJsI/51XR7i2ZrGA5B6zFwnjzxmqPjaGfW3tZNrz1eljq29mOOqeCfF/irRt87PNw0uXSVAvrmOMNT569MptsYaV0sic/wbY13e8hPrb9K2ySUJ0j6G/Lu0U4qpTrR23jMp6m5hU+YTaWCeh9aIsm/rqUHV4bFv42kgnZdfH1PUj1D7DVH9d8khRN1zFRl/+/TW//qxL1uH83+mk3H+SvRtS2TDU90nX2TpM6/1xzZpZtoYdK763dqlz0f6uNeFehcs+H/nbGP77MpX06n/ofpzP+tVmTUvRtVuX/cjS67OE5kRBrxyJ+w/dPo7r+9cO1160e3gqu0S2uW7PjN/L6ns/UfMf10Lai87frJ+3KndAfc8yTf1M3T4s6qm4/yh7/2GSkG8UMw//DvRLgbYZSEOxr0LCWvRdjfh9XGzfqN4NivfZd7rsmFp08zmbssrKJEuTfVMZopdpbuwSrhNv3/N2s+0PDG3KNB6RMrFvJHv6B85HXObAoWsd3zm3i+6uZYytv+5+pohbpo6+tpZJFfmGlrcMf4c8b1Pe2OUIsaXJrinCTfaxtZOt+NYnU3hIfQlN20Z/1+dt7JaqLsbIzycNWZmrlNg2Dc2/LJ1T+T6WrrYSml4Ku7ik7yIx2opJD51vU9UfVRmrqL8u/olZj0PyCLV5irxcdKoi/6rKb8qTrHsnhW9jyZH/nSpeWDzxd9769uQ016lgUuf2pAfKPhu2FpfZL2Yb9snLNl/fNIepXaUsj4vNXCXUZ75px8ojNP8UPvAta2g6fb+F1ckZuneshv1vGXXDeyRRrN/bBPS1Jul+l+7zW86R7Wv63WXyDpt/RxraRjvC+TC3O61/Sqj/prag8x372yQivn+XwudrI2X2E2KdtJEov52e0L+uv4FO3p/rvssgsL8F4d/z9PzlWS94m8fqS3361Fi+6qaVYHwi9Yz4iH2fobIj+45cpz/TUaarr/4+z+vaWtVtyAX2d1LG8W9C3f+F1mnf36/k4w3YPrLv+XBVXCJs3cr+n4MKJuLv/fN9GhNdXVP5pJMN9vFi3rpv3/r8Ywg3SYp66zNOsO8QGcxPpnmRS/1mvmJjju3v7absI2xspQrvs1dNbjOj/wP7h1RlZyKGy8occ408UL8En4v6xfC/K3z52XzJd62T8vuZGGsxo/6O46ntmNqqFb/jps2/hHV4rPKH0svT4pstU7t2tZ9u/ZdqbJL1MwP6O86Fyt4jYaIrGz9mjEt8lFL4PtVE6votG2P6fpdf/GZRse7s3bf4BtSl/DIbKMctx++Z+8o6K6z9FPOwKsRmXiaNl7C+6NYRpjlbqG1j72f49qsuY4brd/amb4ZVc8TQ+sSH985LrEe8iPWJnfPrJRbWbb+dwn4x6o+r/aS2S7w3qWt//LnYz2ntE0vH1uDcyKatx1rH+EiMPEN1SZG/iz6+9o01Rob6O7Q+xLZ1jHobK61U+pWVvo2EpuWqzzD6Poa+pvhli0wn8Zq/72Mzm2d90o5VN1x9ZKuzbTgvqWwUIin8FSpl1CXXvFRxU0iozVPYJDRtF3uFphn6XAyJUUdD7SjTJ8v6n9fVbVObkKWp001lc9VRlqdOf5v0ZM+bymdbfp1NfG0bq27Y5JMyfxeJkU6o/inKH8O2Zfgidb6h/g3VJ7QcVbWL0Pxt6rlrPqa4KfQ25a2zl4/E8GdM/4fK/wA=\"));\nconst $7826f90f6f0cecc9$var$stateMachine = new (0, $6uUbQ$dfa)((0, (/*@__PURE__*/$parcel$interopDefault($4b0735ca6c692ea5$exports))));\nclass $7826f90f6f0cecc9$export$2e2bcd8739ae039 extends (0, $649970d87335b30f$export$2e2bcd8739ae039) {\n  static planFeatures(plan) {\n    plan.addStage($7826f90f6f0cecc9$var$setupSyllables);\n    plan.addStage(['locl', 'ccmp']);\n    plan.addStage($7826f90f6f0cecc9$var$initialReordering);\n    plan.addStage('nukt');\n    plan.addStage('akhn');\n    plan.addStage('rphf', false);\n    plan.addStage('rkrf');\n    plan.addStage('pref', false);\n    plan.addStage('blwf', false);\n    plan.addStage('abvf', false);\n    plan.addStage('half', false);\n    plan.addStage('pstf', false);\n    plan.addStage('vatu');\n    plan.addStage('cjct');\n    plan.addStage('cfar', false);\n    plan.addStage($7826f90f6f0cecc9$var$finalReordering);\n    plan.addStage({\n      local: ['init'],\n      global: ['pres', 'abvs', 'blws', 'psts', 'haln', 'dist', 'abvm', 'blwm', 'calt', 'clig']\n    });\n    // Setup the indic config for the selected script\n    plan.unicodeScript = $130d1a642ebcd2b7$export$ce50e82f12a827a4(plan.script);\n    plan.indicConfig = (0, $90a9d3398ee54fe5$export$e99d119da76a0fc5)[plan.unicodeScript] || (0, $90a9d3398ee54fe5$export$e99d119da76a0fc5).Default;\n    plan.isOldSpec = plan.indicConfig.hasOldSpec && plan.script[plan.script.length - 1] !== '2';\n    // TODO: turn off kern (Khmer) and liga features.\n  }\n  static assignFeatures(plan, glyphs) {\n    // Decompose split matras\n    // TODO: do this in a more general unicode normalizer\n    for (let i = glyphs.length - 1; i >= 0; i--) {\n      let codepoint = glyphs[i].codePoints[0];\n      let d = (0, $90a9d3398ee54fe5$export$f647c9cfdd77d95a)[codepoint] || $7826f90f6f0cecc9$var$decompositions[codepoint];\n      if (d) {\n        let decomposed = d.map(c => {\n          let g = plan.font.glyphForCodePoint(c);\n          return new (0, $10e7b257e1a9a756$export$2e2bcd8739ae039)(plan.font, g.id, [c], glyphs[i].features);\n        });\n        glyphs.splice(i, 1, ...decomposed);\n      }\n    }\n  }\n}\n(0, $6uUbQ$_)($7826f90f6f0cecc9$export$2e2bcd8739ae039, \"zeroMarkWidths\", 'NONE');\nfunction $7826f90f6f0cecc9$var$indicCategory(glyph) {\n  return $7826f90f6f0cecc9$var$trie.get(glyph.codePoints[0]) >> 8;\n}\nfunction $7826f90f6f0cecc9$var$indicPosition(glyph) {\n  return 1 << ($7826f90f6f0cecc9$var$trie.get(glyph.codePoints[0]) & 0xff);\n}\nclass $7826f90f6f0cecc9$var$IndicInfo {\n  constructor(category, position, syllableType, syllable) {\n    this.category = category;\n    this.position = position;\n    this.syllableType = syllableType;\n    this.syllable = syllable;\n  }\n}\nfunction $7826f90f6f0cecc9$var$setupSyllables(font, glyphs) {\n  let syllable = 0;\n  let last = 0;\n  for (let [start, end, tags] of $7826f90f6f0cecc9$var$stateMachine.match(glyphs.map($7826f90f6f0cecc9$var$indicCategory))) {\n    if (start > last) {\n      ++syllable;\n      for (let i = last; i < start; i++) glyphs[i].shaperInfo = new $7826f90f6f0cecc9$var$IndicInfo((0, $90a9d3398ee54fe5$export$a513ea61a7bee91c).X, (0, $90a9d3398ee54fe5$export$1a1f61c9c4dd9df0).End, 'non_indic_cluster', syllable);\n    }\n    ++syllable;\n    // Create shaper info\n    for (let i = start; i <= end; i++) glyphs[i].shaperInfo = new $7826f90f6f0cecc9$var$IndicInfo(1 << $7826f90f6f0cecc9$var$indicCategory(glyphs[i]), $7826f90f6f0cecc9$var$indicPosition(glyphs[i]), tags[0], syllable);\n    last = end + 1;\n  }\n  if (last < glyphs.length) {\n    ++syllable;\n    for (let i = last; i < glyphs.length; i++) glyphs[i].shaperInfo = new $7826f90f6f0cecc9$var$IndicInfo((0, $90a9d3398ee54fe5$export$a513ea61a7bee91c).X, (0, $90a9d3398ee54fe5$export$1a1f61c9c4dd9df0).End, 'non_indic_cluster', syllable);\n  }\n}\nfunction $7826f90f6f0cecc9$var$isConsonant(glyph) {\n  return glyph.shaperInfo.category & (0, $90a9d3398ee54fe5$export$8519deaa7de2b07);\n}\nfunction $7826f90f6f0cecc9$var$isJoiner(glyph) {\n  return glyph.shaperInfo.category & (0, $90a9d3398ee54fe5$export$bbcd928767338e0d);\n}\nfunction $7826f90f6f0cecc9$var$isHalantOrCoeng(glyph) {\n  return glyph.shaperInfo.category & (0, $90a9d3398ee54fe5$export$ca9599b2a300afc);\n}\nfunction $7826f90f6f0cecc9$var$wouldSubstitute(glyphs, feature) {\n  for (let glyph of glyphs) glyph.features = {\n    [feature]: true\n  };\n  let GSUB = glyphs[0]._font._layoutEngine.engine.GSUBProcessor;\n  GSUB.applyFeatures([feature], glyphs);\n  return glyphs.length === 1;\n}\nfunction $7826f90f6f0cecc9$var$consonantPosition(font, consonant, virama) {\n  let glyphs = [virama, consonant, virama];\n  if ($7826f90f6f0cecc9$var$wouldSubstitute(glyphs.slice(0, 2), 'blwf') || $7826f90f6f0cecc9$var$wouldSubstitute(glyphs.slice(1, 3), 'blwf')) return (0, $90a9d3398ee54fe5$export$1a1f61c9c4dd9df0).Below_C;else if ($7826f90f6f0cecc9$var$wouldSubstitute(glyphs.slice(0, 2), 'pstf') || $7826f90f6f0cecc9$var$wouldSubstitute(glyphs.slice(1, 3), 'pstf')) return (0, $90a9d3398ee54fe5$export$1a1f61c9c4dd9df0).Post_C;else if ($7826f90f6f0cecc9$var$wouldSubstitute(glyphs.slice(0, 2), 'pref') || $7826f90f6f0cecc9$var$wouldSubstitute(glyphs.slice(1, 3), 'pref')) return (0, $90a9d3398ee54fe5$export$1a1f61c9c4dd9df0).Post_C;\n  return (0, $90a9d3398ee54fe5$export$1a1f61c9c4dd9df0).Base_C;\n}\nfunction $7826f90f6f0cecc9$var$initialReordering(font, glyphs, plan) {\n  let indicConfig = plan.indicConfig;\n  let features = font._layoutEngine.engine.GSUBProcessor.features;\n  let dottedCircle = font.glyphForCodePoint(0x25cc).id;\n  let virama = font.glyphForCodePoint(indicConfig.virama).id;\n  if (virama) {\n    let info = new (0, $10e7b257e1a9a756$export$2e2bcd8739ae039)(font, virama, [indicConfig.virama]);\n    for (let i = 0; i < glyphs.length; i++) if (glyphs[i].shaperInfo.position === (0, $90a9d3398ee54fe5$export$1a1f61c9c4dd9df0).Base_C) glyphs[i].shaperInfo.position = $7826f90f6f0cecc9$var$consonantPosition(font, glyphs[i].copy(), info);\n  }\n  for (let start = 0, end = $7826f90f6f0cecc9$var$nextSyllable(glyphs, 0); start < glyphs.length; start = end, end = $7826f90f6f0cecc9$var$nextSyllable(glyphs, start)) {\n    let {\n      category: category,\n      syllableType: syllableType\n    } = glyphs[start].shaperInfo;\n    if (syllableType === 'symbol_cluster' || syllableType === 'non_indic_cluster') continue;\n    if (syllableType === 'broken_cluster' && dottedCircle) {\n      let g = new (0, $10e7b257e1a9a756$export$2e2bcd8739ae039)(font, dottedCircle, [0x25cc]);\n      g.shaperInfo = new $7826f90f6f0cecc9$var$IndicInfo(1 << $7826f90f6f0cecc9$var$indicCategory(g), $7826f90f6f0cecc9$var$indicPosition(g), glyphs[start].shaperInfo.syllableType, glyphs[start].shaperInfo.syllable);\n      // Insert after possible Repha.\n      let i = start;\n      while (i < end && glyphs[i].shaperInfo.category === (0, $90a9d3398ee54fe5$export$a513ea61a7bee91c).Repha) i++;\n      glyphs.splice(i++, 0, g);\n      end++;\n    }\n    // 1. Find base consonant:\n    //\n    // The shaping engine finds the base consonant of the syllable, using the\n    // following algorithm: starting from the end of the syllable, move backwards\n    // until a consonant is found that does not have a below-base or post-base\n    // form (post-base forms have to follow below-base forms), or that is not a\n    // pre-base reordering Ra, or arrive at the first consonant. The consonant\n    // stopped at will be the base.\n    let base = end;\n    let limit = start;\n    let hasReph = false;\n    // If the syllable starts with Ra + Halant (in a script that has Reph)\n    // and has more than one consonant, Ra is excluded from candidates for\n    // base consonants.\n    if (indicConfig.rephPos !== (0, $90a9d3398ee54fe5$export$1a1f61c9c4dd9df0).Ra_To_Become_Reph && features.rphf && start + 3 <= end && (indicConfig.rephMode === 'Implicit' && !$7826f90f6f0cecc9$var$isJoiner(glyphs[start + 2]) || indicConfig.rephMode === 'Explicit' && glyphs[start + 2].shaperInfo.category === (0, $90a9d3398ee54fe5$export$a513ea61a7bee91c).ZWJ)) {\n      // See if it matches the 'rphf' feature.\n      let g = [glyphs[start].copy(), glyphs[start + 1].copy(), glyphs[start + 2].copy()];\n      if ($7826f90f6f0cecc9$var$wouldSubstitute(g.slice(0, 2), 'rphf') || indicConfig.rephMode === 'Explicit' && $7826f90f6f0cecc9$var$wouldSubstitute(g, 'rphf')) {\n        limit += 2;\n        while (limit < end && $7826f90f6f0cecc9$var$isJoiner(glyphs[limit])) limit++;\n        base = start;\n        hasReph = true;\n      }\n    } else if (indicConfig.rephMode === 'Log_Repha' && glyphs[start].shaperInfo.category === (0, $90a9d3398ee54fe5$export$a513ea61a7bee91c).Repha) {\n      limit++;\n      while (limit < end && $7826f90f6f0cecc9$var$isJoiner(glyphs[limit])) limit++;\n      base = start;\n      hasReph = true;\n    }\n    switch (indicConfig.basePos) {\n      case 'Last':\n        {\n          // starting from the end of the syllable, move backwards\n          let i = end;\n          let seenBelow = false;\n          do {\n            let info = glyphs[--i].shaperInfo;\n            // until a consonant is found\n            if ($7826f90f6f0cecc9$var$isConsonant(glyphs[i])) {\n              // that does not have a below-base or post-base form\n              // (post-base forms have to follow below-base forms),\n              if (info.position !== (0, $90a9d3398ee54fe5$export$1a1f61c9c4dd9df0).Below_C && (info.position !== (0, $90a9d3398ee54fe5$export$1a1f61c9c4dd9df0).Post_C || seenBelow)) {\n                base = i;\n                break;\n              }\n              // or that is not a pre-base reordering Ra,\n              //\n              // IMPLEMENTATION NOTES:\n              //\n              // Our pre-base reordering Ra's are marked POS_POST_C, so will be skipped\n              // by the logic above already.\n              //\n              // or arrive at the first consonant. The consonant stopped at will\n              // be the base.\n              if (info.position === (0, $90a9d3398ee54fe5$export$1a1f61c9c4dd9df0).Below_C) seenBelow = true;\n              base = i;\n            } else if (start < i && info.category === (0, $90a9d3398ee54fe5$export$a513ea61a7bee91c).ZWJ && glyphs[i - 1].shaperInfo.category === (0, $90a9d3398ee54fe5$export$a513ea61a7bee91c).H) break;\n          } while (i > limit);\n          break;\n        }\n      case 'First':\n        // The first consonant is always the base.\n        base = start;\n        // Mark all subsequent consonants as below.\n        for (let i = base + 1; i < end; i++) if ($7826f90f6f0cecc9$var$isConsonant(glyphs[i])) glyphs[i].shaperInfo.position = (0, $90a9d3398ee54fe5$export$1a1f61c9c4dd9df0).Below_C;\n    }\n    // If the syllable starts with Ra + Halant (in a script that has Reph)\n    // and has more than one consonant, Ra is excluded from candidates for\n    // base consonants.\n    //\n    //  Only do this for unforced Reph. (ie. not for Ra,H,ZWJ)\n    if (hasReph && base === start && limit - base <= 2) hasReph = false;\n    // 2. Decompose and reorder Matras:\n    //\n    // Each matra and any syllable modifier sign in the cluster are moved to the\n    // appropriate position relative to the consonant(s) in the cluster. The\n    // shaping engine decomposes two- or three-part matras into their constituent\n    // parts before any repositioning. Matra characters are classified by which\n    // consonant in a conjunct they have affinity for and are reordered to the\n    // following positions:\n    //\n    //   o Before first half form in the syllable\n    //   o After subjoined consonants\n    //   o After post-form consonant\n    //   o After main consonant (for above marks)\n    //\n    // IMPLEMENTATION NOTES:\n    //\n    // The normalize() routine has already decomposed matras for us, so we don't\n    // need to worry about that.\n    // 3.  Reorder marks to canonical order:\n    //\n    // Adjacent nukta and halant or nukta and vedic sign are always repositioned\n    // if necessary, so that the nukta is first.\n    //\n    // IMPLEMENTATION NOTES:\n    //\n    // We don't need to do this: the normalize() routine already did this for us.\n    // Reorder characters\n    for (let i = start; i < base; i++) {\n      let info = glyphs[i].shaperInfo;\n      info.position = Math.min((0, $90a9d3398ee54fe5$export$1a1f61c9c4dd9df0).Pre_C, info.position);\n    }\n    if (base < end) glyphs[base].shaperInfo.position = (0, $90a9d3398ee54fe5$export$1a1f61c9c4dd9df0).Base_C;\n    // Mark final consonants.  A final consonant is one appearing after a matra,\n    // like in Khmer.\n    for (let i = base + 1; i < end; i++) if (glyphs[i].shaperInfo.category === (0, $90a9d3398ee54fe5$export$a513ea61a7bee91c).M) {\n      for (let j = i + 1; j < end; j++) if ($7826f90f6f0cecc9$var$isConsonant(glyphs[j])) {\n        glyphs[j].shaperInfo.position = (0, $90a9d3398ee54fe5$export$1a1f61c9c4dd9df0).Final_C;\n        break;\n      }\n      break;\n    }\n    // Handle beginning Ra\n    if (hasReph) glyphs[start].shaperInfo.position = (0, $90a9d3398ee54fe5$export$1a1f61c9c4dd9df0).Ra_To_Become_Reph;\n    // For old-style Indic script tags, move the first post-base Halant after\n    // last consonant.\n    //\n    // Reports suggest that in some scripts Uniscribe does this only if there\n    // is *not* a Halant after last consonant already (eg. Kannada), while it\n    // does it unconditionally in other scripts (eg. Malayalam).  We don't\n    // currently know about other scripts, so we single out Malayalam for now.\n    //\n    // Kannada test case:\n    // U+0C9A,U+0CCD,U+0C9A,U+0CCD\n    // With some versions of Lohit Kannada.\n    // https://bugs.freedesktop.org/show_bug.cgi?id=59118\n    //\n    // Malayalam test case:\n    // U+0D38,U+0D4D,U+0D31,U+0D4D,U+0D31,U+0D4D\n    // With lohit-ttf-20121122/Lohit-Malayalam.ttf\n    if (plan.isOldSpec) {\n      let disallowDoubleHalants = plan.unicodeScript !== 'Malayalam';\n      for (let i = base + 1; i < end; i++) if (glyphs[i].shaperInfo.category === (0, $90a9d3398ee54fe5$export$a513ea61a7bee91c).H) {\n        let j;\n        for (j = end - 1; j > i; j--) {\n          if ($7826f90f6f0cecc9$var$isConsonant(glyphs[j]) || disallowDoubleHalants && glyphs[j].shaperInfo.category === (0, $90a9d3398ee54fe5$export$a513ea61a7bee91c).H) break;\n        }\n        if (glyphs[j].shaperInfo.category !== (0, $90a9d3398ee54fe5$export$a513ea61a7bee91c).H && j > i) {\n          // Move Halant to after last consonant.\n          let t = glyphs[i];\n          glyphs.splice(i, 0, ...glyphs.splice(i + 1, j - i));\n          glyphs[j] = t;\n        }\n        break;\n      }\n    }\n    // Attach misc marks to previous char to move with them.\n    let lastPos = (0, $90a9d3398ee54fe5$export$1a1f61c9c4dd9df0).Start;\n    for (let i = start; i < end; i++) {\n      let info = glyphs[i].shaperInfo;\n      if (info.category & ((0, $90a9d3398ee54fe5$export$bbcd928767338e0d) | (0, $90a9d3398ee54fe5$export$a513ea61a7bee91c).N | (0, $90a9d3398ee54fe5$export$a513ea61a7bee91c).RS | (0, $90a9d3398ee54fe5$export$a513ea61a7bee91c).CM | (0, $90a9d3398ee54fe5$export$ca9599b2a300afc) & info.category)) {\n        info.position = lastPos;\n        if (info.category === (0, $90a9d3398ee54fe5$export$a513ea61a7bee91c).H && info.position === (0, $90a9d3398ee54fe5$export$1a1f61c9c4dd9df0).Pre_M) {\n          // Uniscribe doesn't move the Halant with Left Matra.\n          // TEST: U+092B,U+093F,U+094DE\n          // We follow.  This is important for the Sinhala\n          // U+0DDA split matra since it decomposes to U+0DD9,U+0DCA\n          // where U+0DD9 is a left matra and U+0DCA is the virama.\n          // We don't want to move the virama with the left matra.\n          // TEST: U+0D9A,U+0DDA\n          for (let j = i; j > start; j--) if (glyphs[j - 1].shaperInfo.position !== (0, $90a9d3398ee54fe5$export$1a1f61c9c4dd9df0).Pre_M) {\n            info.position = glyphs[j - 1].shaperInfo.position;\n            break;\n          }\n        }\n      } else if (info.position !== (0, $90a9d3398ee54fe5$export$1a1f61c9c4dd9df0).SMVD) lastPos = info.position;\n    }\n    // For post-base consonants let them own anything before them\n    // since the last consonant or matra.\n    let last = base;\n    for (let i = base + 1; i < end; i++) {\n      if ($7826f90f6f0cecc9$var$isConsonant(glyphs[i])) {\n        for (let j = last + 1; j < i; j++) if (glyphs[j].shaperInfo.position < (0, $90a9d3398ee54fe5$export$1a1f61c9c4dd9df0).SMVD) glyphs[j].shaperInfo.position = glyphs[i].shaperInfo.position;\n        last = i;\n      } else if (glyphs[i].shaperInfo.category === (0, $90a9d3398ee54fe5$export$a513ea61a7bee91c).M) last = i;\n    }\n    let arr = glyphs.slice(start, end);\n    arr.sort((a, b) => a.shaperInfo.position - b.shaperInfo.position);\n    glyphs.splice(start, arr.length, ...arr);\n    // Find base again\n    for (let i = start; i < end; i++) if (glyphs[i].shaperInfo.position === (0, $90a9d3398ee54fe5$export$1a1f61c9c4dd9df0).Base_C) {\n      base = i;\n      break;\n    }\n    // Setup features now\n    // Reph\n    for (let i = start; i < end && glyphs[i].shaperInfo.position === (0, $90a9d3398ee54fe5$export$1a1f61c9c4dd9df0).Ra_To_Become_Reph; i++) glyphs[i].features.rphf = true;\n    // Pre-base\n    let blwf = !plan.isOldSpec && indicConfig.blwfMode === 'Pre_And_Post';\n    for (let i = start; i < base; i++) {\n      glyphs[i].features.half = true;\n      if (blwf) glyphs[i].features.blwf = true;\n    }\n    // Post-base\n    for (let i = base + 1; i < end; i++) {\n      glyphs[i].features.abvf = true;\n      glyphs[i].features.pstf = true;\n      glyphs[i].features.blwf = true;\n    }\n    if (plan.isOldSpec && plan.unicodeScript === 'Devanagari') {\n      // Old-spec eye-lash Ra needs special handling.  From the\n      // spec:\n      //\n      // \"The feature 'below-base form' is applied to consonants\n      // having below-base forms and following the base consonant.\n      // The exception is vattu, which may appear below half forms\n      // as well as below the base glyph. The feature 'below-base\n      // form' will be applied to all such occurrences of Ra as well.\"\n      //\n      // Test case: U+0924,U+094D,U+0930,U+094d,U+0915\n      // with Sanskrit 2003 font.\n      //\n      // However, note that Ra,Halant,ZWJ is the correct way to\n      // request eyelash form of Ra, so we wouldbn't inhibit it\n      // in that sequence.\n      //\n      // Test case: U+0924,U+094D,U+0930,U+094d,U+200D,U+0915\n      for (let i = start; i + 1 < base; i++) if (glyphs[i].shaperInfo.category === (0, $90a9d3398ee54fe5$export$a513ea61a7bee91c).Ra && glyphs[i + 1].shaperInfo.category === (0, $90a9d3398ee54fe5$export$a513ea61a7bee91c).H && (i + 1 === base || glyphs[i + 2].shaperInfo.category === (0, $90a9d3398ee54fe5$export$a513ea61a7bee91c).ZWJ)) {\n        glyphs[i].features.blwf = true;\n        glyphs[i + 1].features.blwf = true;\n      }\n    }\n    let prefLen = 2;\n    if (features.pref && base + prefLen < end)\n      // Find a Halant,Ra sequence and mark it for pre-base reordering processing.\n      for (let i = base + 1; i + prefLen - 1 < end; i++) {\n        let g = [glyphs[i].copy(), glyphs[i + 1].copy()];\n        if ($7826f90f6f0cecc9$var$wouldSubstitute(g, 'pref')) {\n          for (let j = 0; j < prefLen; j++) glyphs[i++].features.pref = true;\n          // Mark the subsequent stuff with 'cfar'.  Used in Khmer.\n          // Read the feature spec.\n          // This allows distinguishing the following cases with MS Khmer fonts:\n          // U+1784,U+17D2,U+179A,U+17D2,U+1782\n          // U+1784,U+17D2,U+1782,U+17D2,U+179A\n          if (features.cfar) for (; i < end; i++) glyphs[i].features.cfar = true;\n          break;\n        }\n      }\n    // Apply ZWJ/ZWNJ effects\n    for (let i = start + 1; i < end; i++) if ($7826f90f6f0cecc9$var$isJoiner(glyphs[i])) {\n      let nonJoiner = glyphs[i].shaperInfo.category === (0, $90a9d3398ee54fe5$export$a513ea61a7bee91c).ZWNJ;\n      let j = i;\n      do {\n        j--;\n        // ZWJ/ZWNJ should disable CJCT.  They do that by simply\n        // being there, since we don't skip them for the CJCT\n        // feature (ie. F_MANUAL_ZWJ)\n        // A ZWNJ disables HALF.\n        if (nonJoiner) delete glyphs[j].features.half;\n      } while (j > start && !$7826f90f6f0cecc9$var$isConsonant(glyphs[j]));\n    }\n  }\n}\nfunction $7826f90f6f0cecc9$var$finalReordering(font, glyphs, plan) {\n  let indicConfig = plan.indicConfig;\n  let features = font._layoutEngine.engine.GSUBProcessor.features;\n  for (let start = 0, end = $7826f90f6f0cecc9$var$nextSyllable(glyphs, 0); start < glyphs.length; start = end, end = $7826f90f6f0cecc9$var$nextSyllable(glyphs, start)) {\n    // 4. Final reordering:\n    //\n    // After the localized forms and basic shaping forms GSUB features have been\n    // applied (see below), the shaping engine performs some final glyph\n    // reordering before applying all the remaining font features to the entire\n    // cluster.\n    let tryPref = !!features.pref;\n    // Find base again\n    let base = start;\n    for (; base < end; base++) if (glyphs[base].shaperInfo.position >= (0, $90a9d3398ee54fe5$export$1a1f61c9c4dd9df0).Base_C) {\n      if (tryPref && base + 1 < end) {\n        for (let i = base + 1; i < end; i++) if (glyphs[i].features.pref) {\n          if (!(glyphs[i].substituted && glyphs[i].isLigated && !glyphs[i].isMultiplied)) {\n            // Ok, this was a 'pref' candidate but didn't form any.\n            // Base is around here...\n            base = i;\n            while (base < end && $7826f90f6f0cecc9$var$isHalantOrCoeng(glyphs[base])) base++;\n            glyphs[base].shaperInfo.position = (0, $90a9d3398ee54fe5$export$1a1f61c9c4dd9df0).BASE_C;\n            tryPref = false;\n          }\n          break;\n        }\n      }\n      // For Malayalam, skip over unformed below- (but NOT post-) forms.\n      if (plan.unicodeScript === 'Malayalam') for (let i = base + 1; i < end; i++) {\n        while (i < end && $7826f90f6f0cecc9$var$isJoiner(glyphs[i])) i++;\n        if (i === end || !$7826f90f6f0cecc9$var$isHalantOrCoeng(glyphs[i])) break;\n        i++; // Skip halant.\n        while (i < end && $7826f90f6f0cecc9$var$isJoiner(glyphs[i])) i++;\n        if (i < end && $7826f90f6f0cecc9$var$isConsonant(glyphs[i]) && glyphs[i].shaperInfo.position === (0, $90a9d3398ee54fe5$export$1a1f61c9c4dd9df0).Below_C) {\n          base = i;\n          glyphs[base].shaperInfo.position = (0, $90a9d3398ee54fe5$export$1a1f61c9c4dd9df0).Base_C;\n        }\n      }\n      if (start < base && glyphs[base].shaperInfo.position > (0, $90a9d3398ee54fe5$export$1a1f61c9c4dd9df0).Base_C) base--;\n      break;\n    }\n    if (base === end && start < base && glyphs[base - 1].shaperInfo.category === (0, $90a9d3398ee54fe5$export$a513ea61a7bee91c).ZWJ) base--;\n    if (base < end) while (start < base && glyphs[base].shaperInfo.category & ((0, $90a9d3398ee54fe5$export$a513ea61a7bee91c).N | (0, $90a9d3398ee54fe5$export$ca9599b2a300afc))) base--;\n    // o Reorder matras:\n    //\n    // If a pre-base matra character had been reordered before applying basic\n    // features, the glyph can be moved closer to the main consonant based on\n    // whether half-forms had been formed. Actual position for the matra is\n    // defined as after last standalone halant glyph, after initial matra\n    // position and before the main consonant. If ZWJ or ZWNJ follow this\n    // halant, position is moved after it.\n    //\n    if (start + 1 < end && start < base) {\n      // If we lost track of base, alas, position before last thingy.\n      let newPos = base === end ? base - 2 : base - 1;\n      // Malayalam / Tamil do not have \"half\" forms or explicit virama forms.\n      // The glyphs formed by 'half' are Chillus or ligated explicit viramas.\n      // We want to position matra after them.\n      if (plan.unicodeScript !== 'Malayalam' && plan.unicodeScript !== 'Tamil') {\n        while (newPos > start && !(glyphs[newPos].shaperInfo.category & ((0, $90a9d3398ee54fe5$export$a513ea61a7bee91c).M | (0, $90a9d3398ee54fe5$export$ca9599b2a300afc)))) newPos--;\n        // If we found no Halant we are done.\n        // Otherwise only proceed if the Halant does\n        // not belong to the Matra itself!\n        if ($7826f90f6f0cecc9$var$isHalantOrCoeng(glyphs[newPos]) && glyphs[newPos].shaperInfo.position !== (0, $90a9d3398ee54fe5$export$1a1f61c9c4dd9df0).Pre_M)\n          // If ZWJ or ZWNJ follow this halant, position is moved after it.\n          {\n            if (newPos + 1 < end && $7826f90f6f0cecc9$var$isJoiner(glyphs[newPos + 1])) newPos++;\n          } else newPos = start; // No move.\n      }\n      if (start < newPos && glyphs[newPos].shaperInfo.position !== (0, $90a9d3398ee54fe5$export$1a1f61c9c4dd9df0).Pre_M) {\n        // Now go see if there's actually any matras...\n        for (let i = newPos; i > start; i--) if (glyphs[i - 1].shaperInfo.position === (0, $90a9d3398ee54fe5$export$1a1f61c9c4dd9df0).Pre_M) {\n          let oldPos = i - 1;\n          if (oldPos < base && base <= newPos) base--;\n          let tmp = glyphs[oldPos];\n          glyphs.splice(oldPos, 0, ...glyphs.splice(oldPos + 1, newPos - oldPos));\n          glyphs[newPos] = tmp;\n          newPos--;\n        }\n      }\n    }\n    // o Reorder reph:\n    //\n    // Rephs original position is always at the beginning of the syllable,\n    // (i.e. it is not reordered at the character reordering stage). However,\n    // it will be reordered according to the basic-forms shaping results.\n    // Possible positions for reph, depending on the script, are; after main,\n    // before post-base consonant forms, and after post-base consonant forms.\n    // Two cases:\n    //\n    // - If repha is encoded as a sequence of characters (Ra,H or Ra,H,ZWJ), then\n    //   we should only move it if the sequence ligated to the repha form.\n    //\n    // - If repha is encoded separately and in the logical position, we should only\n    //   move it if it did NOT ligate.  If it ligated, it's probably the font trying\n    //   to make it work without the reordering.\n    if (start + 1 < end && glyphs[start].shaperInfo.position === (0, $90a9d3398ee54fe5$export$1a1f61c9c4dd9df0).Ra_To_Become_Reph && glyphs[start].shaperInfo.category === (0, $90a9d3398ee54fe5$export$a513ea61a7bee91c).Repha !== (glyphs[start].isLigated && !glyphs[start].isMultiplied)) {\n      let newRephPos;\n      let rephPos = indicConfig.rephPos;\n      let found = false;\n      // 1. If reph should be positioned after post-base consonant forms,\n      //    proceed to step 5.\n      if (rephPos !== (0, $90a9d3398ee54fe5$export$1a1f61c9c4dd9df0).After_Post) {\n        //  2. If the reph repositioning class is not after post-base: target\n        //     position is after the first explicit halant glyph between the\n        //     first post-reph consonant and last main consonant. If ZWJ or ZWNJ\n        //     are following this halant, position is moved after it. If such\n        //     position is found, this is the target position. Otherwise,\n        //     proceed to the next step.\n        //\n        //     Note: in old-implementation fonts, where classifications were\n        //     fixed in shaping engine, there was no case where reph position\n        //     will be found on this step.\n        newRephPos = start + 1;\n        while (newRephPos < base && !$7826f90f6f0cecc9$var$isHalantOrCoeng(glyphs[newRephPos])) newRephPos++;\n        if (newRephPos < base && $7826f90f6f0cecc9$var$isHalantOrCoeng(glyphs[newRephPos])) {\n          // ->If ZWJ or ZWNJ are following this halant, position is moved after it.\n          if (newRephPos + 1 < base && $7826f90f6f0cecc9$var$isJoiner(glyphs[newRephPos + 1])) newRephPos++;\n          found = true;\n        }\n        // 3. If reph should be repositioned after the main consonant: find the\n        //    first consonant not ligated with main, or find the first\n        //    consonant that is not a potential pre-base reordering Ra.\n        if (!found && rephPos === (0, $90a9d3398ee54fe5$export$1a1f61c9c4dd9df0).After_Main) {\n          newRephPos = base;\n          while (newRephPos + 1 < end && glyphs[newRephPos + 1].shaperInfo.position <= (0, $90a9d3398ee54fe5$export$1a1f61c9c4dd9df0).After_Main) newRephPos++;\n          found = newRephPos < end;\n        }\n        // 4. If reph should be positioned before post-base consonant, find\n        //    first post-base classified consonant not ligated with main. If no\n        //    consonant is found, the target position should be before the\n        //    first matra, syllable modifier sign or vedic sign.\n        //\n        // This is our take on what step 4 is trying to say (and failing, BADLY).\n        if (!found && rephPos === (0, $90a9d3398ee54fe5$export$1a1f61c9c4dd9df0).After_Sub) {\n          newRephPos = base;\n          while (newRephPos + 1 < end && !(glyphs[newRephPos + 1].shaperInfo.position & ((0, $90a9d3398ee54fe5$export$1a1f61c9c4dd9df0).Post_C | (0, $90a9d3398ee54fe5$export$1a1f61c9c4dd9df0).After_Post | (0, $90a9d3398ee54fe5$export$1a1f61c9c4dd9df0).SMVD))) newRephPos++;\n          found = newRephPos < end;\n        }\n      }\n      //  5. If no consonant is found in steps 3 or 4, move reph to a position\n      //     immediately before the first post-base matra, syllable modifier\n      //     sign or vedic sign that has a reordering class after the intended\n      //     reph position. For example, if the reordering position for reph\n      //     is post-main, it will skip above-base matras that also have a\n      //     post-main position.\n      if (!found) {\n        // Copied from step 2.\n        newRephPos = start + 1;\n        while (newRephPos < base && !$7826f90f6f0cecc9$var$isHalantOrCoeng(glyphs[newRephPos])) newRephPos++;\n        if (newRephPos < base && $7826f90f6f0cecc9$var$isHalantOrCoeng(glyphs[newRephPos])) {\n          // ->If ZWJ or ZWNJ are following this halant, position is moved after it.\n          if (newRephPos + 1 < base && $7826f90f6f0cecc9$var$isJoiner(glyphs[newRephPos + 1])) newRephPos++;\n          found = true;\n        }\n      }\n      // 6. Otherwise, reorder reph to the end of the syllable.\n      if (!found) {\n        newRephPos = end - 1;\n        while (newRephPos > start && glyphs[newRephPos].shaperInfo.position === (0, $90a9d3398ee54fe5$export$1a1f61c9c4dd9df0).SMVD) newRephPos--;\n        // If the Reph is to be ending up after a Matra,Halant sequence,\n        // position it before that Halant so it can interact with the Matra.\n        // However, if it's a plain Consonant,Halant we shouldn't do that.\n        // Uniscribe doesn't do this.\n        // TEST: U+0930,U+094D,U+0915,U+094B,U+094D\n        if ($7826f90f6f0cecc9$var$isHalantOrCoeng(glyphs[newRephPos])) {\n          for (let i = base + 1; i < newRephPos; i++) if (glyphs[i].shaperInfo.category === (0, $90a9d3398ee54fe5$export$a513ea61a7bee91c).M) newRephPos--;\n        }\n      }\n      let reph = glyphs[start];\n      glyphs.splice(start, 0, ...glyphs.splice(start + 1, newRephPos - start));\n      glyphs[newRephPos] = reph;\n      if (start < base && base <= newRephPos) base--;\n    }\n    // o Reorder pre-base reordering consonants:\n    //\n    // If a pre-base reordering consonant is found, reorder it according to\n    // the following rules:\n    if (tryPref && base + 1 < end) {\n      for (let i = base + 1; i < end; i++) if (glyphs[i].features.pref) {\n        // 1. Only reorder a glyph produced by substitution during application\n        //    of the <pref> feature. (Note that a font may shape a Ra consonant with\n        //    the feature generally but block it in certain contexts.)\n        // Note: We just check that something got substituted.  We don't check that\n        // the <pref> feature actually did it...\n        //\n        // Reorder pref only if it ligated.\n        if (glyphs[i].isLigated && !glyphs[i].isMultiplied) {\n          // 2. Try to find a target position the same way as for pre-base matra.\n          //    If it is found, reorder pre-base consonant glyph.\n          //\n          // 3. If position is not found, reorder immediately before main\n          //    consonant.\n          let newPos = base;\n          // Malayalam / Tamil do not have \"half\" forms or explicit virama forms.\n          // The glyphs formed by 'half' are Chillus or ligated explicit viramas.\n          // We want to position matra after them.\n          if (plan.unicodeScript !== 'Malayalam' && plan.unicodeScript !== 'Tamil') {\n            while (newPos > start && !(glyphs[newPos - 1].shaperInfo.category & ((0, $90a9d3398ee54fe5$export$a513ea61a7bee91c).M | (0, $90a9d3398ee54fe5$export$ca9599b2a300afc)))) newPos--;\n            // In Khmer coeng model, a H,Ra can go *after* matras.  If it goes after a\n            // split matra, it should be reordered to *before* the left part of such matra.\n            if (newPos > start && glyphs[newPos - 1].shaperInfo.category === (0, $90a9d3398ee54fe5$export$a513ea61a7bee91c).M) {\n              let oldPos = i;\n              for (let j = base + 1; j < oldPos; j++) if (glyphs[j].shaperInfo.category === (0, $90a9d3398ee54fe5$export$a513ea61a7bee91c).M) {\n                newPos--;\n                break;\n              }\n            }\n          }\n          if (newPos > start && $7826f90f6f0cecc9$var$isHalantOrCoeng(glyphs[newPos - 1]))\n            // -> If ZWJ or ZWNJ follow this halant, position is moved after it.\n            {\n              if (newPos < end && $7826f90f6f0cecc9$var$isJoiner(glyphs[newPos])) newPos++;\n            }\n          let oldPos = i;\n          let tmp = glyphs[oldPos];\n          glyphs.splice(newPos + 1, 0, ...glyphs.splice(newPos, oldPos - newPos));\n          glyphs[newPos] = tmp;\n          if (newPos <= base && base < oldPos) base++;\n        }\n        break;\n      }\n    }\n    // Apply 'init' to the Left Matra if it's a word start.\n    if (glyphs[start].shaperInfo.position === (0, $90a9d3398ee54fe5$export$1a1f61c9c4dd9df0).Pre_M && (!start || !/Cf|Mn/.test((0, $6uUbQ$getCategory)(glyphs[start - 1].codePoints[0])))) glyphs[start].features.init = true;\n  }\n}\nfunction $7826f90f6f0cecc9$var$nextSyllable(glyphs, start) {\n  if (start >= glyphs.length) return start;\n  let syllable = glyphs[start].shaperInfo.syllable;\n  while (++start < glyphs.length && glyphs[start].shaperInfo.syllable === syllable);\n  return start;\n}\nconst {\n  categories: $7ab494fe977143c6$var$categories,\n  decompositions: $7ab494fe977143c6$var$decompositions\n} = (0, (/*@__PURE__*/$parcel$interopDefault($aa333a9607471296$exports)));\nconst $7ab494fe977143c6$var$trie = new (0, $6uUbQ$unicodetrie)((0, $12727730ddfc8bfe$export$94fdf11bafc8de6b)(\"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\"));\nconst $7ab494fe977143c6$var$stateMachine = new (0, $6uUbQ$dfa)((0, (/*@__PURE__*/$parcel$interopDefault($aa333a9607471296$exports))));\nclass $7ab494fe977143c6$export$2e2bcd8739ae039 extends (0, $649970d87335b30f$export$2e2bcd8739ae039) {\n  static planFeatures(plan) {\n    plan.addStage($7ab494fe977143c6$var$setupSyllables);\n    // Default glyph pre-processing group\n    plan.addStage(['locl', 'ccmp', 'nukt', 'akhn']);\n    // Reordering group\n    plan.addStage($7ab494fe977143c6$var$clearSubstitutionFlags);\n    plan.addStage(['rphf'], false);\n    plan.addStage($7ab494fe977143c6$var$recordRphf);\n    plan.addStage($7ab494fe977143c6$var$clearSubstitutionFlags);\n    plan.addStage(['pref']);\n    plan.addStage($7ab494fe977143c6$var$recordPref);\n    // Orthographic unit shaping group\n    plan.addStage(['rkrf', 'abvf', 'blwf', 'half', 'pstf', 'vatu', 'cjct']);\n    plan.addStage($7ab494fe977143c6$var$reorder);\n    // Topographical features\n    // Scripts that need this are handled by the Arabic shaper, not implemented here for now.\n    // plan.addStage(['isol', 'init', 'medi', 'fina', 'med2', 'fin2', 'fin3'], false);\n    // Standard topographic presentation and positional feature application\n    plan.addStage(['abvs', 'blws', 'pres', 'psts', 'dist', 'abvm', 'blwm']);\n  }\n  static assignFeatures(plan, glyphs) {\n    // Decompose split vowels\n    // TODO: do this in a more general unicode normalizer\n    for (let i = glyphs.length - 1; i >= 0; i--) {\n      let codepoint = glyphs[i].codePoints[0];\n      if ($7ab494fe977143c6$var$decompositions[codepoint]) {\n        let decomposed = $7ab494fe977143c6$var$decompositions[codepoint].map(c => {\n          let g = plan.font.glyphForCodePoint(c);\n          return new (0, $10e7b257e1a9a756$export$2e2bcd8739ae039)(plan.font, g.id, [c], glyphs[i].features);\n        });\n        glyphs.splice(i, 1, ...decomposed);\n      }\n    }\n  }\n}\n(0, $6uUbQ$_)($7ab494fe977143c6$export$2e2bcd8739ae039, \"zeroMarkWidths\", 'BEFORE_GPOS');\nfunction $7ab494fe977143c6$var$useCategory(glyph) {\n  return $7ab494fe977143c6$var$trie.get(glyph.codePoints[0]);\n}\nclass $7ab494fe977143c6$var$USEInfo {\n  constructor(category, syllableType, syllable) {\n    this.category = category;\n    this.syllableType = syllableType;\n    this.syllable = syllable;\n  }\n}\nfunction $7ab494fe977143c6$var$setupSyllables(font, glyphs) {\n  let syllable = 0;\n  for (let [start, end, tags] of $7ab494fe977143c6$var$stateMachine.match(glyphs.map($7ab494fe977143c6$var$useCategory))) {\n    ++syllable;\n    // Create shaper info\n    for (let i = start; i <= end; i++) glyphs[i].shaperInfo = new $7ab494fe977143c6$var$USEInfo($7ab494fe977143c6$var$categories[$7ab494fe977143c6$var$useCategory(glyphs[i])], tags[0], syllable);\n    // Assign rphf feature\n    let limit = glyphs[start].shaperInfo.category === 'R' ? 1 : Math.min(3, end - start);\n    for (let i = start; i < start + limit; i++) glyphs[i].features.rphf = true;\n  }\n}\nfunction $7ab494fe977143c6$var$clearSubstitutionFlags(font, glyphs) {\n  for (let glyph of glyphs) glyph.substituted = false;\n}\nfunction $7ab494fe977143c6$var$recordRphf(font, glyphs) {\n  for (let glyph of glyphs) if (glyph.substituted && glyph.features.rphf)\n    // Mark a substituted repha.\n    glyph.shaperInfo.category = 'R';\n}\nfunction $7ab494fe977143c6$var$recordPref(font, glyphs) {\n  for (let glyph of glyphs) if (glyph.substituted)\n    // Mark a substituted pref as VPre, as they behave the same way.\n    glyph.shaperInfo.category = 'VPre';\n}\nfunction $7ab494fe977143c6$var$reorder(font, glyphs) {\n  let dottedCircle = font.glyphForCodePoint(0x25cc).id;\n  for (let start = 0, end = $7ab494fe977143c6$var$nextSyllable(glyphs, 0); start < glyphs.length; start = end, end = $7ab494fe977143c6$var$nextSyllable(glyphs, start)) {\n    let i, j;\n    let info = glyphs[start].shaperInfo;\n    let type = info.syllableType;\n    // Only a few syllable types need reordering.\n    if (type !== 'virama_terminated_cluster' && type !== 'standard_cluster' && type !== 'broken_cluster') continue;\n    // Insert a dotted circle glyph in broken clusters.\n    if (type === 'broken_cluster' && dottedCircle) {\n      let g = new (0, $10e7b257e1a9a756$export$2e2bcd8739ae039)(font, dottedCircle, [0x25cc]);\n      g.shaperInfo = info;\n      // Insert after possible Repha.\n      for (i = start; i < end && glyphs[i].shaperInfo.category === 'R'; i++);\n      glyphs.splice(++i, 0, g);\n      end++;\n    }\n    // Move things forward.\n    if (info.category === 'R' && end - start > 1)\n      // Got a repha. Reorder it to after first base, before first halant.\n      for (i = start + 1; i < end; i++) {\n        info = glyphs[i].shaperInfo;\n        if ($7ab494fe977143c6$var$isBase(info) || $7ab494fe977143c6$var$isHalant(glyphs[i])) {\n          // If we hit a halant, move before it; otherwise it's a base: move to it's\n          // place, and shift things in between backward.\n          if ($7ab494fe977143c6$var$isHalant(glyphs[i])) i--;\n          glyphs.splice(start, 0, ...glyphs.splice(start + 1, i - start), glyphs[i]);\n          break;\n        }\n      }\n    // Move things back.\n    for (i = start, j = end; i < end; i++) {\n      info = glyphs[i].shaperInfo;\n      if ($7ab494fe977143c6$var$isBase(info) || $7ab494fe977143c6$var$isHalant(glyphs[i]))\n        // If we hit a halant, move after it; otherwise it's a base: move to it's\n        // place, and shift things in between backward.\n        j = $7ab494fe977143c6$var$isHalant(glyphs[i]) ? i + 1 : i;else if ((info.category === 'VPre' || info.category === 'VMPre') && j < i) glyphs.splice(j, 1, glyphs[i], ...glyphs.splice(j, i - j));\n    }\n  }\n}\nfunction $7ab494fe977143c6$var$nextSyllable(glyphs, start) {\n  if (start >= glyphs.length) return start;\n  let syllable = glyphs[start].shaperInfo.syllable;\n  while (++start < glyphs.length && glyphs[start].shaperInfo.syllable === syllable);\n  return start;\n}\nfunction $7ab494fe977143c6$var$isHalant(glyph) {\n  return glyph.shaperInfo.category === 'H' && !glyph.isLigated;\n}\nfunction $7ab494fe977143c6$var$isBase(info) {\n  return info.category === 'B' || info.category === 'GB';\n}\nconst $102b6fe50f1d50b4$var$SHAPERS = {\n  arab: (0, $764eb544bbe1ccf0$export$2e2bcd8739ae039),\n  mong: (0, $764eb544bbe1ccf0$export$2e2bcd8739ae039),\n  syrc: (0, $764eb544bbe1ccf0$export$2e2bcd8739ae039),\n  'nko ': (0, $764eb544bbe1ccf0$export$2e2bcd8739ae039),\n  phag: (0, $764eb544bbe1ccf0$export$2e2bcd8739ae039),\n  mand: (0, $764eb544bbe1ccf0$export$2e2bcd8739ae039),\n  mani: (0, $764eb544bbe1ccf0$export$2e2bcd8739ae039),\n  phlp: (0, $764eb544bbe1ccf0$export$2e2bcd8739ae039),\n  hang: (0, $e1c6bbc8cb416f8c$export$2e2bcd8739ae039),\n  bng2: (0, $7826f90f6f0cecc9$export$2e2bcd8739ae039),\n  beng: (0, $7826f90f6f0cecc9$export$2e2bcd8739ae039),\n  dev2: (0, $7826f90f6f0cecc9$export$2e2bcd8739ae039),\n  deva: (0, $7826f90f6f0cecc9$export$2e2bcd8739ae039),\n  gjr2: (0, $7826f90f6f0cecc9$export$2e2bcd8739ae039),\n  gujr: (0, $7826f90f6f0cecc9$export$2e2bcd8739ae039),\n  guru: (0, $7826f90f6f0cecc9$export$2e2bcd8739ae039),\n  gur2: (0, $7826f90f6f0cecc9$export$2e2bcd8739ae039),\n  knda: (0, $7826f90f6f0cecc9$export$2e2bcd8739ae039),\n  knd2: (0, $7826f90f6f0cecc9$export$2e2bcd8739ae039),\n  mlm2: (0, $7826f90f6f0cecc9$export$2e2bcd8739ae039),\n  mlym: (0, $7826f90f6f0cecc9$export$2e2bcd8739ae039),\n  ory2: (0, $7826f90f6f0cecc9$export$2e2bcd8739ae039),\n  orya: (0, $7826f90f6f0cecc9$export$2e2bcd8739ae039),\n  taml: (0, $7826f90f6f0cecc9$export$2e2bcd8739ae039),\n  tml2: (0, $7826f90f6f0cecc9$export$2e2bcd8739ae039),\n  telu: (0, $7826f90f6f0cecc9$export$2e2bcd8739ae039),\n  tel2: (0, $7826f90f6f0cecc9$export$2e2bcd8739ae039),\n  khmr: (0, $7826f90f6f0cecc9$export$2e2bcd8739ae039),\n  bali: (0, $7ab494fe977143c6$export$2e2bcd8739ae039),\n  batk: (0, $7ab494fe977143c6$export$2e2bcd8739ae039),\n  brah: (0, $7ab494fe977143c6$export$2e2bcd8739ae039),\n  bugi: (0, $7ab494fe977143c6$export$2e2bcd8739ae039),\n  buhd: (0, $7ab494fe977143c6$export$2e2bcd8739ae039),\n  cakm: (0, $7ab494fe977143c6$export$2e2bcd8739ae039),\n  cham: (0, $7ab494fe977143c6$export$2e2bcd8739ae039),\n  dupl: (0, $7ab494fe977143c6$export$2e2bcd8739ae039),\n  egyp: (0, $7ab494fe977143c6$export$2e2bcd8739ae039),\n  gran: (0, $7ab494fe977143c6$export$2e2bcd8739ae039),\n  hano: (0, $7ab494fe977143c6$export$2e2bcd8739ae039),\n  java: (0, $7ab494fe977143c6$export$2e2bcd8739ae039),\n  kthi: (0, $7ab494fe977143c6$export$2e2bcd8739ae039),\n  kali: (0, $7ab494fe977143c6$export$2e2bcd8739ae039),\n  khar: (0, $7ab494fe977143c6$export$2e2bcd8739ae039),\n  khoj: (0, $7ab494fe977143c6$export$2e2bcd8739ae039),\n  sind: (0, $7ab494fe977143c6$export$2e2bcd8739ae039),\n  lepc: (0, $7ab494fe977143c6$export$2e2bcd8739ae039),\n  limb: (0, $7ab494fe977143c6$export$2e2bcd8739ae039),\n  mahj: (0, $7ab494fe977143c6$export$2e2bcd8739ae039),\n  // mand: UniversalShaper, // Mandaic\n  // mani: UniversalShaper, // Manichaean\n  mtei: (0, $7ab494fe977143c6$export$2e2bcd8739ae039),\n  modi: (0, $7ab494fe977143c6$export$2e2bcd8739ae039),\n  // mong: UniversalShaper, // Mongolian\n  // 'nko ': UniversalShaper, // NKo\n  hmng: (0, $7ab494fe977143c6$export$2e2bcd8739ae039),\n  // phag: UniversalShaper, // Phags-pa\n  // phlp: UniversalShaper, // Psalter Pahlavi\n  rjng: (0, $7ab494fe977143c6$export$2e2bcd8739ae039),\n  saur: (0, $7ab494fe977143c6$export$2e2bcd8739ae039),\n  shrd: (0, $7ab494fe977143c6$export$2e2bcd8739ae039),\n  sidd: (0, $7ab494fe977143c6$export$2e2bcd8739ae039),\n  sinh: (0, $7826f90f6f0cecc9$export$2e2bcd8739ae039),\n  sund: (0, $7ab494fe977143c6$export$2e2bcd8739ae039),\n  sylo: (0, $7ab494fe977143c6$export$2e2bcd8739ae039),\n  tglg: (0, $7ab494fe977143c6$export$2e2bcd8739ae039),\n  tagb: (0, $7ab494fe977143c6$export$2e2bcd8739ae039),\n  tale: (0, $7ab494fe977143c6$export$2e2bcd8739ae039),\n  lana: (0, $7ab494fe977143c6$export$2e2bcd8739ae039),\n  tavt: (0, $7ab494fe977143c6$export$2e2bcd8739ae039),\n  takr: (0, $7ab494fe977143c6$export$2e2bcd8739ae039),\n  tibt: (0, $7ab494fe977143c6$export$2e2bcd8739ae039),\n  tfng: (0, $7ab494fe977143c6$export$2e2bcd8739ae039),\n  tirh: (0, $7ab494fe977143c6$export$2e2bcd8739ae039),\n  latn: (0, $649970d87335b30f$export$2e2bcd8739ae039),\n  DFLT: (0, $649970d87335b30f$export$2e2bcd8739ae039 // Default\n  )\n};\nfunction $102b6fe50f1d50b4$export$7877a478dd30fd3d(script) {\n  if (!Array.isArray(script)) script = [script];\n  for (let s of script) {\n    let shaper = $102b6fe50f1d50b4$var$SHAPERS[s];\n    if (shaper) return shaper;\n  }\n  return 0, $649970d87335b30f$export$2e2bcd8739ae039;\n}\nclass $0a876c45f1f7c41c$export$2e2bcd8739ae039 extends (0, $a83b9c36aaa94fd3$export$2e2bcd8739ae039) {\n  applyLookup(lookupType, table) {\n    switch (lookupType) {\n      case 1:\n        {\n          let index = this.coverageIndex(table.coverage);\n          if (index === -1) return false;\n          let glyph = this.glyphIterator.cur;\n          switch (table.version) {\n            case 1:\n              glyph.id = glyph.id + table.deltaGlyphID & 0xffff;\n              break;\n            case 2:\n              glyph.id = table.substitute.get(index);\n              break;\n          }\n          return true;\n        }\n      case 2:\n        {\n          let index = this.coverageIndex(table.coverage);\n          if (index !== -1) {\n            let sequence = table.sequences.get(index);\n            if (sequence.length === 0) {\n              // If the sequence length is zero, delete the glyph.\n              // The OpenType spec disallows this, but seems like Harfbuzz and Uniscribe allow it.\n              this.glyphs.splice(this.glyphIterator.index, 1);\n              return true;\n            }\n            this.glyphIterator.cur.id = sequence[0];\n            this.glyphIterator.cur.ligatureComponent = 0;\n            let features = this.glyphIterator.cur.features;\n            let curGlyph = this.glyphIterator.cur;\n            let replacement = sequence.slice(1).map((gid, i) => {\n              let glyph = new (0, $10e7b257e1a9a756$export$2e2bcd8739ae039)(this.font, gid, undefined, features);\n              glyph.shaperInfo = curGlyph.shaperInfo;\n              glyph.isLigated = curGlyph.isLigated;\n              glyph.ligatureComponent = i + 1;\n              glyph.substituted = true;\n              glyph.isMultiplied = true;\n              return glyph;\n            });\n            this.glyphs.splice(this.glyphIterator.index + 1, 0, ...replacement);\n            return true;\n          }\n          return false;\n        }\n      case 3:\n        {\n          let index = this.coverageIndex(table.coverage);\n          if (index !== -1) {\n            let USER_INDEX = 0; // TODO\n            this.glyphIterator.cur.id = table.alternateSet.get(index)[USER_INDEX];\n            return true;\n          }\n          return false;\n        }\n      case 4:\n        {\n          let index = this.coverageIndex(table.coverage);\n          if (index === -1) return false;\n          for (let ligature of table.ligatureSets.get(index)) {\n            let matched = this.sequenceMatchIndices(1, ligature.components);\n            if (!matched) continue;\n            let curGlyph = this.glyphIterator.cur;\n            // Concatenate all of the characters the new ligature will represent\n            let characters = curGlyph.codePoints.slice();\n            for (let index of matched) characters.push(...this.glyphs[index].codePoints);\n            // Create the replacement ligature glyph\n            let ligatureGlyph = new (0, $10e7b257e1a9a756$export$2e2bcd8739ae039)(this.font, ligature.glyph, characters, curGlyph.features);\n            ligatureGlyph.shaperInfo = curGlyph.shaperInfo;\n            ligatureGlyph.isLigated = true;\n            ligatureGlyph.substituted = true;\n            // From Harfbuzz:\n            // - If it *is* a mark ligature, we don't allocate a new ligature id, and leave\n            //   the ligature to keep its old ligature id.  This will allow it to attach to\n            //   a base ligature in GPOS.  Eg. if the sequence is: LAM,LAM,SHADDA,FATHA,HEH,\n            //   and LAM,LAM,HEH for a ligature, they will leave SHADDA and FATHA with a\n            //   ligature id and component value of 2.  Then if SHADDA,FATHA form a ligature\n            //   later, we don't want them to lose their ligature id/component, otherwise\n            //   GPOS will fail to correctly position the mark ligature on top of the\n            //   LAM,LAM,HEH ligature. See https://bugzilla.gnome.org/show_bug.cgi?id=676343\n            //\n            // - If a ligature is formed of components that some of which are also ligatures\n            //   themselves, and those ligature components had marks attached to *their*\n            //   components, we have to attach the marks to the new ligature component\n            //   positions!  Now *that*'s tricky!  And these marks may be following the\n            //   last component of the whole sequence, so we should loop forward looking\n            //   for them and update them.\n            //\n            //   Eg. the sequence is LAM,LAM,SHADDA,FATHA,HEH, and the font first forms a\n            //   'calt' ligature of LAM,HEH, leaving the SHADDA and FATHA with a ligature\n            //   id and component == 1.  Now, during 'liga', the LAM and the LAM-HEH ligature\n            //   form a LAM-LAM-HEH ligature.  We need to reassign the SHADDA and FATHA to\n            //   the new ligature with a component value of 2.\n            //\n            //   This in fact happened to a font...  See https://bugzilla.gnome.org/show_bug.cgi?id=437633\n            let isMarkLigature = curGlyph.isMark;\n            for (let i = 0; i < matched.length && isMarkLigature; i++) isMarkLigature = this.glyphs[matched[i]].isMark;\n            ligatureGlyph.ligatureID = isMarkLigature ? null : this.ligatureID++;\n            let lastLigID = curGlyph.ligatureID;\n            let lastNumComps = curGlyph.codePoints.length;\n            let curComps = lastNumComps;\n            let idx = this.glyphIterator.index + 1;\n            // Set ligatureID and ligatureComponent on glyphs that were skipped in the matched sequence.\n            // This allows GPOS to attach marks to the correct ligature components.\n            for (let matchIndex of matched) {\n              // Don't assign new ligature components for mark ligatures (see above)\n              if (isMarkLigature) idx = matchIndex;else while (idx < matchIndex) {\n                var ligatureComponent = curComps - lastNumComps + Math.min(this.glyphs[idx].ligatureComponent || 1, lastNumComps);\n                this.glyphs[idx].ligatureID = ligatureGlyph.ligatureID;\n                this.glyphs[idx].ligatureComponent = ligatureComponent;\n                idx++;\n              }\n              lastLigID = this.glyphs[idx].ligatureID;\n              lastNumComps = this.glyphs[idx].codePoints.length;\n              curComps += lastNumComps;\n              idx++; // skip base glyph\n            }\n            // Adjust ligature components for any marks following\n            if (lastLigID && !isMarkLigature) for (let i = idx; i < this.glyphs.length; i++) {\n              if (this.glyphs[i].ligatureID === lastLigID) {\n                var ligatureComponent = curComps - lastNumComps + Math.min(this.glyphs[i].ligatureComponent || 1, lastNumComps);\n                this.glyphs[i].ligatureComponent = ligatureComponent;\n              } else break;\n            }\n            // Delete the matched glyphs, and replace the current glyph with the ligature glyph\n            for (let i = matched.length - 1; i >= 0; i--) this.glyphs.splice(matched[i], 1);\n            this.glyphs[this.glyphIterator.index] = ligatureGlyph;\n            return true;\n          }\n          return false;\n        }\n      case 5:\n        return this.applyContext(table);\n      case 6:\n        return this.applyChainingContext(table);\n      case 7:\n        return this.applyLookup(table.lookupType, table.extension);\n      default:\n        throw new Error(`GSUB lookupType ${lookupType} is not supported`);\n    }\n  }\n}\nclass $c96c93587d49c14d$export$2e2bcd8739ae039 extends (0, $a83b9c36aaa94fd3$export$2e2bcd8739ae039) {\n  applyPositionValue(sequenceIndex, value) {\n    let position = this.positions[this.glyphIterator.peekIndex(sequenceIndex)];\n    if (value.xAdvance != null) position.xAdvance += value.xAdvance;\n    if (value.yAdvance != null) position.yAdvance += value.yAdvance;\n    if (value.xPlacement != null) position.xOffset += value.xPlacement;\n    if (value.yPlacement != null) position.yOffset += value.yPlacement;\n    // Adjustments for font variations\n    let variationProcessor = this.font._variationProcessor;\n    let variationStore = this.font.GDEF && this.font.GDEF.itemVariationStore;\n    if (variationProcessor && variationStore) {\n      if (value.xPlaDevice) position.xOffset += variationProcessor.getDelta(variationStore, value.xPlaDevice.a, value.xPlaDevice.b);\n      if (value.yPlaDevice) position.yOffset += variationProcessor.getDelta(variationStore, value.yPlaDevice.a, value.yPlaDevice.b);\n      if (value.xAdvDevice) position.xAdvance += variationProcessor.getDelta(variationStore, value.xAdvDevice.a, value.xAdvDevice.b);\n      if (value.yAdvDevice) position.yAdvance += variationProcessor.getDelta(variationStore, value.yAdvDevice.a, value.yAdvDevice.b);\n    }\n    // TODO: device tables\n  }\n  applyLookup(lookupType, table) {\n    switch (lookupType) {\n      case 1:\n        {\n          let index = this.coverageIndex(table.coverage);\n          if (index === -1) return false;\n          switch (table.version) {\n            case 1:\n              this.applyPositionValue(0, table.value);\n              break;\n            case 2:\n              this.applyPositionValue(0, table.values.get(index));\n              break;\n          }\n          return true;\n        }\n      case 2:\n        {\n          let nextGlyph = this.glyphIterator.peek();\n          if (!nextGlyph) return false;\n          let index = this.coverageIndex(table.coverage);\n          if (index === -1) return false;\n          switch (table.version) {\n            case 1:\n              let set = table.pairSets.get(index);\n              for (let pair of set) if (pair.secondGlyph === nextGlyph.id) {\n                this.applyPositionValue(0, pair.value1);\n                this.applyPositionValue(1, pair.value2);\n                return true;\n              }\n              return false;\n            case 2:\n              let class1 = this.getClassID(this.glyphIterator.cur.id, table.classDef1);\n              let class2 = this.getClassID(nextGlyph.id, table.classDef2);\n              if (class1 === -1 || class2 === -1) return false;\n              var pair = table.classRecords.get(class1).get(class2);\n              this.applyPositionValue(0, pair.value1);\n              this.applyPositionValue(1, pair.value2);\n              return true;\n          }\n        }\n      case 3:\n        {\n          let nextIndex = this.glyphIterator.peekIndex();\n          let nextGlyph = this.glyphs[nextIndex];\n          if (!nextGlyph) return false;\n          let curRecord = table.entryExitRecords[this.coverageIndex(table.coverage)];\n          if (!curRecord || !curRecord.exitAnchor) return false;\n          let nextRecord = table.entryExitRecords[this.coverageIndex(table.coverage, nextGlyph.id)];\n          if (!nextRecord || !nextRecord.entryAnchor) return false;\n          let entry = this.getAnchor(nextRecord.entryAnchor);\n          let exit = this.getAnchor(curRecord.exitAnchor);\n          let cur = this.positions[this.glyphIterator.index];\n          let next = this.positions[nextIndex];\n          let d;\n          switch (this.direction) {\n            case 'ltr':\n              cur.xAdvance = exit.x + cur.xOffset;\n              d = entry.x + next.xOffset;\n              next.xAdvance -= d;\n              next.xOffset -= d;\n              break;\n            case 'rtl':\n              d = exit.x + cur.xOffset;\n              cur.xAdvance -= d;\n              cur.xOffset -= d;\n              next.xAdvance = entry.x + next.xOffset;\n              break;\n          }\n          if (this.glyphIterator.flags.rightToLeft) {\n            this.glyphIterator.cur.cursiveAttachment = nextIndex;\n            cur.yOffset = entry.y - exit.y;\n          } else {\n            nextGlyph.cursiveAttachment = this.glyphIterator.index;\n            cur.yOffset = exit.y - entry.y;\n          }\n          return true;\n        }\n      case 4:\n        {\n          let markIndex = this.coverageIndex(table.markCoverage);\n          if (markIndex === -1) return false;\n          // search backward for a base glyph\n          let baseGlyphIndex = this.glyphIterator.index;\n          while (--baseGlyphIndex >= 0 && (this.glyphs[baseGlyphIndex].isMark || this.glyphs[baseGlyphIndex].ligatureComponent > 0));\n          if (baseGlyphIndex < 0) return false;\n          let baseIndex = this.coverageIndex(table.baseCoverage, this.glyphs[baseGlyphIndex].id);\n          if (baseIndex === -1) return false;\n          let markRecord = table.markArray[markIndex];\n          let baseAnchor = table.baseArray[baseIndex][markRecord.class];\n          this.applyAnchor(markRecord, baseAnchor, baseGlyphIndex);\n          return true;\n        }\n      case 5:\n        {\n          let markIndex = this.coverageIndex(table.markCoverage);\n          if (markIndex === -1) return false;\n          // search backward for a base glyph\n          let baseGlyphIndex = this.glyphIterator.index;\n          while (--baseGlyphIndex >= 0 && this.glyphs[baseGlyphIndex].isMark);\n          if (baseGlyphIndex < 0) return false;\n          let ligIndex = this.coverageIndex(table.ligatureCoverage, this.glyphs[baseGlyphIndex].id);\n          if (ligIndex === -1) return false;\n          let ligAttach = table.ligatureArray[ligIndex];\n          let markGlyph = this.glyphIterator.cur;\n          let ligGlyph = this.glyphs[baseGlyphIndex];\n          let compIndex = ligGlyph.ligatureID && ligGlyph.ligatureID === markGlyph.ligatureID && markGlyph.ligatureComponent > 0 ? Math.min(markGlyph.ligatureComponent, ligGlyph.codePoints.length) - 1 : ligGlyph.codePoints.length - 1;\n          let markRecord = table.markArray[markIndex];\n          let baseAnchor = ligAttach[compIndex][markRecord.class];\n          this.applyAnchor(markRecord, baseAnchor, baseGlyphIndex);\n          return true;\n        }\n      case 6:\n        {\n          let mark1Index = this.coverageIndex(table.mark1Coverage);\n          if (mark1Index === -1) return false;\n          // get the previous mark to attach to\n          let prevIndex = this.glyphIterator.peekIndex(-1);\n          let prev = this.glyphs[prevIndex];\n          if (!prev || !prev.isMark) return false;\n          let cur = this.glyphIterator.cur;\n          // The following logic was borrowed from Harfbuzz\n          let good = false;\n          if (cur.ligatureID === prev.ligatureID) {\n            if (!cur.ligatureID) good = true;else if (cur.ligatureComponent === prev.ligatureComponent) good = true;\n          } else\n            // If ligature ids don't match, it may be the case that one of the marks\n            // itself is a ligature, in which case match.\n            if (cur.ligatureID && !cur.ligatureComponent || prev.ligatureID && !prev.ligatureComponent) good = true;\n          if (!good) return false;\n          let mark2Index = this.coverageIndex(table.mark2Coverage, prev.id);\n          if (mark2Index === -1) return false;\n          let markRecord = table.mark1Array[mark1Index];\n          let baseAnchor = table.mark2Array[mark2Index][markRecord.class];\n          this.applyAnchor(markRecord, baseAnchor, prevIndex);\n          return true;\n        }\n      case 7:\n        return this.applyContext(table);\n      case 8:\n        return this.applyChainingContext(table);\n      case 9:\n        return this.applyLookup(table.lookupType, table.extension);\n      default:\n        throw new Error(`Unsupported GPOS table: ${lookupType}`);\n    }\n  }\n  applyAnchor(markRecord, baseAnchor, baseGlyphIndex) {\n    let baseCoords = this.getAnchor(baseAnchor);\n    let markCoords = this.getAnchor(markRecord.markAnchor);\n    let basePos = this.positions[baseGlyphIndex];\n    let markPos = this.positions[this.glyphIterator.index];\n    markPos.xOffset = baseCoords.x - markCoords.x;\n    markPos.yOffset = baseCoords.y - markCoords.y;\n    this.glyphIterator.cur.markAttachment = baseGlyphIndex;\n  }\n  getAnchor(anchor) {\n    // TODO: contour point, device tables\n    let x = anchor.xCoordinate;\n    let y = anchor.yCoordinate;\n    // Adjustments for font variations\n    let variationProcessor = this.font._variationProcessor;\n    let variationStore = this.font.GDEF && this.font.GDEF.itemVariationStore;\n    if (variationProcessor && variationStore) {\n      if (anchor.xDeviceTable) x += variationProcessor.getDelta(variationStore, anchor.xDeviceTable.a, anchor.xDeviceTable.b);\n      if (anchor.yDeviceTable) y += variationProcessor.getDelta(variationStore, anchor.yDeviceTable.a, anchor.yDeviceTable.b);\n    }\n    return {\n      x: x,\n      y: y\n    };\n  }\n  applyFeatures(userFeatures, glyphs, advances) {\n    super.applyFeatures(userFeatures, glyphs, advances);\n    for (var i = 0; i < this.glyphs.length; i++) this.fixCursiveAttachment(i);\n    this.fixMarkAttachment();\n  }\n  fixCursiveAttachment(i) {\n    let glyph = this.glyphs[i];\n    if (glyph.cursiveAttachment != null) {\n      let j = glyph.cursiveAttachment;\n      glyph.cursiveAttachment = null;\n      this.fixCursiveAttachment(j);\n      this.positions[i].yOffset += this.positions[j].yOffset;\n    }\n  }\n  fixMarkAttachment() {\n    for (let i = 0; i < this.glyphs.length; i++) {\n      let glyph = this.glyphs[i];\n      if (glyph.markAttachment != null) {\n        let j = glyph.markAttachment;\n        this.positions[i].xOffset += this.positions[j].xOffset;\n        this.positions[i].yOffset += this.positions[j].yOffset;\n        if (this.direction === 'ltr') for (let k = j; k < i; k++) {\n          this.positions[i].xOffset -= this.positions[k].xAdvance;\n          this.positions[i].yOffset -= this.positions[k].yAdvance;\n        } else for (let k = j + 1; k < i + 1; k++) {\n          this.positions[i].xOffset += this.positions[k].xAdvance;\n          this.positions[i].yOffset += this.positions[k].yAdvance;\n        }\n      }\n    }\n  }\n}\nclass $a62492810de27e3d$export$2e2bcd8739ae039 {\n  setup(glyphRun) {\n    // Map glyphs to GlyphInfo objects so data can be passed between\n    // GSUB and GPOS without mutating the real (shared) Glyph objects.\n    this.glyphInfos = glyphRun.glyphs.map(glyph => new (0, $10e7b257e1a9a756$export$2e2bcd8739ae039)(this.font, glyph.id, [...glyph.codePoints]));\n    // Select a script based on what is available in GSUB/GPOS.\n    let script = null;\n    if (this.GPOSProcessor) script = this.GPOSProcessor.selectScript(glyphRun.script, glyphRun.language, glyphRun.direction);\n    if (this.GSUBProcessor) script = this.GSUBProcessor.selectScript(glyphRun.script, glyphRun.language, glyphRun.direction);\n    // Choose a shaper based on the script, and setup a shaping plan.\n    // This determines which features to apply to which glyphs.\n    this.shaper = $102b6fe50f1d50b4$export$7877a478dd30fd3d(script);\n    this.plan = new (0, $94d7a73bd2edfc9a$export$2e2bcd8739ae039)(this.font, script, glyphRun.direction);\n    this.shaper.plan(this.plan, this.glyphInfos, glyphRun.features);\n    // Assign chosen features to output glyph run\n    for (let key in this.plan.allFeatures) glyphRun.features[key] = true;\n  }\n  substitute(glyphRun) {\n    if (this.GSUBProcessor) {\n      this.plan.process(this.GSUBProcessor, this.glyphInfos);\n      // Map glyph infos back to normal Glyph objects\n      glyphRun.glyphs = this.glyphInfos.map(glyphInfo => this.font.getGlyph(glyphInfo.id, glyphInfo.codePoints));\n    }\n  }\n  position(glyphRun) {\n    if (this.shaper.zeroMarkWidths === 'BEFORE_GPOS') this.zeroMarkAdvances(glyphRun.positions);\n    if (this.GPOSProcessor) this.plan.process(this.GPOSProcessor, this.glyphInfos, glyphRun.positions);\n    if (this.shaper.zeroMarkWidths === 'AFTER_GPOS') this.zeroMarkAdvances(glyphRun.positions);\n    // Reverse the glyphs and positions if the script is right-to-left\n    if (glyphRun.direction === 'rtl') {\n      glyphRun.glyphs.reverse();\n      glyphRun.positions.reverse();\n    }\n    return this.GPOSProcessor && this.GPOSProcessor.features;\n  }\n  zeroMarkAdvances(positions) {\n    for (let i = 0; i < this.glyphInfos.length; i++) if (this.glyphInfos[i].isMark) {\n      positions[i].xAdvance = 0;\n      positions[i].yAdvance = 0;\n    }\n  }\n  cleanup() {\n    this.glyphInfos = null;\n    this.plan = null;\n    this.shaper = null;\n  }\n  getAvailableFeatures(script, language) {\n    let features = [];\n    if (this.GSUBProcessor) {\n      this.GSUBProcessor.selectScript(script, language);\n      features.push(...Object.keys(this.GSUBProcessor.features));\n    }\n    if (this.GPOSProcessor) {\n      this.GPOSProcessor.selectScript(script, language);\n      features.push(...Object.keys(this.GPOSProcessor.features));\n    }\n    return features;\n  }\n  constructor(font) {\n    this.font = font;\n    this.glyphInfos = null;\n    this.plan = null;\n    this.GSUBProcessor = null;\n    this.GPOSProcessor = null;\n    this.fallbackPosition = true;\n    if (font.GSUB) this.GSUBProcessor = new (0, $0a876c45f1f7c41c$export$2e2bcd8739ae039)(font, font.GSUB);\n    if (font.GPOS) this.GPOSProcessor = new (0, $c96c93587d49c14d$export$2e2bcd8739ae039)(font, font.GPOS);\n  }\n}\nclass $4c0a7fa5df7a9ab1$export$2e2bcd8739ae039 {\n  layout(string, features, script, language, direction) {\n    // Make the features parameter optional\n    if (typeof features === 'string') {\n      direction = language;\n      language = script;\n      script = features;\n      features = [];\n    }\n    // Map string to glyphs if needed\n    if (typeof string === 'string') {\n      // Attempt to detect the script from the string if not provided.\n      if (script == null) script = $130d1a642ebcd2b7$export$e5cb25e204fb8450(string);\n      var glyphs = this.font.glyphsForString(string);\n    } else {\n      // Attempt to detect the script from the glyph code points if not provided.\n      if (script == null) {\n        let codePoints = [];\n        for (let glyph of string) codePoints.push(...glyph.codePoints);\n        script = $130d1a642ebcd2b7$export$16fab0757cfc223d(codePoints);\n      }\n      var glyphs = string;\n    }\n    let glyphRun = new (0, $be07b3e97a42687a$export$2e2bcd8739ae039)(glyphs, features, script, language, direction);\n    // Return early if there are no glyphs\n    if (glyphs.length === 0) {\n      glyphRun.positions = [];\n      return glyphRun;\n    }\n    // Setup the advanced layout engine\n    if (this.engine && this.engine.setup) this.engine.setup(glyphRun);\n    // Substitute and position the glyphs\n    this.substitute(glyphRun);\n    this.position(glyphRun);\n    this.hideDefaultIgnorables(glyphRun.glyphs, glyphRun.positions);\n    // Let the layout engine clean up any state it might have\n    if (this.engine && this.engine.cleanup) this.engine.cleanup();\n    return glyphRun;\n  }\n  substitute(glyphRun) {\n    // Call the advanced layout engine to make substitutions\n    if (this.engine && this.engine.substitute) this.engine.substitute(glyphRun);\n  }\n  position(glyphRun) {\n    // Get initial glyph positions\n    glyphRun.positions = glyphRun.glyphs.map(glyph => new (0, $1ac75d9a55b67f01$export$2e2bcd8739ae039)(glyph.advanceWidth));\n    let positioned = null;\n    // Call the advanced layout engine. Returns the features applied.\n    if (this.engine && this.engine.position) positioned = this.engine.position(glyphRun);\n    // if there is no GPOS table, use unicode properties to position marks.\n    if (!positioned && (!this.engine || this.engine.fallbackPosition)) {\n      if (!this.unicodeLayoutEngine) this.unicodeLayoutEngine = new (0, $0a4bdfeb6dfd6f5e$export$2e2bcd8739ae039)(this.font);\n      this.unicodeLayoutEngine.positionGlyphs(glyphRun.glyphs, glyphRun.positions);\n    }\n    // if kerning is not supported by GPOS, do kerning with the TrueType/AAT kern table\n    if ((!positioned || !positioned.kern) && glyphRun.features.kern !== false && this.font.kern) {\n      if (!this.kernProcessor) this.kernProcessor = new (0, $0bba3a9db57637f3$export$2e2bcd8739ae039)(this.font);\n      this.kernProcessor.process(glyphRun.glyphs, glyphRun.positions);\n      glyphRun.features.kern = true;\n    }\n  }\n  hideDefaultIgnorables(glyphs, positions) {\n    let space = this.font.glyphForCodePoint(0x20);\n    for (let i = 0; i < glyphs.length; i++) if (this.isDefaultIgnorable(glyphs[i].codePoints[0])) {\n      glyphs[i] = space;\n      positions[i].xAdvance = 0;\n      positions[i].yAdvance = 0;\n    }\n  }\n  isDefaultIgnorable(ch) {\n    // From DerivedCoreProperties.txt in the Unicode database,\n    // minus U+115F, U+1160, U+3164 and U+FFA0, which is what\n    // Harfbuzz and Uniscribe do.\n    let plane = ch >> 16;\n    if (plane === 0)\n      // BMP\n      switch (ch >> 8) {\n        case 0x00:\n          return ch === 0x00AD;\n        case 0x03:\n          return ch === 0x034F;\n        case 0x06:\n          return ch === 0x061C;\n        case 0x17:\n          return 0x17B4 <= ch && ch <= 0x17B5;\n        case 0x18:\n          return 0x180B <= ch && ch <= 0x180E;\n        case 0x20:\n          return 0x200B <= ch && ch <= 0x200F || 0x202A <= ch && ch <= 0x202E || 0x2060 <= ch && ch <= 0x206F;\n        case 0xFE:\n          return 0xFE00 <= ch && ch <= 0xFE0F || ch === 0xFEFF;\n        case 0xFF:\n          return 0xFFF0 <= ch && ch <= 0xFFF8;\n        default:\n          return false;\n      } else\n      // Other planes\n      switch (plane) {\n        case 0x01:\n          return 0x1BCA0 <= ch && ch <= 0x1BCA3 || 0x1D173 <= ch && ch <= 0x1D17A;\n        case 0x0E:\n          return 0xE0000 <= ch && ch <= 0xE0FFF;\n        default:\n          return false;\n      }\n  }\n  getAvailableFeatures(script, language) {\n    let features = [];\n    if (this.engine) features.push(...this.engine.getAvailableFeatures(script, language));\n    if (this.font.kern && features.indexOf('kern') === -1) features.push('kern');\n    return features;\n  }\n  stringsForGlyph(gid) {\n    let result = new Set();\n    let codePoints = this.font._cmapProcessor.codePointsForGlyph(gid);\n    for (let codePoint of codePoints) result.add(String.fromCodePoint(codePoint));\n    if (this.engine && this.engine.stringsForGlyph) for (let string of this.engine.stringsForGlyph(gid)) result.add(string);\n    return Array.from(result);\n  }\n  constructor(font) {\n    this.font = font;\n    this.unicodeLayoutEngine = null;\n    this.kernProcessor = null;\n    // Choose an advanced layout engine. We try the AAT morx table first since more\n    // scripts are currently supported because the shaping logic is built into the font.\n    if (this.font.morx) this.engine = new (0, $ba6dd74203be8728$export$2e2bcd8739ae039)(this.font);else if (this.font.GSUB || this.font.GPOS) this.engine = new (0, $a62492810de27e3d$export$2e2bcd8739ae039)(this.font);\n  }\n}\nconst $f43aec954cdfdf21$var$SVG_COMMANDS = {\n  moveTo: 'M',\n  lineTo: 'L',\n  quadraticCurveTo: 'Q',\n  bezierCurveTo: 'C',\n  closePath: 'Z'\n};\nclass $f43aec954cdfdf21$export$2e2bcd8739ae039 {\n  /**\n  * Compiles the path to a JavaScript function that can be applied with\n  * a graphics context in order to render the path.\n  * @return {string}\n  */\n  toFunction() {\n    return ctx => {\n      this.commands.forEach(c => {\n        return ctx[c.command].apply(ctx, c.args);\n      });\n    };\n  }\n  /**\n  * Converts the path to an SVG path data string\n  * @return {string}\n  */\n  toSVG() {\n    let cmds = this.commands.map(c => {\n      let args = c.args.map(arg => Math.round(arg * 100) / 100);\n      return `${$f43aec954cdfdf21$var$SVG_COMMANDS[c.command]}${args.join(' ')}`;\n    });\n    return cmds.join('');\n  }\n  /**\n  * Gets the \"control box\" of a path.\n  * This is like the bounding box, but it includes all points including\n  * control points of bezier segments and is much faster to compute than\n  * the real bounding box.\n  * @type {BBox}\n  */\n  get cbox() {\n    if (!this._cbox) {\n      let cbox = new (0, $f34600ab9d7f70d8$export$2e2bcd8739ae039)();\n      for (let command of this.commands) for (let i = 0; i < command.args.length; i += 2) cbox.addPoint(command.args[i], command.args[i + 1]);\n      this._cbox = Object.freeze(cbox);\n    }\n    return this._cbox;\n  }\n  /**\n  * Gets the exact bounding box of the path by evaluating curve segments.\n  * Slower to compute than the control box, but more accurate.\n  * @type {BBox}\n  */\n  get bbox() {\n    if (this._bbox) return this._bbox;\n    let bbox = new (0, $f34600ab9d7f70d8$export$2e2bcd8739ae039)();\n    let cx = 0,\n      cy = 0;\n    let f = t => Math.pow(1 - t, 3) * p0[i] + 3 * Math.pow(1 - t, 2) * t * p1[i] + 3 * (1 - t) * Math.pow(t, 2) * p2[i] + Math.pow(t, 3) * p3[i];\n    for (let c of this.commands) switch (c.command) {\n      case 'moveTo':\n      case 'lineTo':\n        let [x, y] = c.args;\n        bbox.addPoint(x, y);\n        cx = x;\n        cy = y;\n        break;\n      case 'quadraticCurveTo':\n      case 'bezierCurveTo':\n        if (c.command === 'quadraticCurveTo') {\n          // http://fontforge.org/bezier.html\n          var [qp1x, qp1y, p3x, p3y] = c.args;\n          var cp1x = cx + 2 / 3 * (qp1x - cx); // CP1 = QP0 + 2/3 * (QP1-QP0)\n          var cp1y = cy + 2 / 3 * (qp1y - cy);\n          var cp2x = p3x + 2 / 3 * (qp1x - p3x); // CP2 = QP2 + 2/3 * (QP1-QP2)\n          var cp2y = p3y + 2 / 3 * (qp1y - p3y);\n        } else var [cp1x, cp1y, cp2x, cp2y, p3x, p3y] = c.args;\n        // http://blog.hackers-cafe.net/2009/06/how-to-calculate-bezier-curves-bounding.html\n        bbox.addPoint(p3x, p3y);\n        var p0 = [cx, cy];\n        var p1 = [cp1x, cp1y];\n        var p2 = [cp2x, cp2y];\n        var p3 = [p3x, p3y];\n        for (var i = 0; i <= 1; i++) {\n          let b = 6 * p0[i] - 12 * p1[i] + 6 * p2[i];\n          let a = -3 * p0[i] + 9 * p1[i] - 9 * p2[i] + 3 * p3[i];\n          c = 3 * p1[i] - 3 * p0[i];\n          if (a === 0) {\n            if (b === 0) continue;\n            let t = -c / b;\n            if (0 < t && t < 1) {\n              if (i === 0) bbox.addPoint(f(t), bbox.maxY);else if (i === 1) bbox.addPoint(bbox.maxX, f(t));\n            }\n            continue;\n          }\n          let b2ac = Math.pow(b, 2) - 4 * c * a;\n          if (b2ac < 0) continue;\n          let t1 = (-b + Math.sqrt(b2ac)) / (2 * a);\n          if (0 < t1 && t1 < 1) {\n            if (i === 0) bbox.addPoint(f(t1), bbox.maxY);else if (i === 1) bbox.addPoint(bbox.maxX, f(t1));\n          }\n          let t2 = (-b - Math.sqrt(b2ac)) / (2 * a);\n          if (0 < t2 && t2 < 1) {\n            if (i === 0) bbox.addPoint(f(t2), bbox.maxY);else if (i === 1) bbox.addPoint(bbox.maxX, f(t2));\n          }\n        }\n        cx = p3x;\n        cy = p3y;\n        break;\n    }\n    return this._bbox = Object.freeze(bbox);\n  }\n  /**\n  * Applies a mapping function to each point in the path.\n  * @param {function} fn\n  * @return {Path}\n  */\n  mapPoints(fn) {\n    let path = new $f43aec954cdfdf21$export$2e2bcd8739ae039();\n    for (let c of this.commands) {\n      let args = [];\n      for (let i = 0; i < c.args.length; i += 2) {\n        let [x, y] = fn(c.args[i], c.args[i + 1]);\n        args.push(x, y);\n      }\n      path[c.command](...args);\n    }\n    return path;\n  }\n  /**\n  * Transforms the path by the given matrix.\n  */\n  transform(m0, m1, m2, m3, m4, m5) {\n    return this.mapPoints((x, y) => {\n      const tx = m0 * x + m2 * y + m4;\n      const ty = m1 * x + m3 * y + m5;\n      return [tx, ty];\n    });\n  }\n  /**\n  * Translates the path by the given offset.\n  */\n  translate(x, y) {\n    return this.transform(1, 0, 0, 1, x, y);\n  }\n  /**\n  * Rotates the path by the given angle (in radians).\n  */\n  rotate(angle) {\n    let cos = Math.cos(angle);\n    let sin = Math.sin(angle);\n    return this.transform(cos, sin, -sin, cos, 0, 0);\n  }\n  /**\n  * Scales the path.\n  */\n  scale(scaleX) {\n    let scaleY = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : scaleX;\n    return this.transform(scaleX, 0, 0, scaleY, 0, 0);\n  }\n  constructor() {\n    this.commands = [];\n    this._bbox = null;\n    this._cbox = null;\n  }\n}\nfor (let command of ['moveTo', 'lineTo', 'quadraticCurveTo', 'bezierCurveTo', 'closePath']) $f43aec954cdfdf21$export$2e2bcd8739ae039.prototype[command] = function () {\n  this._bbox = this._cbox = null;\n  for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n    args[_key2] = arguments[_key2];\n  }\n  this.commands.push({\n    command: command,\n    args: args\n  });\n  return this;\n};\nvar $7713b9b7b438dff8$export$2e2bcd8739ae039 = ['.notdef', '.null', 'nonmarkingreturn', 'space', 'exclam', 'quotedbl', 'numbersign', 'dollar', 'percent', 'ampersand', 'quotesingle', 'parenleft', 'parenright', 'asterisk', 'plus', 'comma', 'hyphen', 'period', 'slash', 'zero', 'one', 'two', 'three', 'four', 'five', 'six', 'seven', 'eight', 'nine', 'colon', 'semicolon', 'less', 'equal', 'greater', 'question', 'at', 'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z', 'bracketleft', 'backslash', 'bracketright', 'asciicircum', 'underscore', 'grave', 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z', 'braceleft', 'bar', 'braceright', 'asciitilde', 'Adieresis', 'Aring', 'Ccedilla', 'Eacute', 'Ntilde', 'Odieresis', 'Udieresis', 'aacute', 'agrave', 'acircumflex', 'adieresis', 'atilde', 'aring', 'ccedilla', 'eacute', 'egrave', 'ecircumflex', 'edieresis', 'iacute', 'igrave', 'icircumflex', 'idieresis', 'ntilde', 'oacute', 'ograve', 'ocircumflex', 'odieresis', 'otilde', 'uacute', 'ugrave', 'ucircumflex', 'udieresis', 'dagger', 'degree', 'cent', 'sterling', 'section', 'bullet', 'paragraph', 'germandbls', 'registered', 'copyright', 'trademark', 'acute', 'dieresis', 'notequal', 'AE', 'Oslash', 'infinity', 'plusminus', 'lessequal', 'greaterequal', 'yen', 'mu', 'partialdiff', 'summation', 'product', 'pi', 'integral', 'ordfeminine', 'ordmasculine', 'Omega', 'ae', 'oslash', 'questiondown', 'exclamdown', 'logicalnot', 'radical', 'florin', 'approxequal', 'Delta', 'guillemotleft', 'guillemotright', 'ellipsis', 'nonbreakingspace', 'Agrave', 'Atilde', 'Otilde', 'OE', 'oe', 'endash', 'emdash', 'quotedblleft', 'quotedblright', 'quoteleft', 'quoteright', 'divide', 'lozenge', 'ydieresis', 'Ydieresis', 'fraction', 'currency', 'guilsinglleft', 'guilsinglright', 'fi', 'fl', 'daggerdbl', 'periodcentered', 'quotesinglbase', 'quotedblbase', 'perthousand', 'Acircumflex', 'Ecircumflex', 'Aacute', 'Edieresis', 'Egrave', 'Iacute', 'Icircumflex', 'Idieresis', 'Igrave', 'Oacute', 'Ocircumflex', 'apple', 'Ograve', 'Uacute', 'Ucircumflex', 'Ugrave', 'dotlessi', 'circumflex', 'tilde', 'macron', 'breve', 'dotaccent', 'ring', 'cedilla', 'hungarumlaut', 'ogonek', 'caron', 'Lslash', 'lslash', 'Scaron', 'scaron', 'Zcaron', 'zcaron', 'brokenbar', 'Eth', 'eth', 'Yacute', 'yacute', 'Thorn', 'thorn', 'minus', 'multiply', 'onesuperior', 'twosuperior', 'threesuperior', 'onehalf', 'onequarter', 'threequarters', 'franc', 'Gbreve', 'gbreve', 'Idotaccent', 'Scedilla', 'scedilla', 'Cacute', 'cacute', 'Ccaron', 'ccaron', 'dcroat'];\nclass $f92906be28e61769$export$2e2bcd8739ae039 {\n  _getPath() {\n    return new (0, $f43aec954cdfdf21$export$2e2bcd8739ae039)();\n  }\n  _getCBox() {\n    return this.path.cbox;\n  }\n  _getBBox() {\n    return this.path.bbox;\n  }\n  _getTableMetrics(table) {\n    if (this.id < table.metrics.length) return table.metrics.get(this.id);\n    let metric = table.metrics.get(table.metrics.length - 1);\n    let res = {\n      advance: metric ? metric.advance : 0,\n      bearing: table.bearings.get(this.id - table.metrics.length) || 0\n    };\n    return res;\n  }\n  _getMetrics(cbox) {\n    if (this._metrics) return this._metrics;\n    let {\n      advance: advanceWidth,\n      bearing: leftBearing\n    } = this._getTableMetrics(this._font.hmtx);\n    // For vertical metrics, use vmtx if available, or fall back to global data from OS/2 or hhea\n    if (this._font.vmtx) var {\n      advance: advanceHeight,\n      bearing: topBearing\n    } = this._getTableMetrics(this._font.vmtx);else {\n      let os2;\n      if (typeof cbox === 'undefined' || cbox === null) ({\n        cbox: cbox\n      } = this);\n      if ((os2 = this._font['OS/2']) && os2.version > 0) {\n        var advanceHeight = Math.abs(os2.typoAscender - os2.typoDescender);\n        var topBearing = os2.typoAscender - cbox.maxY;\n      } else {\n        let {\n          hhea: hhea\n        } = this._font;\n        var advanceHeight = Math.abs(hhea.ascent - hhea.descent);\n        var topBearing = hhea.ascent - cbox.maxY;\n      }\n    }\n    if (this._font._variationProcessor && this._font.HVAR) advanceWidth += this._font._variationProcessor.getAdvanceAdjustment(this.id, this._font.HVAR);\n    return this._metrics = {\n      advanceWidth: advanceWidth,\n      advanceHeight: advanceHeight,\n      leftBearing: leftBearing,\n      topBearing: topBearing\n    };\n  }\n  /**\n  * The glyphs control box.\n  * This is often the same as the bounding box, but is faster to compute.\n  * Because of the way bezier curves are defined, some of the control points\n  * can be outside of the bounding box. Where `bbox` takes this into account,\n  * `cbox` does not. Thus, cbox is less accurate, but faster to compute.\n  * See [here](http://www.freetype.org/freetype2/docs/glyphs/glyphs-6.html#section-2)\n  * for a more detailed description.\n  *\n  * @type {BBox}\n  */\n  get cbox() {\n    return this._getCBox();\n  }\n  /**\n  * The glyphs bounding box, i.e. the rectangle that encloses the\n  * glyph outline as tightly as possible.\n  * @type {BBox}\n  */\n  get bbox() {\n    return this._getBBox();\n  }\n  /**\n  * A vector Path object representing the glyph outline.\n  * @type {Path}\n  */\n  get path() {\n    // Cache the path so we only decode it once\n    // Decoding is actually performed by subclasses\n    return this._getPath();\n  }\n  /**\n  * Returns a path scaled to the given font size.\n  * @param {number} size\n  * @return {Path}\n  */\n  getScaledPath(size) {\n    let scale = 1 / this._font.unitsPerEm * size;\n    return this.path.scale(scale);\n  }\n  /**\n  * The glyph's advance width.\n  * @type {number}\n  */\n  get advanceWidth() {\n    return this._getMetrics().advanceWidth;\n  }\n  /**\n  * The glyph's advance height.\n  * @type {number}\n  */\n  get advanceHeight() {\n    return this._getMetrics().advanceHeight;\n  }\n  get ligatureCaretPositions() {}\n  _getName() {\n    let {\n      post: post\n    } = this._font;\n    if (!post) return null;\n    switch (post.version) {\n      case 1:\n        return (0, $7713b9b7b438dff8$export$2e2bcd8739ae039)[this.id];\n      case 2:\n        let id = post.glyphNameIndex[this.id];\n        if (id < (0, $7713b9b7b438dff8$export$2e2bcd8739ae039).length) return (0, $7713b9b7b438dff8$export$2e2bcd8739ae039)[id];\n        return post.names[id - (0, $7713b9b7b438dff8$export$2e2bcd8739ae039).length];\n      case 2.5:\n        return (0, $7713b9b7b438dff8$export$2e2bcd8739ae039)[this.id + post.offsets[this.id]];\n      case 4:\n        return String.fromCharCode(post.map[this.id]);\n    }\n  }\n  /**\n  * The glyph's name\n  * @type {string}\n  */\n  get name() {\n    return this._getName();\n  }\n  /**\n  * Renders the glyph to the given graphics context, at the specified font size.\n  * @param {CanvasRenderingContext2d} ctx\n  * @param {number} size\n  */\n  render(ctx, size) {\n    ctx.save();\n    let scale = 1 / this._font.head.unitsPerEm * size;\n    ctx.scale(scale, scale);\n    let fn = this.path.toFunction();\n    fn(ctx);\n    ctx.fill();\n    ctx.restore();\n  }\n  constructor(id, codePoints, font) {\n    /**\n    * The glyph id in the font\n    * @type {number}\n    */\n    this.id = id;\n    /**\n    * An array of unicode code points that are represented by this glyph.\n    * There can be multiple code points in the case of ligatures and other glyphs\n    * that represent multiple visual characters.\n    * @type {number[]}\n    */\n    this.codePoints = codePoints;\n    this._font = font;\n    // TODO: get this info from GDEF if available\n    this.isMark = this.codePoints.length > 0 && this.codePoints.every((0, $6uUbQ$isMark));\n    this.isLigature = this.codePoints.length > 1;\n  }\n}\n(0, $6uUbQ$_1)([(0, $e71565f2ce09cb6b$export$69a3209f1a06c04d)], $f92906be28e61769$export$2e2bcd8739ae039.prototype, \"cbox\", null);\n(0, $6uUbQ$_1)([(0, $e71565f2ce09cb6b$export$69a3209f1a06c04d)], $f92906be28e61769$export$2e2bcd8739ae039.prototype, \"bbox\", null);\n(0, $6uUbQ$_1)([(0, $e71565f2ce09cb6b$export$69a3209f1a06c04d)], $f92906be28e61769$export$2e2bcd8739ae039.prototype, \"path\", null);\n(0, $6uUbQ$_1)([(0, $e71565f2ce09cb6b$export$69a3209f1a06c04d)], $f92906be28e61769$export$2e2bcd8739ae039.prototype, \"advanceWidth\", null);\n(0, $6uUbQ$_1)([(0, $e71565f2ce09cb6b$export$69a3209f1a06c04d)], $f92906be28e61769$export$2e2bcd8739ae039.prototype, \"advanceHeight\", null);\n(0, $6uUbQ$_1)([(0, $e71565f2ce09cb6b$export$69a3209f1a06c04d)], $f92906be28e61769$export$2e2bcd8739ae039.prototype, \"name\", null);\n\n// The header for both simple and composite glyphs\nlet $69aac16029968692$var$GlyfHeader = new $6uUbQ$Struct({\n  numberOfContours: $6uUbQ$int16,\n  xMin: $6uUbQ$int16,\n  yMin: $6uUbQ$int16,\n  xMax: $6uUbQ$int16,\n  yMax: $6uUbQ$int16\n});\n// Flags for simple glyphs\nconst $69aac16029968692$var$ON_CURVE = 1;\nconst $69aac16029968692$var$X_SHORT_VECTOR = 2;\nconst $69aac16029968692$var$Y_SHORT_VECTOR = 4;\nconst $69aac16029968692$var$REPEAT = 8;\nconst $69aac16029968692$var$SAME_X = 16;\nconst $69aac16029968692$var$SAME_Y = 32;\n// Flags for composite glyphs\nconst $69aac16029968692$var$ARG_1_AND_2_ARE_WORDS = 1;\nconst $69aac16029968692$var$ARGS_ARE_XY_VALUES = 2;\nconst $69aac16029968692$var$ROUND_XY_TO_GRID = 4;\nconst $69aac16029968692$var$WE_HAVE_A_SCALE = 8;\nconst $69aac16029968692$var$MORE_COMPONENTS = 32;\nconst $69aac16029968692$var$WE_HAVE_AN_X_AND_Y_SCALE = 64;\nconst $69aac16029968692$var$WE_HAVE_A_TWO_BY_TWO = 128;\nconst $69aac16029968692$var$WE_HAVE_INSTRUCTIONS = 256;\nconst $69aac16029968692$var$USE_MY_METRICS = 512;\nconst $69aac16029968692$var$OVERLAP_COMPOUND = 1024;\nconst $69aac16029968692$var$SCALED_COMPONENT_OFFSET = 2048;\nconst $69aac16029968692$var$UNSCALED_COMPONENT_OFFSET = 4096;\nclass $69aac16029968692$export$baf26146a414f24a {\n  copy() {\n    return new $69aac16029968692$export$baf26146a414f24a(this.onCurve, this.endContour, this.x, this.y);\n  }\n  constructor(onCurve, endContour) {\n    let x = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n    let y = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;\n    this.onCurve = onCurve;\n    this.endContour = endContour;\n    this.x = x;\n    this.y = y;\n  }\n}\n// Represents a component in a composite glyph\nclass $69aac16029968692$var$Component {\n  constructor(glyphID, dx, dy) {\n    this.glyphID = glyphID;\n    this.dx = dx;\n    this.dy = dy;\n    this.pos = 0;\n    this.scaleX = this.scaleY = 1;\n    this.scale01 = this.scale10 = 0;\n  }\n}\nclass $69aac16029968692$export$2e2bcd8739ae039 extends (0, $f92906be28e61769$export$2e2bcd8739ae039) {\n  // Parses just the glyph header and returns the bounding box\n  _getCBox(internal) {\n    // We need to decode the glyph if variation processing is requested,\n    // so it's easier just to recompute the path's cbox after decoding.\n    if (this._font._variationProcessor && !internal) return this.path.cbox;\n    let stream = this._font._getTableStream('glyf');\n    stream.pos += this._font.loca.offsets[this.id];\n    let glyph = $69aac16029968692$var$GlyfHeader.decode(stream);\n    let cbox = new (0, $f34600ab9d7f70d8$export$2e2bcd8739ae039)(glyph.xMin, glyph.yMin, glyph.xMax, glyph.yMax);\n    return Object.freeze(cbox);\n  }\n  // Parses a single glyph coordinate\n  _parseGlyphCoord(stream, prev, short, same) {\n    if (short) {\n      var val = stream.readUInt8();\n      if (!same) val = -val;\n      val += prev;\n    } else if (same) var val = prev;else var val = prev + stream.readInt16BE();\n    return val;\n  }\n  // Decodes the glyph data into points for simple glyphs,\n  // or components for composite glyphs\n  _decode() {\n    let glyfPos = this._font.loca.offsets[this.id];\n    let nextPos = this._font.loca.offsets[this.id + 1];\n    // Nothing to do if there is no data for this glyph\n    if (glyfPos === nextPos) return null;\n    let stream = this._font._getTableStream('glyf');\n    stream.pos += glyfPos;\n    let startPos = stream.pos;\n    let glyph = $69aac16029968692$var$GlyfHeader.decode(stream);\n    if (glyph.numberOfContours > 0) this._decodeSimple(glyph, stream);else if (glyph.numberOfContours < 0) this._decodeComposite(glyph, stream, startPos);\n    return glyph;\n  }\n  _decodeSimple(glyph, stream) {\n    // this is a simple glyph\n    glyph.points = [];\n    let endPtsOfContours = new $6uUbQ$Array($6uUbQ$uint16, glyph.numberOfContours).decode(stream);\n    glyph.instructions = new $6uUbQ$Array($6uUbQ$uint8, $6uUbQ$uint16).decode(stream);\n    let flags = [];\n    let numCoords = endPtsOfContours[endPtsOfContours.length - 1] + 1;\n    while (flags.length < numCoords) {\n      var flag = stream.readUInt8();\n      flags.push(flag);\n      // check for repeat flag\n      if (flag & $69aac16029968692$var$REPEAT) {\n        let count = stream.readUInt8();\n        for (let j = 0; j < count; j++) flags.push(flag);\n      }\n    }\n    for (var i = 0; i < flags.length; i++) {\n      var flag = flags[i];\n      let point = new $69aac16029968692$export$baf26146a414f24a(!!(flag & $69aac16029968692$var$ON_CURVE), endPtsOfContours.indexOf(i) >= 0, 0, 0);\n      glyph.points.push(point);\n    }\n    let px = 0;\n    for (var i = 0; i < flags.length; i++) {\n      var flag = flags[i];\n      glyph.points[i].x = px = this._parseGlyphCoord(stream, px, flag & $69aac16029968692$var$X_SHORT_VECTOR, flag & $69aac16029968692$var$SAME_X);\n    }\n    let py = 0;\n    for (var i = 0; i < flags.length; i++) {\n      var flag = flags[i];\n      glyph.points[i].y = py = this._parseGlyphCoord(stream, py, flag & $69aac16029968692$var$Y_SHORT_VECTOR, flag & $69aac16029968692$var$SAME_Y);\n    }\n    if (this._font._variationProcessor) {\n      let points = glyph.points.slice();\n      points.push(...this._getPhantomPoints(glyph));\n      this._font._variationProcessor.transformPoints(this.id, points);\n      glyph.phantomPoints = points.slice(-4);\n    }\n    return;\n  }\n  _decodeComposite(glyph, stream) {\n    let offset = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n    // this is a composite glyph\n    glyph.components = [];\n    let haveInstructions = false;\n    let flags = $69aac16029968692$var$MORE_COMPONENTS;\n    while (flags & $69aac16029968692$var$MORE_COMPONENTS) {\n      flags = stream.readUInt16BE();\n      let gPos = stream.pos - offset;\n      let glyphID = stream.readUInt16BE();\n      if (!haveInstructions) haveInstructions = (flags & $69aac16029968692$var$WE_HAVE_INSTRUCTIONS) !== 0;\n      if (flags & $69aac16029968692$var$ARG_1_AND_2_ARE_WORDS) {\n        var dx = stream.readInt16BE();\n        var dy = stream.readInt16BE();\n      } else {\n        var dx = stream.readInt8();\n        var dy = stream.readInt8();\n      }\n      var component = new $69aac16029968692$var$Component(glyphID, dx, dy);\n      component.pos = gPos;\n      if (flags & $69aac16029968692$var$WE_HAVE_A_SCALE)\n        // fixed number with 14 bits of fraction\n        component.scaleX = component.scaleY = (stream.readUInt8() << 24 | stream.readUInt8() << 16) / 1073741824;else if (flags & $69aac16029968692$var$WE_HAVE_AN_X_AND_Y_SCALE) {\n        component.scaleX = (stream.readUInt8() << 24 | stream.readUInt8() << 16) / 1073741824;\n        component.scaleY = (stream.readUInt8() << 24 | stream.readUInt8() << 16) / 1073741824;\n      } else if (flags & $69aac16029968692$var$WE_HAVE_A_TWO_BY_TWO) {\n        component.scaleX = (stream.readUInt8() << 24 | stream.readUInt8() << 16) / 1073741824;\n        component.scale01 = (stream.readUInt8() << 24 | stream.readUInt8() << 16) / 1073741824;\n        component.scale10 = (stream.readUInt8() << 24 | stream.readUInt8() << 16) / 1073741824;\n        component.scaleY = (stream.readUInt8() << 24 | stream.readUInt8() << 16) / 1073741824;\n      }\n      glyph.components.push(component);\n    }\n    if (this._font._variationProcessor) {\n      let points = [];\n      for (let j = 0; j < glyph.components.length; j++) {\n        var component = glyph.components[j];\n        points.push(new $69aac16029968692$export$baf26146a414f24a(true, true, component.dx, component.dy));\n      }\n      points.push(...this._getPhantomPoints(glyph));\n      this._font._variationProcessor.transformPoints(this.id, points);\n      glyph.phantomPoints = points.splice(-4, 4);\n      for (let i = 0; i < points.length; i++) {\n        let point = points[i];\n        glyph.components[i].dx = point.x;\n        glyph.components[i].dy = point.y;\n      }\n    }\n    return haveInstructions;\n  }\n  _getPhantomPoints(glyph) {\n    let cbox = this._getCBox(true);\n    if (this._metrics == null) this._metrics = (0, $f92906be28e61769$export$2e2bcd8739ae039).prototype._getMetrics.call(this, cbox);\n    let {\n      advanceWidth: advanceWidth,\n      advanceHeight: advanceHeight,\n      leftBearing: leftBearing,\n      topBearing: topBearing\n    } = this._metrics;\n    return [new $69aac16029968692$export$baf26146a414f24a(false, true, glyph.xMin - leftBearing, 0), new $69aac16029968692$export$baf26146a414f24a(false, true, glyph.xMin - leftBearing + advanceWidth, 0), new $69aac16029968692$export$baf26146a414f24a(false, true, 0, glyph.yMax + topBearing), new $69aac16029968692$export$baf26146a414f24a(false, true, 0, glyph.yMax + topBearing + advanceHeight)];\n  }\n  // Decodes font data, resolves composite glyphs, and returns an array of contours\n  _getContours() {\n    let glyph = this._decode();\n    if (!glyph) return [];\n    let points = [];\n    if (glyph.numberOfContours < 0)\n      // resolve composite glyphs\n      for (let component of glyph.components) {\n        let contours = this._font.getGlyph(component.glyphID)._getContours();\n        for (let i = 0; i < contours.length; i++) {\n          let contour = contours[i];\n          for (let j = 0; j < contour.length; j++) {\n            let point = contour[j];\n            let x = point.x * component.scaleX + point.y * component.scale01 + component.dx;\n            let y = point.y * component.scaleY + point.x * component.scale10 + component.dy;\n            points.push(new $69aac16029968692$export$baf26146a414f24a(point.onCurve, point.endContour, x, y));\n          }\n        }\n      } else points = glyph.points || [];\n    // Recompute and cache metrics if we performed variation processing, and don't have an HVAR table\n    if (glyph.phantomPoints && !this._font.directory.tables.HVAR) {\n      this._metrics.advanceWidth = glyph.phantomPoints[1].x - glyph.phantomPoints[0].x;\n      this._metrics.advanceHeight = glyph.phantomPoints[3].y - glyph.phantomPoints[2].y;\n      this._metrics.leftBearing = glyph.xMin - glyph.phantomPoints[0].x;\n      this._metrics.topBearing = glyph.phantomPoints[2].y - glyph.yMax;\n    }\n    let contours = [];\n    let cur = [];\n    for (let k = 0; k < points.length; k++) {\n      var point = points[k];\n      cur.push(point);\n      if (point.endContour) {\n        contours.push(cur);\n        cur = [];\n      }\n    }\n    return contours;\n  }\n  _getMetrics() {\n    if (this._metrics) return this._metrics;\n    let cbox = this._getCBox(true);\n    super._getMetrics(cbox);\n    if (this._font._variationProcessor && !this._font.HVAR)\n      // No HVAR table, decode the glyph. This triggers recomputation of metrics.\n      this.path;\n    return this._metrics;\n  }\n  // Converts contours to a Path object that can be rendered\n  _getPath() {\n    let contours = this._getContours();\n    let path = new (0, $f43aec954cdfdf21$export$2e2bcd8739ae039)();\n    for (let i = 0; i < contours.length; i++) {\n      let contour = contours[i];\n      let firstPt = contour[0];\n      let lastPt = contour[contour.length - 1];\n      let start = 0;\n      if (firstPt.onCurve) {\n        // The first point will be consumed by the moveTo command, so skip in the loop\n        var curvePt = null;\n        start = 1;\n      } else {\n        if (lastPt.onCurve)\n          // Start at the last point if the first point is off curve and the last point is on curve\n          firstPt = lastPt;else\n          // Start at the middle if both the first and last points are off curve\n          firstPt = new $69aac16029968692$export$baf26146a414f24a(false, false, (firstPt.x + lastPt.x) / 2, (firstPt.y + lastPt.y) / 2);\n        var curvePt = firstPt;\n      }\n      path.moveTo(firstPt.x, firstPt.y);\n      for (let j = start; j < contour.length; j++) {\n        let pt = contour[j];\n        let prevPt = j === 0 ? firstPt : contour[j - 1];\n        if (prevPt.onCurve && pt.onCurve) path.lineTo(pt.x, pt.y);else if (prevPt.onCurve && !pt.onCurve) var curvePt = pt;else if (!prevPt.onCurve && !pt.onCurve) {\n          let midX = (prevPt.x + pt.x) / 2;\n          let midY = (prevPt.y + pt.y) / 2;\n          path.quadraticCurveTo(prevPt.x, prevPt.y, midX, midY);\n          var curvePt = pt;\n        } else if (!prevPt.onCurve && pt.onCurve) {\n          path.quadraticCurveTo(curvePt.x, curvePt.y, pt.x, pt.y);\n          var curvePt = null;\n        } else throw new Error(\"Unknown TTF path state\");\n      }\n      // Connect the first and last points\n      if (curvePt) path.quadraticCurveTo(curvePt.x, curvePt.y, firstPt.x, firstPt.y);\n      path.closePath();\n    }\n    return path;\n  }\n  constructor() {\n    super(...arguments);\n    (0, $6uUbQ$_)(this, \"type\", 'TTF');\n  }\n}\nclass $62cc5109c6101893$export$2e2bcd8739ae039 extends (0, $f92906be28e61769$export$2e2bcd8739ae039) {\n  _getName() {\n    if (this._font.CFF2) return super._getName();\n    return this._font['CFF '].getGlyphName(this.id);\n  }\n  bias(s) {\n    if (s.length < 1240) return 107;else if (s.length < 33900) return 1131;else return 32768;\n  }\n  _getPath() {\n    let cff = this._font.CFF2 || this._font['CFF '];\n    let {\n      stream: stream\n    } = cff;\n    let str = cff.topDict.CharStrings[this.id];\n    let end = str.offset + str.length;\n    stream.pos = str.offset;\n    let path = new (0, $f43aec954cdfdf21$export$2e2bcd8739ae039)();\n    let stack = [];\n    let trans = [];\n    let width = null;\n    let nStems = 0;\n    let x = 0,\n      y = 0;\n    let usedGsubrs;\n    let usedSubrs;\n    let open = false;\n    this._usedGsubrs = usedGsubrs = {};\n    this._usedSubrs = usedSubrs = {};\n    let gsubrs = cff.globalSubrIndex || [];\n    let gsubrsBias = this.bias(gsubrs);\n    let privateDict = cff.privateDictForGlyph(this.id) || {};\n    let subrs = privateDict.Subrs || [];\n    let subrsBias = this.bias(subrs);\n    let vstore = cff.topDict.vstore && cff.topDict.vstore.itemVariationStore;\n    let vsindex = privateDict.vsindex;\n    let variationProcessor = this._font._variationProcessor;\n    function checkWidth() {\n      if (width == null) width = stack.shift() + privateDict.nominalWidthX;\n    }\n    function parseStems() {\n      if (stack.length % 2 !== 0) checkWidth();\n      nStems += stack.length >> 1;\n      return stack.length = 0;\n    }\n    function moveTo(x, y) {\n      if (open) path.closePath();\n      path.moveTo(x, y);\n      open = true;\n    }\n    let parse = function () {\n      while (stream.pos < end) {\n        let op = stream.readUInt8();\n        if (op < 32) {\n          let index, subr, phase;\n          let c1x, c1y, c2x, c2y, c3x, c3y;\n          let c4x, c4y, c5x, c5y, c6x, c6y;\n          let pts;\n          switch (op) {\n            case 1:\n            case 3:\n            case 18:\n            case 23:\n              parseStems();\n              break;\n            case 4:\n              if (stack.length > 1) checkWidth();\n              y += stack.shift();\n              moveTo(x, y);\n              break;\n            case 5:\n              while (stack.length >= 2) {\n                x += stack.shift();\n                y += stack.shift();\n                path.lineTo(x, y);\n              }\n              break;\n            case 6:\n            case 7:\n              phase = op === 6;\n              while (stack.length >= 1) {\n                if (phase) x += stack.shift();else y += stack.shift();\n                path.lineTo(x, y);\n                phase = !phase;\n              }\n              break;\n            case 8:\n              while (stack.length > 0) {\n                c1x = x + stack.shift();\n                c1y = y + stack.shift();\n                c2x = c1x + stack.shift();\n                c2y = c1y + stack.shift();\n                x = c2x + stack.shift();\n                y = c2y + stack.shift();\n                path.bezierCurveTo(c1x, c1y, c2x, c2y, x, y);\n              }\n              break;\n            case 10:\n              index = stack.pop() + subrsBias;\n              subr = subrs[index];\n              if (subr) {\n                usedSubrs[index] = true;\n                let p = stream.pos;\n                let e = end;\n                stream.pos = subr.offset;\n                end = subr.offset + subr.length;\n                parse();\n                stream.pos = p;\n                end = e;\n              }\n              break;\n            case 11:\n              if (cff.version >= 2) break;\n              return;\n            case 14:\n              if (cff.version >= 2) break;\n              if (stack.length > 0) checkWidth();\n              if (open) {\n                path.closePath();\n                open = false;\n              }\n              break;\n            case 15:\n              if (cff.version < 2) throw new Error('vsindex operator not supported in CFF v1');\n              vsindex = stack.pop();\n              break;\n            case 16:\n              {\n                if (cff.version < 2) throw new Error('blend operator not supported in CFF v1');\n                if (!variationProcessor) throw new Error('blend operator in non-variation font');\n                let blendVector = variationProcessor.getBlendVector(vstore, vsindex);\n                let numBlends = stack.pop();\n                let numOperands = numBlends * blendVector.length;\n                let delta = stack.length - numOperands;\n                let base = delta - numBlends;\n                for (let i = 0; i < numBlends; i++) {\n                  let sum = stack[base + i];\n                  for (let j = 0; j < blendVector.length; j++) sum += blendVector[j] * stack[delta++];\n                  stack[base + i] = sum;\n                }\n                while (numOperands--) stack.pop();\n                break;\n              }\n            case 19:\n            case 20:\n              parseStems();\n              stream.pos += nStems + 7 >> 3;\n              break;\n            case 21:\n              if (stack.length > 2) checkWidth();\n              x += stack.shift();\n              y += stack.shift();\n              moveTo(x, y);\n              break;\n            case 22:\n              if (stack.length > 1) checkWidth();\n              x += stack.shift();\n              moveTo(x, y);\n              break;\n            case 24:\n              while (stack.length >= 8) {\n                c1x = x + stack.shift();\n                c1y = y + stack.shift();\n                c2x = c1x + stack.shift();\n                c2y = c1y + stack.shift();\n                x = c2x + stack.shift();\n                y = c2y + stack.shift();\n                path.bezierCurveTo(c1x, c1y, c2x, c2y, x, y);\n              }\n              x += stack.shift();\n              y += stack.shift();\n              path.lineTo(x, y);\n              break;\n            case 25:\n              while (stack.length >= 8) {\n                x += stack.shift();\n                y += stack.shift();\n                path.lineTo(x, y);\n              }\n              c1x = x + stack.shift();\n              c1y = y + stack.shift();\n              c2x = c1x + stack.shift();\n              c2y = c1y + stack.shift();\n              x = c2x + stack.shift();\n              y = c2y + stack.shift();\n              path.bezierCurveTo(c1x, c1y, c2x, c2y, x, y);\n              break;\n            case 26:\n              if (stack.length % 2) x += stack.shift();\n              while (stack.length >= 4) {\n                c1x = x;\n                c1y = y + stack.shift();\n                c2x = c1x + stack.shift();\n                c2y = c1y + stack.shift();\n                x = c2x;\n                y = c2y + stack.shift();\n                path.bezierCurveTo(c1x, c1y, c2x, c2y, x, y);\n              }\n              break;\n            case 27:\n              if (stack.length % 2) y += stack.shift();\n              while (stack.length >= 4) {\n                c1x = x + stack.shift();\n                c1y = y;\n                c2x = c1x + stack.shift();\n                c2y = c1y + stack.shift();\n                x = c2x + stack.shift();\n                y = c2y;\n                path.bezierCurveTo(c1x, c1y, c2x, c2y, x, y);\n              }\n              break;\n            case 28:\n              stack.push(stream.readInt16BE());\n              break;\n            case 29:\n              index = stack.pop() + gsubrsBias;\n              subr = gsubrs[index];\n              if (subr) {\n                usedGsubrs[index] = true;\n                let p = stream.pos;\n                let e = end;\n                stream.pos = subr.offset;\n                end = subr.offset + subr.length;\n                parse();\n                stream.pos = p;\n                end = e;\n              }\n              break;\n            case 30:\n            case 31:\n              phase = op === 31;\n              while (stack.length >= 4) {\n                if (phase) {\n                  c1x = x + stack.shift();\n                  c1y = y;\n                  c2x = c1x + stack.shift();\n                  c2y = c1y + stack.shift();\n                  y = c2y + stack.shift();\n                  x = c2x + (stack.length === 1 ? stack.shift() : 0);\n                } else {\n                  c1x = x;\n                  c1y = y + stack.shift();\n                  c2x = c1x + stack.shift();\n                  c2y = c1y + stack.shift();\n                  x = c2x + stack.shift();\n                  y = c2y + (stack.length === 1 ? stack.shift() : 0);\n                }\n                path.bezierCurveTo(c1x, c1y, c2x, c2y, x, y);\n                phase = !phase;\n              }\n              break;\n            case 12:\n              op = stream.readUInt8();\n              switch (op) {\n                case 3:\n                  let a = stack.pop();\n                  let b = stack.pop();\n                  stack.push(a && b ? 1 : 0);\n                  break;\n                case 4:\n                  a = stack.pop();\n                  b = stack.pop();\n                  stack.push(a || b ? 1 : 0);\n                  break;\n                case 5:\n                  a = stack.pop();\n                  stack.push(a ? 0 : 1);\n                  break;\n                case 9:\n                  a = stack.pop();\n                  stack.push(Math.abs(a));\n                  break;\n                case 10:\n                  a = stack.pop();\n                  b = stack.pop();\n                  stack.push(a + b);\n                  break;\n                case 11:\n                  a = stack.pop();\n                  b = stack.pop();\n                  stack.push(a - b);\n                  break;\n                case 12:\n                  a = stack.pop();\n                  b = stack.pop();\n                  stack.push(a / b);\n                  break;\n                case 14:\n                  a = stack.pop();\n                  stack.push(-a);\n                  break;\n                case 15:\n                  a = stack.pop();\n                  b = stack.pop();\n                  stack.push(a === b ? 1 : 0);\n                  break;\n                case 18:\n                  stack.pop();\n                  break;\n                case 20:\n                  let val = stack.pop();\n                  let idx = stack.pop();\n                  trans[idx] = val;\n                  break;\n                case 21:\n                  idx = stack.pop();\n                  stack.push(trans[idx] || 0);\n                  break;\n                case 22:\n                  let s1 = stack.pop();\n                  let s2 = stack.pop();\n                  let v1 = stack.pop();\n                  let v2 = stack.pop();\n                  stack.push(v1 <= v2 ? s1 : s2);\n                  break;\n                case 23:\n                  stack.push(Math.random());\n                  break;\n                case 24:\n                  a = stack.pop();\n                  b = stack.pop();\n                  stack.push(a * b);\n                  break;\n                case 26:\n                  a = stack.pop();\n                  stack.push(Math.sqrt(a));\n                  break;\n                case 27:\n                  a = stack.pop();\n                  stack.push(a, a);\n                  break;\n                case 28:\n                  a = stack.pop();\n                  b = stack.pop();\n                  stack.push(b, a);\n                  break;\n                case 29:\n                  idx = stack.pop();\n                  if (idx < 0) idx = 0;else if (idx > stack.length - 1) idx = stack.length - 1;\n                  stack.push(stack[idx]);\n                  break;\n                case 30:\n                  let n = stack.pop();\n                  let j = stack.pop();\n                  if (j >= 0) while (j > 0) {\n                    var t = stack[n - 1];\n                    for (let i = n - 2; i >= 0; i--) stack[i + 1] = stack[i];\n                    stack[0] = t;\n                    j--;\n                  } else while (j < 0) {\n                    var t = stack[0];\n                    for (let i = 0; i <= n; i++) stack[i] = stack[i + 1];\n                    stack[n - 1] = t;\n                    j++;\n                  }\n                  break;\n                case 34:\n                  c1x = x + stack.shift();\n                  c1y = y;\n                  c2x = c1x + stack.shift();\n                  c2y = c1y + stack.shift();\n                  c3x = c2x + stack.shift();\n                  c3y = c2y;\n                  c4x = c3x + stack.shift();\n                  c4y = c3y;\n                  c5x = c4x + stack.shift();\n                  c5y = c4y;\n                  c6x = c5x + stack.shift();\n                  c6y = c5y;\n                  x = c6x;\n                  y = c6y;\n                  path.bezierCurveTo(c1x, c1y, c2x, c2y, c3x, c3y);\n                  path.bezierCurveTo(c4x, c4y, c5x, c5y, c6x, c6y);\n                  break;\n                case 35:\n                  pts = [];\n                  for (let i = 0; i <= 5; i++) {\n                    x += stack.shift();\n                    y += stack.shift();\n                    pts.push(x, y);\n                  }\n                  path.bezierCurveTo(...pts.slice(0, 6));\n                  path.bezierCurveTo(...pts.slice(6));\n                  stack.shift(); // fd\n                  break;\n                case 36:\n                  c1x = x + stack.shift();\n                  c1y = y + stack.shift();\n                  c2x = c1x + stack.shift();\n                  c2y = c1y + stack.shift();\n                  c3x = c2x + stack.shift();\n                  c3y = c2y;\n                  c4x = c3x + stack.shift();\n                  c4y = c3y;\n                  c5x = c4x + stack.shift();\n                  c5y = c4y + stack.shift();\n                  c6x = c5x + stack.shift();\n                  c6y = c5y;\n                  x = c6x;\n                  y = c6y;\n                  path.bezierCurveTo(c1x, c1y, c2x, c2y, c3x, c3y);\n                  path.bezierCurveTo(c4x, c4y, c5x, c5y, c6x, c6y);\n                  break;\n                case 37:\n                  let startx = x;\n                  let starty = y;\n                  pts = [];\n                  for (let i = 0; i <= 4; i++) {\n                    x += stack.shift();\n                    y += stack.shift();\n                    pts.push(x, y);\n                  }\n                  if (Math.abs(x - startx) > Math.abs(y - starty)) {\n                    x += stack.shift();\n                    y = starty;\n                  } else {\n                    x = startx;\n                    y += stack.shift();\n                  }\n                  pts.push(x, y);\n                  path.bezierCurveTo(...pts.slice(0, 6));\n                  path.bezierCurveTo(...pts.slice(6));\n                  break;\n                default:\n                  throw new Error(`Unknown op: 12 ${op}`);\n              }\n              break;\n            default:\n              throw new Error(`Unknown op: ${op}`);\n          }\n        } else if (op < 247) stack.push(op - 139);else if (op < 251) {\n          var b1 = stream.readUInt8();\n          stack.push((op - 247) * 256 + b1 + 108);\n        } else if (op < 255) {\n          var b1 = stream.readUInt8();\n          stack.push(-(op - 251) * 256 - b1 - 108);\n        } else stack.push(stream.readInt32BE() / 65536);\n      }\n    };\n    parse();\n    if (open) path.closePath();\n    return path;\n  }\n  constructor() {\n    super(...arguments);\n    (0, $6uUbQ$_)(this, \"type\", 'CFF');\n  }\n}\nlet $25d8f049c222084c$var$SBIXImage = new $6uUbQ$Struct({\n  originX: $6uUbQ$uint16,\n  originY: $6uUbQ$uint16,\n  type: new $6uUbQ$String(4),\n  data: new $6uUbQ$Buffer(t => t.parent.buflen - t._currentOffset)\n});\nclass $25d8f049c222084c$export$2e2bcd8739ae039 extends (0, $69aac16029968692$export$2e2bcd8739ae039) {\n  /**\n  * Returns an object representing a glyph image at the given point size.\n  * The object has a data property with a Buffer containing the actual image data,\n  * along with the image type, and origin.\n  *\n  * @param {number} size\n  * @return {object}\n  */\n  getImageForSize(size) {\n    for (let i = 0; i < this._font.sbix.imageTables.length; i++) {\n      var table = this._font.sbix.imageTables[i];\n      if (table.ppem >= size) break;\n    }\n    let offsets = table.imageOffsets;\n    let start = offsets[this.id];\n    let end = offsets[this.id + 1];\n    if (start === end) return null;\n    this._font.stream.pos = start;\n    return $25d8f049c222084c$var$SBIXImage.decode(this._font.stream, {\n      buflen: end - start\n    });\n  }\n  render(ctx, size) {\n    let img = this.getImageForSize(size);\n    if (img != null) {\n      let scale = size / this._font.unitsPerEm;\n      ctx.image(img.data, {\n        height: size,\n        x: img.originX,\n        y: (this.bbox.minY - img.originY) * scale\n      });\n    }\n    if (this._font.sbix.flags.renderOutlines) super.render(ctx, size);\n  }\n  constructor() {\n    super(...arguments);\n    (0, $6uUbQ$_)(this, \"type\", 'SBIX');\n  }\n}\nclass $0d411f0165859681$var$COLRLayer {\n  constructor(glyph, color) {\n    this.glyph = glyph;\n    this.color = color;\n  }\n}\nclass $0d411f0165859681$export$2e2bcd8739ae039 extends (0, $f92906be28e61769$export$2e2bcd8739ae039) {\n  _getBBox() {\n    let bbox = new (0, $f34600ab9d7f70d8$export$2e2bcd8739ae039)();\n    for (let i = 0; i < this.layers.length; i++) {\n      let layer = this.layers[i];\n      let b = layer.glyph.bbox;\n      bbox.addPoint(b.minX, b.minY);\n      bbox.addPoint(b.maxX, b.maxY);\n    }\n    return bbox;\n  }\n  /**\n  * Returns an array of objects containing the glyph and color for\n  * each layer in the composite color glyph.\n  * @type {object[]}\n  */\n  get layers() {\n    let cpal = this._font.CPAL;\n    let colr = this._font.COLR;\n    let low = 0;\n    let high = colr.baseGlyphRecord.length - 1;\n    while (low <= high) {\n      let mid = low + high >> 1;\n      var rec = colr.baseGlyphRecord[mid];\n      if (this.id < rec.gid) high = mid - 1;else if (this.id > rec.gid) low = mid + 1;else {\n        var baseLayer = rec;\n        break;\n      }\n    }\n    // if base glyph not found in COLR table,\n    // default to normal glyph from glyf or CFF\n    if (baseLayer == null) {\n      var g = this._font._getBaseGlyph(this.id);\n      var color = {\n        red: 0,\n        green: 0,\n        blue: 0,\n        alpha: 255\n      };\n      return [new $0d411f0165859681$var$COLRLayer(g, color)];\n    }\n    // otherwise, return an array of all the layers\n    let layers = [];\n    for (let i = baseLayer.firstLayerIndex; i < baseLayer.firstLayerIndex + baseLayer.numLayers; i++) {\n      var rec = colr.layerRecords[i];\n      var color = cpal.colorRecords[rec.paletteIndex];\n      var g = this._font._getBaseGlyph(rec.gid);\n      layers.push(new $0d411f0165859681$var$COLRLayer(g, color));\n    }\n    return layers;\n  }\n  render(ctx, size) {\n    for (let {\n      glyph: glyph,\n      color: color\n    } of this.layers) {\n      ctx.fillColor([color.red, color.green, color.blue], color.alpha / 255 * 100);\n      glyph.render(ctx, size);\n    }\n    return;\n  }\n  constructor() {\n    super(...arguments);\n    (0, $6uUbQ$_)(this, \"type\", 'COLR');\n  }\n}\nconst $0bb840cac04e911b$var$TUPLES_SHARE_POINT_NUMBERS = 0x8000;\nconst $0bb840cac04e911b$var$TUPLE_COUNT_MASK = 0x0fff;\nconst $0bb840cac04e911b$var$EMBEDDED_TUPLE_COORD = 0x8000;\nconst $0bb840cac04e911b$var$INTERMEDIATE_TUPLE = 0x4000;\nconst $0bb840cac04e911b$var$PRIVATE_POINT_NUMBERS = 0x2000;\nconst $0bb840cac04e911b$var$TUPLE_INDEX_MASK = 0x0fff;\nconst $0bb840cac04e911b$var$POINTS_ARE_WORDS = 0x80;\nconst $0bb840cac04e911b$var$POINT_RUN_COUNT_MASK = 0x7f;\nconst $0bb840cac04e911b$var$DELTAS_ARE_ZERO = 0x80;\nconst $0bb840cac04e911b$var$DELTAS_ARE_WORDS = 0x40;\nconst $0bb840cac04e911b$var$DELTA_RUN_COUNT_MASK = 0x3f;\nclass $0bb840cac04e911b$export$2e2bcd8739ae039 {\n  normalizeCoords(coords) {\n    // the default mapping is linear along each axis, in two segments:\n    // from the minValue to defaultValue, and from defaultValue to maxValue.\n    let normalized = [];\n    for (var i = 0; i < this.font.fvar.axis.length; i++) {\n      let axis = this.font.fvar.axis[i];\n      if (coords[i] < axis.defaultValue) normalized.push((coords[i] - axis.defaultValue + Number.EPSILON) / (axis.defaultValue - axis.minValue + Number.EPSILON));else normalized.push((coords[i] - axis.defaultValue + Number.EPSILON) / (axis.maxValue - axis.defaultValue + Number.EPSILON));\n    }\n    // if there is an avar table, the normalized value is calculated\n    // by interpolating between the two nearest mapped values.\n    if (this.font.avar) for (var i = 0; i < this.font.avar.segment.length; i++) {\n      let segment = this.font.avar.segment[i];\n      for (let j = 0; j < segment.correspondence.length; j++) {\n        let pair = segment.correspondence[j];\n        if (j >= 1 && normalized[i] < pair.fromCoord) {\n          let prev = segment.correspondence[j - 1];\n          normalized[i] = ((normalized[i] - prev.fromCoord) * (pair.toCoord - prev.toCoord) + Number.EPSILON) / (pair.fromCoord - prev.fromCoord + Number.EPSILON) + prev.toCoord;\n          break;\n        }\n      }\n    }\n    return normalized;\n  }\n  transformPoints(gid, glyphPoints) {\n    if (!this.font.fvar || !this.font.gvar) return;\n    let {\n      gvar: gvar\n    } = this.font;\n    if (gid >= gvar.glyphCount) return;\n    let offset = gvar.offsets[gid];\n    if (offset === gvar.offsets[gid + 1]) return;\n    // Read the gvar data for this glyph\n    let {\n      stream: stream\n    } = this.font;\n    stream.pos = offset;\n    if (stream.pos >= stream.length) return;\n    let tupleCount = stream.readUInt16BE();\n    let offsetToData = offset + stream.readUInt16BE();\n    if (tupleCount & $0bb840cac04e911b$var$TUPLES_SHARE_POINT_NUMBERS) {\n      var here = stream.pos;\n      stream.pos = offsetToData;\n      var sharedPoints = this.decodePoints();\n      offsetToData = stream.pos;\n      stream.pos = here;\n    }\n    let origPoints = glyphPoints.map(pt => pt.copy());\n    tupleCount &= $0bb840cac04e911b$var$TUPLE_COUNT_MASK;\n    for (let i = 0; i < tupleCount; i++) {\n      let tupleDataSize = stream.readUInt16BE();\n      let tupleIndex = stream.readUInt16BE();\n      if (tupleIndex & $0bb840cac04e911b$var$EMBEDDED_TUPLE_COORD) {\n        var tupleCoords = [];\n        for (let a = 0; a < gvar.axisCount; a++) tupleCoords.push(stream.readInt16BE() / 16384);\n      } else {\n        if ((tupleIndex & $0bb840cac04e911b$var$TUPLE_INDEX_MASK) >= gvar.globalCoordCount) throw new Error('Invalid gvar table');\n        var tupleCoords = gvar.globalCoords[tupleIndex & $0bb840cac04e911b$var$TUPLE_INDEX_MASK];\n      }\n      if (tupleIndex & $0bb840cac04e911b$var$INTERMEDIATE_TUPLE) {\n        var startCoords = [];\n        for (let a = 0; a < gvar.axisCount; a++) startCoords.push(stream.readInt16BE() / 16384);\n        var endCoords = [];\n        for (let a = 0; a < gvar.axisCount; a++) endCoords.push(stream.readInt16BE() / 16384);\n      }\n      // Get the factor at which to apply this tuple\n      let factor = this.tupleFactor(tupleIndex, tupleCoords, startCoords, endCoords);\n      if (factor === 0) {\n        offsetToData += tupleDataSize;\n        continue;\n      }\n      var here = stream.pos;\n      stream.pos = offsetToData;\n      if (tupleIndex & $0bb840cac04e911b$var$PRIVATE_POINT_NUMBERS) var points = this.decodePoints();else var points = sharedPoints;\n      // points.length = 0 means there are deltas for all points\n      let nPoints = points.length === 0 ? glyphPoints.length : points.length;\n      let xDeltas = this.decodeDeltas(nPoints);\n      let yDeltas = this.decodeDeltas(nPoints);\n      if (points.length === 0) for (let i = 0; i < glyphPoints.length; i++) {\n        var point = glyphPoints[i];\n        point.x += Math.round(xDeltas[i] * factor);\n        point.y += Math.round(yDeltas[i] * factor);\n      } else {\n        let outPoints = origPoints.map(pt => pt.copy());\n        let hasDelta = glyphPoints.map(() => false);\n        for (let i = 0; i < points.length; i++) {\n          let idx = points[i];\n          if (idx < glyphPoints.length) {\n            let point = outPoints[idx];\n            hasDelta[idx] = true;\n            point.x += xDeltas[i] * factor;\n            point.y += yDeltas[i] * factor;\n          }\n        }\n        this.interpolateMissingDeltas(outPoints, origPoints, hasDelta);\n        for (let i = 0; i < glyphPoints.length; i++) {\n          let deltaX = outPoints[i].x - origPoints[i].x;\n          let deltaY = outPoints[i].y - origPoints[i].y;\n          glyphPoints[i].x = Math.round(glyphPoints[i].x + deltaX);\n          glyphPoints[i].y = Math.round(glyphPoints[i].y + deltaY);\n        }\n      }\n      offsetToData += tupleDataSize;\n      stream.pos = here;\n    }\n  }\n  decodePoints() {\n    let stream = this.font.stream;\n    let count = stream.readUInt8();\n    if (count & $0bb840cac04e911b$var$POINTS_ARE_WORDS) count = (count & $0bb840cac04e911b$var$POINT_RUN_COUNT_MASK) << 8 | stream.readUInt8();\n    let points = new Uint16Array(count);\n    let i = 0;\n    let point = 0;\n    while (i < count) {\n      let run = stream.readUInt8();\n      let runCount = (run & $0bb840cac04e911b$var$POINT_RUN_COUNT_MASK) + 1;\n      let fn = run & $0bb840cac04e911b$var$POINTS_ARE_WORDS ? stream.readUInt16 : stream.readUInt8;\n      for (let j = 0; j < runCount && i < count; j++) {\n        point += fn.call(stream);\n        points[i++] = point;\n      }\n    }\n    return points;\n  }\n  decodeDeltas(count) {\n    let stream = this.font.stream;\n    let i = 0;\n    let deltas = new Int16Array(count);\n    while (i < count) {\n      let run = stream.readUInt8();\n      let runCount = (run & $0bb840cac04e911b$var$DELTA_RUN_COUNT_MASK) + 1;\n      if (run & $0bb840cac04e911b$var$DELTAS_ARE_ZERO) i += runCount;else {\n        let fn = run & $0bb840cac04e911b$var$DELTAS_ARE_WORDS ? stream.readInt16BE : stream.readInt8;\n        for (let j = 0; j < runCount && i < count; j++) deltas[i++] = fn.call(stream);\n      }\n    }\n    return deltas;\n  }\n  tupleFactor(tupleIndex, tupleCoords, startCoords, endCoords) {\n    let normalized = this.normalizedCoords;\n    let {\n      gvar: gvar\n    } = this.font;\n    let factor = 1;\n    for (let i = 0; i < gvar.axisCount; i++) {\n      if (tupleCoords[i] === 0) continue;\n      if (normalized[i] === 0) return 0;\n      if ((tupleIndex & $0bb840cac04e911b$var$INTERMEDIATE_TUPLE) === 0) {\n        if (normalized[i] < Math.min(0, tupleCoords[i]) || normalized[i] > Math.max(0, tupleCoords[i])) return 0;\n        factor = (factor * normalized[i] + Number.EPSILON) / (tupleCoords[i] + Number.EPSILON);\n      } else {\n        if (normalized[i] < startCoords[i] || normalized[i] > endCoords[i]) return 0;else if (normalized[i] < tupleCoords[i]) factor = factor * (normalized[i] - startCoords[i] + Number.EPSILON) / (tupleCoords[i] - startCoords[i] + Number.EPSILON);else factor = factor * (endCoords[i] - normalized[i] + Number.EPSILON) / (endCoords[i] - tupleCoords[i] + Number.EPSILON);\n      }\n    }\n    return factor;\n  }\n  // Interpolates points without delta values.\n  // Needed for the  and Q glyphs in Skia.\n  // Algorithm from Freetype.\n  interpolateMissingDeltas(points, inPoints, hasDelta) {\n    if (points.length === 0) return;\n    let point = 0;\n    while (point < points.length) {\n      let firstPoint = point;\n      // find the end point of the contour\n      let endPoint = point;\n      let pt = points[endPoint];\n      while (!pt.endContour) pt = points[++endPoint];\n      // find the first point that has a delta\n      while (point <= endPoint && !hasDelta[point]) point++;\n      if (point > endPoint) continue;\n      let firstDelta = point;\n      let curDelta = point;\n      point++;\n      while (point <= endPoint) {\n        // find the next point with a delta, and interpolate intermediate points\n        if (hasDelta[point]) {\n          this.deltaInterpolate(curDelta + 1, point - 1, curDelta, point, inPoints, points);\n          curDelta = point;\n        }\n        point++;\n      }\n      // shift contour if we only have a single delta\n      if (curDelta === firstDelta) this.deltaShift(firstPoint, endPoint, curDelta, inPoints, points);else {\n        // otherwise, handle the remaining points at the end and beginning of the contour\n        this.deltaInterpolate(curDelta + 1, endPoint, curDelta, firstDelta, inPoints, points);\n        if (firstDelta > 0) this.deltaInterpolate(firstPoint, firstDelta - 1, curDelta, firstDelta, inPoints, points);\n      }\n      point = endPoint + 1;\n    }\n  }\n  deltaInterpolate(p1, p2, ref1, ref2, inPoints, outPoints) {\n    if (p1 > p2) return;\n    let iterable = ['x', 'y'];\n    for (let i = 0; i < iterable.length; i++) {\n      let k = iterable[i];\n      if (inPoints[ref1][k] > inPoints[ref2][k]) {\n        var p = ref1;\n        ref1 = ref2;\n        ref2 = p;\n      }\n      let in1 = inPoints[ref1][k];\n      let in2 = inPoints[ref2][k];\n      let out1 = outPoints[ref1][k];\n      let out2 = outPoints[ref2][k];\n      // If the reference points have the same coordinate but different\n      // delta, inferred delta is zero.  Otherwise interpolate.\n      if (in1 !== in2 || out1 === out2) {\n        let scale = in1 === in2 ? 0 : (out2 - out1) / (in2 - in1);\n        for (let p = p1; p <= p2; p++) {\n          let out = inPoints[p][k];\n          if (out <= in1) out += out1 - in1;else if (out >= in2) out += out2 - in2;else out = out1 + (out - in1) * scale;\n          outPoints[p][k] = out;\n        }\n      }\n    }\n  }\n  deltaShift(p1, p2, ref, inPoints, outPoints) {\n    let deltaX = outPoints[ref].x - inPoints[ref].x;\n    let deltaY = outPoints[ref].y - inPoints[ref].y;\n    if (deltaX === 0 && deltaY === 0) return;\n    for (let p = p1; p <= p2; p++) if (p !== ref) {\n      outPoints[p].x += deltaX;\n      outPoints[p].y += deltaY;\n    }\n  }\n  getAdvanceAdjustment(gid, table) {\n    let outerIndex, innerIndex;\n    if (table.advanceWidthMapping) {\n      let idx = gid;\n      if (idx >= table.advanceWidthMapping.mapCount) idx = table.advanceWidthMapping.mapCount - 1;\n      let entryFormat = table.advanceWidthMapping.entryFormat;\n      ({\n        outerIndex: outerIndex,\n        innerIndex: innerIndex\n      } = table.advanceWidthMapping.mapData[idx]);\n    } else {\n      outerIndex = 0;\n      innerIndex = gid;\n    }\n    return this.getDelta(table.itemVariationStore, outerIndex, innerIndex);\n  }\n  // See pseudo code from `Font Variations Overview'\n  // in the OpenType specification.\n  getDelta(itemStore, outerIndex, innerIndex) {\n    if (outerIndex >= itemStore.itemVariationData.length) return 0;\n    let varData = itemStore.itemVariationData[outerIndex];\n    if (innerIndex >= varData.deltaSets.length) return 0;\n    let deltaSet = varData.deltaSets[innerIndex];\n    let blendVector = this.getBlendVector(itemStore, outerIndex);\n    let netAdjustment = 0;\n    for (let master = 0; master < varData.regionIndexCount; master++) netAdjustment += deltaSet.deltas[master] * blendVector[master];\n    return netAdjustment;\n  }\n  getBlendVector(itemStore, outerIndex) {\n    let varData = itemStore.itemVariationData[outerIndex];\n    if (this.blendVectors.has(varData)) return this.blendVectors.get(varData);\n    let normalizedCoords = this.normalizedCoords;\n    let blendVector = [];\n    // outer loop steps through master designs to be blended\n    for (let master = 0; master < varData.regionIndexCount; master++) {\n      let scalar = 1;\n      let regionIndex = varData.regionIndexes[master];\n      let axes = itemStore.variationRegionList.variationRegions[regionIndex];\n      // inner loop steps through axes in this region\n      for (let j = 0; j < axes.length; j++) {\n        let axis = axes[j];\n        let axisScalar;\n        // compute the scalar contribution of this axis\n        // ignore invalid ranges\n        if (axis.startCoord > axis.peakCoord || axis.peakCoord > axis.endCoord) axisScalar = 1;else if (axis.startCoord < 0 && axis.endCoord > 0 && axis.peakCoord !== 0) axisScalar = 1;else if (axis.peakCoord === 0) axisScalar = 1;else if (normalizedCoords[j] < axis.startCoord || normalizedCoords[j] > axis.endCoord) axisScalar = 0;else {\n          if (normalizedCoords[j] === axis.peakCoord) axisScalar = 1;else if (normalizedCoords[j] < axis.peakCoord) axisScalar = (normalizedCoords[j] - axis.startCoord + Number.EPSILON) / (axis.peakCoord - axis.startCoord + Number.EPSILON);else axisScalar = (axis.endCoord - normalizedCoords[j] + Number.EPSILON) / (axis.endCoord - axis.peakCoord + Number.EPSILON);\n        }\n        // take product of all the axis scalars\n        scalar *= axisScalar;\n      }\n      blendVector[master] = scalar;\n    }\n    this.blendVectors.set(varData, blendVector);\n    return blendVector;\n  }\n  constructor(font, coords) {\n    this.font = font;\n    this.normalizedCoords = this.normalizeCoords(coords);\n    this.blendVectors = new Map();\n  }\n}\nconst $5cc7476da92df375$var$resolved = Promise.resolve();\nclass $5cc7476da92df375$export$2e2bcd8739ae039 {\n  includeGlyph(glyph) {\n    if (typeof glyph === 'object') glyph = glyph.id;\n    if (this.mapping[glyph] == null) {\n      this.glyphs.push(glyph);\n      this.mapping[glyph] = this.glyphs.length - 1;\n    }\n    return this.mapping[glyph];\n  }\n  constructor(font) {\n    this.font = font;\n    this.glyphs = [];\n    this.mapping = {};\n    // always include the missing glyph\n    this.includeGlyph(0);\n  }\n}\n\n// Flags for simple glyphs\nconst $807e58506be70005$var$ON_CURVE = 1;\nconst $807e58506be70005$var$X_SHORT_VECTOR = 2;\nconst $807e58506be70005$var$Y_SHORT_VECTOR = 4;\nconst $807e58506be70005$var$REPEAT = 8;\nconst $807e58506be70005$var$SAME_X = 16;\nconst $807e58506be70005$var$SAME_Y = 32;\nclass $807e58506be70005$var$Point {\n  static size(val) {\n    return val >= 0 && val <= 255 ? 1 : 2;\n  }\n  static encode(stream, value) {\n    if (value >= 0 && value <= 255) stream.writeUInt8(value);else stream.writeInt16BE(value);\n  }\n}\nlet $807e58506be70005$var$Glyf = new $6uUbQ$Struct({\n  numberOfContours: $6uUbQ$int16,\n  xMin: $6uUbQ$int16,\n  yMin: $6uUbQ$int16,\n  xMax: $6uUbQ$int16,\n  yMax: $6uUbQ$int16,\n  endPtsOfContours: new $6uUbQ$Array($6uUbQ$uint16, 'numberOfContours'),\n  instructions: new $6uUbQ$Array($6uUbQ$uint8, $6uUbQ$uint16),\n  flags: new $6uUbQ$Array($6uUbQ$uint8, 0),\n  xPoints: new $6uUbQ$Array($807e58506be70005$var$Point, 0),\n  yPoints: new $6uUbQ$Array($807e58506be70005$var$Point, 0)\n});\nclass $807e58506be70005$export$2e2bcd8739ae039 {\n  encodeSimple(path) {\n    let instructions = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n    let endPtsOfContours = [];\n    let xPoints = [];\n    let yPoints = [];\n    let flags = [];\n    let same = 0;\n    let lastX = 0,\n      lastY = 0,\n      lastFlag = 0;\n    let pointCount = 0;\n    for (let i = 0; i < path.commands.length; i++) {\n      let c = path.commands[i];\n      for (let j = 0; j < c.args.length; j += 2) {\n        let x = c.args[j];\n        let y = c.args[j + 1];\n        let flag = 0;\n        // If the ending point of a quadratic curve is the midpoint\n        // between the control point and the control point of the next\n        // quadratic curve, we can omit the ending point.\n        if (c.command === 'quadraticCurveTo' && j === 2) {\n          let next = path.commands[i + 1];\n          if (next && next.command === 'quadraticCurveTo') {\n            let midX = (lastX + next.args[0]) / 2;\n            let midY = (lastY + next.args[1]) / 2;\n            if (x === midX && y === midY) continue;\n          }\n        }\n        // All points except control points are on curve.\n        if (!(c.command === 'quadraticCurveTo' && j === 0)) flag |= $807e58506be70005$var$ON_CURVE;\n        flag = this._encodePoint(x, lastX, xPoints, flag, $807e58506be70005$var$X_SHORT_VECTOR, $807e58506be70005$var$SAME_X);\n        flag = this._encodePoint(y, lastY, yPoints, flag, $807e58506be70005$var$Y_SHORT_VECTOR, $807e58506be70005$var$SAME_Y);\n        if (flag === lastFlag && same < 255) {\n          flags[flags.length - 1] |= $807e58506be70005$var$REPEAT;\n          same++;\n        } else {\n          if (same > 0) {\n            flags.push(same);\n            same = 0;\n          }\n          flags.push(flag);\n          lastFlag = flag;\n        }\n        lastX = x;\n        lastY = y;\n        pointCount++;\n      }\n      if (c.command === 'closePath') endPtsOfContours.push(pointCount - 1);\n    }\n    // Close the path if the last command didn't already\n    if (path.commands.length > 1 && path.commands[path.commands.length - 1].command !== 'closePath') endPtsOfContours.push(pointCount - 1);\n    let bbox = path.bbox;\n    let glyf = {\n      numberOfContours: endPtsOfContours.length,\n      xMin: bbox.minX,\n      yMin: bbox.minY,\n      xMax: bbox.maxX,\n      yMax: bbox.maxY,\n      endPtsOfContours: endPtsOfContours,\n      instructions: instructions,\n      flags: flags,\n      xPoints: xPoints,\n      yPoints: yPoints\n    };\n    let size = $807e58506be70005$var$Glyf.size(glyf);\n    let tail = 4 - size % 4;\n    let stream = new $6uUbQ$EncodeStream(size + tail);\n    $807e58506be70005$var$Glyf.encode(stream, glyf);\n    // Align to 4-byte length\n    if (tail !== 0) stream.fill(0, tail);\n    return stream.buffer;\n  }\n  _encodePoint(value, last, points, flag, shortFlag, sameFlag) {\n    let diff = value - last;\n    if (value === last) flag |= sameFlag;else {\n      if (-255 <= diff && diff <= 255) {\n        flag |= shortFlag;\n        if (diff < 0) diff = -diff;else flag |= sameFlag;\n      }\n      points.push(diff);\n    }\n    return flag;\n  }\n}\nclass $4abbb6a5dbdc441a$export$2e2bcd8739ae039 extends (0, $5cc7476da92df375$export$2e2bcd8739ae039) {\n  _addGlyph(gid) {\n    let glyph = this.font.getGlyph(gid);\n    let glyf = glyph._decode();\n    // get the offset to the glyph from the loca table\n    let curOffset = this.font.loca.offsets[gid];\n    let nextOffset = this.font.loca.offsets[gid + 1];\n    let stream = this.font._getTableStream('glyf');\n    stream.pos += curOffset;\n    let buffer = stream.readBuffer(nextOffset - curOffset);\n    // if it is a compound glyph, include its components\n    if (glyf && glyf.numberOfContours < 0) {\n      buffer = new Uint8Array(buffer);\n      let view = new DataView(buffer.buffer);\n      for (let component of glyf.components) {\n        gid = this.includeGlyph(component.glyphID);\n        view.setUint16(component.pos, gid);\n      }\n    } else if (glyf && this.font._variationProcessor)\n      // If this is a TrueType variation glyph, re-encode the path\n      buffer = this.glyphEncoder.encodeSimple(glyph.path, glyf.instructions);\n    this.glyf.push(buffer);\n    this.loca.offsets.push(this.offset);\n    this.hmtx.metrics.push({\n      advance: glyph.advanceWidth,\n      bearing: glyph._getMetrics().leftBearing\n    });\n    this.offset += buffer.length;\n    return this.glyf.length - 1;\n  }\n  encode() {\n    // tables required by PDF spec:\n    //   head, hhea, loca, maxp, cvt , prep, glyf, hmtx, fpgm\n    //\n    // additional tables required for standalone fonts:\n    //   name, cmap, OS/2, post\n    this.glyf = [];\n    this.offset = 0;\n    this.loca = {\n      offsets: [],\n      version: this.font.loca.version\n    };\n    this.hmtx = {\n      metrics: [],\n      bearings: []\n    };\n    // include all the glyphs\n    // not using a for loop because we need to support adding more\n    // glyphs to the array as we go, and CoffeeScript caches the length.\n    let i = 0;\n    while (i < this.glyphs.length) this._addGlyph(this.glyphs[i++]);\n    let maxp = (0, $6uUbQ$clone)(this.font.maxp);\n    maxp.numGlyphs = this.glyf.length;\n    this.loca.offsets.push(this.offset);\n    let head = (0, $6uUbQ$clone)(this.font.head);\n    head.indexToLocFormat = this.loca.version;\n    let hhea = (0, $6uUbQ$clone)(this.font.hhea);\n    hhea.numberOfMetrics = this.hmtx.metrics.length;\n    // map = []\n    // for index in [0...256]\n    //     if index < @numGlyphs\n    //         map[index] = index\n    //     else\n    //         map[index] = 0\n    //\n    // cmapTable =\n    //     version: 0\n    //     length: 262\n    //     language: 0\n    //     codeMap: map\n    //\n    // cmap =\n    //     version: 0\n    //     numSubtables: 1\n    //     tables: [\n    //         platformID: 1\n    //         encodingID: 0\n    //         table: cmapTable\n    //     ]\n    // TODO: subset prep, cvt, fpgm?\n    return (0, $816c07a04b6dba87$export$2e2bcd8739ae039).toBuffer({\n      tables: {\n        head: head,\n        hhea: hhea,\n        loca: this.loca,\n        maxp: maxp,\n        'cvt ': this.font['cvt '],\n        prep: this.font.prep,\n        glyf: this.glyf,\n        hmtx: this.hmtx,\n        fpgm: this.font.fpgm\n      }\n    });\n  }\n  constructor(font) {\n    super(font);\n    this.glyphEncoder = new (0, $807e58506be70005$export$2e2bcd8739ae039)();\n  }\n}\nclass $001d739428a71d5a$export$2e2bcd8739ae039 extends (0, $5cc7476da92df375$export$2e2bcd8739ae039) {\n  subsetCharstrings() {\n    this.charstrings = [];\n    let gsubrs = {};\n    for (let gid of this.glyphs) {\n      this.charstrings.push(this.cff.getCharString(gid));\n      let glyph = this.font.getGlyph(gid);\n      let path = glyph.path; // this causes the glyph to be parsed\n      for (let subr in glyph._usedGsubrs) gsubrs[subr] = true;\n    }\n    this.gsubrs = this.subsetSubrs(this.cff.globalSubrIndex, gsubrs);\n  }\n  subsetSubrs(subrs, used) {\n    let res = [];\n    for (let i = 0; i < subrs.length; i++) {\n      let subr = subrs[i];\n      if (used[i]) {\n        this.cff.stream.pos = subr.offset;\n        res.push(this.cff.stream.readBuffer(subr.length));\n      } else res.push(new Uint8Array([11])); // return\n    }\n    return res;\n  }\n  subsetFontdict(topDict) {\n    topDict.FDArray = [];\n    topDict.FDSelect = {\n      version: 0,\n      fds: []\n    };\n    let used_fds = {};\n    let used_subrs = [];\n    let fd_select = {};\n    for (let gid of this.glyphs) {\n      let fd = this.cff.fdForGlyph(gid);\n      if (fd == null) continue;\n      if (!used_fds[fd]) {\n        topDict.FDArray.push(Object.assign({}, this.cff.topDict.FDArray[fd]));\n        used_subrs.push({});\n        fd_select[fd] = topDict.FDArray.length - 1;\n      }\n      used_fds[fd] = true;\n      topDict.FDSelect.fds.push(fd_select[fd]);\n      let glyph = this.font.getGlyph(gid);\n      let path = glyph.path; // this causes the glyph to be parsed\n      for (let subr in glyph._usedSubrs) used_subrs[fd_select[fd]][subr] = true;\n    }\n    for (let i = 0; i < topDict.FDArray.length; i++) {\n      let dict = topDict.FDArray[i];\n      delete dict.FontName;\n      if (dict.Private && dict.Private.Subrs) {\n        dict.Private = Object.assign({}, dict.Private);\n        dict.Private.Subrs = this.subsetSubrs(dict.Private.Subrs, used_subrs[i]);\n      }\n    }\n    return;\n  }\n  createCIDFontdict(topDict) {\n    let used_subrs = {};\n    for (let gid of this.glyphs) {\n      let glyph = this.font.getGlyph(gid);\n      let path = glyph.path; // this causes the glyph to be parsed\n      for (let subr in glyph._usedSubrs) used_subrs[subr] = true;\n    }\n    let privateDict = Object.assign({}, this.cff.topDict.Private);\n    if (this.cff.topDict.Private && this.cff.topDict.Private.Subrs) privateDict.Subrs = this.subsetSubrs(this.cff.topDict.Private.Subrs, used_subrs);\n    topDict.FDArray = [{\n      Private: privateDict\n    }];\n    return topDict.FDSelect = {\n      version: 3,\n      nRanges: 1,\n      ranges: [{\n        first: 0,\n        fd: 0\n      }],\n      sentinel: this.charstrings.length\n    };\n  }\n  addString(string) {\n    if (!string) return null;\n    if (!this.strings) this.strings = [];\n    this.strings.push(string);\n    return (0, $229224aec43783c5$export$2e2bcd8739ae039).length + this.strings.length - 1;\n  }\n  encode() {\n    this.subsetCharstrings();\n    let charset = {\n      version: this.charstrings.length > 255 ? 2 : 1,\n      ranges: [{\n        first: 1,\n        nLeft: this.charstrings.length - 2\n      }]\n    };\n    let topDict = Object.assign({}, this.cff.topDict);\n    topDict.Private = null;\n    topDict.charset = charset;\n    topDict.Encoding = null;\n    topDict.CharStrings = this.charstrings;\n    for (let key of ['version', 'Notice', 'Copyright', 'FullName', 'FamilyName', 'Weight', 'PostScript', 'BaseFontName', 'FontName']) topDict[key] = this.addString(this.cff.string(topDict[key]));\n    topDict.ROS = [this.addString('Adobe'), this.addString('Identity'), 0];\n    topDict.CIDCount = this.charstrings.length;\n    if (this.cff.isCIDFont) this.subsetFontdict(topDict);else this.createCIDFontdict(topDict);\n    let top = {\n      version: 1,\n      hdrSize: this.cff.hdrSize,\n      offSize: 4,\n      header: this.cff.header,\n      nameIndex: [this.cff.postscriptName],\n      topDictIndex: [topDict],\n      stringIndex: this.strings,\n      globalSubrIndex: this.gsubrs\n    };\n    return (0, $b84fd3dd9d8eddb2$export$2e2bcd8739ae039).toBuffer(top);\n  }\n  constructor(font) {\n    super(font);\n    this.cff = this.font['CFF '];\n    if (!this.cff) throw new Error('Not a CFF Font');\n  }\n}\nclass $4c1709dee528ea76$export$2e2bcd8739ae039 {\n  static probe(buffer) {\n    let format = (0, $12727730ddfc8bfe$export$3d28c1996ced1f14).decode(buffer.slice(0, 4));\n    return format === 'true' || format === 'OTTO' || format === String.fromCharCode(0, 1, 0, 0);\n  }\n  setDefaultLanguage() {\n    let lang = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n    this.defaultLanguage = lang;\n  }\n  _getTable(table) {\n    if (!(table.tag in this._tables)) try {\n      this._tables[table.tag] = this._decodeTable(table);\n    } catch (e) {\n      if ($d636bc798e7178db$export$bd5c5d8b8dcafd78) {\n        console.error(`Error decoding table ${table.tag}`);\n        console.error(e.stack);\n      }\n    }\n    return this._tables[table.tag];\n  }\n  _getTableStream(tag) {\n    let table = this.directory.tables[tag];\n    if (table) {\n      this.stream.pos = table.offset;\n      return this.stream;\n    }\n    return null;\n  }\n  _decodeDirectory() {\n    return this.directory = (0, $816c07a04b6dba87$export$2e2bcd8739ae039).decode(this.stream, {\n      _startOffset: 0\n    });\n  }\n  _decodeTable(table) {\n    let pos = this.stream.pos;\n    let stream = this._getTableStream(table.tag);\n    let result = (0, $c3395722bea751e2$export$2e2bcd8739ae039)[table.tag].decode(stream, this, table.length);\n    this.stream.pos = pos;\n    return result;\n  }\n  /**\n  * Gets a string from the font's `name` table\n  * `lang` is a BCP-47 language code.\n  * @return {string}\n  */\n  getName(key) {\n    let lang = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.defaultLanguage || $d636bc798e7178db$export$42940898df819940;\n    let record = this.name && this.name.records[key];\n    if (record)\n      // Attempt to retrieve the entry, depending on which translation is available:\n      return record[lang] || record[this.defaultLanguage] || record[$d636bc798e7178db$export$42940898df819940] || record['en'] || record[Object.keys(record)[0]] // Seriously, ANY language would be fine\n      || null;\n    return null;\n  }\n  /**\n  * The unique PostScript name for this font, e.g. \"Helvetica-Bold\"\n  * @type {string}\n  */\n  get postscriptName() {\n    return this.getName('postscriptName');\n  }\n  /**\n  * The font's full name, e.g. \"Helvetica Bold\"\n  * @type {string}\n  */\n  get fullName() {\n    return this.getName('fullName');\n  }\n  /**\n  * The font's family name, e.g. \"Helvetica\"\n  * @type {string}\n  */\n  get familyName() {\n    return this.getName('fontFamily');\n  }\n  /**\n  * The font's sub-family, e.g. \"Bold\".\n  * @type {string}\n  */\n  get subfamilyName() {\n    return this.getName('fontSubfamily');\n  }\n  /**\n  * The font's copyright information\n  * @type {string}\n  */\n  get copyright() {\n    return this.getName('copyright');\n  }\n  /**\n  * The font's version number\n  * @type {string}\n  */\n  get version() {\n    return this.getName('version');\n  }\n  /**\n  * The fonts [ascender](https://en.wikipedia.org/wiki/Ascender_(typography))\n  * @type {number}\n  */\n  get ascent() {\n    return this.hhea.ascent;\n  }\n  /**\n  * The fonts [descender](https://en.wikipedia.org/wiki/Descender)\n  * @type {number}\n  */\n  get descent() {\n    return this.hhea.descent;\n  }\n  /**\n  * The amount of space that should be included between lines\n  * @type {number}\n  */\n  get lineGap() {\n    return this.hhea.lineGap;\n  }\n  /**\n  * The offset from the normal underline position that should be used\n  * @type {number}\n  */\n  get underlinePosition() {\n    return this.post.underlinePosition;\n  }\n  /**\n  * The weight of the underline that should be used\n  * @type {number}\n  */\n  get underlineThickness() {\n    return this.post.underlineThickness;\n  }\n  /**\n  * If this is an italic font, the angle the cursor should be drawn at to match the font design\n  * @type {number}\n  */\n  get italicAngle() {\n    return this.post.italicAngle;\n  }\n  /**\n  * The height of capital letters above the baseline.\n  * See [here](https://en.wikipedia.org/wiki/Cap_height) for more details.\n  * @type {number}\n  */\n  get capHeight() {\n    let os2 = this['OS/2'];\n    return os2 ? os2.capHeight : this.ascent;\n  }\n  /**\n  * The height of lower case letters in the font.\n  * See [here](https://en.wikipedia.org/wiki/X-height) for more details.\n  * @type {number}\n  */\n  get xHeight() {\n    let os2 = this['OS/2'];\n    return os2 ? os2.xHeight : 0;\n  }\n  /**\n  * The number of glyphs in the font.\n  * @type {number}\n  */\n  get numGlyphs() {\n    return this.maxp.numGlyphs;\n  }\n  /**\n  * The size of the fonts internal coordinate grid\n  * @type {number}\n  */\n  get unitsPerEm() {\n    return this.head.unitsPerEm;\n  }\n  /**\n  * The fonts bounding box, i.e. the box that encloses all glyphs in the font.\n  * @type {BBox}\n  */\n  get bbox() {\n    return Object.freeze(new (0, $f34600ab9d7f70d8$export$2e2bcd8739ae039)(this.head.xMin, this.head.yMin, this.head.xMax, this.head.yMax));\n  }\n  get _cmapProcessor() {\n    return new (0, $f08dd41ef10b694c$export$2e2bcd8739ae039)(this.cmap);\n  }\n  /**\n  * An array of all of the unicode code points supported by the font.\n  * @type {number[]}\n  */\n  get characterSet() {\n    return this._cmapProcessor.getCharacterSet();\n  }\n  /**\n  * Returns whether there is glyph in the font for the given unicode code point.\n  *\n  * @param {number} codePoint\n  * @return {boolean}\n  */\n  hasGlyphForCodePoint(codePoint) {\n    return !!this._cmapProcessor.lookup(codePoint);\n  }\n  /**\n  * Maps a single unicode code point to a Glyph object.\n  * Does not perform any advanced substitutions (there is no context to do so).\n  *\n  * @param {number} codePoint\n  * @return {Glyph}\n  */\n  glyphForCodePoint(codePoint) {\n    return this.getGlyph(this._cmapProcessor.lookup(codePoint), [codePoint]);\n  }\n  /**\n  * Returns an array of Glyph objects for the given string.\n  * This is only a one-to-one mapping from characters to glyphs.\n  * For most uses, you should use font.layout (described below), which\n  * provides a much more advanced mapping supporting AAT and OpenType shaping.\n  *\n  * @param {string} string\n  * @return {Glyph[]}\n  */\n  glyphsForString(string) {\n    let glyphs = [];\n    let len = string.length;\n    let idx = 0;\n    let last = -1;\n    let state = -1;\n    while (idx <= len) {\n      let code = 0;\n      let nextState = 0;\n      if (idx < len) {\n        // Decode the next codepoint from UTF 16\n        code = string.charCodeAt(idx++);\n        if (0xd800 <= code && code <= 0xdbff && idx < len) {\n          let next = string.charCodeAt(idx);\n          if (0xdc00 <= next && next <= 0xdfff) {\n            idx++;\n            code = ((code & 0x3ff) << 10) + (next & 0x3ff) + 0x10000;\n          }\n        }\n        // Compute the next state: 1 if the next codepoint is a variation selector, 0 otherwise.\n        nextState = 0xfe00 <= code && code <= 0xfe0f || 0xe0100 <= code && code <= 0xe01ef ? 1 : 0;\n      } else idx++;\n      if (state === 0 && nextState === 1)\n        // Variation selector following normal codepoint.\n        glyphs.push(this.getGlyph(this._cmapProcessor.lookup(last, code), [last, code]));else if (state === 0 && nextState === 0)\n        // Normal codepoint following normal codepoint.\n        glyphs.push(this.glyphForCodePoint(last));\n      last = code;\n      state = nextState;\n    }\n    return glyphs;\n  }\n  get _layoutEngine() {\n    return new (0, $4c0a7fa5df7a9ab1$export$2e2bcd8739ae039)(this);\n  }\n  /**\n  * Returns a GlyphRun object, which includes an array of Glyphs and GlyphPositions for the given string.\n  *\n  * @param {string} string\n  * @param {string[]} [userFeatures]\n  * @param {string} [script]\n  * @param {string} [language]\n  * @param {string} [direction]\n  * @return {GlyphRun}\n  */\n  layout(string, userFeatures, script, language, direction) {\n    return this._layoutEngine.layout(string, userFeatures, script, language, direction);\n  }\n  /**\n  * Returns an array of strings that map to the given glyph id.\n  * @param {number} gid - glyph id\n  */\n  stringsForGlyph(gid) {\n    return this._layoutEngine.stringsForGlyph(gid);\n  }\n  /**\n  * An array of all [OpenType feature tags](https://www.microsoft.com/typography/otspec/featuretags.htm)\n  * (or mapped AAT tags) supported by the font.\n  * The features parameter is an array of OpenType feature tags to be applied in addition to the default set.\n  * If this is an AAT font, the OpenType feature tags are mapped to AAT features.\n  *\n  * @type {string[]}\n  */\n  get availableFeatures() {\n    return this._layoutEngine.getAvailableFeatures();\n  }\n  getAvailableFeatures(script, language) {\n    return this._layoutEngine.getAvailableFeatures(script, language);\n  }\n  _getBaseGlyph(glyph) {\n    let characters = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n    if (!this._glyphs[glyph]) {\n      if (this.directory.tables.glyf) this._glyphs[glyph] = new (0, $69aac16029968692$export$2e2bcd8739ae039)(glyph, characters, this);else if (this.directory.tables['CFF '] || this.directory.tables.CFF2) this._glyphs[glyph] = new (0, $62cc5109c6101893$export$2e2bcd8739ae039)(glyph, characters, this);\n    }\n    return this._glyphs[glyph] || null;\n  }\n  /**\n  * Returns a glyph object for the given glyph id.\n  * You can pass the array of code points this glyph represents for\n  * your use later, and it will be stored in the glyph object.\n  *\n  * @param {number} glyph\n  * @param {number[]} characters\n  * @return {Glyph}\n  */\n  getGlyph(glyph) {\n    let characters = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n    if (!this._glyphs[glyph]) {\n      if (this.directory.tables.sbix) this._glyphs[glyph] = new (0, $25d8f049c222084c$export$2e2bcd8739ae039)(glyph, characters, this);else if (this.directory.tables.COLR && this.directory.tables.CPAL) this._glyphs[glyph] = new (0, $0d411f0165859681$export$2e2bcd8739ae039)(glyph, characters, this);else this._getBaseGlyph(glyph, characters);\n    }\n    return this._glyphs[glyph] || null;\n  }\n  /**\n  * Returns a Subset for this font.\n  * @return {Subset}\n  */\n  createSubset() {\n    if (this.directory.tables['CFF ']) return new (0, $001d739428a71d5a$export$2e2bcd8739ae039)(this);\n    return new (0, $4abbb6a5dbdc441a$export$2e2bcd8739ae039)(this);\n  }\n  /**\n  * Returns an object describing the available variation axes\n  * that this font supports. Keys are setting tags, and values\n  * contain the axis name, range, and default value.\n  *\n  * @type {object}\n  */\n  get variationAxes() {\n    let res = {};\n    if (!this.fvar) return res;\n    for (let axis of this.fvar.axis) res[axis.axisTag.trim()] = {\n      name: axis.name.en,\n      min: axis.minValue,\n      default: axis.defaultValue,\n      max: axis.maxValue\n    };\n    return res;\n  }\n  /**\n  * Returns an object describing the named variation instances\n  * that the font designer has specified. Keys are variation names\n  * and values are the variation settings for this instance.\n  *\n  * @type {object}\n  */\n  get namedVariations() {\n    let res = {};\n    if (!this.fvar) return res;\n    for (let instance of this.fvar.instance) {\n      let settings = {};\n      for (let i = 0; i < this.fvar.axis.length; i++) {\n        let axis = this.fvar.axis[i];\n        settings[axis.axisTag.trim()] = instance.coord[i];\n      }\n      res[instance.name.en] = settings;\n    }\n    return res;\n  }\n  /**\n  * Returns a new font with the given variation settings applied.\n  * Settings can either be an instance name, or an object containing\n  * variation tags as specified by the `variationAxes` property.\n  *\n  * @param {object} settings\n  * @return {TTFFont}\n  */\n  getVariation(settings) {\n    if (!(this.directory.tables.fvar && (this.directory.tables.gvar && this.directory.tables.glyf || this.directory.tables.CFF2))) throw new Error('Variations require a font with the fvar, gvar and glyf, or CFF2 tables.');\n    if (typeof settings === 'string') settings = this.namedVariations[settings];\n    if (typeof settings !== 'object') throw new Error('Variation settings must be either a variation name or settings object.');\n    // normalize the coordinates\n    let coords = this.fvar.axis.map((axis, i) => {\n      let axisTag = axis.axisTag.trim();\n      if (axisTag in settings) return Math.max(axis.minValue, Math.min(axis.maxValue, settings[axisTag]));else return axis.defaultValue;\n    });\n    let stream = new $6uUbQ$DecodeStream(this.stream.buffer);\n    stream.pos = this._directoryPos;\n    let font = new $4c1709dee528ea76$export$2e2bcd8739ae039(stream, coords);\n    font._tables = this._tables;\n    return font;\n  }\n  get _variationProcessor() {\n    if (!this.fvar) return null;\n    let variationCoords = this.variationCoords;\n    // Ignore if no variation coords and not CFF2\n    if (!variationCoords && !this.CFF2) return null;\n    if (!variationCoords) variationCoords = this.fvar.axis.map(axis => axis.defaultValue);\n    return new (0, $0bb840cac04e911b$export$2e2bcd8739ae039)(this, variationCoords);\n  }\n  // Standardized format plugin API\n  getFont(name) {\n    return this.getVariation(name);\n  }\n  constructor(stream) {\n    let variationCoords = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n    (0, $6uUbQ$_)(this, \"type\", 'TTF');\n    this.defaultLanguage = null;\n    this.stream = stream;\n    this.variationCoords = variationCoords;\n    this._directoryPos = this.stream.pos;\n    this._tables = {};\n    this._glyphs = {};\n    this._decodeDirectory();\n    // define properties for each table to lazily parse\n    for (let tag in this.directory.tables) {\n      let table = this.directory.tables[tag];\n      if ((0, $c3395722bea751e2$export$2e2bcd8739ae039)[tag] && table.length > 0) Object.defineProperty(this, tag, {\n        get: this._getTable.bind(this, table)\n      });\n    }\n  }\n}\n(0, $6uUbQ$_1)([(0, $e71565f2ce09cb6b$export$69a3209f1a06c04d)], $4c1709dee528ea76$export$2e2bcd8739ae039.prototype, \"bbox\", null);\n(0, $6uUbQ$_1)([(0, $e71565f2ce09cb6b$export$69a3209f1a06c04d)], $4c1709dee528ea76$export$2e2bcd8739ae039.prototype, \"_cmapProcessor\", null);\n(0, $6uUbQ$_1)([(0, $e71565f2ce09cb6b$export$69a3209f1a06c04d)], $4c1709dee528ea76$export$2e2bcd8739ae039.prototype, \"characterSet\", null);\n(0, $6uUbQ$_1)([(0, $e71565f2ce09cb6b$export$69a3209f1a06c04d)], $4c1709dee528ea76$export$2e2bcd8739ae039.prototype, \"_layoutEngine\", null);\n(0, $6uUbQ$_1)([(0, $e71565f2ce09cb6b$export$69a3209f1a06c04d)], $4c1709dee528ea76$export$2e2bcd8739ae039.prototype, \"variationAxes\", null);\n(0, $6uUbQ$_1)([(0, $e71565f2ce09cb6b$export$69a3209f1a06c04d)], $4c1709dee528ea76$export$2e2bcd8739ae039.prototype, \"namedVariations\", null);\n(0, $6uUbQ$_1)([(0, $e71565f2ce09cb6b$export$69a3209f1a06c04d)], $4c1709dee528ea76$export$2e2bcd8739ae039.prototype, \"_variationProcessor\", null);\nlet $c1726355ecc5b889$var$WOFFDirectoryEntry = new $6uUbQ$Struct({\n  tag: new $6uUbQ$String(4),\n  offset: new $6uUbQ$Pointer($6uUbQ$uint32, 'void', {\n    type: 'global'\n  }),\n  compLength: $6uUbQ$uint32,\n  length: $6uUbQ$uint32,\n  origChecksum: $6uUbQ$uint32\n});\nlet $c1726355ecc5b889$var$WOFFDirectory = new $6uUbQ$Struct({\n  tag: new $6uUbQ$String(4),\n  flavor: $6uUbQ$uint32,\n  length: $6uUbQ$uint32,\n  numTables: $6uUbQ$uint16,\n  reserved: new $6uUbQ$Reserved($6uUbQ$uint16),\n  totalSfntSize: $6uUbQ$uint32,\n  majorVersion: $6uUbQ$uint16,\n  minorVersion: $6uUbQ$uint16,\n  metaOffset: $6uUbQ$uint32,\n  metaLength: $6uUbQ$uint32,\n  metaOrigLength: $6uUbQ$uint32,\n  privOffset: $6uUbQ$uint32,\n  privLength: $6uUbQ$uint32,\n  tables: new $6uUbQ$Array($c1726355ecc5b889$var$WOFFDirectoryEntry, 'numTables')\n});\n$c1726355ecc5b889$var$WOFFDirectory.process = function () {\n  let tables = {};\n  for (let table of this.tables) tables[table.tag] = table;\n  this.tables = tables;\n};\nvar $c1726355ecc5b889$export$2e2bcd8739ae039 = $c1726355ecc5b889$var$WOFFDirectory;\nclass $760785214b9fc52c$export$2e2bcd8739ae039 extends (0, $4c1709dee528ea76$export$2e2bcd8739ae039) {\n  static probe(buffer) {\n    return (0, $12727730ddfc8bfe$export$3d28c1996ced1f14).decode(buffer.slice(0, 4)) === 'wOFF';\n  }\n  _decodeDirectory() {\n    this.directory = (0, $c1726355ecc5b889$export$2e2bcd8739ae039).decode(this.stream, {\n      _startOffset: 0\n    });\n  }\n  _getTableStream(tag) {\n    let table = this.directory.tables[tag];\n    if (table) {\n      this.stream.pos = table.offset;\n      if (table.compLength < table.length) {\n        this.stream.pos += 2; // skip deflate header\n        let outBuffer = new Uint8Array(table.length);\n        let buf = (0, $6uUbQ$tinyinflate)(this.stream.readBuffer(table.compLength - 2), outBuffer);\n        return new $6uUbQ$DecodeStream(buf);\n      } else return this.stream;\n    }\n    return null;\n  }\n  constructor() {\n    super(...arguments);\n    (0, $6uUbQ$_)(this, \"type\", 'WOFF');\n  }\n}\nclass $8046190c9f1ad19e$export$2e2bcd8739ae039 extends (0, $69aac16029968692$export$2e2bcd8739ae039) {\n  _decode() {\n    // We have to decode in advance (in WOFF2Font), so just return the pre-decoded data.\n    return this._font._transformedGlyphs[this.id];\n  }\n  _getCBox() {\n    return this.path.bbox;\n  }\n  constructor() {\n    super(...arguments);\n    (0, $6uUbQ$_)(this, \"type\", 'WOFF2');\n  }\n}\nconst $c28ec7bbb3b8de3a$var$Base128 = {\n  decode(stream) {\n    let result = 0;\n    let iterable = [0, 1, 2, 3, 4];\n    for (let j = 0; j < iterable.length; j++) {\n      let i = iterable[j];\n      let code = stream.readUInt8();\n      // If any of the top seven bits are set then we're about to overflow.\n      if (result & 0xe0000000) throw new Error('Overflow');\n      result = result << 7 | code & 0x7f;\n      if ((code & 0x80) === 0) return result;\n    }\n    throw new Error('Bad base 128 number');\n  }\n};\nlet $c28ec7bbb3b8de3a$var$knownTags = ['cmap', 'head', 'hhea', 'hmtx', 'maxp', 'name', 'OS/2', 'post', 'cvt ', 'fpgm', 'glyf', 'loca', 'prep', 'CFF ', 'VORG', 'EBDT', 'EBLC', 'gasp', 'hdmx', 'kern', 'LTSH', 'PCLT', 'VDMX', 'vhea', 'vmtx', 'BASE', 'GDEF', 'GPOS', 'GSUB', 'EBSC', 'JSTF', 'MATH', 'CBDT', 'CBLC', 'COLR', 'CPAL', 'SVG ', 'sbix', 'acnt', 'avar', 'bdat', 'bloc', 'bsln', 'cvar', 'fdsc', 'feat', 'fmtx', 'fvar', 'gvar', 'hsty', 'just', 'lcar', 'mort', 'morx', 'opbd', 'prop', 'trak', 'Zapf', 'Silf', 'Glat', 'Gloc', 'Feat', 'Sill'];\nlet $c28ec7bbb3b8de3a$var$WOFF2DirectoryEntry = new $6uUbQ$Struct({\n  flags: $6uUbQ$uint8,\n  customTag: new $6uUbQ$Optional(new $6uUbQ$String(4), t => (t.flags & 0x3f) === 0x3f),\n  tag: t => t.customTag || $c28ec7bbb3b8de3a$var$knownTags[t.flags & 0x3f],\n  length: $c28ec7bbb3b8de3a$var$Base128,\n  transformVersion: t => t.flags >>> 6 & 0x03,\n  transformed: t => t.tag === 'glyf' || t.tag === 'loca' ? t.transformVersion === 0 : t.transformVersion !== 0,\n  transformLength: new $6uUbQ$Optional($c28ec7bbb3b8de3a$var$Base128, t => t.transformed)\n});\nlet $c28ec7bbb3b8de3a$var$WOFF2Directory = new $6uUbQ$Struct({\n  tag: new $6uUbQ$String(4),\n  flavor: $6uUbQ$uint32,\n  length: $6uUbQ$uint32,\n  numTables: $6uUbQ$uint16,\n  reserved: new $6uUbQ$Reserved($6uUbQ$uint16),\n  totalSfntSize: $6uUbQ$uint32,\n  totalCompressedSize: $6uUbQ$uint32,\n  majorVersion: $6uUbQ$uint16,\n  minorVersion: $6uUbQ$uint16,\n  metaOffset: $6uUbQ$uint32,\n  metaLength: $6uUbQ$uint32,\n  metaOrigLength: $6uUbQ$uint32,\n  privOffset: $6uUbQ$uint32,\n  privLength: $6uUbQ$uint32,\n  tables: new $6uUbQ$Array($c28ec7bbb3b8de3a$var$WOFF2DirectoryEntry, 'numTables')\n});\n$c28ec7bbb3b8de3a$var$WOFF2Directory.process = function () {\n  let tables = {};\n  for (let i = 0; i < this.tables.length; i++) {\n    let table = this.tables[i];\n    tables[table.tag] = table;\n  }\n  return this.tables = tables;\n};\nvar $c28ec7bbb3b8de3a$export$2e2bcd8739ae039 = $c28ec7bbb3b8de3a$var$WOFF2Directory;\nclass $21ee218f84ac7f32$export$2e2bcd8739ae039 extends (0, $4c1709dee528ea76$export$2e2bcd8739ae039) {\n  static probe(buffer) {\n    return (0, $12727730ddfc8bfe$export$3d28c1996ced1f14).decode(buffer.slice(0, 4)) === 'wOF2';\n  }\n  _decodeDirectory() {\n    this.directory = (0, $c28ec7bbb3b8de3a$export$2e2bcd8739ae039).decode(this.stream);\n    this._dataPos = this.stream.pos;\n  }\n  _decompress() {\n    // decompress data and setup table offsets if we haven't already\n    if (!this._decompressed) {\n      this.stream.pos = this._dataPos;\n      let buffer = this.stream.readBuffer(this.directory.totalCompressedSize);\n      let decompressedSize = 0;\n      for (let tag in this.directory.tables) {\n        let entry = this.directory.tables[tag];\n        entry.offset = decompressedSize;\n        decompressedSize += entry.transformLength != null ? entry.transformLength : entry.length;\n      }\n      let decompressed = (0, $6uUbQ$brotlidecompressjs)(buffer, decompressedSize);\n      if (!decompressed) throw new Error('Error decoding compressed data in WOFF2');\n      this.stream = new $6uUbQ$DecodeStream(decompressed);\n      this._decompressed = true;\n    }\n  }\n  _decodeTable(table) {\n    this._decompress();\n    return super._decodeTable(table);\n  }\n  // Override this method to get a glyph and return our\n  // custom subclass if there is a glyf table.\n  _getBaseGlyph(glyph) {\n    let characters = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n    if (!this._glyphs[glyph]) {\n      if (this.directory.tables.glyf && this.directory.tables.glyf.transformed) {\n        if (!this._transformedGlyphs) this._transformGlyfTable();\n        return this._glyphs[glyph] = new (0, $8046190c9f1ad19e$export$2e2bcd8739ae039)(glyph, characters, this);\n      } else return super._getBaseGlyph(glyph, characters);\n    }\n  }\n  _transformGlyfTable() {\n    this._decompress();\n    this.stream.pos = this.directory.tables.glyf.offset;\n    let table = $21ee218f84ac7f32$var$GlyfTable.decode(this.stream);\n    let glyphs = [];\n    for (let index = 0; index < table.numGlyphs; index++) {\n      let glyph = {};\n      let nContours = table.nContours.readInt16BE();\n      glyph.numberOfContours = nContours;\n      if (nContours > 0) {\n        let nPoints = [];\n        let totalPoints = 0;\n        for (let i = 0; i < nContours; i++) {\n          let r = $21ee218f84ac7f32$var$read255UInt16(table.nPoints);\n          totalPoints += r;\n          nPoints.push(totalPoints);\n        }\n        glyph.points = $21ee218f84ac7f32$var$decodeTriplet(table.flags, table.glyphs, totalPoints);\n        for (let i = 0; i < nContours; i++) glyph.points[nPoints[i] - 1].endContour = true;\n        var instructionSize = $21ee218f84ac7f32$var$read255UInt16(table.glyphs);\n      } else if (nContours < 0) {\n        let haveInstructions = (0, $69aac16029968692$export$2e2bcd8739ae039).prototype._decodeComposite.call({\n          _font: this\n        }, glyph, table.composites);\n        if (haveInstructions) var instructionSize = $21ee218f84ac7f32$var$read255UInt16(table.glyphs);\n      }\n      glyphs.push(glyph);\n    }\n    this._transformedGlyphs = glyphs;\n  }\n  constructor() {\n    super(...arguments);\n    (0, $6uUbQ$_)(this, \"type\", 'WOFF2');\n  }\n}\n// Special class that accepts a length and returns a sub-stream for that data\nclass $21ee218f84ac7f32$var$Substream {\n  decode(stream, parent) {\n    return new $6uUbQ$DecodeStream(this._buf.decode(stream, parent));\n  }\n  constructor(length) {\n    this.length = length;\n    this._buf = new $6uUbQ$Buffer(length);\n  }\n}\n// This struct represents the entire glyf table\nlet $21ee218f84ac7f32$var$GlyfTable = new $6uUbQ$Struct({\n  version: $6uUbQ$uint32,\n  numGlyphs: $6uUbQ$uint16,\n  indexFormat: $6uUbQ$uint16,\n  nContourStreamSize: $6uUbQ$uint32,\n  nPointsStreamSize: $6uUbQ$uint32,\n  flagStreamSize: $6uUbQ$uint32,\n  glyphStreamSize: $6uUbQ$uint32,\n  compositeStreamSize: $6uUbQ$uint32,\n  bboxStreamSize: $6uUbQ$uint32,\n  instructionStreamSize: $6uUbQ$uint32,\n  nContours: new $21ee218f84ac7f32$var$Substream('nContourStreamSize'),\n  nPoints: new $21ee218f84ac7f32$var$Substream('nPointsStreamSize'),\n  flags: new $21ee218f84ac7f32$var$Substream('flagStreamSize'),\n  glyphs: new $21ee218f84ac7f32$var$Substream('glyphStreamSize'),\n  composites: new $21ee218f84ac7f32$var$Substream('compositeStreamSize'),\n  bboxes: new $21ee218f84ac7f32$var$Substream('bboxStreamSize'),\n  instructions: new $21ee218f84ac7f32$var$Substream('instructionStreamSize')\n});\nconst $21ee218f84ac7f32$var$WORD_CODE = 253;\nconst $21ee218f84ac7f32$var$ONE_MORE_BYTE_CODE2 = 254;\nconst $21ee218f84ac7f32$var$ONE_MORE_BYTE_CODE1 = 255;\nconst $21ee218f84ac7f32$var$LOWEST_U_CODE = 253;\nfunction $21ee218f84ac7f32$var$read255UInt16(stream) {\n  let code = stream.readUInt8();\n  if (code === $21ee218f84ac7f32$var$WORD_CODE) return stream.readUInt16BE();\n  if (code === $21ee218f84ac7f32$var$ONE_MORE_BYTE_CODE1) return stream.readUInt8() + $21ee218f84ac7f32$var$LOWEST_U_CODE;\n  if (code === $21ee218f84ac7f32$var$ONE_MORE_BYTE_CODE2) return stream.readUInt8() + $21ee218f84ac7f32$var$LOWEST_U_CODE * 2;\n  return code;\n}\nfunction $21ee218f84ac7f32$var$withSign(flag, baseval) {\n  return flag & 1 ? baseval : -baseval;\n}\nfunction $21ee218f84ac7f32$var$decodeTriplet(flags, glyphs, nPoints) {\n  let y;\n  let x = y = 0;\n  let res = [];\n  for (let i = 0; i < nPoints; i++) {\n    let dx = 0,\n      dy = 0;\n    let flag = flags.readUInt8();\n    let onCurve = !(flag >> 7);\n    flag &= 0x7f;\n    if (flag < 10) {\n      dx = 0;\n      dy = $21ee218f84ac7f32$var$withSign(flag, ((flag & 14) << 7) + glyphs.readUInt8());\n    } else if (flag < 20) {\n      dx = $21ee218f84ac7f32$var$withSign(flag, ((flag - 10 & 14) << 7) + glyphs.readUInt8());\n      dy = 0;\n    } else if (flag < 84) {\n      var b0 = flag - 20;\n      var b1 = glyphs.readUInt8();\n      dx = $21ee218f84ac7f32$var$withSign(flag, 1 + (b0 & 0x30) + (b1 >> 4));\n      dy = $21ee218f84ac7f32$var$withSign(flag >> 1, 1 + ((b0 & 0x0c) << 2) + (b1 & 0x0f));\n    } else if (flag < 120) {\n      var b0 = flag - 84;\n      dx = $21ee218f84ac7f32$var$withSign(flag, 1 + (b0 / 12 << 8) + glyphs.readUInt8());\n      dy = $21ee218f84ac7f32$var$withSign(flag >> 1, 1 + (b0 % 12 >> 2 << 8) + glyphs.readUInt8());\n    } else if (flag < 124) {\n      var b1 = glyphs.readUInt8();\n      let b2 = glyphs.readUInt8();\n      dx = $21ee218f84ac7f32$var$withSign(flag, (b1 << 4) + (b2 >> 4));\n      dy = $21ee218f84ac7f32$var$withSign(flag >> 1, ((b2 & 0x0f) << 8) + glyphs.readUInt8());\n    } else {\n      dx = $21ee218f84ac7f32$var$withSign(flag, glyphs.readUInt16BE());\n      dy = $21ee218f84ac7f32$var$withSign(flag >> 1, glyphs.readUInt16BE());\n    }\n    x += dx;\n    y += dy;\n    res.push(new (0, $69aac16029968692$export$baf26146a414f24a)(onCurve, false, x, y));\n  }\n  return res;\n}\nlet $cd5853a56c68fec7$var$TTCHeader = new $6uUbQ$VersionedStruct($6uUbQ$uint32, {\n  0x00010000: {\n    numFonts: $6uUbQ$uint32,\n    offsets: new $6uUbQ$Array($6uUbQ$uint32, 'numFonts')\n  },\n  0x00020000: {\n    numFonts: $6uUbQ$uint32,\n    offsets: new $6uUbQ$Array($6uUbQ$uint32, 'numFonts'),\n    dsigTag: $6uUbQ$uint32,\n    dsigLength: $6uUbQ$uint32,\n    dsigOffset: $6uUbQ$uint32\n  }\n});\nclass $cd5853a56c68fec7$export$2e2bcd8739ae039 {\n  static probe(buffer) {\n    return (0, $12727730ddfc8bfe$export$3d28c1996ced1f14).decode(buffer.slice(0, 4)) === 'ttcf';\n  }\n  getFont(name) {\n    for (let offset of this.header.offsets) {\n      let stream = new $6uUbQ$DecodeStream(this.stream.buffer);\n      stream.pos = offset;\n      let font = new (0, $4c1709dee528ea76$export$2e2bcd8739ae039)(stream);\n      if (font.postscriptName === name || font.postscriptName instanceof Uint8Array && name instanceof Uint8Array && font.postscriptName.every((v, i) => name[i] === v)) return font;\n    }\n    return null;\n  }\n  get fonts() {\n    let fonts = [];\n    for (let offset of this.header.offsets) {\n      let stream = new $6uUbQ$DecodeStream(this.stream.buffer);\n      stream.pos = offset;\n      fonts.push(new (0, $4c1709dee528ea76$export$2e2bcd8739ae039)(stream));\n    }\n    return fonts;\n  }\n  constructor(stream) {\n    (0, $6uUbQ$_)(this, \"type\", 'TTC');\n    this.stream = stream;\n    if (stream.readString(4) !== 'ttcf') throw new Error('Not a TrueType collection');\n    this.header = $cd5853a56c68fec7$var$TTCHeader.decode(stream);\n  }\n}\nlet $05f49f930186144e$var$DFontName = new $6uUbQ$String($6uUbQ$uint8);\nlet $05f49f930186144e$var$DFontData = new $6uUbQ$Struct({\n  len: $6uUbQ$uint32,\n  buf: new $6uUbQ$Buffer('len')\n});\nlet $05f49f930186144e$var$Ref = new $6uUbQ$Struct({\n  id: $6uUbQ$uint16,\n  nameOffset: $6uUbQ$int16,\n  attr: $6uUbQ$uint8,\n  dataOffset: $6uUbQ$uint24,\n  handle: $6uUbQ$uint32\n});\nlet $05f49f930186144e$var$Type = new $6uUbQ$Struct({\n  name: new $6uUbQ$String(4),\n  maxTypeIndex: $6uUbQ$uint16,\n  refList: new $6uUbQ$Pointer($6uUbQ$uint16, new $6uUbQ$Array($05f49f930186144e$var$Ref, t => t.maxTypeIndex + 1), {\n    type: 'parent'\n  })\n});\nlet $05f49f930186144e$var$TypeList = new $6uUbQ$Struct({\n  length: $6uUbQ$uint16,\n  types: new $6uUbQ$Array($05f49f930186144e$var$Type, t => t.length + 1)\n});\nlet $05f49f930186144e$var$DFontMap = new $6uUbQ$Struct({\n  reserved: new $6uUbQ$Reserved($6uUbQ$uint8, 24),\n  typeList: new $6uUbQ$Pointer($6uUbQ$uint16, $05f49f930186144e$var$TypeList),\n  nameListOffset: new $6uUbQ$Pointer($6uUbQ$uint16, 'void')\n});\nlet $05f49f930186144e$var$DFontHeader = new $6uUbQ$Struct({\n  dataOffset: $6uUbQ$uint32,\n  map: new $6uUbQ$Pointer($6uUbQ$uint32, $05f49f930186144e$var$DFontMap),\n  dataLength: $6uUbQ$uint32,\n  mapLength: $6uUbQ$uint32\n});\nclass $05f49f930186144e$export$2e2bcd8739ae039 {\n  static probe(buffer) {\n    let stream = new $6uUbQ$DecodeStream(buffer);\n    try {\n      var header = $05f49f930186144e$var$DFontHeader.decode(stream);\n    } catch (e) {\n      return false;\n    }\n    for (let type of header.map.typeList.types) {\n      if (type.name === 'sfnt') return true;\n    }\n    return false;\n  }\n  getFont(name) {\n    if (!this.sfnt) return null;\n    for (let ref of this.sfnt.refList) {\n      let pos = this.header.dataOffset + ref.dataOffset + 4;\n      let stream = new $6uUbQ$DecodeStream(this.stream.buffer.slice(pos));\n      let font = new (0, $4c1709dee528ea76$export$2e2bcd8739ae039)(stream);\n      if (font.postscriptName === name || font.postscriptName instanceof Uint8Array && name instanceof Uint8Array && font.postscriptName.every((v, i) => name[i] === v)) return font;\n    }\n    return null;\n  }\n  get fonts() {\n    let fonts = [];\n    for (let ref of this.sfnt.refList) {\n      let pos = this.header.dataOffset + ref.dataOffset + 4;\n      let stream = new $6uUbQ$DecodeStream(this.stream.buffer.slice(pos));\n      fonts.push(new (0, $4c1709dee528ea76$export$2e2bcd8739ae039)(stream));\n    }\n    return fonts;\n  }\n  constructor(stream) {\n    (0, $6uUbQ$_)(this, \"type\", 'DFont');\n    this.stream = stream;\n    this.header = $05f49f930186144e$var$DFontHeader.decode(this.stream);\n    for (let type of this.header.map.typeList.types) {\n      for (let ref of type.refList) if (ref.nameOffset >= 0) {\n        this.stream.pos = ref.nameOffset + this.header.map.nameListOffset;\n        ref.name = $05f49f930186144e$var$DFontName.decode(this.stream);\n      } else ref.name = null;\n      if (type.name === 'sfnt') this.sfnt = type;\n    }\n  }\n}\n\n// Register font formats\n(0, $d636bc798e7178db$export$36b2f24e97d43be)((0, $4c1709dee528ea76$export$2e2bcd8739ae039));\n(0, $d636bc798e7178db$export$36b2f24e97d43be)((0, $760785214b9fc52c$export$2e2bcd8739ae039));\n(0, $d636bc798e7178db$export$36b2f24e97d43be)((0, $21ee218f84ac7f32$export$2e2bcd8739ae039));\n(0, $d636bc798e7178db$export$36b2f24e97d43be)((0, $cd5853a56c68fec7$export$2e2bcd8739ae039));\n(0, $d636bc798e7178db$export$36b2f24e97d43be)((0, $05f49f930186144e$export$2e2bcd8739ae039));\nexport { $d636bc798e7178db$export$bd5c5d8b8dcafd78 as logErrors, $d636bc798e7178db$export$36b2f24e97d43be as registerFormat, $d636bc798e7178db$export$185802fd694ee1f5 as create, $d636bc798e7178db$export$42940898df819940 as defaultLanguage, $d636bc798e7178db$export$5157e7780d44cc36 as setDefaultLanguage };","map":{"version":3,"names":["$d636bc798e7178db$export$bd5c5d8b8dcafd78","$d636bc798e7178db$var$formats","$d636bc798e7178db$export$36b2f24e97d43be","format","push","$d636bc798e7178db$export$185802fd694ee1f5","buffer","postscriptName","i","length","probe","font","$6uUbQ$DecodeStream","getFont","Error","$d636bc798e7178db$export$42940898df819940","$d636bc798e7178db$export$5157e7780d44cc36","lang","arguments","undefined","$e71565f2ce09cb6b$export$69a3209f1a06c04d","target","key","descriptor","get","value","call","Object","defineProperty","fn","cache","Map","memoized","_len","args","Array","_key","has","result","apply","set","$26a62205ad06574e$var$SubHeader","$6uUbQ$Struct","firstCode","$6uUbQ$uint16","entryCount","idDelta","$6uUbQ$int16","idRangeOffset","$26a62205ad06574e$var$CmapGroup","startCharCode","$6uUbQ$uint32","endCharCode","glyphID","$26a62205ad06574e$var$UnicodeValueRange","startUnicodeValue","$6uUbQ$uint24","additionalCount","$6uUbQ$uint8","$26a62205ad06574e$var$UVSMapping","unicodeValue","$26a62205ad06574e$var$DefaultUVS","$6uUbQ$Array","$26a62205ad06574e$var$NonDefaultUVS","$26a62205ad06574e$var$VarSelectorRecord","varSelector","defaultUVS","$6uUbQ$Pointer","type","nonDefaultUVS","$26a62205ad06574e$var$CmapSubtable","$6uUbQ$VersionedStruct","language","codeMap","$6uUbQ$LazyArray","subHeaderKeys","subHeaderCount","t","Math","max","subHeaders","glyphIndexArray","segCountX2","segCount","searchRange","entrySelector","rangeShift","endCode","reservedPad","$6uUbQ$Reserved","startCode","_currentOffset","glyphIndices","reserved","is32","nGroups","groups","numRecords","varSelectors","$26a62205ad06574e$var$CmapEntry","platformID","encodingID","table","lazy","$26a62205ad06574e$export$2e2bcd8739ae039","version","numSubtables","tables","$f2612a29f92ac062$export$2e2bcd8739ae039","$6uUbQ$int32","revision","checkSumAdjustment","magicNumber","flags","unitsPerEm","created","modified","xMin","yMin","xMax","yMax","macStyle","$6uUbQ$Bitfield","lowestRecPPEM","fontDirectionHint","indexToLocFormat","glyphDataFormat","$2c179dd593583073$export$2e2bcd8739ae039","ascent","descent","lineGap","advanceWidthMax","minLeftSideBearing","minRightSideBearing","xMaxExtent","caretSlopeRise","caretSlopeRun","caretOffset","metricDataFormat","numberOfMetrics","$bdc9060542264b85$var$HmtxEntry","advance","bearing","$bdc9060542264b85$export$2e2bcd8739ae039","metrics","parent","hhea","bearings","maxp","numGlyphs","$dbf51cb3d3fe409d$export$2e2bcd8739ae039","maxPoints","maxContours","maxComponentPoints","maxComponentContours","maxZones","maxTwilightPoints","maxStorage","maxFunctionDefs","maxInstructionDefs","maxStackElements","maxSizeOfInstructions","maxComponentElements","maxComponentDepth","$e449ad78d50845fe$export$badc544e0651b6b1","languageID","$e449ad78d50845fe$export$479e671907f486d1","$e449ad78d50845fe$export$6fef87b7618bdf0b","$e449ad78d50845fe$var$SINGLE_BYTE_ENCODINGS","Set","$e449ad78d50845fe$var$MAC_ENCODINGS","$e449ad78d50845fe$var$encodingCache","$e449ad78d50845fe$export$1dceb3c14ed68bee","encoding","cached","mapping","res","charCodeAt","decoder","TextDecoder","Uint8Array","s","decode","$e449ad78d50845fe$export$2092376fd002e13","$2bcf221753ec8e32$var$NameRecord","nameID","string","$6uUbQ$String","relativeTo","ctx","stringOffset","allowNull","$2bcf221753ec8e32$var$LangTagRecord","tag","$2bcf221753ec8e32$var$NameTable","count","records","langTagCount","langTags","$2bcf221753ec8e32$export$2e2bcd8739ae039","$2bcf221753ec8e32$var$NAMES","process","stream","record","obj","preEncode","isArray","val","indexOf","en","size","$84b272aa31b70606$var$OS2","header","xAvgCharWidth","usWeightClass","usWidthClass","fsType","ySubscriptXSize","ySubscriptYSize","ySubscriptXOffset","ySubscriptYOffset","ySuperscriptXSize","ySuperscriptYSize","ySuperscriptXOffset","ySuperscriptYOffset","yStrikeoutSize","yStrikeoutPosition","sFamilyClass","panose","ulCharRange","vendorID","fsSelection","usFirstCharIndex","usLastCharIndex","typoAscender","typoDescender","typoLineGap","winAscent","winDescent","codePageRange","xHeight","capHeight","defaultChar","breakChar","maxContent","usLowerOpticalPointSize","usUpperOpticalPointSize","$84b272aa31b70606$var$versions","versions","$84b272aa31b70606$export$2e2bcd8739ae039","$32d9e2eb9565d93c$export$2e2bcd8739ae039","$6uUbQ$fixed32","italicAngle","underlinePosition","underlineThickness","isFixedPitch","minMemType42","maxMemType42","minMemType1","maxMemType1","numberOfGlyphs","glyphNameIndex","names","offsets","map","$5202bd9d9ad8eaac$export$2e2bcd8739ae039","controlValues","$5c0f37ca5ffb1850$export$2e2bcd8739ae039","instructions","$2b2b260902b1c57e$var$loca","_processed","$2b2b260902b1c57e$export$2e2bcd8739ae039","$7afb878c7bea4f66$export$2e2bcd8739ae039","controlValueProgram","$6c92b6371bce8bd9$export$2e2bcd8739ae039","$6uUbQ$Buffer","$43e9821ef3717eec$export$2e2bcd8739ae039","getCFFVersion","hdrSize","readUInt32BE","readUInt16BE","offSize","readUInt8","offsetType","pos","ret","startPos","start","end","offset","arr","item","encode","writeUInt16BE","sizes","writeUInt8","constructor","$c2d28e92708f99da$var$FLOAT_EOF","$c2d28e92708f99da$var$FLOAT_LOOKUP","$c2d28e92708f99da$var$FLOAT_ENCODE_LOOKUP","$c2d28e92708f99da$export$2e2bcd8739ae039","readInt16BE","readInt32BE","str","b","n1","n2","parseFloat","forceLarge","ceil","Number","writeInt32BE","c1","c2","writeInt16BE","$61aa549f16d58b9b$export$2e2bcd8739ae039","decodeOperands","operands","op","encodeOperands","defineProperties","_startOffset","fields","field","$6uUbQ$PropertyDescriptor","dict","includePointers","pointerSize","startOffset","len","k","$6uUbQ$fastdeepequal","pointers","pointerOffset","ops","ptr","$0e34a43d05bde82c$export$2e2bcd8739ae039","$0e34a43d05bde82c$var$Ptr","options","valueOf","$6d59db2e29cc77b3$var$CFFBlendOp","numBlends","pop","$6d59db2e29cc77b3$export$2e2bcd8739ae039","$229224aec43783c5$export$2e2bcd8739ae039","$bc0433d9b7e41f5f$export$dee0027060fa13bd","$bc0433d9b7e41f5f$export$4f58f497e14a53c3","$ef658f5c9a1488b2$export$c33b50336c234f16","$ef658f5c9a1488b2$export$3ed0f9e1fee8d489","$ef658f5c9a1488b2$export$dc28be11139d4120","$7cbbe4e24ef3cb75$var$LangSysTable","reqFeatureIndex","featureCount","featureIndexes","$7cbbe4e24ef3cb75$var$LangSysRecord","langSys","$7cbbe4e24ef3cb75$var$Script","defaultLangSys","langSysRecords","$7cbbe4e24ef3cb75$var$ScriptRecord","script","$7cbbe4e24ef3cb75$export$3e15fc05ce864229","$7cbbe4e24ef3cb75$var$FeatureParams","$7cbbe4e24ef3cb75$export$6e91cf7616333d5","featureParams","lookupCount","lookupListIndexes","$7cbbe4e24ef3cb75$var$FeatureRecord","feature","$7cbbe4e24ef3cb75$export$aa18130def4b6cb4","$7cbbe4e24ef3cb75$var$LookupFlags","markAttachmentType","$7cbbe4e24ef3cb75$export$df0008c6ff2da22a","SubTable","Lookup","lookupType","subTableCount","subTables","markFilteringSet","$6uUbQ$Optional","useMarkFilteringSet","$7cbbe4e24ef3cb75$var$RangeRecord","startCoverageIndex","$7cbbe4e24ef3cb75$export$17608c3f81a6111","glyphCount","glyphs","rangeCount","rangeRecords","$7cbbe4e24ef3cb75$var$ClassRangeRecord","class","$7cbbe4e24ef3cb75$export$843d551fbbafef71","startGlyph","classValueArray","classRangeCount","classRangeRecord","$7cbbe4e24ef3cb75$export$8215d14a63d9fb10","a","deltaFormat","$7cbbe4e24ef3cb75$var$LookupRecord","sequenceIndex","lookupListIndex","$7cbbe4e24ef3cb75$var$Rule","input","lookupRecords","$7cbbe4e24ef3cb75$var$RuleSet","$7cbbe4e24ef3cb75$var$ClassRule","classes","$7cbbe4e24ef3cb75$var$ClassSet","$7cbbe4e24ef3cb75$export$841858b892ce1f4c","coverage","ruleSetCount","ruleSets","classDef","classSetCnt","classSet","coverages","$7cbbe4e24ef3cb75$var$ChainRule","backtrackGlyphCount","backtrack","inputGlyphCount","lookaheadGlyphCount","lookahead","$7cbbe4e24ef3cb75$var$ChainRuleSet","$7cbbe4e24ef3cb75$export$5e6d09e6861162f6","chainCount","chainRuleSets","backtrackClassDef","inputClassDef","lookaheadClassDef","chainClassSet","backtrackCoverage","inputCoverage","lookaheadCoverage","$1a47b0c45c1c22fe$var$F2DOT14","$6uUbQ$Fixed","$1a47b0c45c1c22fe$var$RegionAxisCoordinates","startCoord","peakCoord","endCoord","$1a47b0c45c1c22fe$var$VariationRegionList","axisCount","regionCount","variationRegions","$1a47b0c45c1c22fe$var$DeltaSet","shortDeltas","shortDeltaCount","regionDeltas","$6uUbQ$int8","regionIndexCount","deltas","concat","$1a47b0c45c1c22fe$var$ItemVariationData","itemCount","regionIndexes","deltaSets","$1a47b0c45c1c22fe$export$fe1b122a2710f241","variationRegionList","variationDataCount","itemVariationData","$1a47b0c45c1c22fe$var$ConditionTable","axisIndex","filterRangeMinValue","filterRangeMaxValue","$1a47b0c45c1c22fe$var$ConditionSet","conditionCount","conditionTable","$1a47b0c45c1c22fe$var$FeatureTableSubstitutionRecord","featureIndex","alternateFeatureTable","$1a47b0c45c1c22fe$var$FeatureTableSubstitution","substitutionCount","substitutions","$1a47b0c45c1c22fe$var$FeatureVariationRecord","conditionSet","featureTableSubstitution","$1a47b0c45c1c22fe$export$441b70b7971dd419","majorVersion","minorVersion","featureVariationRecordCount","featureVariationRecords","$b84fd3dd9d8eddb2$var$PredefinedOp","predefinedOps","index","$b84fd3dd9d8eddb2$var$CFFEncodingVersion","$6uUbQ$Number","$b84fd3dd9d8eddb2$var$Range1","first","nLeft","$b84fd3dd9d8eddb2$var$Range2","$b84fd3dd9d8eddb2$var$CFFCustomEncoding","nCodes","codes","nRanges","ranges","$b84fd3dd9d8eddb2$var$CFFEncoding","$b84fd3dd9d8eddb2$var$RangeArray","$6uUbQ$resolveLength","range","$b84fd3dd9d8eddb2$var$CFFCustomCharset","CharStrings","$b84fd3dd9d8eddb2$var$CFFCharset","$b84fd3dd9d8eddb2$var$FDRange3","fd","$b84fd3dd9d8eddb2$var$FDRange4","$b84fd3dd9d8eddb2$var$FDSelect","fds","sentinel","$b84fd3dd9d8eddb2$var$ptr","$b84fd3dd9d8eddb2$var$CFFPrivateOp","$b84fd3dd9d8eddb2$var$FontDict","$b84fd3dd9d8eddb2$var$CFFTopDict","$b84fd3dd9d8eddb2$var$VariationStore","itemVariationStore","$b84fd3dd9d8eddb2$var$CFF2TopDict","$b84fd3dd9d8eddb2$var$CFFTop","$6uUbQ$fixed16","nameIndex","topDictIndex","stringIndex","globalSubrIndex","topDict","$b84fd3dd9d8eddb2$export$2e2bcd8739ae039","$822ac0d589e4e237$var$CFFFont","top","isCIDFont","ROS","sid","fullName","FullName","familyName","FamilyName","getCharString","glyph","readBuffer","getGlyphName","gid","charset","fdForGlyph","FDSelect","low","high","mid","privateDictForGlyph","FDArray","Private","$822ac0d589e4e237$export$2e2bcd8739ae039","$2bbf2bc1ce37cd8f$var$VerticalOrigin","glyphIndex","vertOriginY","$2bbf2bc1ce37cd8f$export$2e2bcd8739ae039","defaultVertOriginY","numVertOriginYMetrics","$0941618dc22a946d$export$16b227cb15d716a0","height","width","horiBearingX","horiBearingY","horiAdvance","vertBearingX","vertBearingY","vertAdvance","$0941618dc22a946d$export$62c53e75f69bfe12","bearingX","bearingY","$0941618dc22a946d$var$EBDTComponent","xOffset","yOffset","$0941618dc22a946d$var$ByteAligned","$0941618dc22a946d$var$BitAligned","$0941618dc22a946d$export$f1f5ddeb20d14f","data","pad","numComponents","components","dataLen","$9911c4c7201c13de$var$SBitLineMetrics","ascender","descender","widthMax","caretSlopeNumerator","caretSlopeDenominator","minOriginSB","minAdvanceSB","maxBeforeBL","minAfterBL","$9911c4c7201c13de$var$CodeOffsetPair","glyphCode","$9911c4c7201c13de$var$IndexSubtable","imageFormat","imageDataOffset","offsetArray","lastGlyphIndex","firstGlyphIndex","imageSize","bigMetrics","glyphArray","glyphCodeArray","$9911c4c7201c13de$var$IndexSubtableArray","subtable","$9911c4c7201c13de$var$BitmapSizeTable","indexSubTableArray","indexTablesSize","numberOfIndexSubTables","colorRef","hori","vert","startGlyphIndex","endGlyphIndex","ppemX","ppemY","bitDepth","$9911c4c7201c13de$export$2e2bcd8739ae039","numSizes","$abb847051efd51b1$var$ImageTable","ppem","resolution","imageOffsets","$abb847051efd51b1$export$2e2bcd8739ae039","numImgTables","imageTables","$eb629188f3dfefdd$var$LayerRecord","paletteIndex","$eb629188f3dfefdd$var$BaseGlyphRecord","firstLayerIndex","numLayers","$eb629188f3dfefdd$export$2e2bcd8739ae039","numBaseGlyphRecords","baseGlyphRecord","layerRecords","numLayerRecords","$08734b8e7dc64587$var$ColorRecord","blue","green","red","alpha","$08734b8e7dc64587$export$2e2bcd8739ae039","numPaletteEntries","numPalettes","numColorRecords","colorRecords","colorRecordIndices","offsetPaletteTypeArray","offsetPaletteLabelArray","offsetPaletteEntryLabelArray","$497cef411d884e34$var$BaseCoord","coordinate","referenceGlyph","baseCoordPoint","deviceTable","$497cef411d884e34$var$BaseValues","defaultIndex","baseCoordCount","baseCoords","$497cef411d884e34$var$FeatMinMaxRecord","minCoord","maxCoord","$497cef411d884e34$var$MinMax","featMinMaxCount","featMinMaxRecords","$497cef411d884e34$var$BaseLangSysRecord","minMax","$497cef411d884e34$var$BaseScript","baseValues","defaultMinMax","baseLangSysCount","baseLangSysRecords","$497cef411d884e34$var$BaseScriptRecord","$497cef411d884e34$var$BaseScriptList","$497cef411d884e34$var$BaseTagList","$497cef411d884e34$var$Axis","baseTagList","baseScriptList","$497cef411d884e34$export$2e2bcd8739ae039","horizAxis","vertAxis","$cf5f33c63ef209e6$var$AttachPoint","$cf5f33c63ef209e6$var$AttachList","attachPoints","$cf5f33c63ef209e6$var$CaretValue","caretValuePoint","$cf5f33c63ef209e6$var$LigGlyph","$cf5f33c63ef209e6$var$LigCaretList","ligGlyphCount","ligGlyphs","$cf5f33c63ef209e6$var$MarkGlyphSetsDef","markSetTableFormat","markSetCount","$cf5f33c63ef209e6$export$2e2bcd8739ae039","glyphClassDef","attachList","ligCaretList","markAttachClassDef","markGlyphSetsDef","$47e0e8ef515d9903$var$ValueFormat","$47e0e8ef515d9903$var$types","xPlacement","yPlacement","xAdvance","yAdvance","xPlaDevice","rel","yPlaDevice","xAdvDevice","yAdvDevice","$47e0e8ef515d9903$var$ValueRecord","buildStruct","struct","$47e0e8ef515d9903$var$PairValueRecord","secondGlyph","value1","value2","$47e0e8ef515d9903$var$PairSet","$47e0e8ef515d9903$var$Class2Record","$47e0e8ef515d9903$var$Anchor","xCoordinate","yCoordinate","anchorPoint","xDeviceTable","yDeviceTable","$47e0e8ef515d9903$var$EntryExitRecord","entryAnchor","exitAnchor","$47e0e8ef515d9903$var$MarkRecord","markAnchor","$47e0e8ef515d9903$var$MarkArray","$47e0e8ef515d9903$var$BaseRecord","classCount","$47e0e8ef515d9903$var$BaseArray","$47e0e8ef515d9903$var$ComponentRecord","$47e0e8ef515d9903$var$LigatureAttach","$47e0e8ef515d9903$var$LigatureArray","$47e0e8ef515d9903$export$73a8cfb19cd43a0f","valueFormat","valueCount","values","valueFormat1","valueFormat2","pairSetCount","pairSets","classDef1","classDef2","class1Count","class2Count","classRecords","entryExitCount","entryExitRecords","markCoverage","baseCoverage","markArray","baseArray","ligatureCoverage","ligatureArray","mark1Coverage","mark2Coverage","mark1Array","mark2Array","posFormat","extension","$47e0e8ef515d9903$export$2e2bcd8739ae039","scriptList","featureList","lookupList","featureVariations","$d3f442064af66e06$var$Sequence","$d3f442064af66e06$var$AlternateSet","$d3f442064af66e06$var$Ligature","compCount","$d3f442064af66e06$var$LigatureSet","$d3f442064af66e06$var$GSUBLookup","deltaGlyphID","substitute","substFormat","sequences","alternateSet","ligatureSets","substitutes","$d3f442064af66e06$export$2e2bcd8739ae039","$71cfb3c4767fbd0c$var$JstfGSUBModList","$71cfb3c4767fbd0c$var$JstfPriority","shrinkageEnableGSUB","shrinkageDisableGSUB","shrinkageEnableGPOS","shrinkageDisableGPOS","shrinkageJstfMax","extensionEnableGSUB","extensionDisableGSUB","extensionEnableGPOS","extensionDisableGPOS","extensionJstfMax","$71cfb3c4767fbd0c$var$JstfLangSys","$71cfb3c4767fbd0c$var$JstfLangSysRecord","jstfLangSys","$71cfb3c4767fbd0c$var$JstfScript","extenderGlyphs","langSysCount","$71cfb3c4767fbd0c$var$JstfScriptRecord","$71cfb3c4767fbd0c$export$2e2bcd8739ae039","scriptCount","$d059a6bd2d3b5b63$var$VariableSizeNumber","readUInt24BE","_size","$d059a6bd2d3b5b63$var$MapDataEntry","entry","entryFormat","outerIndex","innerIndex","$d059a6bd2d3b5b63$var$DeltaSetIndexMap","mapCount","mapData","$d059a6bd2d3b5b63$export$2e2bcd8739ae039","advanceWidthMapping","LSBMapping","RSBMapping","$dceeca3e1977ce30$var$Signature","$dceeca3e1977ce30$var$SignatureBlock","cbSignature","signature","$dceeca3e1977ce30$export$2e2bcd8739ae039","ulVersion","usNumSigs","usFlag","signatures","signatureBlocks","$8acd740a9435aad0$var$GaspRange","rangeMaxPPEM","rangeGaspBehavior","$8acd740a9435aad0$export$2e2bcd8739ae039","numRanges","gaspRanges","$b5f380243c34d6a0$var$DeviceRecord","pixelSize","maximumWidth","widths","$b5f380243c34d6a0$export$2e2bcd8739ae039","sizeDeviceRecord","$ca2df1256966e313$var$KernPair","left","right","$ca2df1256966e313$var$ClassTable","firstGlyph","nGlyphs","$ca2df1256966e313$var$Kern2Array","off","leftTable","rowWidth","$ca2df1256966e313$var$KernSubtable","nPairs","pairs","rightTable","array","kernValueCount","leftClassCount","rightClassCount","kernValue","leftClass","rightClass","kernIndex","$ca2df1256966e313$var$KernTable","subVersion","padding","tupleIndex","$ca2df1256966e313$export$2e2bcd8739ae039","nTables","$7a9f92b0c46ebe33$export$2e2bcd8739ae039","yPels","$2b2ccc419d152631$export$2e2bcd8739ae039","fontNumber","pitch","style","typeFamily","symbolSet","typeface","characterComplement","fileName","strokeWeight","widthType","serifStyle","$ca5b40b9bcda9c9b$var$Ratio","bCharSet","xRatio","yStartRatio","yEndRatio","$ca5b40b9bcda9c9b$var$vTable","yPelHeight","$ca5b40b9bcda9c9b$var$VdmxGroup","recs","startsz","endsz","entries","$ca5b40b9bcda9c9b$export$2e2bcd8739ae039","numRecs","numRatios","ratioRanges","$69530a3c40755af0$export$2e2bcd8739ae039","advanceHeightMax","minTopSideBearing","minBottomSideBearing","yMaxExtent","$344073dd270f0e62$var$VmtxEntry","$344073dd270f0e62$export$2e2bcd8739ae039","vhea","$3793b781918cfced$var$shortFrac","$3793b781918cfced$var$Correspondence","fromCoord","toCoord","$3793b781918cfced$var$Segment","pairCount","correspondence","$3793b781918cfced$export$2e2bcd8739ae039","segment","$6cb7dd5f47d82580$var$UnboundedArrayAccessor","getItem","_items","base","inspect","name","$6cb7dd5f47d82580$export$c5af1eebc882e39a","$6cb7dd5f47d82580$export$8351f8c2ae2f103c","ValueType","Shadow","BinarySearchHeader","unitSize","nUnits","LookupSegmentSingle","lastGlyph","LookupSegmentArray","LookupSingle","binarySearchHeader","segments","$6cb7dd5f47d82580$export$79f7d93d790934ba","entryData","assign","newState","Entry","StateArray","nClasses","StateHeader","classTable","stateArray","entryTable","$6cb7dd5f47d82580$export$105027425199cc51","ClassLookupTable","newStateOffset","StateHeader1","$6a3746e8c708f5a3$var$BslnSubtable","mappingData","standardGlyph","controlPoints","$6a3746e8c708f5a3$export$2e2bcd8739ae039","defaultBaseline","$d0c76fac617b308a$var$Setting","setting","fontFeatures","$d0c76fac617b308a$var$FeatureName","nSettings","settingTable","featureFlags","defaultSetting","$d0c76fac617b308a$export$2e2bcd8739ae039","featureNameCount","reserved1","reserved2","featureNames","$e83fd065f00fcd01$var$Axis","axisTag","minValue","defaultValue","maxValue","$e83fd065f00fcd01$var$Instance","coord","postscriptNameID","instanceSize","$e83fd065f00fcd01$export$2e2bcd8739ae039","offsetToData","countSizePairs","axisSize","instanceCount","axis","instance","$dbe33c8d3a7f131c$var$shortFrac","$dbe33c8d3a7f131c$var$Offset","$dbe33c8d3a7f131c$var$gvar","globalCoordCount","globalCoords","$dbe33c8d3a7f131c$export$2e2bcd8739ae039","$05b01887df96c4ee$var$ClassTable","subFeatureFlags","stateTable","$05b01887df96c4ee$var$WidthDeltaRecord","justClass","beforeGrowLimit","beforeShrinkLimit","afterGrowLimit","afterShrinkLimit","growFlags","shrinkFlags","$05b01887df96c4ee$var$WidthDeltaCluster","$05b01887df96c4ee$var$ActionData","lowerLimit","upperLimit","order","addGlyph","substThreshold","substGlyph","variationAxis","minimumLimit","noStretchValue","maximumLimit","$05b01887df96c4ee$var$Action","actionClass","actionType","actionLength","actionData","$05b01887df96c4ee$var$PostcompensationAction","$05b01887df96c4ee$var$PostCompensationTable","lookupTable","$05b01887df96c4ee$var$JustificationTable","wdcOffset","postCompensationTable","widthDeltaClusters","$05b01887df96c4ee$export$2e2bcd8739ae039","horizontal","vertical","$03ee6ebd54db1053$var$LigatureData","action","$03ee6ebd54db1053$var$ContextualData","markIndex","currentIndex","$03ee6ebd54db1053$var$InsertionData","currentInsertIndex","markedInsertIndex","$03ee6ebd54db1053$var$SubstitutionTable","items","$03ee6ebd54db1053$var$SubtableData","substitutionTable","ligatureActions","ligatureList","insertionActions","$03ee6ebd54db1053$var$Subtable","$03ee6ebd54db1053$var$FeatureEntry","featureType","featureSetting","enableFlags","disableFlags","$03ee6ebd54db1053$var$MorxChain","defaultFlags","chainLength","nFeatureEntries","nSubtables","features","subtables","$03ee6ebd54db1053$export$2e2bcd8739ae039","unused","nChains","chains","$b7492a80b0d1a056$var$OpticalBounds","bottom","$b7492a80b0d1a056$export$2e2bcd8739ae039","$c3395722bea751e2$var$tables","$c3395722bea751e2$export$2e2bcd8739ae039","cmap","head","hmtx","post","fpgm","loca","prep","glyf","VORG","EBLC","CBLC","sbix","COLR","CPAL","BASE","GDEF","GPOS","GSUB","JSTF","HVAR","DSIG","gasp","hdmx","kern","LTSH","PCLT","VDMX","vmtx","avar","bsln","feat","fvar","gvar","just","morx","opbd","$816c07a04b6dba87$var$TableEntry","checkSum","$816c07a04b6dba87$var$Directory","numTables","$6uUbQ$VoidPointer","maxExponentFor2","floor","log","LN2","maxPowerOf2","pow","$816c07a04b6dba87$export$2e2bcd8739ae039","$12727730ddfc8bfe$export$2e0ae67339d5f1ac","cmp","min","$12727730ddfc8bfe$export$d02631cccf789723","$12727730ddfc8bfe$export$3d28c1996ced1f14","$12727730ddfc8bfe$var$CHARS","$12727730ddfc8bfe$var$LOOKUP","$12727730ddfc8bfe$export$94fdf11bafc8de6b","base64","bufferLength","bytes","p","encoded1","encoded2","encoded3","encoded4","$f08dd41ef10b694c$export$2e2bcd8739ae039","findSubtable","cmapTable","lookup","codepoint","variationSelector","getVariationSelector","rangeOffset","group","uvs","selectors","toArray","x","sel","getCharacterSet","endCodes","tail","codePointsForGlyph","delta","c","g","$0bba3a9db57637f3$export$2e2bcd8739ae039","positions","id","getKerning","crossStream","variation","pairIdx","pair","leftOffset","rightOffset","override","$0a4bdfeb6dfd6f5e$export$2e2bcd8739ae039","positionGlyphs","clusterStart","clusterEnd","isMark","positionCluster","baseBox","cbox","copy","codePoints","minX","yGap","mark","markBox","position","combiningClass","getCombiningClass","maxX","minY","maxY","codePoint","$6uUbQ$getCombiningClass","$f34600ab9d7f70d8$export$2e2bcd8739ae039","addPoint","y","abs","Infinity","$130d1a642ebcd2b7$var$UNICODE_SCRIPTS","Caucasian_Albanian","Arabic","Imperial_Aramaic","Armenian","Avestan","Balinese","Bamum","Bassa_Vah","Batak","Bengali","Bopomofo","Brahmi","Braille","Buginese","Buhid","Chakma","Canadian_Aboriginal","Carian","Cham","Cherokee","Coptic","Cypriot","Cyrillic","Devanagari","Deseret","Duployan","Egyptian_Hieroglyphs","Elbasan","Ethiopic","Georgian","Glagolitic","Gothic","Grantha","Greek","Gujarati","Gurmukhi","Hangul","Han","Hanunoo","Hebrew","Hiragana","Pahawh_Hmong","Katakana_Or_Hiragana","Old_Italic","Javanese","Kayah_Li","Katakana","Kharoshthi","Khmer","Khojki","Kannada","Kaithi","Tai_Tham","Lao","Latin","Lepcha","Limbu","Linear_A","Linear_B","Lisu","Lycian","Lydian","Mahajani","Mandaic","Manichaean","Mende_Kikakui","Meroitic_Cursive","Meroitic_Hieroglyphs","Malayalam","Modi","Mongolian","Mro","Meetei_Mayek","Myanmar","Old_North_Arabian","Nabataean","Nko","Ogham","Ol_Chiki","Old_Turkic","Oriya","Osmanya","Palmyrene","Pau_Cin_Hau","Old_Permic","Phags_Pa","Inscriptional_Pahlavi","Psalter_Pahlavi","Phoenician","Miao","Inscriptional_Parthian","Rejang","Runic","Samaritan","Old_South_Arabian","Saurashtra","Shavian","Sharada","Siddham","Khudawadi","Sinhala","Sora_Sompeng","Sundanese","Syloti_Nagri","Syriac","Tagbanwa","Takri","Tai_Le","New_Tai_Lue","Tamil","Tai_Viet","Telugu","Tifinagh","Tagalog","Thaana","Thai","Tibetan","Tirhuta","Ugaritic","Vai","Warang_Citi","Old_Persian","Cuneiform","Yi","Inherited","Common","Unknown","$130d1a642ebcd2b7$var$OPENTYPE_SCRIPTS","$130d1a642ebcd2b7$export$b32f0b5f69d65e51","$130d1a642ebcd2b7$export$ce50e82f12a827a4","$130d1a642ebcd2b7$export$e5cb25e204fb8450","idx","code","next","$6uUbQ$getScript","$130d1a642ebcd2b7$export$16fab0757cfc223d","$130d1a642ebcd2b7$var$RTL","arab","hebr","syrc","thaa","cprt","khar","phnx","lydi","avst","armi","phli","prti","sarb","orkh","samr","mand","merc","mero","mani","mend","nbat","narb","palm","phlp","$130d1a642ebcd2b7$export$9fddb9d0dd7d8a54","$be07b3e97a42687a$export$2e2bcd8739ae039","advanceWidth","advanceHeight","bbox","direction","$1ac75d9a55b67f01$export$2e2bcd8739ae039","$3b6302b64eccc32c$var$features","allTypographicFeatures","exclusive","allTypeFeatures","ligatures","requiredLigatures","commonLigatures","rareLigatures","rebusPictures","diphthongLigatures","squaredLigatures","abbrevSquaredLigatures","symbolLigatures","contextualLigatures","historicalLigatures","cursiveConnection","unconnected","partiallyConnected","cursive","letterCase","verticalSubstitution","substituteVerticalForms","linguisticRearrangement","numberSpacing","monospacedNumbers","proportionalNumbers","thirdWidthNumbers","quarterWidthNumbers","smartSwash","wordInitialSwashes","wordFinalSwashes","nonFinalSwashes","diacritics","showDiacritics","hideDiacritics","decomposeDiacritics","verticalPosition","normalPosition","superiors","inferiors","ordinals","scientificInferiors","fractions","noFractions","verticalFractions","diagonalFractions","overlappingCharacters","preventOverlap","typographicExtras","slashedZero","mathematicalExtras","mathematicalGreek","ornamentSets","noOrnaments","dingbats","piCharacters","fleurons","decorativeBorders","internationalSymbols","mathSymbols","characterAlternatives","noAlternates","designComplexity","designLevel1","designLevel2","designLevel3","designLevel4","designLevel5","styleOptions","noStyleOptions","displayText","engravedText","illuminatedCaps","titlingCaps","tallCaps","characterShape","traditionalCharacters","simplifiedCharacters","JIS1978Characters","JIS1983Characters","JIS1990Characters","traditionalAltOne","traditionalAltTwo","traditionalAltThree","traditionalAltFour","traditionalAltFive","expertCharacters","JIS2004Characters","hojoCharacters","NLCCharacters","traditionalNamesCharacters","numberCase","lowerCaseNumbers","upperCaseNumbers","textSpacing","proportionalText","monospacedText","halfWidthText","thirdWidthText","quarterWidthText","altProportionalText","altHalfWidthText","transliteration","noTransliteration","annotation","noAnnotation","boxAnnotation","roundedBoxAnnotation","circleAnnotation","invertedCircleAnnotation","parenthesisAnnotation","periodAnnotation","romanNumeralAnnotation","diamondAnnotation","invertedBoxAnnotation","invertedRoundedBoxAnnotation","kanaSpacing","fullWidthKana","proportionalKana","ideographicSpacing","fullWidthIdeographs","proportionalIdeographs","halfWidthIdeographs","unicodeDecomposition","canonicalComposition","compatibilityComposition","transcodingComposition","rubyKana","CJKSymbolAlternatives","noCJKSymbolAlternatives","CJKSymbolAltOne","CJKSymbolAltTwo","CJKSymbolAltThree","CJKSymbolAltFour","CJKSymbolAltFive","ideographicAlternatives","noIdeographicAlternatives","ideographicAltOne","ideographicAltTwo","ideographicAltThree","ideographicAltFour","ideographicAltFive","CJKVerticalRomanPlacement","CJKVerticalRomanCentered","CJKVerticalRomanHBaseline","italicCJKRoman","CJKItalicRoman","caseSensitiveLayout","caseSensitiveSpacing","alternateKana","alternateHorizKana","alternateVertKana","stylisticAlternatives","noStylisticAlternates","stylisticAltOne","stylisticAltTwo","stylisticAltThree","stylisticAltFour","stylisticAltFive","stylisticAltSix","stylisticAltSeven","stylisticAltEight","stylisticAltNine","stylisticAltTen","stylisticAltEleven","stylisticAltTwelve","stylisticAltThirteen","stylisticAltFourteen","stylisticAltFifteen","stylisticAltSixteen","stylisticAltSeventeen","stylisticAltEighteen","stylisticAltNineteen","stylisticAltTwenty","contextualAlternates","swashAlternates","contextualSwashAlternates","lowerCase","defaultLowerCase","lowerCaseSmallCaps","lowerCasePetiteCaps","upperCase","defaultUpperCase","upperCaseSmallCaps","upperCasePetiteCaps","languageTag","CJKRomanSpacing","halfWidthCJKRoman","proportionalCJKRoman","defaultCJKRoman","fullWidthCJKRoman","$3b6302b64eccc32c$var$feature","selector","$3b6302b64eccc32c$var$OTMapping","rlig","clig","dlig","hlig","liga","hist","smcp","pcap","frac","dnom","numr","afrc","case","ccmp","cpct","valt","swsh","cswh","curs","c2pc","c2sc","init","fin2","medi","med2","fin3","fina","pkna","half","halt","hkna","vkna","ital","lnum","onum","mgrk","calt","vrt2","tnum","pnum","sups","subs","ordn","pwid","hwid","qwid","twid","fwid","palt","trad","smpl","jp78","jp83","jp90","jp04","expt","hojo","nlck","tnam","ruby","titl","zero","ss01","ss02","ss03","ss04","ss05","ss06","ss07","ss08","ss09","ss10","ss11","ss12","ss13","ss14","ss15","ss16","ss17","ss18","ss19","ss20","slice","$3b6302b64eccc32c$var$AATMapping","ot","aat","$3b6302b64eccc32c$export$b813f7d2a1677c16","r","$3b6302b64eccc32c$var$mapFeatureStrings","f","isNaN","typeCode","settingCode","$3b6302b64eccc32c$export$bd6df347a4f391c4","keys","$ff5ce077dae0f144$export$2e2bcd8739ae039","seg","glyphsForValue","classValue","$50c7aac9316f2948$var$START_OF_TEXT_STATE","$50c7aac9316f2948$var$START_OF_LINE_STATE","$50c7aac9316f2948$var$END_OF_TEXT_CLASS","$50c7aac9316f2948$var$OUT_OF_BOUNDS_CLASS","$50c7aac9316f2948$var$DELETED_GLYPH_CLASS","$50c7aac9316f2948$var$END_OF_LINE_CLASS","$50c7aac9316f2948$var$DONT_ADVANCE","$50c7aac9316f2948$export$2e2bcd8739ae039","reverse","processEntry","currentState","dir","classCode","shouldAdvance","row","entryIndex","traverse","opts","state","visited","add","enter","exit","$55f71433a605c87d$var$MARK_FIRST","$55f71433a605c87d$var$MARK_LAST","$55f71433a605c87d$var$VERB","$55f71433a605c87d$var$SET_MARK","$55f71433a605c87d$var$SET_COMPONENT","$55f71433a605c87d$var$PERFORM_ACTION","$55f71433a605c87d$var$LAST_MASK","$55f71433a605c87d$var$STORE_MASK","$55f71433a605c87d$var$OFFSET_MASK","$55f71433a605c87d$var$VERTICAL_ONLY","$55f71433a605c87d$var$REVERSE_DIRECTION","$55f71433a605c87d$var$HORIZONTAL_AND_VERTICAL","$55f71433a605c87d$var$CURRENT_IS_KASHIDA_LIKE","$55f71433a605c87d$var$MARKED_IS_KASHIDA_LIKE","$55f71433a605c87d$var$CURRENT_INSERT_BEFORE","$55f71433a605c87d$var$MARKED_INSERT_BEFORE","$55f71433a605c87d$var$CURRENT_INSERT_COUNT","$55f71433a605c87d$var$MARKED_INSERT_COUNT","$55f71433a605c87d$export$2e2bcd8739ae039","chain","processSubtable","splice","processNoncontextualSubstitutions","ligatureStack","markedGlyph","markedIndex","stateMachine","getStateMachine","getProcessor","processIndicRearragement","processContextualSubstitution","processLigature","processGlyphInsertion","$55f71433a605c87d$var$reorderGlyphs","subsitutions","getGlyph","actions","actionIndex","last","ligatureIndex","ligatureGlyphs","componentGlyph","unshift","store","component","ligatureEntry","_insertGlyphs","insertionActionIndex","isBefore","insertions","getSupportedFeatures","generateInputs","inputCache","generateInputCache","generateInputsForSubtable","stack","found","bind","$55f71433a605c87d$var$swap","rangeA","rangeB","reverseA","reverseB","verb","$ba6dd74203be8728$export$2e2bcd8739ae039","glyphRun","morxProcessor","getAvailableFeatures","stringsForGlyph","glyphStrings","_addStrings","strings","_cmapProcessor","String","fromCodePoint","fallbackPosition","$94d7a73bd2edfc9a$export$2e2bcd8739ae039","_addFeatures","global","stageIndex","stages","stage","allFeatures","globalFeatures","arg","local","addStage","setFeatureOverrides","assignGlobalFeatures","processor","applyFeatures","$649970d87335b30f$var$VARIATION_FEATURES","$649970d87335b30f$var$COMMON_FEATURES","$649970d87335b30f$var$FRACTIONAL_FEATURES","$649970d87335b30f$var$HORIZONTAL_FEATURES","$649970d87335b30f$var$VERTICAL_FEATURES","$649970d87335b30f$var$DIRECTIONAL_FEATURES","ltr","rtl","$649970d87335b30f$export$2e2bcd8739ae039","plan","planPreprocessing","planFeatures","planPostprocessing","assignFeatures","userFeatures","$6uUbQ$isDigit","$6uUbQ$_","$764eb544bbe1ccf0$var$trie","$6uUbQ$unicodetrie","$764eb544bbe1ccf0$var$FEATURES","$764eb544bbe1ccf0$var$ShapingClasses","Non_Joining","Left_Joining","Right_Joining","Dual_Joining","Join_Causing","ALAPH","Transparent","$764eb544bbe1ccf0$var$ISOL","$764eb544bbe1ccf0$var$FINA","$764eb544bbe1ccf0$var$FIN2","$764eb544bbe1ccf0$var$FIN3","$764eb544bbe1ccf0$var$MEDI","$764eb544bbe1ccf0$var$MED2","$764eb544bbe1ccf0$var$INIT","$764eb544bbe1ccf0$var$NONE","$764eb544bbe1ccf0$var$STATE_TABLE","$764eb544bbe1ccf0$export$2e2bcd8739ae039","prev","curAction","prevAction","$764eb544bbe1ccf0$var$getShapingClass","category","$6uUbQ$getCategory","$85d408632270248b$export$2e2bcd8739ae039","reset","cur","shouldIgnore","ignoreMarks","ignoreBaseGlyphs","isBase","ignoreLigatures","isLigature","move","peek","increment","peekIndex","$a83b9c36aaa94fd3$var$DEFAULT_SCRIPTS","$a83b9c36aaa94fd3$export$2e2bcd8739ae039","findScript","selectScript","changed","scriptTag","repeat","substituteFeature","substituteFeatureForVariations","lookupsForFeatures","exclude","lookups","lookupIndex","sort","variationsIndex","substitution","findVariationsIndex","coords","variations","conditions","variationConditionsMatch","every","condition","advances","applyLookups","glyphIterator","currentFeature","applyLookup","applyLookupList","lookupRecord","coverageIndex","match","sequence","matched","sequenceMatches","sequenceMatchIndices","coverageSequenceMatches","getClassID","classSequenceMatches","classID","applyContext","rule","applyChainingContext","rules","_variationProcessor","normalizedCoords","ligatureID","$10e7b257e1a9a756$export$2e2bcd8739ae039","_id","substituted","_font","prototype","$6uUbQ$isMark","ligatureComponent","isLigated","cursiveAttachment","markAttachment","shaperInfo","isMultiplied","$e1c6bbc8cb416f8c$export$2e2bcd8739ae039","$e1c6bbc8cb416f8c$var$getType","$e1c6bbc8cb416f8c$var$STATE_TABLE","$e1c6bbc8cb416f8c$var$DECOMPOSE","hasGlyphForCodePoint","$e1c6bbc8cb416f8c$var$decompose","$e1c6bbc8cb416f8c$var$COMPOSE","$e1c6bbc8cb416f8c$var$compose","$e1c6bbc8cb416f8c$var$TONE_MARK","$e1c6bbc8cb416f8c$var$reorderToneMark","$e1c6bbc8cb416f8c$var$INVALID","$e1c6bbc8cb416f8c$var$insertDottedCircle","$e1c6bbc8cb416f8c$var$HANGUL_BASE","$e1c6bbc8cb416f8c$var$HANGUL_END","$e1c6bbc8cb416f8c$var$HANGUL_COUNT","$e1c6bbc8cb416f8c$var$L_BASE","$e1c6bbc8cb416f8c$var$V_BASE","$e1c6bbc8cb416f8c$var$T_BASE","$e1c6bbc8cb416f8c$var$L_COUNT","$e1c6bbc8cb416f8c$var$V_COUNT","$e1c6bbc8cb416f8c$var$T_COUNT","$e1c6bbc8cb416f8c$var$L_END","$e1c6bbc8cb416f8c$var$V_END","$e1c6bbc8cb416f8c$var$T_END","$e1c6bbc8cb416f8c$var$DOTTED_CIRCLE","$e1c6bbc8cb416f8c$var$isL","$e1c6bbc8cb416f8c$var$isV","$e1c6bbc8cb416f8c$var$isT","$e1c6bbc8cb416f8c$var$isTone","$e1c6bbc8cb416f8c$var$isLVT","$e1c6bbc8cb416f8c$var$isLV","$e1c6bbc8cb416f8c$var$isCombiningL","$e1c6bbc8cb416f8c$var$isCombiningV","$e1c6bbc8cb416f8c$var$isCombiningT","$e1c6bbc8cb416f8c$var$X","$e1c6bbc8cb416f8c$var$L","$e1c6bbc8cb416f8c$var$V","$e1c6bbc8cb416f8c$var$T","$e1c6bbc8cb416f8c$var$LV","$e1c6bbc8cb416f8c$var$LVT","$e1c6bbc8cb416f8c$var$M","$e1c6bbc8cb416f8c$var$NO_ACTION","$e1c6bbc8cb416f8c$var$getGlyph","glyphForCodePoint","l","v","ljmo","vjmo","insert","tjmo","prevType","lv","del","$e1c6bbc8cb416f8c$var$getLength","dottedCircle","$4b0735ca6c692ea5$exports","JSON","parse","$aa333a9607471296$exports","$90a9d3398ee54fe5$export$a513ea61a7bee91c","X","C","V","N","H","ZWNJ","ZWJ","M","SM","VD","A","Placeholder","Dotted_Circle","RS","Coeng","Repha","Ra","CM","Symbol","$90a9d3398ee54fe5$export$1a1f61c9c4dd9df0","Start","Ra_To_Become_Reph","Pre_M","Pre_C","Base_C","After_Main","Above_C","Before_Sub","Below_C","After_Sub","Before_Post","Post_C","After_Post","Final_C","SMVD","End","$90a9d3398ee54fe5$export$8519deaa7de2b07","$90a9d3398ee54fe5$export$bbcd928767338e0d","$90a9d3398ee54fe5$export$ca9599b2a300afc","$90a9d3398ee54fe5$export$e99d119da76a0fc5","Default","hasOldSpec","virama","basePos","rephPos","rephMode","blwfMode","$90a9d3398ee54fe5$export$f647c9cfdd77d95a","decompositions","$7826f90f6f0cecc9$var$decompositions","$parcel$interopDefault","$7826f90f6f0cecc9$var$trie","$7826f90f6f0cecc9$var$stateMachine","$6uUbQ$dfa","$7826f90f6f0cecc9$export$2e2bcd8739ae039","$7826f90f6f0cecc9$var$setupSyllables","$7826f90f6f0cecc9$var$initialReordering","$7826f90f6f0cecc9$var$finalReordering","unicodeScript","indicConfig","isOldSpec","d","decomposed","$7826f90f6f0cecc9$var$indicCategory","$7826f90f6f0cecc9$var$indicPosition","$7826f90f6f0cecc9$var$IndicInfo","syllableType","syllable","tags","$7826f90f6f0cecc9$var$isConsonant","$7826f90f6f0cecc9$var$isJoiner","$7826f90f6f0cecc9$var$isHalantOrCoeng","$7826f90f6f0cecc9$var$wouldSubstitute","_layoutEngine","engine","GSUBProcessor","$7826f90f6f0cecc9$var$consonantPosition","consonant","info","$7826f90f6f0cecc9$var$nextSyllable","limit","hasReph","rphf","seenBelow","j","disallowDoubleHalants","lastPos","blwf","abvf","pstf","prefLen","pref","cfar","nonJoiner","tryPref","BASE_C","newPos","oldPos","tmp","newRephPos","reph","test","categories","$7ab494fe977143c6$var$categories","$7ab494fe977143c6$var$decompositions","$7ab494fe977143c6$var$trie","$7ab494fe977143c6$var$stateMachine","$7ab494fe977143c6$export$2e2bcd8739ae039","$7ab494fe977143c6$var$setupSyllables","$7ab494fe977143c6$var$clearSubstitutionFlags","$7ab494fe977143c6$var$recordRphf","$7ab494fe977143c6$var$recordPref","$7ab494fe977143c6$var$reorder","$7ab494fe977143c6$var$useCategory","$7ab494fe977143c6$var$USEInfo","$7ab494fe977143c6$var$nextSyllable","$7ab494fe977143c6$var$isBase","$7ab494fe977143c6$var$isHalant","$102b6fe50f1d50b4$var$SHAPERS","mong","phag","hang","bng2","beng","dev2","deva","gjr2","gujr","guru","gur2","knda","knd2","mlm2","mlym","ory2","orya","taml","tml2","telu","tel2","khmr","bali","batk","brah","bugi","buhd","cakm","cham","dupl","egyp","gran","hano","java","kthi","kali","khoj","sind","lepc","limb","mahj","mtei","modi","hmng","rjng","saur","shrd","sidd","sinh","sund","sylo","tglg","tagb","tale","lana","tavt","takr","tibt","tfng","tirh","latn","DFLT","$102b6fe50f1d50b4$export$7877a478dd30fd3d","shaper","$0a876c45f1f7c41c$export$2e2bcd8739ae039","curGlyph","replacement","USER_INDEX","ligature","characters","ligatureGlyph","isMarkLigature","lastLigID","lastNumComps","curComps","matchIndex","$c96c93587d49c14d$export$2e2bcd8739ae039","applyPositionValue","variationProcessor","variationStore","getDelta","nextGlyph","class1","class2","nextIndex","curRecord","nextRecord","getAnchor","rightToLeft","baseGlyphIndex","baseIndex","markRecord","baseAnchor","applyAnchor","ligIndex","ligAttach","markGlyph","ligGlyph","compIndex","mark1Index","prevIndex","good","mark2Index","markCoords","markPos","anchor","fixCursiveAttachment","fixMarkAttachment","$a62492810de27e3d$export$2e2bcd8739ae039","setup","glyphInfos","GPOSProcessor","glyphInfo","zeroMarkWidths","zeroMarkAdvances","cleanup","$4c0a7fa5df7a9ab1$export$2e2bcd8739ae039","layout","glyphsForString","hideDefaultIgnorables","positioned","unicodeLayoutEngine","kernProcessor","space","isDefaultIgnorable","ch","plane","from","$f43aec954cdfdf21$var$SVG_COMMANDS","moveTo","lineTo","quadraticCurveTo","bezierCurveTo","closePath","$f43aec954cdfdf21$export$2e2bcd8739ae039","toFunction","commands","forEach","command","toSVG","cmds","round","join","_cbox","freeze","_bbox","cx","cy","p0","p1","p2","p3","qp1x","qp1y","p3x","p3y","cp1x","cp1y","cp2x","cp2y","b2ac","t1","sqrt","t2","mapPoints","path","transform","m0","m1","m2","m3","m4","m5","tx","ty","translate","rotate","angle","cos","sin","scale","scaleX","scaleY","_len2","_key2","$7713b9b7b438dff8$export$2e2bcd8739ae039","$f92906be28e61769$export$2e2bcd8739ae039","_getPath","_getCBox","_getBBox","_getTableMetrics","metric","_getMetrics","_metrics","leftBearing","topBearing","os2","getAdvanceAdjustment","getScaledPath","ligatureCaretPositions","_getName","fromCharCode","render","save","fill","restore","$69aac16029968692$var$GlyfHeader","numberOfContours","$69aac16029968692$var$ON_CURVE","$69aac16029968692$var$X_SHORT_VECTOR","$69aac16029968692$var$Y_SHORT_VECTOR","$69aac16029968692$var$REPEAT","$69aac16029968692$var$SAME_X","$69aac16029968692$var$SAME_Y","$69aac16029968692$var$ARG_1_AND_2_ARE_WORDS","$69aac16029968692$var$ARGS_ARE_XY_VALUES","$69aac16029968692$var$ROUND_XY_TO_GRID","$69aac16029968692$var$WE_HAVE_A_SCALE","$69aac16029968692$var$MORE_COMPONENTS","$69aac16029968692$var$WE_HAVE_AN_X_AND_Y_SCALE","$69aac16029968692$var$WE_HAVE_A_TWO_BY_TWO","$69aac16029968692$var$WE_HAVE_INSTRUCTIONS","$69aac16029968692$var$USE_MY_METRICS","$69aac16029968692$var$OVERLAP_COMPOUND","$69aac16029968692$var$SCALED_COMPONENT_OFFSET","$69aac16029968692$var$UNSCALED_COMPONENT_OFFSET","$69aac16029968692$export$baf26146a414f24a","onCurve","endContour","$69aac16029968692$var$Component","dx","dy","scale01","scale10","$69aac16029968692$export$2e2bcd8739ae039","internal","_getTableStream","_parseGlyphCoord","short","same","_decode","glyfPos","nextPos","_decodeSimple","_decodeComposite","points","endPtsOfContours","numCoords","flag","point","px","py","_getPhantomPoints","transformPoints","phantomPoints","haveInstructions","gPos","readInt8","_getContours","contours","contour","directory","firstPt","lastPt","curvePt","pt","prevPt","midX","midY","$62cc5109c6101893$export$2e2bcd8739ae039","CFF2","bias","cff","trans","nStems","usedGsubrs","usedSubrs","open","_usedGsubrs","_usedSubrs","gsubrs","gsubrsBias","privateDict","subrs","Subrs","subrsBias","vstore","vsindex","checkWidth","shift","nominalWidthX","parseStems","subr","phase","c1x","c1y","c2x","c2y","c3x","c3y","c4x","c4y","c5x","c5y","c6x","c6y","pts","e","blendVector","getBlendVector","numOperands","sum","s1","s2","v1","v2","random","n","startx","starty","b1","$25d8f049c222084c$var$SBIXImage","originX","originY","buflen","$25d8f049c222084c$export$2e2bcd8739ae039","getImageForSize","img","image","renderOutlines","$0d411f0165859681$var$COLRLayer","color","$0d411f0165859681$export$2e2bcd8739ae039","layers","layer","cpal","colr","rec","baseLayer","_getBaseGlyph","fillColor","$0bb840cac04e911b$var$TUPLES_SHARE_POINT_NUMBERS","$0bb840cac04e911b$var$TUPLE_COUNT_MASK","$0bb840cac04e911b$var$EMBEDDED_TUPLE_COORD","$0bb840cac04e911b$var$INTERMEDIATE_TUPLE","$0bb840cac04e911b$var$PRIVATE_POINT_NUMBERS","$0bb840cac04e911b$var$TUPLE_INDEX_MASK","$0bb840cac04e911b$var$POINTS_ARE_WORDS","$0bb840cac04e911b$var$POINT_RUN_COUNT_MASK","$0bb840cac04e911b$var$DELTAS_ARE_ZERO","$0bb840cac04e911b$var$DELTAS_ARE_WORDS","$0bb840cac04e911b$var$DELTA_RUN_COUNT_MASK","$0bb840cac04e911b$export$2e2bcd8739ae039","normalizeCoords","normalized","EPSILON","glyphPoints","tupleCount","here","sharedPoints","decodePoints","origPoints","tupleDataSize","tupleCoords","startCoords","endCoords","factor","tupleFactor","nPoints","xDeltas","decodeDeltas","yDeltas","outPoints","hasDelta","interpolateMissingDeltas","deltaX","deltaY","Uint16Array","run","runCount","readUInt16","Int16Array","inPoints","firstPoint","endPoint","firstDelta","curDelta","deltaInterpolate","deltaShift","ref1","ref2","iterable","in1","in2","out1","out2","out","ref","itemStore","varData","deltaSet","netAdjustment","master","blendVectors","scalar","regionIndex","axes","axisScalar","$5cc7476da92df375$var$resolved","Promise","resolve","$5cc7476da92df375$export$2e2bcd8739ae039","includeGlyph","$807e58506be70005$var$ON_CURVE","$807e58506be70005$var$X_SHORT_VECTOR","$807e58506be70005$var$Y_SHORT_VECTOR","$807e58506be70005$var$REPEAT","$807e58506be70005$var$SAME_X","$807e58506be70005$var$SAME_Y","$807e58506be70005$var$Point","$807e58506be70005$var$Glyf","xPoints","yPoints","$807e58506be70005$export$2e2bcd8739ae039","encodeSimple","lastX","lastY","lastFlag","pointCount","_encodePoint","$6uUbQ$EncodeStream","shortFlag","sameFlag","diff","$4abbb6a5dbdc441a$export$2e2bcd8739ae039","_addGlyph","curOffset","nextOffset","view","DataView","setUint16","glyphEncoder","$6uUbQ$clone","toBuffer","$001d739428a71d5a$export$2e2bcd8739ae039","subsetCharstrings","charstrings","subsetSubrs","used","subsetFontdict","used_fds","used_subrs","fd_select","FontName","createCIDFontdict","addString","Encoding","CIDCount","$4c1709dee528ea76$export$2e2bcd8739ae039","setDefaultLanguage","defaultLanguage","_getTable","_tables","_decodeTable","console","error","_decodeDirectory","getName","subfamilyName","copyright","characterSet","nextState","availableFeatures","_glyphs","createSubset","variationAxes","trim","default","namedVariations","settings","getVariation","_directoryPos","variationCoords","$c1726355ecc5b889$var$WOFFDirectoryEntry","compLength","origChecksum","$c1726355ecc5b889$var$WOFFDirectory","flavor","totalSfntSize","metaOffset","metaLength","metaOrigLength","privOffset","privLength","$c1726355ecc5b889$export$2e2bcd8739ae039","$760785214b9fc52c$export$2e2bcd8739ae039","outBuffer","buf","$6uUbQ$tinyinflate","$8046190c9f1ad19e$export$2e2bcd8739ae039","_transformedGlyphs","$c28ec7bbb3b8de3a$var$Base128","$c28ec7bbb3b8de3a$var$knownTags","$c28ec7bbb3b8de3a$var$WOFF2DirectoryEntry","customTag","transformVersion","transformed","transformLength","$c28ec7bbb3b8de3a$var$WOFF2Directory","totalCompressedSize","$c28ec7bbb3b8de3a$export$2e2bcd8739ae039","$21ee218f84ac7f32$export$2e2bcd8739ae039","_dataPos","_decompress","_decompressed","decompressedSize","decompressed","$6uUbQ$brotlidecompressjs","_transformGlyfTable","$21ee218f84ac7f32$var$GlyfTable","nContours","totalPoints","$21ee218f84ac7f32$var$read255UInt16","$21ee218f84ac7f32$var$decodeTriplet","instructionSize","composites","$21ee218f84ac7f32$var$Substream","_buf","indexFormat","nContourStreamSize","nPointsStreamSize","flagStreamSize","glyphStreamSize","compositeStreamSize","bboxStreamSize","instructionStreamSize","bboxes","$21ee218f84ac7f32$var$WORD_CODE","$21ee218f84ac7f32$var$ONE_MORE_BYTE_CODE2","$21ee218f84ac7f32$var$ONE_MORE_BYTE_CODE1","$21ee218f84ac7f32$var$LOWEST_U_CODE","$21ee218f84ac7f32$var$withSign","baseval","b0","b2","$cd5853a56c68fec7$var$TTCHeader","numFonts","dsigTag","dsigLength","dsigOffset","$cd5853a56c68fec7$export$2e2bcd8739ae039","fonts","readString","$05f49f930186144e$var$DFontName","$05f49f930186144e$var$DFontData","$05f49f930186144e$var$Ref","nameOffset","attr","dataOffset","handle","$05f49f930186144e$var$Type","maxTypeIndex","refList","$05f49f930186144e$var$TypeList","types","$05f49f930186144e$var$DFontMap","typeList","nameListOffset","$05f49f930186144e$var$DFontHeader","dataLength","mapLength","$05f49f930186144e$export$2e2bcd8739ae039","sfnt"],"sources":["C:\\Users\\JS\\testinge\\node_modules\\fontkit\\dist\\src\\index.js","C:\\Users\\JS\\testinge\\node_modules\\fontkit\\dist\\src\\base.js","C:\\Users\\JS\\testinge\\node_modules\\fontkit\\dist\\src\\TTFFont.js","C:\\Users\\JS\\testinge\\node_modules\\fontkit\\dist\\src\\decorators.js","C:\\Users\\JS\\testinge\\node_modules\\fontkit\\dist\\src\\tables\\directory.js","C:\\Users\\JS\\testinge\\node_modules\\fontkit\\dist\\src\\tables\\index.js","C:\\Users\\JS\\testinge\\node_modules\\fontkit\\dist\\src\\tables\\cmap.js","C:\\Users\\JS\\testinge\\node_modules\\fontkit\\dist\\src\\tables\\head.js","C:\\Users\\JS\\testinge\\node_modules\\fontkit\\dist\\src\\tables\\hhea.js","C:\\Users\\JS\\testinge\\node_modules\\fontkit\\dist\\src\\tables\\hmtx.js","C:\\Users\\JS\\testinge\\node_modules\\fontkit\\dist\\src\\tables\\maxp.js","C:\\Users\\JS\\testinge\\node_modules\\fontkit\\dist\\src\\tables\\name.js","C:\\Users\\JS\\testinge\\node_modules\\fontkit\\dist\\src\\encodings.js","C:\\Users\\JS\\testinge\\node_modules\\fontkit\\dist\\src\\tables\\OS2.js","C:\\Users\\JS\\testinge\\node_modules\\fontkit\\dist\\src\\tables\\post.js","C:\\Users\\JS\\testinge\\node_modules\\fontkit\\dist\\src\\tables\\cvt.js","C:\\Users\\JS\\testinge\\node_modules\\fontkit\\dist\\src\\tables\\fpgm.js","C:\\Users\\JS\\testinge\\node_modules\\fontkit\\dist\\src\\tables\\loca.js","C:\\Users\\JS\\testinge\\node_modules\\fontkit\\dist\\src\\tables\\prep.js","C:\\Users\\JS\\testinge\\node_modules\\fontkit\\dist\\src\\tables\\glyf.js","C:\\Users\\JS\\testinge\\node_modules\\fontkit\\dist\\src\\cff\\CFFFont.js","C:\\Users\\JS\\testinge\\node_modules\\fontkit\\dist\\src\\cff\\CFFIndex.js","C:\\Users\\JS\\testinge\\node_modules\\fontkit\\dist\\src\\cff\\CFFTop.js","C:\\Users\\JS\\testinge\\node_modules\\fontkit\\dist\\src\\cff\\CFFDict.js","C:\\Users\\JS\\testinge\\node_modules\\fontkit\\dist\\src\\cff\\CFFOperand.js","C:\\Users\\JS\\testinge\\node_modules\\fontkit\\dist\\src\\cff\\CFFPointer.js","C:\\Users\\JS\\testinge\\node_modules\\fontkit\\dist\\src\\cff\\CFFPrivateDict.js","C:\\Users\\JS\\testinge\\node_modules\\fontkit\\dist\\src\\cff\\CFFStandardStrings.js","C:\\Users\\JS\\testinge\\node_modules\\fontkit\\dist\\src\\cff\\CFFEncodings.js","C:\\Users\\JS\\testinge\\node_modules\\fontkit\\dist\\src\\cff\\CFFCharsets.js","C:\\Users\\JS\\testinge\\node_modules\\fontkit\\dist\\src\\tables\\variations.js","C:\\Users\\JS\\testinge\\node_modules\\fontkit\\dist\\src\\tables\\opentype.js","C:\\Users\\JS\\testinge\\node_modules\\fontkit\\dist\\src\\tables\\VORG.js","C:\\Users\\JS\\testinge\\node_modules\\fontkit\\dist\\src\\tables\\EBLC.js","C:\\Users\\JS\\testinge\\node_modules\\fontkit\\dist\\src\\tables\\EBDT.js","C:\\Users\\JS\\testinge\\node_modules\\fontkit\\dist\\src\\tables\\sbix.js","C:\\Users\\JS\\testinge\\node_modules\\fontkit\\dist\\src\\tables\\COLR.js","C:\\Users\\JS\\testinge\\node_modules\\fontkit\\dist\\src\\tables\\CPAL.js","C:\\Users\\JS\\testinge\\node_modules\\fontkit\\dist\\src\\tables\\BASE.js","C:\\Users\\JS\\testinge\\node_modules\\fontkit\\dist\\src\\tables\\GDEF.js","C:\\Users\\JS\\testinge\\node_modules\\fontkit\\dist\\src\\tables\\GPOS.js","C:\\Users\\JS\\testinge\\node_modules\\fontkit\\dist\\src\\tables\\GSUB.js","C:\\Users\\JS\\testinge\\node_modules\\fontkit\\dist\\src\\tables\\JSTF.js","C:\\Users\\JS\\testinge\\node_modules\\fontkit\\dist\\src\\tables\\HVAR.js","C:\\Users\\JS\\testinge\\node_modules\\fontkit\\dist\\src\\tables\\DSIG.js","C:\\Users\\JS\\testinge\\node_modules\\fontkit\\dist\\src\\tables\\gasp.js","C:\\Users\\JS\\testinge\\node_modules\\fontkit\\dist\\src\\tables\\hdmx.js","C:\\Users\\JS\\testinge\\node_modules\\fontkit\\dist\\src\\tables\\kern.js","C:\\Users\\JS\\testinge\\node_modules\\fontkit\\dist\\src\\tables\\LTSH.js","C:\\Users\\JS\\testinge\\node_modules\\fontkit\\dist\\src\\tables\\PCLT.js","C:\\Users\\JS\\testinge\\node_modules\\fontkit\\dist\\src\\tables\\VDMX.js","C:\\Users\\JS\\testinge\\node_modules\\fontkit\\dist\\src\\tables\\vhea.js","C:\\Users\\JS\\testinge\\node_modules\\fontkit\\dist\\src\\tables\\vmtx.js","C:\\Users\\JS\\testinge\\node_modules\\fontkit\\dist\\src\\tables\\avar.js","C:\\Users\\JS\\testinge\\node_modules\\fontkit\\dist\\src\\tables\\bsln.js","C:\\Users\\JS\\testinge\\node_modules\\fontkit\\dist\\src\\tables\\aat.js","C:\\Users\\JS\\testinge\\node_modules\\fontkit\\dist\\src\\tables\\feat.js","C:\\Users\\JS\\testinge\\node_modules\\fontkit\\dist\\src\\tables\\fvar.js","C:\\Users\\JS\\testinge\\node_modules\\fontkit\\dist\\src\\tables\\gvar.js","C:\\Users\\JS\\testinge\\node_modules\\fontkit\\dist\\src\\tables\\just.js","C:\\Users\\JS\\testinge\\node_modules\\fontkit\\dist\\src\\tables\\morx.js","C:\\Users\\JS\\testinge\\node_modules\\fontkit\\dist\\src\\tables\\opbd.js","C:\\Users\\JS\\testinge\\node_modules\\fontkit\\dist\\src\\CmapProcessor.js","C:\\Users\\JS\\testinge\\node_modules\\fontkit\\dist\\src\\utils.js","C:\\Users\\JS\\testinge\\node_modules\\fontkit\\dist\\src\\layout\\LayoutEngine.js","C:\\Users\\JS\\testinge\\node_modules\\fontkit\\dist\\src\\layout\\KernProcessor.js","C:\\Users\\JS\\testinge\\node_modules\\fontkit\\dist\\src\\layout\\UnicodeLayoutEngine.js","C:\\Users\\JS\\testinge\\node_modules\\fontkit\\dist\\src\\layout\\GlyphRun.js","C:\\Users\\JS\\testinge\\node_modules\\fontkit\\dist\\src\\glyph\\BBox.js","C:\\Users\\JS\\testinge\\node_modules\\fontkit\\dist\\src\\layout\\Script.js","C:\\Users\\JS\\testinge\\node_modules\\fontkit\\dist\\src\\layout\\GlyphPosition.js","C:\\Users\\JS\\testinge\\node_modules\\fontkit\\dist\\src\\aat\\AATLayoutEngine.js","C:\\Users\\JS\\testinge\\node_modules\\fontkit\\dist\\src\\aat\\AATFeatureMap.js","C:\\Users\\JS\\testinge\\node_modules\\fontkit\\dist\\src\\aat\\AATMorxProcessor.js","C:\\Users\\JS\\testinge\\node_modules\\fontkit\\dist\\src\\aat\\AATStateMachine.js","C:\\Users\\JS\\testinge\\node_modules\\fontkit\\dist\\src\\aat\\AATLookupTable.js","C:\\Users\\JS\\testinge\\node_modules\\fontkit\\dist\\src\\opentype\\OTLayoutEngine.js","C:\\Users\\JS\\testinge\\node_modules\\fontkit\\dist\\src\\opentype\\ShapingPlan.js","C:\\Users\\JS\\testinge\\node_modules\\fontkit\\dist\\src\\opentype\\shapers\\index.js","C:\\Users\\JS\\testinge\\node_modules\\fontkit\\dist\\src\\opentype\\shapers\\DefaultShaper.js","C:\\Users\\JS\\testinge\\node_modules\\fontkit\\dist\\src\\opentype\\shapers\\ArabicShaper.js","C:\\Users\\JS\\testinge\\node_modules\\fontkit\\dist\\src\\opentype\\shapers\\HangulShaper.js","C:\\Users\\JS\\testinge\\node_modules\\fontkit\\dist\\src\\opentype\\GlyphInfo.js","C:\\Users\\JS\\testinge\\node_modules\\fontkit\\dist\\src\\opentype\\OTProcessor.js","C:\\Users\\JS\\testinge\\node_modules\\fontkit\\dist\\src\\opentype\\GlyphIterator.js","C:\\Users\\JS\\testinge\\node_modules\\fontkit\\dist\\src\\opentype\\shapers\\IndicShaper.js","C:\\Users\\JS\\testinge\\node_modules\\fontkit\\dist\\src\\opentype\\shapers\\indic.json","C:\\Users\\JS\\testinge\\node_modules\\fontkit\\dist\\src\\opentype\\shapers\\use.json","C:\\Users\\JS\\testinge\\node_modules\\fontkit\\dist\\src\\opentype\\shapers\\indic-data.js","C:\\Users\\JS\\testinge\\node_modules\\fontkit\\dist\\src\\opentype\\shapers\\UniversalShaper.js","C:\\Users\\JS\\testinge\\node_modules\\fontkit\\dist\\src\\opentype\\GSUBProcessor.js","C:\\Users\\JS\\testinge\\node_modules\\fontkit\\dist\\src\\opentype\\GPOSProcessor.js","C:\\Users\\JS\\testinge\\node_modules\\fontkit\\dist\\src\\glyph\\TTFGlyph.js","C:\\Users\\JS\\testinge\\node_modules\\fontkit\\dist\\src\\glyph\\Glyph.js","C:\\Users\\JS\\testinge\\node_modules\\fontkit\\dist\\src\\glyph\\Path.js","C:\\Users\\JS\\testinge\\node_modules\\fontkit\\dist\\src\\glyph\\StandardNames.js","C:\\Users\\JS\\testinge\\node_modules\\fontkit\\dist\\src\\glyph\\CFFGlyph.js","C:\\Users\\JS\\testinge\\node_modules\\fontkit\\dist\\src\\glyph\\SBIXGlyph.js","C:\\Users\\JS\\testinge\\node_modules\\fontkit\\dist\\src\\glyph\\COLRGlyph.js","C:\\Users\\JS\\testinge\\node_modules\\fontkit\\dist\\src\\glyph\\GlyphVariationProcessor.js","C:\\Users\\JS\\testinge\\node_modules\\fontkit\\dist\\src\\subset\\TTFSubset.js","C:\\Users\\JS\\testinge\\node_modules\\fontkit\\dist\\src\\subset\\Subset.js","C:\\Users\\JS\\testinge\\node_modules\\fontkit\\dist\\src\\glyph\\TTFGlyphEncoder.js","C:\\Users\\JS\\testinge\\node_modules\\fontkit\\dist\\src\\subset\\CFFSubset.js","C:\\Users\\JS\\testinge\\node_modules\\fontkit\\dist\\src\\WOFFFont.js","C:\\Users\\JS\\testinge\\node_modules\\fontkit\\dist\\src\\tables\\WOFFDirectory.js","C:\\Users\\JS\\testinge\\node_modules\\fontkit\\dist\\src\\WOFF2Font.js","C:\\Users\\JS\\testinge\\node_modules\\fontkit\\dist\\src\\glyph\\WOFF2Glyph.js","C:\\Users\\JS\\testinge\\node_modules\\fontkit\\dist\\src\\tables\\WOFF2Directory.js","C:\\Users\\JS\\testinge\\node_modules\\fontkit\\dist\\src\\TrueTypeCollection.js","C:\\Users\\JS\\testinge\\node_modules\\fontkit\\dist\\src\\DFont.js"],"sourcesContent":["import { registerFormat, create, defaultLanguage, setDefaultLanguage } from './base';\nimport TTFFont from './TTFFont';\nimport WOFFFont from './WOFFFont';\nimport WOFF2Font from './WOFF2Font';\nimport TrueTypeCollection from './TrueTypeCollection';\nimport DFont from './DFont';\n\n// Register font formats\nregisterFormat(TTFFont);\nregisterFormat(WOFFFont);\nregisterFormat(WOFF2Font);\nregisterFormat(TrueTypeCollection);\nregisterFormat(DFont);\n\nexport * from './base';\n","import {DecodeStream} from 'restructure';\n\nexport let logErrors = false;\n\nlet formats = [];\nexport function registerFormat(format) {\n  formats.push(format);\n};\n\nexport function create(buffer, postscriptName) {\n  for (let i = 0; i < formats.length; i++) {\n    let format = formats[i];\n    if (format.probe(buffer)) {\n      let font = new format(new DecodeStream(buffer));\n      if (postscriptName) {\n        return font.getFont(postscriptName);\n      }\n\n      return font;\n    }\n  }\n\n  throw new Error('Unknown font format');\n};\n\nexport let defaultLanguage = 'en';\nexport function setDefaultLanguage(lang = 'en') {\n  defaultLanguage = lang;\n};\n","import * as r from 'restructure';\nimport { cache } from './decorators';\nimport * as fontkit from './base';\nimport Directory from './tables/directory';\nimport tables from './tables';\nimport CmapProcessor from './CmapProcessor';\nimport LayoutEngine from './layout/LayoutEngine';\nimport TTFGlyph from './glyph/TTFGlyph';\nimport CFFGlyph from './glyph/CFFGlyph';\nimport SBIXGlyph from './glyph/SBIXGlyph';\nimport COLRGlyph from './glyph/COLRGlyph';\nimport GlyphVariationProcessor from './glyph/GlyphVariationProcessor';\nimport TTFSubset from './subset/TTFSubset';\nimport CFFSubset from './subset/CFFSubset';\nimport BBox from './glyph/BBox';\nimport { asciiDecoder } from './utils';\n\n/**\n * This is the base class for all SFNT-based font formats in fontkit.\n * It supports TrueType, and PostScript glyphs, and several color glyph formats.\n */\nexport default class TTFFont {\n  type = 'TTF';\n\n  static probe(buffer) {\n    let format = asciiDecoder.decode(buffer.slice(0, 4));\n    return format === 'true' || format === 'OTTO' || format === String.fromCharCode(0, 1, 0, 0);\n  }\n\n  constructor(stream, variationCoords = null) {\n    this.defaultLanguage = null;\n    this.stream = stream;\n    this.variationCoords = variationCoords;\n\n    this._directoryPos = this.stream.pos;\n    this._tables = {};\n    this._glyphs = {};\n    this._decodeDirectory();\n\n    // define properties for each table to lazily parse\n    for (let tag in this.directory.tables) {\n      let table = this.directory.tables[tag];\n      if (tables[tag] && table.length > 0) {\n        Object.defineProperty(this, tag, {\n          get: this._getTable.bind(this, table)\n        });\n      }\n    }\n  }\n\n  setDefaultLanguage(lang = null) {\n    this.defaultLanguage = lang;\n  }\n\n  _getTable(table) {\n    if (!(table.tag in this._tables)) {\n      try {\n        this._tables[table.tag] = this._decodeTable(table);\n      } catch (e) {\n        if (fontkit.logErrors) {\n          console.error(`Error decoding table ${table.tag}`);\n          console.error(e.stack);\n        }\n      }\n    }\n\n    return this._tables[table.tag];\n  }\n\n  _getTableStream(tag) {\n    let table = this.directory.tables[tag];\n    if (table) {\n      this.stream.pos = table.offset;\n      return this.stream;\n    }\n\n    return null;\n  }\n\n  _decodeDirectory() {\n    return this.directory = Directory.decode(this.stream, {_startOffset: 0});\n  }\n\n  _decodeTable(table) {\n    let pos = this.stream.pos;\n\n    let stream = this._getTableStream(table.tag);\n    let result = tables[table.tag].decode(stream, this, table.length);\n\n    this.stream.pos = pos;\n    return result;\n  }\n\n  /**\n   * Gets a string from the font's `name` table\n   * `lang` is a BCP-47 language code.\n   * @return {string}\n   */\n  getName(key, lang = this.defaultLanguage || fontkit.defaultLanguage) {\n    let record = this.name && this.name.records[key];\n    if (record) {\n      // Attempt to retrieve the entry, depending on which translation is available:\n      return (\n          record[lang]\n          || record[this.defaultLanguage]\n          || record[fontkit.defaultLanguage]\n          || record['en']\n          || record[Object.keys(record)[0]] // Seriously, ANY language would be fine\n          || null\n      );\n    }\n\n    return null;\n  }\n\n  /**\n   * The unique PostScript name for this font, e.g. \"Helvetica-Bold\"\n   * @type {string}\n   */\n  get postscriptName() {\n    return this.getName('postscriptName');\n  }\n\n  /**\n   * The font's full name, e.g. \"Helvetica Bold\"\n   * @type {string}\n   */\n  get fullName() {\n    return this.getName('fullName');\n  }\n\n  /**\n   * The font's family name, e.g. \"Helvetica\"\n   * @type {string}\n   */\n  get familyName() {\n    return this.getName('fontFamily');\n  }\n\n  /**\n   * The font's sub-family, e.g. \"Bold\".\n   * @type {string}\n   */\n  get subfamilyName() {\n    return this.getName('fontSubfamily');\n  }\n\n  /**\n   * The font's copyright information\n   * @type {string}\n   */\n  get copyright() {\n    return this.getName('copyright');\n  }\n\n  /**\n   * The font's version number\n   * @type {string}\n   */\n  get version() {\n    return this.getName('version');\n  }\n\n  /**\n   * The fonts [ascender](https://en.wikipedia.org/wiki/Ascender_(typography))\n   * @type {number}\n   */\n  get ascent() {\n    return this.hhea.ascent;\n  }\n\n  /**\n   * The fonts [descender](https://en.wikipedia.org/wiki/Descender)\n   * @type {number}\n   */\n  get descent() {\n    return this.hhea.descent;\n  }\n\n  /**\n   * The amount of space that should be included between lines\n   * @type {number}\n   */\n  get lineGap() {\n    return this.hhea.lineGap;\n  }\n\n  /**\n   * The offset from the normal underline position that should be used\n   * @type {number}\n   */\n  get underlinePosition() {\n    return this.post.underlinePosition;\n  }\n\n  /**\n   * The weight of the underline that should be used\n   * @type {number}\n   */\n  get underlineThickness() {\n    return this.post.underlineThickness;\n  }\n\n  /**\n   * If this is an italic font, the angle the cursor should be drawn at to match the font design\n   * @type {number}\n   */\n  get italicAngle() {\n    return this.post.italicAngle;\n  }\n\n  /**\n   * The height of capital letters above the baseline.\n   * See [here](https://en.wikipedia.org/wiki/Cap_height) for more details.\n   * @type {number}\n   */\n  get capHeight() {\n    let os2 = this['OS/2'];\n    return os2 ? os2.capHeight : this.ascent;\n  }\n\n  /**\n   * The height of lower case letters in the font.\n   * See [here](https://en.wikipedia.org/wiki/X-height) for more details.\n   * @type {number}\n   */\n  get xHeight() {\n    let os2 = this['OS/2'];\n    return os2 ? os2.xHeight : 0;\n  }\n\n  /**\n   * The number of glyphs in the font.\n   * @type {number}\n   */\n  get numGlyphs() {\n    return this.maxp.numGlyphs;\n  }\n\n  /**\n   * The size of the fonts internal coordinate grid\n   * @type {number}\n   */\n  get unitsPerEm() {\n    return this.head.unitsPerEm;\n  }\n\n  /**\n   * The fonts bounding box, i.e. the box that encloses all glyphs in the font.\n   * @type {BBox}\n   */\n  @cache\n  get bbox() {\n    return Object.freeze(new BBox(this.head.xMin, this.head.yMin, this.head.xMax, this.head.yMax));\n  }\n\n  @cache\n  get _cmapProcessor() {\n    return new CmapProcessor(this.cmap);\n  }\n\n  /**\n   * An array of all of the unicode code points supported by the font.\n   * @type {number[]}\n   */\n  @cache\n  get characterSet() {\n    return this._cmapProcessor.getCharacterSet();\n  }\n\n  /**\n   * Returns whether there is glyph in the font for the given unicode code point.\n   *\n   * @param {number} codePoint\n   * @return {boolean}\n   */\n  hasGlyphForCodePoint(codePoint) {\n    return !!this._cmapProcessor.lookup(codePoint);\n  }\n\n  /**\n   * Maps a single unicode code point to a Glyph object.\n   * Does not perform any advanced substitutions (there is no context to do so).\n   *\n   * @param {number} codePoint\n   * @return {Glyph}\n   */\n  glyphForCodePoint(codePoint) {\n    return this.getGlyph(this._cmapProcessor.lookup(codePoint), [codePoint]);\n  }\n\n  /**\n   * Returns an array of Glyph objects for the given string.\n   * This is only a one-to-one mapping from characters to glyphs.\n   * For most uses, you should use font.layout (described below), which\n   * provides a much more advanced mapping supporting AAT and OpenType shaping.\n   *\n   * @param {string} string\n   * @return {Glyph[]}\n   */\n  glyphsForString(string) {\n    let glyphs = [];\n    let len = string.length;\n    let idx = 0;\n    let last = -1;\n    let state = -1;\n\n    while (idx <= len) {\n      let code = 0;\n      let nextState = 0;\n\n      if (idx < len) {\n        // Decode the next codepoint from UTF 16\n        code = string.charCodeAt(idx++);\n        if (0xd800 <= code && code <= 0xdbff && idx < len) {\n          let next = string.charCodeAt(idx);\n          if (0xdc00 <= next && next <= 0xdfff) {\n            idx++;\n            code = ((code & 0x3ff) << 10) + (next & 0x3ff) + 0x10000;\n          }\n        }\n\n        // Compute the next state: 1 if the next codepoint is a variation selector, 0 otherwise.\n        nextState = ((0xfe00 <= code && code <= 0xfe0f) || (0xe0100 <= code && code <= 0xe01ef)) ? 1 : 0;\n      } else {\n        idx++;\n      }\n\n      if (state === 0 && nextState === 1) {\n        // Variation selector following normal codepoint.\n        glyphs.push(this.getGlyph(this._cmapProcessor.lookup(last, code), [last, code]));\n      } else if (state === 0 && nextState === 0) {\n        // Normal codepoint following normal codepoint.\n        glyphs.push(this.glyphForCodePoint(last));\n      }\n\n      last = code;\n      state = nextState;\n    }\n\n    return glyphs;\n  }\n\n  @cache\n  get _layoutEngine() {\n    return new LayoutEngine(this);\n  }\n\n  /**\n   * Returns a GlyphRun object, which includes an array of Glyphs and GlyphPositions for the given string.\n   *\n   * @param {string} string\n   * @param {string[]} [userFeatures]\n   * @param {string} [script]\n   * @param {string} [language]\n   * @param {string} [direction]\n   * @return {GlyphRun}\n   */\n  layout(string, userFeatures, script, language, direction) {\n    return this._layoutEngine.layout(string, userFeatures, script, language, direction);\n  }\n\n  /**\n   * Returns an array of strings that map to the given glyph id.\n   * @param {number} gid - glyph id\n   */\n  stringsForGlyph(gid) {\n    return this._layoutEngine.stringsForGlyph(gid);\n  }\n\n  /**\n   * An array of all [OpenType feature tags](https://www.microsoft.com/typography/otspec/featuretags.htm)\n   * (or mapped AAT tags) supported by the font.\n   * The features parameter is an array of OpenType feature tags to be applied in addition to the default set.\n   * If this is an AAT font, the OpenType feature tags are mapped to AAT features.\n   *\n   * @type {string[]}\n   */\n  get availableFeatures() {\n    return this._layoutEngine.getAvailableFeatures();\n  }\n\n  getAvailableFeatures(script, language) {\n    return this._layoutEngine.getAvailableFeatures(script, language);\n  }\n\n  _getBaseGlyph(glyph, characters = []) {\n    if (!this._glyphs[glyph]) {\n      if (this.directory.tables.glyf) {\n        this._glyphs[glyph] = new TTFGlyph(glyph, characters, this);\n\n      } else if (this.directory.tables['CFF '] || this.directory.tables.CFF2) {\n        this._glyphs[glyph] = new CFFGlyph(glyph, characters, this);\n      }\n    }\n\n    return this._glyphs[glyph] || null;\n  }\n\n  /**\n   * Returns a glyph object for the given glyph id.\n   * You can pass the array of code points this glyph represents for\n   * your use later, and it will be stored in the glyph object.\n   *\n   * @param {number} glyph\n   * @param {number[]} characters\n   * @return {Glyph}\n   */\n  getGlyph(glyph, characters = []) {\n    if (!this._glyphs[glyph]) {\n      if (this.directory.tables.sbix) {\n        this._glyphs[glyph] = new SBIXGlyph(glyph, characters, this);\n\n      } else if ((this.directory.tables.COLR) && (this.directory.tables.CPAL)) {\n        this._glyphs[glyph] = new COLRGlyph(glyph, characters, this);\n\n      } else {\n        this._getBaseGlyph(glyph, characters);\n      }\n    }\n\n    return this._glyphs[glyph] || null;\n  }\n\n  /**\n   * Returns a Subset for this font.\n   * @return {Subset}\n   */\n  createSubset() {\n    if (this.directory.tables['CFF ']) {\n      return new CFFSubset(this);\n    }\n\n    return new TTFSubset(this);\n  }\n\n  /**\n   * Returns an object describing the available variation axes\n   * that this font supports. Keys are setting tags, and values\n   * contain the axis name, range, and default value.\n   *\n   * @type {object}\n   */\n  @cache\n  get variationAxes() {\n    let res = {};\n    if (!this.fvar) {\n      return res;\n    }\n\n    for (let axis of this.fvar.axis) {\n      res[axis.axisTag.trim()] = {\n        name: axis.name.en,\n        min: axis.minValue,\n        default: axis.defaultValue,\n        max: axis.maxValue\n      };\n    }\n\n    return res;\n  }\n\n  /**\n   * Returns an object describing the named variation instances\n   * that the font designer has specified. Keys are variation names\n   * and values are the variation settings for this instance.\n   *\n   * @type {object}\n   */\n  @cache\n  get namedVariations() {\n    let res = {};\n    if (!this.fvar) {\n      return res;\n    }\n\n    for (let instance of this.fvar.instance) {\n      let settings = {};\n      for (let i = 0; i < this.fvar.axis.length; i++) {\n        let axis = this.fvar.axis[i];\n        settings[axis.axisTag.trim()] = instance.coord[i];\n      }\n\n      res[instance.name.en] = settings;\n    }\n\n    return res;\n  }\n\n  /**\n   * Returns a new font with the given variation settings applied.\n   * Settings can either be an instance name, or an object containing\n   * variation tags as specified by the `variationAxes` property.\n   *\n   * @param {object} settings\n   * @return {TTFFont}\n   */\n  getVariation(settings) {\n    if (!(this.directory.tables.fvar && ((this.directory.tables.gvar && this.directory.tables.glyf) || this.directory.tables.CFF2))) {\n      throw new Error('Variations require a font with the fvar, gvar and glyf, or CFF2 tables.');\n    }\n\n    if (typeof settings === 'string') {\n      settings = this.namedVariations[settings];\n    }\n\n    if (typeof settings !== 'object') {\n      throw new Error('Variation settings must be either a variation name or settings object.');\n    }\n\n    // normalize the coordinates\n    let coords = this.fvar.axis.map((axis, i) => {\n      let axisTag = axis.axisTag.trim();\n      if (axisTag in settings) {\n        return Math.max(axis.minValue, Math.min(axis.maxValue, settings[axisTag]));\n      } else {\n        return axis.defaultValue;\n      }\n    });\n\n    let stream = new r.DecodeStream(this.stream.buffer);\n    stream.pos = this._directoryPos;\n\n    let font = new TTFFont(stream, coords);\n    font._tables = this._tables;\n\n    return font;\n  }\n\n  @cache\n  get _variationProcessor() {\n    if (!this.fvar) {\n      return null;\n    }\n\n    let variationCoords = this.variationCoords;\n\n    // Ignore if no variation coords and not CFF2\n    if (!variationCoords && !this.CFF2) {\n      return null;\n    }\n\n    if (!variationCoords) {\n      variationCoords = this.fvar.axis.map(axis => axis.defaultValue);\n    }\n\n    return new GlyphVariationProcessor(this, variationCoords);\n  }\n\n  // Standardized format plugin API\n  getFont(name) {\n    return this.getVariation(name);\n  }\n}\n","/**\n * This decorator caches the results of a getter or method such that\n * the results are lazily computed once, and then cached.\n * @private\n */\nexport function cache(target, key, descriptor) {\n  if (descriptor.get) {\n    let get = descriptor.get;\n    descriptor.get = function() {\n      let value = get.call(this);\n      Object.defineProperty(this, key, { value });\n      return value;\n    };\n  } else if (typeof descriptor.value === 'function') {\n    let fn = descriptor.value;\n\n    return {\n      get() {\n        let cache = new Map;\n        function memoized(...args) {\n          let key = args.length > 0 ? args[0] : 'value';\n          if (cache.has(key)) {\n            return cache.get(key);\n          }\n\n          let result = fn.apply(this, args);\n          cache.set(key, result);\n          return result;\n        };\n\n        Object.defineProperty(this, key, {value: memoized});\n        return memoized;\n      }\n    };\n  }\n}\n","import * as r from 'restructure';\nimport Tables from './';\n\nlet TableEntry = new r.Struct({\n  tag:        new r.String(4),\n  checkSum:   r.uint32,\n  offset:     new r.Pointer(r.uint32, 'void', { type: 'global' }),\n  length:     r.uint32\n});\n\nlet Directory = new r.Struct({\n  tag:            new r.String(4),\n  numTables:      r.uint16,\n  searchRange:    r.uint16,\n  entrySelector:  r.uint16,\n  rangeShift:     r.uint16,\n  tables:         new r.Array(TableEntry, 'numTables')\n});\n\nDirectory.process = function() {\n  let tables = {};\n  for (let table of this.tables) {\n    tables[table.tag] = table;\n  }\n\n  this.tables = tables;\n};\n\nDirectory.preEncode = function() {\n  if (!Array.isArray(this.tables)) {\n    let tables = [];\n    for (let tag in this.tables) {\n      let table = this.tables[tag];\n      if (table) {\n        tables.push({\n          tag: tag,\n          checkSum: 0,\n          offset: new r.VoidPointer(Tables[tag], table),\n          length: Tables[tag].size(table)\n        });\n      }\n    }\n    \n    this.tables = tables;\n  }\n\n  this.tag = 'true';\n  this.numTables = this.tables.length;\n\n  let maxExponentFor2 = Math.floor((Math.log(this.numTables) / Math.LN2));\n  let maxPowerOf2 = Math.pow(2, maxExponentFor2);\n\n  this.searchRange =  maxPowerOf2 * 16;\n  this.entrySelector = Math.log(maxPowerOf2) / Math.LN2;\n  this.rangeShift = this.numTables * 16 - this.searchRange;\n};\n\nexport default Directory;\n","let tables = {};\nexport default tables;\n\n// Required Tables\nimport cmap from './cmap';\nimport head from './head';\nimport hhea from './hhea';\nimport hmtx from './hmtx';\nimport maxp from './maxp';\nimport name from './name';\nimport OS2 from './OS2';\nimport post from './post';\n\ntables.cmap = cmap;\ntables.head = head;\ntables.hhea = hhea;\ntables.hmtx = hmtx;\ntables.maxp = maxp;\ntables.name = name;\ntables['OS/2'] = OS2;\ntables.post = post;\n\n\n// TrueType Outlines\nimport cvt from './cvt';\nimport fpgm from './fpgm';\nimport loca from './loca';\nimport prep from './prep';\nimport glyf from './glyf';\n\ntables.fpgm = fpgm;\ntables.loca = loca;\ntables.prep = prep;\ntables['cvt '] = cvt;\ntables.glyf = glyf;\n\n\n// PostScript Outlines\nimport CFFFont from '../cff/CFFFont';\nimport VORG from './VORG';\n\ntables['CFF '] = CFFFont;\ntables['CFF2'] = CFFFont;\ntables.VORG = VORG;\n\n\n// Bitmap Glyphs\nimport EBLC from './EBLC';\nimport sbix from './sbix';\nimport COLR from './COLR';\nimport CPAL from './CPAL';\n\ntables.EBLC = EBLC;\ntables.CBLC = tables.EBLC;\ntables.sbix = sbix;\ntables.COLR = COLR;\ntables.CPAL = CPAL;\n\n\n// Advanced OpenType Tables\nimport BASE from './BASE';\nimport GDEF from './GDEF';\nimport GPOS from './GPOS';\nimport GSUB from './GSUB';\nimport JSTF from './JSTF';\n\ntables.BASE = BASE;\ntables.GDEF = GDEF;\ntables.GPOS = GPOS;\ntables.GSUB = GSUB;\ntables.JSTF = JSTF;\n\n// OpenType variations tables\nimport HVAR from './HVAR';\n\ntables.HVAR = HVAR;\n\n// Other OpenType Tables\nimport DSIG from './DSIG';\nimport gasp from './gasp';\nimport hdmx from './hdmx';\nimport kern from './kern';\nimport LTSH from './LTSH';\nimport PCLT from './PCLT';\nimport VDMX from './VDMX';\nimport vhea from './vhea';\nimport vmtx from './vmtx';\n\ntables.DSIG = DSIG;\ntables.gasp = gasp;\ntables.hdmx = hdmx;\ntables.kern = kern;\ntables.LTSH = LTSH;\ntables.PCLT = PCLT;\ntables.VDMX = VDMX;\ntables.vhea = vhea;\ntables.vmtx = vmtx;\n\n\n// Apple Advanced Typography Tables\nimport avar from './avar';\nimport bsln from './bsln';\nimport feat from './feat';\nimport fvar from './fvar';\nimport gvar from './gvar';\nimport just from './just';\nimport morx from './morx';\nimport opbd from './opbd';\n\ntables.avar = avar;\ntables.bsln = bsln;\ntables.feat = feat;\ntables.fvar = fvar;\ntables.gvar = gvar;\ntables.just = just;\ntables.morx = morx;\ntables.opbd = opbd;\n","import * as r from 'restructure';\n\nlet SubHeader = new r.Struct({\n  firstCode:      r.uint16,\n  entryCount:     r.uint16,\n  idDelta:        r.int16,\n  idRangeOffset:  r.uint16\n});\n\nlet CmapGroup = new r.Struct({\n  startCharCode:  r.uint32,\n  endCharCode:    r.uint32,\n  glyphID:        r.uint32\n});\n\nlet UnicodeValueRange = new r.Struct({\n  startUnicodeValue:  r.uint24,\n  additionalCount:    r.uint8\n});\n\nlet UVSMapping = new r.Struct({\n  unicodeValue: r.uint24,\n  glyphID:      r.uint16\n});\n\nlet DefaultUVS = new r.Array(UnicodeValueRange, r.uint32);\nlet NonDefaultUVS = new r.Array(UVSMapping, r.uint32);\n\nlet VarSelectorRecord = new r.Struct({\n  varSelector:    r.uint24,\n  defaultUVS:     new r.Pointer(r.uint32, DefaultUVS, {type: 'parent'}),\n  nonDefaultUVS:  new r.Pointer(r.uint32, NonDefaultUVS, {type: 'parent'})\n});\n\nlet CmapSubtable = new r.VersionedStruct(r.uint16, {\n  0: { // Byte encoding\n    length:     r.uint16,   // Total table length in bytes (set to 262 for format 0)\n    language:   r.uint16,   // Language code for this encoding subtable, or zero if language-independent\n    codeMap:    new r.LazyArray(r.uint8, 256)\n  },\n\n  2: { // High-byte mapping (CJK)\n    length:           r.uint16,\n    language:         r.uint16,\n    subHeaderKeys:    new r.Array(r.uint16, 256),\n    subHeaderCount:   t => Math.max.apply(Math, t.subHeaderKeys),\n    subHeaders:       new r.LazyArray(SubHeader, 'subHeaderCount'),\n    glyphIndexArray:  new r.LazyArray(r.uint16, 'subHeaderCount')\n  },\n\n  4: { // Segment mapping to delta values\n    length:           r.uint16,              // Total table length in bytes\n    language:         r.uint16,              // Language code\n    segCountX2:       r.uint16,\n    segCount:         t => t.segCountX2 >> 1,\n    searchRange:      r.uint16,\n    entrySelector:    r.uint16,\n    rangeShift:       r.uint16,\n    endCode:          new r.LazyArray(r.uint16, 'segCount'),\n    reservedPad:      new r.Reserved(r.uint16),       // This value should be zero\n    startCode:        new r.LazyArray(r.uint16, 'segCount'),\n    idDelta:          new r.LazyArray(r.int16, 'segCount'),\n    idRangeOffset:    new r.LazyArray(r.uint16, 'segCount'),\n    glyphIndexArray:  new r.LazyArray(r.uint16, t => (t.length - t._currentOffset) / 2)\n  },\n\n  6: { // Trimmed table\n    length:         r.uint16,\n    language:       r.uint16,\n    firstCode:      r.uint16,\n    entryCount:     r.uint16,\n    glyphIndices:   new r.LazyArray(r.uint16, 'entryCount')\n  },\n\n  8: { // mixed 16-bit and 32-bit coverage\n    reserved: new r.Reserved(r.uint16),\n    length:   r.uint32,\n    language: r.uint16,\n    is32:     new r.LazyArray(r.uint8, 8192),\n    nGroups:  r.uint32,\n    groups:   new r.LazyArray(CmapGroup, 'nGroups')\n  },\n\n  10: { // Trimmed Array\n    reserved:       new r.Reserved(r.uint16),\n    length:         r.uint32,\n    language:       r.uint32,\n    firstCode:      r.uint32,\n    entryCount:     r.uint32,\n    glyphIndices:   new r.LazyArray(r.uint16, 'numChars')\n  },\n\n  12: { // Segmented coverage\n    reserved: new r.Reserved(r.uint16),\n    length:   r.uint32,\n    language: r.uint32,\n    nGroups:  r.uint32,\n    groups:   new r.LazyArray(CmapGroup, 'nGroups')\n  },\n\n  13: { // Many-to-one range mappings (same as 12 except for group.startGlyphID)\n    reserved: new r.Reserved(r.uint16),\n    length:   r.uint32,\n    language: r.uint32,\n    nGroups:  r.uint32,\n    groups:   new r.LazyArray(CmapGroup, 'nGroups')\n  },\n\n  14: { // Unicode Variation Sequences\n    length:       r.uint32,\n    numRecords:   r.uint32,\n    varSelectors: new r.LazyArray(VarSelectorRecord, 'numRecords')\n  }\n});\n\nlet CmapEntry = new r.Struct({\n  platformID:  r.uint16,  // Platform identifier\n  encodingID:  r.uint16,  // Platform-specific encoding identifier\n  table:       new r.Pointer(r.uint32, CmapSubtable, {type: 'parent', lazy: true})\n});\n\n// character to glyph mapping\nexport default new r.Struct({\n  version:      r.uint16,\n  numSubtables: r.uint16,\n  tables:       new r.Array(CmapEntry, 'numSubtables')\n});\n","import * as r from 'restructure';\n\n// font header\nexport default new r.Struct({\n  version:            r.int32,                   // 0x00010000 (version 1.0)\n  revision:           r.int32,                   // set by font manufacturer\n  checkSumAdjustment: r.uint32,\n  magicNumber:        r.uint32,                  // set to 0x5F0F3CF5\n  flags:              r.uint16,\n  unitsPerEm:         r.uint16,                  // range from 64 to 16384\n  created:            new r.Array(r.int32, 2),\n  modified:           new r.Array(r.int32, 2),\n  xMin:               r.int16,                   // for all glyph bounding boxes\n  yMin:               r.int16,                   // for all glyph bounding boxes\n  xMax:               r.int16,                   // for all glyph bounding boxes\n  yMax:               r.int16,                   // for all glyph bounding boxes\n  macStyle:           new r.Bitfield(r.uint16, [\n    'bold', 'italic', 'underline', 'outline',\n    'shadow', 'condensed', 'extended'\n  ]),\n  lowestRecPPEM:      r.uint16,                  // smallest readable size in pixels\n  fontDirectionHint:  r.int16,\n  indexToLocFormat:   r.int16,                   // 0 for short offsets, 1 for long\n  glyphDataFormat:    r.int16                    // 0 for current format\n});\n","import * as r from 'restructure';\n\n// horizontal header\nexport default new r.Struct({\n  version:              r.int32,\n  ascent:               r.int16,   // Distance from baseline of highest ascender\n  descent:              r.int16,   // Distance from baseline of lowest descender\n  lineGap:              r.int16,   // Typographic line gap\n  advanceWidthMax:      r.uint16,  // Maximum advance width value in 'hmtx' table\n  minLeftSideBearing:   r.int16,   // Maximum advance width value in 'hmtx' table\n  minRightSideBearing:  r.int16,   // Minimum right sidebearing value\n  xMaxExtent:           r.int16,\n  caretSlopeRise:       r.int16,   // Used to calculate the slope of the cursor (rise/run); 1 for vertical\n  caretSlopeRun:        r.int16,   // 0 for vertical\n  caretOffset:          r.int16,   // Set to 0 for non-slanted fonts\n  reserved:             new r.Reserved(r.int16, 4),\n  metricDataFormat:     r.int16,   // 0 for current format\n  numberOfMetrics:      r.uint16   // Number of advance widths in 'hmtx' table\n});\n","import * as r from 'restructure';\n\nlet HmtxEntry = new r.Struct({\n  advance: r.uint16,\n  bearing: r.int16\n});\n\nexport default new r.Struct({\n  metrics:    new r.LazyArray(HmtxEntry, t => t.parent.hhea.numberOfMetrics),\n  bearings:   new r.LazyArray(r.int16, t => t.parent.maxp.numGlyphs - t.parent.hhea.numberOfMetrics)\n});\n","import * as r from 'restructure';\n\n// maxiumum profile\nexport default new r.Struct({\n  version:                r.int32,\n  numGlyphs:              r.uint16,  // The number of glyphs in the font\n  maxPoints:              r.uint16,  // Maximum points in a non-composite glyph\n  maxContours:            r.uint16,  // Maximum contours in a non-composite glyph\n  maxComponentPoints:     r.uint16,  // Maximum points in a composite glyph\n  maxComponentContours:   r.uint16,  // Maximum contours in a composite glyph\n  maxZones:               r.uint16,  // 1 if instructions do not use the twilight zone, 2 otherwise\n  maxTwilightPoints:      r.uint16,  // Maximum points used in Z0\n  maxStorage:             r.uint16,  // Number of Storage Area locations\n  maxFunctionDefs:        r.uint16,  // Number of FDEFs\n  maxInstructionDefs:     r.uint16,  // Number of IDEFs\n  maxStackElements:       r.uint16,  // Maximum stack depth\n  maxSizeOfInstructions:  r.uint16,  // Maximum byte count for glyph instructions\n  maxComponentElements:   r.uint16,  // Maximum number of components referenced at top level for any composite glyph\n  maxComponentDepth:      r.uint16   // Maximum levels of recursion; 1 for simple components\n});\n","import * as r from 'restructure';\nimport {getEncoding, LANGUAGES} from '../encodings';\n\nlet NameRecord = new r.Struct({\n  platformID: r.uint16,\n  encodingID: r.uint16,\n  languageID: r.uint16,\n  nameID:     r.uint16,\n  length:     r.uint16,\n  string:     new r.Pointer(r.uint16,\n    new r.String('length', t => getEncoding(t.platformID, t.encodingID, t.languageID)),\n    { type: 'parent', relativeTo: ctx => ctx.parent.stringOffset, allowNull: false }\n  )\n});\n\nlet LangTagRecord = new r.Struct({\n  length:  r.uint16,\n  tag:     new r.Pointer(r.uint16, new r.String('length', 'utf16be'), {type: 'parent', relativeTo: ctx => ctx.stringOffset})\n});\n\nvar NameTable = new r.VersionedStruct(r.uint16, {\n  0: {\n    count:          r.uint16,\n    stringOffset:   r.uint16,\n    records:        new r.Array(NameRecord, 'count')\n  },\n  1: {\n    count:          r.uint16,\n    stringOffset:   r.uint16,\n    records:        new r.Array(NameRecord, 'count'),\n    langTagCount:   r.uint16,\n    langTags:       new r.Array(LangTagRecord, 'langTagCount')\n  }\n});\n\nexport default NameTable;\n\nconst NAMES = [\n  'copyright',\n  'fontFamily',\n  'fontSubfamily',\n  'uniqueSubfamily',\n  'fullName',\n  'version',\n  'postscriptName', // Note: A font may have only one PostScript name and that name must be ASCII.\n  'trademark',\n  'manufacturer',\n  'designer',\n  'description',\n  'vendorURL',\n  'designerURL',\n  'license',\n  'licenseURL',\n  null, // reserved\n  'preferredFamily',\n  'preferredSubfamily',\n  'compatibleFull',\n  'sampleText',\n  'postscriptCIDFontName',\n  'wwsFamilyName',\n  'wwsSubfamilyName'\n];\n\nNameTable.process = function(stream) {\n  var records = {};\n  for (let record of this.records) {\n    // find out what language this is for\n    let language = LANGUAGES[record.platformID][record.languageID];\n\n    if (language == null && this.langTags != null && record.languageID >= 0x8000) {\n      language = this.langTags[record.languageID - 0x8000].tag;\n    }\n\n    if (language == null) {\n      language = record.platformID + '-' + record.languageID;\n    }\n\n    // if the nameID is >= 256, it is a font feature record (AAT)\n    let key = record.nameID >= 256 ? 'fontFeatures' : (NAMES[record.nameID] || record.nameID);\n    if (records[key] == null) {\n      records[key] = {};\n    }\n\n    let obj = records[key];\n    if (record.nameID >= 256) {\n      obj = obj[record.nameID] || (obj[record.nameID] = {});\n    }\n\n    if (typeof record.string === 'string' || typeof obj[language] !== 'string') {\n      obj[language] = record.string;\n    }\n  }\n\n  this.records = records;\n};\n\nNameTable.preEncode = function() {\n  if (Array.isArray(this.records)) return;\n  this.version = 0;\n\n  let records = [];\n  for (let key in this.records) {\n    let val = this.records[key];\n    if (key === 'fontFeatures') continue;\n\n    records.push({\n      platformID: 3,\n      encodingID: 1,\n      languageID: 0x409,\n      nameID: NAMES.indexOf(key),\n      length: val.en.length * 2,\n      string: val.en\n    });\n\n    if (key === 'postscriptName') {\n      records.push({\n        platformID: 1,\n        encodingID: 0,\n        languageID: 0,\n        nameID: NAMES.indexOf(key),\n        length: val.en.length,\n        string: val.en\n      });\n    }\n  }\n\n  this.records = records;\n  this.count = records.length;\n  this.stringOffset = NameTable.size(this, null, false);\n};\n","/**\n * Gets an encoding name from platform, encoding, and language ids.\n * Returned encoding names can be used in iconv-lite to decode text.\n */\nexport function getEncoding(platformID, encodingID, languageID = 0) {\n  if (platformID === 1 && MAC_LANGUAGE_ENCODINGS[languageID]) {\n    return MAC_LANGUAGE_ENCODINGS[languageID];\n  }\n  \n  return ENCODINGS[platformID][encodingID];\n}\n\nconst SINGLE_BYTE_ENCODINGS = new Set(['x-mac-roman', 'x-mac-cyrillic', 'iso-8859-6', 'iso-8859-8']);\nconst MAC_ENCODINGS = {\n  'x-mac-croatian': ' ',\n  'x-mac-gaelic': ' ',\n  'x-mac-greek': ' \\u00AD',\n  'x-mac-icelandic': ' ',\n  'x-mac-inuit': ' ',\n  'x-mac-ce': ' ',\n  'x-mac-romanian': ' ',\n  'x-mac-turkish': ' '\n};\n\nconst encodingCache = new Map();\n\nexport function getEncodingMapping(encoding) {\n  let cached = encodingCache.get(encoding);\n  if (cached) {\n    return cached;\n  }\n\n  // These encodings aren't supported by TextDecoder.\n  let mapping = MAC_ENCODINGS[encoding];\n  if (mapping) {\n    let res = new Map();\n    for (let i = 0; i < mapping.length; i++) {\n      res.set(mapping.charCodeAt(i), 0x80 + i);\n    }\n\n    encodingCache.set(encoding, res);\n    return res;\n  }\n\n  // Only single byte encodings can be mapped 1:1.\n  if (SINGLE_BYTE_ENCODINGS.has(encoding)) {\n    // TextEncoder only supports utf8, whereas TextDecoder supports legacy encodings.\n    // Use this to create a mapping of code points.\n    let decoder = new TextDecoder(encoding);\n    let mapping = new Uint8Array(0x80);\n    for (let i = 0; i < 0x80; i++) {\n      mapping[i] = 0x80 + i;\n    }\n\n    let res = new Map();\n    let s = decoder.decode(mapping);\n    for (let i = 0; i < 0x80; i++) {\n      res.set(s.charCodeAt(i), 0x80 + i);\n    }\n\n    encodingCache.set(encoding, res);\n    return res;\n  }\n}\n\n// Map of platform ids to encoding ids.\nexport const ENCODINGS = [\n  // unicode\n  ['utf-16be', 'utf-16be', 'utf-16be', 'utf-16be', 'utf-16be', 'utf-16be', 'utf-16be'],\n  \n  // macintosh\n  // Mappings available at http://unicode.org/Public/MAPPINGS/VENDORS/APPLE/\n  // 0\tRoman                 17\tMalayalam\n  // 1\tJapanese\t            18\tSinhalese\n  // 2\tTraditional Chinese\t  19\tBurmese\n  // 3\tKorean\t              20\tKhmer\n  // 4\tArabic\t              21\tThai\n  // 5\tHebrew\t              22\tLaotian\n  // 6\tGreek\t                23\tGeorgian\n  // 7\tRussian\t              24\tArmenian\n  // 8\tRSymbol\t              25\tSimplified Chinese\n  // 9\tDevanagari\t          26\tTibetan\n  // 10\tGurmukhi\t            27\tMongolian\n  // 11\tGujarati\t            28\tGeez\n  // 12\tOriya\t                29\tSlavic\n  // 13\tBengali\t              30\tVietnamese\n  // 14\tTamil\t                31\tSindhi\n  // 15\tTelugu\t              32\t(Uninterpreted)\n  // 16\tKannada\n  ['x-mac-roman', 'shift-jis', 'big5', 'euc-kr', 'iso-8859-6', 'iso-8859-8',\n   'x-mac-greek', 'x-mac-cyrillic', 'x-mac-symbol', 'x-mac-devanagari', 'x-mac-gurmukhi', 'x-mac-gujarati',\n   'Oriya', 'Bengali', 'Tamil', 'Telugu', 'Kannada', 'Malayalam', 'Sinhalese',\n   'Burmese', 'Khmer', 'iso-8859-11', 'Laotian', 'Georgian', 'Armenian', 'gbk', \n   'Tibetan', 'Mongolian', 'Geez', 'x-mac-ce', 'Vietnamese', 'Sindhi'],\n  \n  // ISO (deprecated)\n  ['ascii', null, 'iso-8859-1'],\n  \n  // windows\n  // Docs here: http://msdn.microsoft.com/en-us/library/system.text.encoding(v=vs.110).aspx\n  ['symbol', 'utf-16be', 'shift-jis', 'gb18030', 'big5', 'euc-kr', 'johab', null, null, null, 'utf-16be']\n];\n\n// Overrides for Mac scripts by language id.\n// See http://unicode.org/Public/MAPPINGS/VENDORS/APPLE/Readme.txt\nexport const MAC_LANGUAGE_ENCODINGS = {\n  15: 'x-mac-icelandic',\n  17: 'x-mac-turkish',\n  18: 'x-mac-croatian',\n  24: 'x-mac-ce',\n  25: 'x-mac-ce',\n  26: 'x-mac-ce',\n  27: 'x-mac-ce',\n  28: 'x-mac-ce',\n  30: 'x-mac-icelandic',\n  37: 'x-mac-romanian',\n  38: 'x-mac-ce',\n  39: 'x-mac-ce',\n  40: 'x-mac-ce',\n  143: 'x-mac-inuit',\n  146: 'x-mac-gaelic'\n};\n\n// Map of platform ids to BCP-47 language codes.\nexport const LANGUAGES = [\n  // unicode\n  [],\n  \n  { // macintosh\n    0: 'en',        30: 'fo',       60: 'ks',       90: 'rw',\n    1: 'fr',        31: 'fa',       61: 'ku',       91: 'rn',\n    2: 'de',        32: 'ru',       62: 'sd',       92: 'ny',\n    3: 'it',        33: 'zh',       63: 'bo',       93: 'mg',\n    4: 'nl',        34: 'nl-BE',    64: 'ne',       94: 'eo',\n    5: 'sv',        35: 'ga',       65: 'sa',       128: 'cy',\n    6: 'es',        36: 'sq',       66: 'mr',       129: 'eu',\n    7: 'da',        37: 'ro',       67: 'bn',       130: 'ca',\n    8: 'pt',        38: 'cz',       68: 'as',       131: 'la',\n    9: 'no',        39: 'sk',       69: 'gu',       132: 'qu',\n    10: 'he',       40: 'si',       70: 'pa',       133: 'gn',\n    11: 'ja',       41: 'yi',       71: 'or',       134: 'ay',\n    12: 'ar',       42: 'sr',       72: 'ml',       135: 'tt',\n    13: 'fi',       43: 'mk',       73: 'kn',       136: 'ug',\n    14: 'el',       44: 'bg',       74: 'ta',       137: 'dz',\n    15: 'is',       45: 'uk',       75: 'te',       138: 'jv',\n    16: 'mt',       46: 'be',       76: 'si',       139: 'su',\n    17: 'tr',       47: 'uz',       77: 'my',       140: 'gl',\n    18: 'hr',       48: 'kk',       78: 'km',       141: 'af',\n    19: 'zh-Hant',  49: 'az-Cyrl',  79: 'lo',       142: 'br',\n    20: 'ur',       50: 'az-Arab',  80: 'vi',       143: 'iu',\n    21: 'hi',       51: 'hy',       81: 'id',       144: 'gd',\n    22: 'th',       52: 'ka',       82: 'tl',       145: 'gv',\n    23: 'ko',       53: 'mo',       83: 'ms',       146: 'ga',\n    24: 'lt',       54: 'ky',       84: 'ms-Arab',  147: 'to',\n    25: 'pl',       55: 'tg',       85: 'am',       148: 'el-polyton',\n    26: 'hu',       56: 'tk',       86: 'ti',       149: 'kl',\n    27: 'es',       57: 'mn-CN',    87: 'om',       150: 'az',\n    28: 'lv',       58: 'mn',       88: 'so',       151: 'nn',\n    29: 'se',       59: 'ps',       89: 'sw',\n  },\n  \n  // ISO (deprecated)\n  [],\n  \n  { // windows                                        \n    0x0436: 'af',       0x4009: 'en-IN',    0x0487: 'rw',          0x0432: 'tn',       \n    0x041C: 'sq',       0x1809: 'en-IE',    0x0441: 'sw',          0x045B: 'si',          \n    0x0484: 'gsw',      0x2009: 'en-JM',    0x0457: 'kok',         0x041B: 'sk',          \n    0x045E: 'am',       0x4409: 'en-MY',    0x0412: 'ko',          0x0424: 'sl',          \n    0x1401: 'ar-DZ',    0x1409: 'en-NZ',    0x0440: 'ky',          0x2C0A: 'es-AR',       \n    0x3C01: 'ar-BH',    0x3409: 'en-PH',    0x0454: 'lo',          0x400A: 'es-BO',       \n    0x0C01: 'ar',       0x4809: 'en-SG',    0x0426: 'lv',          0x340A: 'es-CL',       \n    0x0801: 'ar-IQ',    0x1C09: 'en-ZA',    0x0427: 'lt',          0x240A: 'es-CO',       \n    0x2C01: 'ar-JO',    0x2C09: 'en-TT',    0x082E: 'dsb',         0x140A: 'es-CR',       \n    0x3401: 'ar-KW',    0x0809: 'en-GB',    0x046E: 'lb',          0x1C0A: 'es-DO',       \n    0x3001: 'ar-LB',    0x0409: 'en',       0x042F: 'mk',          0x300A: 'es-EC',       \n    0x1001: 'ar-LY',    0x3009: 'en-ZW',    0x083E: 'ms-BN',       0x440A: 'es-SV',       \n    0x1801: 'ary',      0x0425: 'et',       0x043E: 'ms',          0x100A: 'es-GT',       \n    0x2001: 'ar-OM',    0x0438: 'fo',       0x044C: 'ml',          0x480A: 'es-HN',       \n    0x4001: 'ar-QA',    0x0464: 'fil',      0x043A: 'mt',          0x080A: 'es-MX',       \n    0x0401: 'ar-SA',    0x040B: 'fi',       0x0481: 'mi',          0x4C0A: 'es-NI',       \n    0x2801: 'ar-SY',    0x080C: 'fr-BE',    0x047A: 'arn',         0x180A: 'es-PA',       \n    0x1C01: 'aeb',      0x0C0C: 'fr-CA',    0x044E: 'mr',          0x3C0A: 'es-PY',       \n    0x3801: 'ar-AE',    0x040C: 'fr',       0x047C: 'moh',         0x280A: 'es-PE',       \n    0x2401: 'ar-YE',    0x140C: 'fr-LU',    0x0450: 'mn',          0x500A: 'es-PR',       \n    0x042B: 'hy',       0x180C: 'fr-MC',    0x0850: 'mn-CN',       0x0C0A: 'es',          \n    0x044D: 'as',       0x100C: 'fr-CH',    0x0461: 'ne',          0x040A: 'es',          \n    0x082C: 'az-Cyrl',  0x0462: 'fy',       0x0414: 'nb',          0x540A: 'es-US',       \n    0x042C: 'az',       0x0456: 'gl',       0x0814: 'nn',          0x380A: 'es-UY',     \n    0x046D: 'ba',       0x0437: 'ka',       0x0482: 'oc',          0x200A: 'es-VE',       \n    0x042D: 'eu',       0x0C07: 'de-AT',    0x0448: 'or',          0x081D: 'sv-FI',       \n    0x0423: 'be',       0x0407: 'de',       0x0463: 'ps',          0x041D: 'sv',          \n    0x0845: 'bn',       0x1407: 'de-LI',    0x0415: 'pl',          0x045A: 'syr',         \n    0x0445: 'bn-IN',    0x1007: 'de-LU',    0x0416: 'pt',          0x0428: 'tg',          \n    0x201A: 'bs-Cyrl',  0x0807: 'de-CH',    0x0816: 'pt-PT',       0x085F: 'tzm',         \n    0x141A: 'bs',       0x0408: 'el',       0x0446: 'pa',          0x0449: 'ta',          \n    0x047E: 'br',       0x046F: 'kl',       0x046B: 'qu-BO',       0x0444: 'tt',          \n    0x0402: 'bg',       0x0447: 'gu',       0x086B: 'qu-EC',       0x044A: 'te',          \n    0x0403: 'ca',       0x0468: 'ha',       0x0C6B: 'qu',          0x041E: 'th',          \n    0x0C04: 'zh-HK',    0x040D: 'he',       0x0418: 'ro',          0x0451: 'bo',          \n    0x1404: 'zh-MO',    0x0439: 'hi',       0x0417: 'rm',          0x041F: 'tr',          \n    0x0804: 'zh',       0x040E: 'hu',       0x0419: 'ru',          0x0442: 'tk',          \n    0x1004: 'zh-SG',    0x040F: 'is',       0x243B: 'smn',         0x0480: 'ug',          \n    0x0404: 'zh-TW',    0x0470: 'ig',       0x103B: 'smj-NO',      0x0422: 'uk',          \n    0x0483: 'co',       0x0421: 'id',       0x143B: 'smj',         0x042E: 'hsb',         \n    0x041A: 'hr',       0x045D: 'iu',       0x0C3B: 'se-FI',       0x0420: 'ur',          \n    0x101A: 'hr-BA',    0x085D: 'iu-Latn',  0x043B: 'se',          0x0843: 'uz-Cyrl',     \n    0x0405: 'cs',       0x083C: 'ga',       0x083B: 'se-SE',       0x0443: 'uz',          \n    0x0406: 'da',       0x0434: 'xh',       0x203B: 'sms',         0x042A: 'vi',          \n    0x048C: 'prs',      0x0435: 'zu',       0x183B: 'sma-NO',      0x0452: 'cy',          \n    0x0465: 'dv',       0x0410: 'it',       0x1C3B: 'sms',         0x0488: 'wo',          \n    0x0813: 'nl-BE',    0x0810: 'it-CH',    0x044F: 'sa',          0x0485: 'sah',         \n    0x0413: 'nl',       0x0411: 'ja',       0x1C1A: 'sr-Cyrl-BA',  0x0478: 'ii',          \n    0x0C09: 'en-AU',    0x044B: 'kn',       0x0C1A: 'sr',          0x046A: 'yo',           \n    0x2809: 'en-BZ',    0x043F: 'kk',       0x181A: 'sr-Latn-BA',  \n    0x1009: 'en-CA',    0x0453: 'km',       0x081A: 'sr-Latn',     \n    0x2409: 'en-029',   0x0486: 'quc',      0x046C: 'nso',         \n  }\n];\n","import * as r from 'restructure';\n\nvar OS2 = new r.VersionedStruct(r.uint16, {\n  header: {\n    xAvgCharWidth:          r.int16,   // average weighted advance width of lower case letters and space\n    usWeightClass:          r.uint16,  // visual weight of stroke in glyphs\n    usWidthClass:           r.uint16,  // relative change from the normal aspect ratio (width to height ratio)\n    fsType:                 new r.Bitfield(r.uint16, [ // Indicates font embedding licensing rights\n      null, 'noEmbedding', 'viewOnly', 'editable', null,\n      null, null, null, 'noSubsetting', 'bitmapOnly'\n    ]),\n    ySubscriptXSize:        r.int16,   // recommended horizontal size in pixels for subscripts\n    ySubscriptYSize:        r.int16,   // recommended vertical size in pixels for subscripts\n    ySubscriptXOffset:      r.int16,   // recommended horizontal offset for subscripts\n    ySubscriptYOffset:      r.int16,   // recommended vertical offset form the baseline for subscripts\n    ySuperscriptXSize:      r.int16,   // recommended horizontal size in pixels for superscripts\n    ySuperscriptYSize:      r.int16,   // recommended vertical size in pixels for superscripts\n    ySuperscriptXOffset:    r.int16,   // recommended horizontal offset for superscripts\n    ySuperscriptYOffset:    r.int16,   // recommended vertical offset from the baseline for superscripts\n    yStrikeoutSize:         r.int16,   // width of the strikeout stroke\n    yStrikeoutPosition:     r.int16,   // position of the strikeout stroke relative to the baseline\n    sFamilyClass:           r.int16,   // classification of font-family design\n    panose:                 new r.Array(r.uint8, 10),   // describe the visual characteristics of a given typeface\n    ulCharRange:            new r.Array(r.uint32, 4),\n    vendorID:               new r.String(4),          // four character identifier for the font vendor\n    fsSelection:            new r.Bitfield(r.uint16, [  // bit field containing information about the font\n      'italic', 'underscore', 'negative', 'outlined', 'strikeout',\n      'bold', 'regular', 'useTypoMetrics', 'wws', 'oblique'\n    ]),\n    usFirstCharIndex:       r.uint16,  // The minimum Unicode index in this font\n    usLastCharIndex:        r.uint16   // The maximum Unicode index in this font\n  },\n\n  // The Apple version of this table ends here, but the Microsoft one continues on...\n  0: {},\n\n  1: {\n    typoAscender:       r.int16,\n    typoDescender:      r.int16,\n    typoLineGap:        r.int16,\n    winAscent:          r.uint16,\n    winDescent:         r.uint16,\n    codePageRange:      new r.Array(r.uint32, 2)\n  },\n\n  2: {\n    // these should be common with version 1 somehow\n    typoAscender:       r.int16,\n    typoDescender:      r.int16,\n    typoLineGap:        r.int16,\n    winAscent:          r.uint16,\n    winDescent:         r.uint16,\n    codePageRange:      new r.Array(r.uint32, 2),\n\n    xHeight:            r.int16,\n    capHeight:          r.int16,\n    defaultChar:        r.uint16,\n    breakChar:          r.uint16,\n    maxContent:         r.uint16\n  },\n\n  5: {\n    typoAscender:       r.int16,\n    typoDescender:      r.int16,\n    typoLineGap:        r.int16,\n    winAscent:          r.uint16,\n    winDescent:         r.uint16,\n    codePageRange:      new r.Array(r.uint32, 2),\n\n    xHeight:            r.int16,\n    capHeight:          r.int16,\n    defaultChar:        r.uint16,\n    breakChar:          r.uint16,\n    maxContent:         r.uint16,\n\n    usLowerOpticalPointSize: r.uint16,\n    usUpperOpticalPointSize: r.uint16\n  }\n});\n\nlet versions = OS2.versions;\nversions[3] = versions[4] = versions[2];\n\nexport default OS2;\n","import * as r from 'restructure';\n\n// PostScript information\nexport default new r.VersionedStruct(r.fixed32, {\n  header: { // these fields exist at the top of all versions\n    italicAngle:        r.fixed32, // Italic angle in counter-clockwise degrees from the vertical.\n    underlinePosition:  r.int16,   // Suggested distance of the top of the underline from the baseline\n    underlineThickness: r.int16,   // Suggested values for the underline thickness\n    isFixedPitch:       r.uint32,  // Whether the font is monospaced\n    minMemType42:       r.uint32,  // Minimum memory usage when a TrueType font is downloaded as a Type 42 font\n    maxMemType42:       r.uint32,  // Maximum memory usage when a TrueType font is downloaded as a Type 42 font\n    minMemType1:        r.uint32,  // Minimum memory usage when a TrueType font is downloaded as a Type 1 font\n    maxMemType1:        r.uint32   // Maximum memory usage when a TrueType font is downloaded as a Type 1 font\n  },\n\n  1: {}, // version 1 has no additional fields\n\n  2: {\n    numberOfGlyphs: r.uint16,\n    glyphNameIndex: new r.Array(r.uint16, 'numberOfGlyphs'),\n    names:          new r.Array(new r.String(r.uint8))\n  },\n\n  2.5: {\n    numberOfGlyphs: r.uint16,\n    offsets:        new r.Array(r.uint8, 'numberOfGlyphs')\n  },\n\n  3: {}, // version 3 has no additional fields\n\n  4: {\n    map: new r.Array(r.uint32, t => t.parent.maxp.numGlyphs)\n  }\n});\n","import * as r from 'restructure';\n\n// An array of predefined values accessible by instructions\nexport default new r.Struct({\n  controlValues: new r.Array(r.int16)\n});\n","import * as r from 'restructure';\n\n// A list of instructions that are executed once when a font is first used.\n// These instructions are known as the font program. The main use of this table\n// is for the definition of functions that are used in many different glyph programs.\nexport default new r.Struct({\n  instructions: new r.Array(r.uint8)\n});\n","import * as r from 'restructure';\n\nlet loca = new r.VersionedStruct('head.indexToLocFormat', {\n  0: {\n    offsets: new r.Array(r.uint16)\n  },\n  1: {\n    offsets: new r.Array(r.uint32)\n  }\n});\n\nloca.process = function() {\n  if (this.version === 0 && !this._processed) {\n    for (let i = 0; i < this.offsets.length; i++) {\n      this.offsets[i] <<= 1;\n    }\n    this._processed = true;\n  }\n};\n\nloca.preEncode = function() {\n  if (this.version === 0 && this._processed !== false) {\n    for (let i = 0; i < this.offsets.length; i++) {\n      this.offsets[i] >>>= 1;\n    }\n    this._processed = false;\n  }\n};\n\nexport default loca;\n","import * as r from 'restructure';\n\n// Set of instructions executed whenever the point size or font transformation change\nexport default new r.Struct({\n  controlValueProgram: new r.Array(r.uint8)\n});\n","import * as r from 'restructure';\n\n// only used for encoding\nexport default new r.Array(new r.Buffer);\n","import * as r from 'restructure';\nimport CFFIndex from './CFFIndex';\nimport CFFTop from './CFFTop';\nimport CFFPrivateDict from './CFFPrivateDict';\nimport standardStrings from './CFFStandardStrings';\n\nclass CFFFont {\n  constructor(stream) {\n    this.stream = stream;\n    this.decode();\n  }\n\n  static decode(stream) {\n    return new CFFFont(stream);\n  }\n\n  decode() {\n    let start = this.stream.pos;\n    let top = CFFTop.decode(this.stream);\n    for (let key in top) {\n      let val = top[key];\n      this[key] = val;\n    }\n\n    if (this.version < 2) {\n      if (this.topDictIndex.length !== 1) {\n        throw new Error(\"Only a single font is allowed in CFF\");\n      }\n\n      this.topDict = this.topDictIndex[0];\n    }\n\n    this.isCIDFont = this.topDict.ROS != null;\n    return this;\n  }\n\n  string(sid) {\n    if (this.version >= 2) {\n      return null;\n    }\n\n    if (sid < standardStrings.length) {\n      return standardStrings[sid];\n    }\n\n    return this.stringIndex[sid - standardStrings.length];\n  }\n\n  get postscriptName() {\n    if (this.version < 2) {\n      return this.nameIndex[0];\n    }\n\n    return null;\n  }\n\n  get fullName() {\n    return this.string(this.topDict.FullName);\n  }\n\n  get familyName() {\n    return this.string(this.topDict.FamilyName);\n  }\n\n  getCharString(glyph) {\n    this.stream.pos = this.topDict.CharStrings[glyph].offset;\n    return this.stream.readBuffer(this.topDict.CharStrings[glyph].length);\n  }\n\n  getGlyphName(gid) {\n    // CFF2 glyph names are in the post table.\n    if (this.version >= 2) {\n      return null;\n    }\n\n    // CID-keyed fonts don't have glyph names\n    if (this.isCIDFont) {\n      return null;\n    }\n\n    let { charset } = this.topDict;\n    if (Array.isArray(charset)) {\n      return charset[gid];\n    }\n\n    if (gid === 0) {\n      return '.notdef';\n    }\n\n    gid -= 1;\n\n    switch (charset.version) {\n      case 0:\n        return this.string(charset.glyphs[gid]);\n\n      case 1:\n      case 2:\n        for (let i = 0; i < charset.ranges.length; i++) {\n          let range = charset.ranges[i];\n          if (range.offset <= gid && gid <= range.offset + range.nLeft) {\n            return this.string(range.first + (gid - range.offset));\n          }\n        }\n        break;\n    }\n\n    return null;\n  }\n\n  fdForGlyph(gid) {\n    if (!this.topDict.FDSelect) {\n      return null;\n    }\n\n    switch (this.topDict.FDSelect.version) {\n      case 0:\n        return this.topDict.FDSelect.fds[gid];\n\n      case 3:\n      case 4:\n        let { ranges } = this.topDict.FDSelect;\n        let low = 0;\n        let high = ranges.length - 1;\n\n        while (low <= high) {\n          let mid = (low + high) >> 1;\n\n          if (gid < ranges[mid].first) {\n            high = mid - 1;\n          } else if (mid < high && gid >= ranges[mid + 1].first) {\n            low = mid + 1;\n          } else {\n            return ranges[mid].fd;\n          }\n        }\n      default:\n        throw new Error(`Unknown FDSelect version: ${this.topDict.FDSelect.version}`);\n    }\n  }\n\n  privateDictForGlyph(gid) {\n    if (this.topDict.FDSelect) {\n      let fd = this.fdForGlyph(gid);\n      if (this.topDict.FDArray[fd]) {\n        return this.topDict.FDArray[fd].Private;\n      }\n\n      return null;\n    }\n\n    if (this.version < 2) {\n      return this.topDict.Private;\n    }\n\n    return this.topDict.FDArray[0].Private;\n  }\n}\n\nexport default CFFFont;\n","import * as r from 'restructure';\n\nexport default class CFFIndex {\n  constructor(type) {\n    this.type = type;\n  }\n\n  getCFFVersion(ctx) {\n    while (ctx && !ctx.hdrSize) {\n      ctx = ctx.parent;\n    }\n\n    return ctx ? ctx.version : -1;\n  }\n\n  decode(stream, parent) {\n    let version = this.getCFFVersion(parent);\n    let count = version >= 2\n      ? stream.readUInt32BE()\n      : stream.readUInt16BE();\n\n    if (count === 0) {\n      return [];\n    }\n\n    let offSize = stream.readUInt8();\n    let offsetType;\n    if (offSize === 1) {\n      offsetType = r.uint8;\n    } else if (offSize === 2) {\n      offsetType = r.uint16;\n    } else if (offSize === 3) {\n      offsetType = r.uint24;\n    } else if (offSize === 4) {\n      offsetType = r.uint32;\n    } else {\n      throw new Error(`Bad offset size in CFFIndex: ${offSize} ${stream.pos}`);\n    }\n\n    let ret = [];\n    let startPos = stream.pos + ((count + 1) * offSize) - 1;\n\n    let start = offsetType.decode(stream);\n    for (let i = 0; i < count; i++) {\n      let end = offsetType.decode(stream);\n\n      if (this.type != null) {\n        let pos = stream.pos;\n        stream.pos = startPos + start;\n\n        parent.length = end - start;\n        ret.push(this.type.decode(stream, parent));\n        stream.pos = pos;\n      } else {\n        ret.push({\n          offset: startPos + start,\n          length: end - start\n        });\n      }\n\n      start = end;\n    }\n\n    stream.pos = startPos + start;\n    return ret;\n  }\n\n  size(arr, parent) {\n    let size = 2;\n    if (arr.length === 0) {\n      return size;\n    }\n\n    let type = this.type || new r.Buffer;\n\n    // find maximum offset to detminine offset type\n    let offset = 1;\n    for (let i = 0; i < arr.length; i++) {\n      let item = arr[i];\n      offset += type.size(item, parent);\n    }\n\n    let offsetType;\n    if (offset <= 0xff) {\n      offsetType = r.uint8;\n    } else if (offset <= 0xffff) {\n      offsetType = r.uint16;\n    } else if (offset <= 0xffffff) {\n      offsetType = r.uint24;\n    } else if (offset <= 0xffffffff) {\n      offsetType = r.uint32;\n    } else {\n      throw new Error(\"Bad offset in CFFIndex\");\n    }\n\n    size += 1 + offsetType.size() * (arr.length + 1);\n    size += offset - 1;\n\n    return size;\n  }\n\n  encode(stream, arr, parent) {\n    stream.writeUInt16BE(arr.length);\n    if (arr.length === 0) {\n      return;\n    }\n\n    let type = this.type || new r.Buffer;\n\n    // find maximum offset to detminine offset type\n    let sizes = [];\n    let offset = 1;\n    for (let item of arr) {\n      let s = type.size(item, parent);\n      sizes.push(s);\n      offset += s;\n    }\n\n    let offsetType;\n    if (offset <= 0xff) {\n      offsetType = r.uint8;\n    } else if (offset <= 0xffff) {\n      offsetType = r.uint16;\n    } else if (offset <= 0xffffff) {\n      offsetType = r.uint24;\n    } else if (offset <= 0xffffffff) {\n      offsetType = r.uint32;\n    } else {\n      throw new Error(\"Bad offset in CFFIndex\");\n    }\n\n    // write offset size\n    stream.writeUInt8(offsetType.size());\n\n    // write elements\n    offset = 1;\n    offsetType.encode(stream, offset);\n\n    for (let size of sizes) {\n      offset += size;\n      offsetType.encode(stream, offset);\n    }\n\n    for (let item of arr) {\n      type.encode(stream, item, parent);\n    }\n\n    return;\n  }\n}\n","import * as r from 'restructure';\nimport { resolveLength } from 'restructure';\nimport CFFDict from './CFFDict';\nimport CFFIndex from './CFFIndex';\nimport CFFPointer from './CFFPointer';\nimport CFFPrivateDict from './CFFPrivateDict';\nimport StandardStrings from './CFFStandardStrings';\nimport { StandardEncoding, ExpertEncoding } from './CFFEncodings';\nimport { ISOAdobeCharset, ExpertCharset, ExpertSubsetCharset } from './CFFCharsets';\nimport { ItemVariationStore } from '../tables/variations';\n\n// Checks if an operand is an index of a predefined value,\n// otherwise delegates to the provided type.\nclass PredefinedOp {\n  constructor(predefinedOps, type) {\n    this.predefinedOps = predefinedOps;\n    this.type = type;\n  }\n\n  decode(stream, parent, operands) {\n    if (this.predefinedOps[operands[0]]) {\n      return this.predefinedOps[operands[0]];\n    }\n\n    return this.type.decode(stream, parent, operands);\n  }\n\n  size(value, ctx) {\n    return this.type.size(value, ctx);\n  }\n\n  encode(stream, value, ctx) {\n    let index = this.predefinedOps.indexOf(value);\n    if (index !== -1) {\n      return index;\n    }\n\n    return this.type.encode(stream, value, ctx);\n  }\n}\n\nclass CFFEncodingVersion extends r.Number {\n  constructor() {\n    super('UInt8');\n  }\n\n  decode(stream) {\n    return r.uint8.decode(stream) & 0x7f;\n  }\n}\n\nlet Range1 = new r.Struct({\n  first: r.uint16,\n  nLeft: r.uint8\n});\n\nlet Range2 = new r.Struct({\n  first: r.uint16,\n  nLeft: r.uint16\n});\n\nlet CFFCustomEncoding = new r.VersionedStruct(new CFFEncodingVersion(), {\n  0: {\n    nCodes: r.uint8,\n    codes: new r.Array(r.uint8, 'nCodes')\n  },\n\n  1: {\n    nRanges: r.uint8,\n    ranges: new r.Array(Range1, 'nRanges')\n  }\n\n  // TODO: supplement?\n});\n\nlet CFFEncoding = new PredefinedOp([ StandardEncoding, ExpertEncoding ], new CFFPointer(CFFCustomEncoding, { lazy: true }));\n\n// Decodes an array of ranges until the total\n// length is equal to the provided length.\nclass RangeArray extends r.Array {\n  decode(stream, parent) {\n    let length = resolveLength(this.length, stream, parent);\n    let count = 0;\n    let res = [];\n    while (count < length) {\n      let range = this.type.decode(stream, parent);\n      range.offset = count;\n      count += range.nLeft + 1;\n      res.push(range);\n    }\n\n    return res;\n  }\n}\n\nlet CFFCustomCharset = new r.VersionedStruct(r.uint8, {\n  0: {\n    glyphs: new r.Array(r.uint16, t => t.parent.CharStrings.length - 1)\n  },\n\n  1: {\n    ranges: new RangeArray(Range1, t => t.parent.CharStrings.length - 1)\n  },\n\n  2: {\n    ranges: new RangeArray(Range2, t => t.parent.CharStrings.length - 1)\n  }\n});\n\nlet CFFCharset = new PredefinedOp([ ISOAdobeCharset, ExpertCharset, ExpertSubsetCharset ], new CFFPointer(CFFCustomCharset, {lazy: true}));\n\nlet FDRange3 = new r.Struct({\n  first: r.uint16,\n  fd: r.uint8\n});\n\nlet FDRange4 = new r.Struct({\n  first: r.uint32,\n  fd: r.uint16\n});\n\nlet FDSelect = new r.VersionedStruct(r.uint8, {\n  0: {\n    fds: new r.Array(r.uint8, t => t.parent.CharStrings.length)\n  },\n\n  3: {\n    nRanges: r.uint16,\n    ranges: new r.Array(FDRange3, 'nRanges'),\n    sentinel: r.uint16\n  },\n\n  4: {\n    nRanges: r.uint32,\n    ranges: new r.Array(FDRange4, 'nRanges'),\n    sentinel: r.uint32\n  }\n});\n\nlet ptr = new CFFPointer(CFFPrivateDict);\nclass CFFPrivateOp {\n  decode(stream, parent, operands) {\n    parent.length = operands[0];\n    return ptr.decode(stream, parent, [operands[1]]);\n  }\n\n  size(dict, ctx) {\n    return [CFFPrivateDict.size(dict, ctx, false), ptr.size(dict, ctx)[0]];\n  }\n\n  encode(stream, dict, ctx) {\n    return [CFFPrivateDict.size(dict, ctx, false), ptr.encode(stream, dict, ctx)[0]];\n  }\n}\n\nlet FontDict = new CFFDict([\n  // key       name                   type(s)                                 default\n  [18,        'Private',              new CFFPrivateOp,                       null],\n  [[12, 38],  'FontName',             'sid',                                  null],\n  [[12, 7],   'FontMatrix',           'array',                                [0.001, 0, 0, 0.001, 0, 0]],\n  [[12, 5],   'PaintType',            'number',                               0],\n]);\n\nlet CFFTopDict = new CFFDict([\n  // key       name                   type(s)                                 default\n  [[12, 30],  'ROS',                  ['sid', 'sid', 'number'],               null],\n\n  [0,         'version',              'sid',                                  null],\n  [1,         'Notice',               'sid',                                  null],\n  [[12, 0],   'Copyright',            'sid',                                  null],\n  [2,         'FullName',             'sid',                                  null],\n  [3,         'FamilyName',           'sid',                                  null],\n  [4,         'Weight',               'sid',                                  null],\n  [[12, 1],   'isFixedPitch',         'boolean',                              false],\n  [[12, 2],   'ItalicAngle',          'number',                               0],\n  [[12, 3],   'UnderlinePosition',    'number',                               -100],\n  [[12, 4],   'UnderlineThickness',   'number',                               50],\n  [[12, 5],   'PaintType',            'number',                               0],\n  [[12, 6],   'CharstringType',       'number',                               2],\n  [[12, 7],   'FontMatrix',           'array',                                [0.001, 0, 0, 0.001, 0, 0]],\n  [13,        'UniqueID',             'number',                               null],\n  [5,         'FontBBox',             'array',                                [0, 0, 0, 0]],\n  [[12, 8],   'StrokeWidth',          'number',                               0],\n  [14,        'XUID',                 'array',                                null],\n  [15,        'charset',              CFFCharset,                             ISOAdobeCharset],\n  [16,        'Encoding',             CFFEncoding,                            StandardEncoding],\n  [17,        'CharStrings',          new CFFPointer(new CFFIndex),           null],\n  [18,        'Private',              new CFFPrivateOp,                       null],\n  [[12, 20],  'SyntheticBase',        'number',                               null],\n  [[12, 21],  'PostScript',           'sid',                                  null],\n  [[12, 22],  'BaseFontName',         'sid',                                  null],\n  [[12, 23],  'BaseFontBlend',        'delta',                                null],\n\n  // CID font specific\n  [[12, 31],  'CIDFontVersion',       'number',                               0],\n  [[12, 32],  'CIDFontRevision',      'number',                               0],\n  [[12, 33],  'CIDFontType',          'number',                               0],\n  [[12, 34],  'CIDCount',             'number',                               8720],\n  [[12, 35],  'UIDBase',              'number',                               null],\n  [[12, 37],  'FDSelect',             new CFFPointer(FDSelect),               null],\n  [[12, 36],  'FDArray',              new CFFPointer(new CFFIndex(FontDict)), null],\n  [[12, 38],  'FontName',             'sid',                                  null]\n]);\n\nlet VariationStore = new r.Struct({\n  length: r.uint16,\n  itemVariationStore: ItemVariationStore\n})\n\nlet CFF2TopDict = new CFFDict([\n  [[12, 7],   'FontMatrix',           'array',                                [0.001, 0, 0, 0.001, 0, 0]],\n  [17,        'CharStrings',          new CFFPointer(new CFFIndex),           null],\n  [[12, 37],  'FDSelect',             new CFFPointer(FDSelect),               null],\n  [[12, 36],  'FDArray',              new CFFPointer(new CFFIndex(FontDict)), null],\n  [24,        'vstore',               new CFFPointer(VariationStore),         null],\n  [25,        'maxstack',             'number',                               193]\n]);\n\nlet CFFTop = new r.VersionedStruct(r.fixed16, {\n  1: {\n    hdrSize:            r.uint8,\n    offSize:            r.uint8,\n    nameIndex:          new CFFIndex(new r.String('length')),\n    topDictIndex:       new CFFIndex(CFFTopDict),\n    stringIndex:        new CFFIndex(new r.String('length')),\n    globalSubrIndex:    new CFFIndex\n  },\n\n  2: {\n    hdrSize:            r.uint8,\n    length:             r.uint16,\n    topDict:            CFF2TopDict,\n    globalSubrIndex:    new CFFIndex\n  }\n});\n\nexport default CFFTop;\n","import isEqual from 'fast-deep-equal';\nimport * as r from 'restructure';\nimport CFFOperand from './CFFOperand';\nimport { PropertyDescriptor } from 'restructure';\n\nexport default class CFFDict {\n  constructor(ops = []) {\n    this.ops = ops;\n    this.fields = {};\n    for (let field of ops) {\n      let key = Array.isArray(field[0]) ? field[0][0] << 8 | field[0][1] : field[0];\n      this.fields[key] = field;\n    }\n  }\n\n  decodeOperands(type, stream, ret, operands) {\n    if (Array.isArray(type)) {\n      return operands.map((op, i) => this.decodeOperands(type[i], stream, ret, [op]));\n    } else if (type.decode != null) {\n      return type.decode(stream, ret, operands);\n    } else {\n      switch (type) {\n        case 'number':\n        case 'offset':\n        case 'sid':\n          return operands[0];\n        case 'boolean':\n          return !!operands[0];\n        default:\n          return operands;\n      }\n    }\n  }\n\n  encodeOperands(type, stream, ctx, operands) {\n    if (Array.isArray(type)) {\n      return operands.map((op, i) => this.encodeOperands(type[i], stream, ctx, op)[0]);\n    } else if (type.encode != null) {\n      return type.encode(stream, operands, ctx);\n    } else if (typeof operands === 'number') {\n      return [operands];\n    } else if (typeof operands === 'boolean') {\n      return [+operands];\n    } else if (Array.isArray(operands)) {\n      return operands;\n    } else {\n      return [operands];\n    }\n  }\n\n  decode(stream, parent) {\n    let end = stream.pos + parent.length;\n    let ret = {};\n    let operands = [];\n\n    // define hidden properties\n    Object.defineProperties(ret, {\n      parent:         { value: parent },\n      _startOffset:   { value: stream.pos }\n    });\n\n    // fill in defaults\n    for (let key in this.fields) {\n      let field = this.fields[key];\n      ret[field[1]] = field[3];\n    }\n\n    while (stream.pos < end) {\n      let b = stream.readUInt8();\n      if (b < 28) {\n        if (b === 12) {\n          b = (b << 8) | stream.readUInt8();\n        }\n\n        let field = this.fields[b];\n        if (!field) {\n          throw new Error(`Unknown operator ${b}`);\n        }\n\n        let val = this.decodeOperands(field[2], stream, ret, operands);\n        if (val != null) {\n          if (val instanceof PropertyDescriptor) {\n            Object.defineProperty(ret, field[1], val);\n          } else {\n            ret[field[1]] = val;\n          }\n        }\n\n        operands = [];\n      } else {\n        operands.push(CFFOperand.decode(stream, b));\n      }\n    }\n\n    return ret;\n  }\n\n  size(dict, parent, includePointers = true) {\n    let ctx = {\n      parent,\n      val: dict,\n      pointerSize: 0,\n      startOffset: parent.startOffset || 0\n    };\n\n    let len = 0;\n\n    for (let k in this.fields) {\n      let field = this.fields[k];\n      let val = dict[field[1]];\n      if (val == null || isEqual(val, field[3])) {\n        continue;\n      }\n\n      let operands = this.encodeOperands(field[2], null, ctx, val);\n      for (let op of operands) {\n        len += CFFOperand.size(op);\n      }\n\n      let key = Array.isArray(field[0]) ? field[0] : [field[0]];\n      len += key.length;\n    }\n\n    if (includePointers) {\n      len += ctx.pointerSize;\n    }\n\n    return len;\n  }\n\n  encode(stream, dict, parent) {\n    let ctx = {\n      pointers: [],\n      startOffset: stream.pos,\n      parent,\n      val: dict,\n      pointerSize: 0\n    };\n\n    ctx.pointerOffset = stream.pos + this.size(dict, ctx, false);\n\n    for (let field of this.ops) {\n      let val = dict[field[1]];\n      if (val == null || isEqual(val, field[3])) {\n        continue;\n      }\n\n      let operands = this.encodeOperands(field[2], stream, ctx, val);\n      for (let op of operands) {\n        CFFOperand.encode(stream, op);\n      }\n\n      let key = Array.isArray(field[0]) ? field[0] : [field[0]];\n      for (let op of key) {\n        stream.writeUInt8(op);\n      }\n    }\n\n    let i = 0;\n    while (i < ctx.pointers.length) {\n      let ptr = ctx.pointers[i++];\n      ptr.type.encode(stream, ptr.val, ptr.parent);\n    }\n\n    return;\n  }\n}\n","const FLOAT_EOF = 0xf;\nconst FLOAT_LOOKUP = [\n  '0', '1', '2', '3', '4', '5', '6', '7',\n  '8', '9', '.', 'E', 'E-', null, '-'\n];\n\nconst FLOAT_ENCODE_LOOKUP = {\n  '.': 10,\n  'E': 11,\n  'E-': 12,\n  '-': 14\n};\n\nexport default class CFFOperand {\n  static decode(stream, value) {\n    if (32 <= value && value <= 246) {\n      return value - 139;\n    }\n\n    if (247 <= value && value <= 250) {\n      return (value - 247) * 256 + stream.readUInt8() + 108;\n    }\n\n    if (251 <= value && value <= 254) {\n      return -(value - 251) * 256 - stream.readUInt8() - 108;\n    }\n\n    if (value === 28) {\n      return stream.readInt16BE();\n    }\n\n    if (value === 29) {\n      return stream.readInt32BE();\n    }\n\n    if (value === 30) {\n      let str = '';\n      while (true) {\n        let b = stream.readUInt8();\n\n        let n1 = b >> 4;\n        if (n1 === FLOAT_EOF) { break; }\n        str += FLOAT_LOOKUP[n1];\n\n        let n2 = b & 15;\n        if (n2 === FLOAT_EOF) { break; }\n        str += FLOAT_LOOKUP[n2];\n      }\n\n      return parseFloat(str);\n    }\n\n    return null;\n  }\n\n  static size(value) {\n    // if the value needs to be forced to the largest size (32 bit)\n    // e.g. for unknown pointers, set to 32768\n    if (value.forceLarge) {\n      value = 32768;\n    }\n\n    if ((value | 0) !== value) { // floating point\n      let str = '' + value;\n      return 1 + Math.ceil((str.length + 1) / 2);\n\n    } else if (-107 <= value && value <= 107) {\n      return 1;\n\n    } else if (108 <= value && value <= 1131 || -1131 <= value && value <= -108) {\n      return 2;\n\n    } else if (-32768 <= value && value <= 32767) {\n      return 3;\n\n    } else {\n      return 5;\n    }\n  }\n\n  static encode(stream, value) {\n    // if the value needs to be forced to the largest size (32 bit)\n    // e.g. for unknown pointers, save the old value and set to 32768\n    let val = Number(value);\n\n    if (value.forceLarge) {\n      stream.writeUInt8(29);\n      return stream.writeInt32BE(val);\n\n    } else if ((val | 0) !== val) { // floating point\n      stream.writeUInt8(30);\n\n      let str = '' + val;\n      for (let i = 0; i < str.length; i += 2) {\n        let c1 = str[i];\n        let n1 = FLOAT_ENCODE_LOOKUP[c1] || +c1;\n\n        if (i === str.length - 1) {\n          var n2 = FLOAT_EOF;\n        } else {\n          let c2 = str[i + 1];\n          var n2 = FLOAT_ENCODE_LOOKUP[c2] || +c2;\n        }\n\n        stream.writeUInt8((n1 << 4) | (n2 & 15));\n      }\n\n      if (n2 !== FLOAT_EOF) {\n        return stream.writeUInt8((FLOAT_EOF << 4));\n      }\n\n    } else if (-107 <= val && val <= 107) {\n      return stream.writeUInt8(val + 139);\n\n    } else if (108 <= val && val <= 1131) {\n      val -= 108;\n      stream.writeUInt8((val >> 8) + 247);\n      return stream.writeUInt8(val & 0xff);\n\n    } else if (-1131 <= val && val <= -108) {\n      val = -val - 108;\n      stream.writeUInt8((val >> 8) + 251);\n      return stream.writeUInt8(val & 0xff);\n\n    } else if (-32768 <= val && val <= 32767) {\n      stream.writeUInt8(28);\n      return stream.writeInt16BE(val);\n\n    } else {\n      stream.writeUInt8(29);\n      return stream.writeInt32BE(val);\n    }\n  }\n}\n","import * as r from 'restructure';\n\nexport default class CFFPointer extends r.Pointer {\n  constructor(type, options = {}) {\n    if (options.type == null) {\n      options.type = 'global';\n    }\n\n    super(null, type, options);\n  }\n\n  decode(stream, parent, operands) {\n    this.offsetType = {\n      decode: () => operands[0]\n    };\n\n    return super.decode(stream, parent, operands);\n  }\n\n  encode(stream, value, ctx) {\n    if (!stream) {\n      // compute the size (so ctx.pointerSize is correct)\n      this.offsetType = {\n        size: () => 0\n      };\n\n      this.size(value, ctx);\n      return [new Ptr(0)];\n    }\n\n    let ptr = null;\n    this.offsetType = {\n      encode: (stream, val) => ptr = val\n    };\n\n    super.encode(stream, value, ctx);\n    return [new Ptr(ptr)];\n  }\n}\n\nclass Ptr {\n  constructor(val) {\n    this.val = val;\n    this.forceLarge = true;\n  }\n\n  valueOf() {\n    return this.val;\n  }\n}\n","import CFFDict from './CFFDict';\nimport CFFIndex from './CFFIndex';\nimport CFFPointer from './CFFPointer';\n\nclass CFFBlendOp {\n  static decode(stream, parent, operands) {\n    let numBlends = operands.pop();\n\n    // TODO: actually blend. For now just consume the deltas\n    // since we don't use any of the values anyway.\n    while (operands.length > numBlends) {\n      operands.pop();\n    }\n  }\n}\n\nexport default new CFFDict([\n  // key       name                    type                                          default\n  [6,         'BlueValues',           'delta',                                       null],\n  [7,         'OtherBlues',           'delta',                                       null],\n  [8,         'FamilyBlues',          'delta',                                       null],\n  [9,         'FamilyOtherBlues',     'delta',                                       null],\n  [[12, 9],   'BlueScale',            'number',                                      0.039625],\n  [[12, 10],  'BlueShift',            'number',                                      7],\n  [[12, 11],  'BlueFuzz',             'number',                                      1],\n  [10,        'StdHW',                'number',                                      null],\n  [11,        'StdVW',                'number',                                      null],\n  [[12, 12],  'StemSnapH',            'delta',                                       null],\n  [[12, 13],  'StemSnapV',            'delta',                                       null],\n  [[12, 14],  'ForceBold',            'boolean',                                     false],\n  [[12, 17],  'LanguageGroup',        'number',                                      0],\n  [[12, 18],  'ExpansionFactor',      'number',                                      0.06],\n  [[12, 19],  'initialRandomSeed',    'number',                                      0],\n  [20,        'defaultWidthX',        'number',                                      0],\n  [21,        'nominalWidthX',        'number',                                      0],\n  [22,        'vsindex',              'number',                                      0],\n  [23,        'blend',                CFFBlendOp,                                    null],\n  [19,        'Subrs',                new CFFPointer(new CFFIndex, {type: 'local'}), null]\n]);\n","// Automatically generated from Appendix A of the CFF specification; do\n// not edit. Length should be 391.\nexport default [\n  \".notdef\", \"space\", \"exclam\", \"quotedbl\", \"numbersign\", \"dollar\",\n  \"percent\", \"ampersand\", \"quoteright\", \"parenleft\", \"parenright\",\n  \"asterisk\", \"plus\", \"comma\", \"hyphen\", \"period\", \"slash\", \"zero\", \"one\",\n  \"two\", \"three\", \"four\", \"five\", \"six\", \"seven\", \"eight\", \"nine\", \"colon\",\n  \"semicolon\", \"less\", \"equal\", \"greater\", \"question\", \"at\", \"A\", \"B\", \"C\",\n  \"D\", \"E\", \"F\", \"G\", \"H\", \"I\", \"J\", \"K\", \"L\", \"M\", \"N\", \"O\", \"P\", \"Q\", \"R\",\n  \"S\", \"T\", \"U\", \"V\", \"W\", \"X\", \"Y\", \"Z\", \"bracketleft\", \"backslash\",\n  \"bracketright\", \"asciicircum\", \"underscore\", \"quoteleft\", \"a\", \"b\", \"c\",\n  \"d\", \"e\", \"f\", \"g\", \"h\", \"i\", \"j\", \"k\", \"l\", \"m\", \"n\", \"o\", \"p\", \"q\", \"r\",\n  \"s\", \"t\", \"u\", \"v\", \"w\", \"x\", \"y\", \"z\", \"braceleft\", \"bar\", \"braceright\",\n  \"asciitilde\", \"exclamdown\", \"cent\", \"sterling\", \"fraction\", \"yen\",\n  \"florin\", \"section\", \"currency\", \"quotesingle\", \"quotedblleft\",\n  \"guillemotleft\", \"guilsinglleft\", \"guilsinglright\", \"fi\", \"fl\", \"endash\",\n  \"dagger\", \"daggerdbl\", \"periodcentered\", \"paragraph\", \"bullet\",\n  \"quotesinglbase\", \"quotedblbase\", \"quotedblright\", \"guillemotright\",\n  \"ellipsis\", \"perthousand\", \"questiondown\", \"grave\", \"acute\", \"circumflex\",\n  \"tilde\", \"macron\", \"breve\", \"dotaccent\", \"dieresis\", \"ring\", \"cedilla\",\n  \"hungarumlaut\", \"ogonek\", \"caron\", \"emdash\", \"AE\", \"ordfeminine\", \"Lslash\",\n  \"Oslash\", \"OE\", \"ordmasculine\", \"ae\", \"dotlessi\", \"lslash\", \"oslash\", \"oe\",\n  \"germandbls\", \"onesuperior\", \"logicalnot\", \"mu\", \"trademark\", \"Eth\",\n  \"onehalf\", \"plusminus\", \"Thorn\", \"onequarter\", \"divide\", \"brokenbar\",\n  \"degree\", \"thorn\", \"threequarters\", \"twosuperior\", \"registered\", \"minus\",\n  \"eth\", \"multiply\", \"threesuperior\", \"copyright\", \"Aacute\", \"Acircumflex\",\n  \"Adieresis\", \"Agrave\", \"Aring\", \"Atilde\", \"Ccedilla\", \"Eacute\",\n  \"Ecircumflex\", \"Edieresis\", \"Egrave\", \"Iacute\", \"Icircumflex\", \"Idieresis\",\n  \"Igrave\", \"Ntilde\", \"Oacute\", \"Ocircumflex\", \"Odieresis\", \"Ograve\",\n  \"Otilde\", \"Scaron\", \"Uacute\", \"Ucircumflex\", \"Udieresis\", \"Ugrave\",\n  \"Yacute\", \"Ydieresis\", \"Zcaron\", \"aacute\", \"acircumflex\", \"adieresis\",\n  \"agrave\", \"aring\", \"atilde\", \"ccedilla\", \"eacute\", \"ecircumflex\",\n  \"edieresis\", \"egrave\", \"iacute\", \"icircumflex\", \"idieresis\", \"igrave\",\n  \"ntilde\", \"oacute\", \"ocircumflex\", \"odieresis\", \"ograve\", \"otilde\",\n  \"scaron\", \"uacute\", \"ucircumflex\", \"udieresis\", \"ugrave\", \"yacute\",\n  \"ydieresis\", \"zcaron\", \"exclamsmall\", \"Hungarumlautsmall\",\n  \"dollaroldstyle\", \"dollarsuperior\", \"ampersandsmall\", \"Acutesmall\",\n  \"parenleftsuperior\", \"parenrightsuperior\", \"twodotenleader\",\n  \"onedotenleader\", \"zerooldstyle\", \"oneoldstyle\", \"twooldstyle\",\n  \"threeoldstyle\", \"fouroldstyle\", \"fiveoldstyle\", \"sixoldstyle\",\n  \"sevenoldstyle\", \"eightoldstyle\", \"nineoldstyle\", \"commasuperior\",\n  \"threequartersemdash\", \"periodsuperior\", \"questionsmall\", \"asuperior\",\n  \"bsuperior\", \"centsuperior\", \"dsuperior\", \"esuperior\", \"isuperior\",\n  \"lsuperior\", \"msuperior\", \"nsuperior\", \"osuperior\", \"rsuperior\",\n  \"ssuperior\", \"tsuperior\", \"ff\", \"ffi\", \"ffl\", \"parenleftinferior\",\n  \"parenrightinferior\", \"Circumflexsmall\", \"hyphensuperior\", \"Gravesmall\",\n  \"Asmall\", \"Bsmall\", \"Csmall\", \"Dsmall\", \"Esmall\", \"Fsmall\", \"Gsmall\",\n  \"Hsmall\", \"Ismall\", \"Jsmall\", \"Ksmall\", \"Lsmall\", \"Msmall\", \"Nsmall\",\n  \"Osmall\", \"Psmall\", \"Qsmall\", \"Rsmall\", \"Ssmall\", \"Tsmall\", \"Usmall\",\n  \"Vsmall\", \"Wsmall\", \"Xsmall\", \"Ysmall\", \"Zsmall\", \"colonmonetary\",\n  \"onefitted\", \"rupiah\", \"Tildesmall\", \"exclamdownsmall\", \"centoldstyle\",\n  \"Lslashsmall\", \"Scaronsmall\", \"Zcaronsmall\", \"Dieresissmall\", \"Brevesmall\",\n  \"Caronsmall\", \"Dotaccentsmall\", \"Macronsmall\", \"figuredash\",\n  \"hypheninferior\", \"Ogoneksmall\", \"Ringsmall\", \"Cedillasmall\",\n  \"questiondownsmall\", \"oneeighth\", \"threeeighths\", \"fiveeighths\",\n  \"seveneighths\", \"onethird\", \"twothirds\", \"zerosuperior\", \"foursuperior\",\n  \"fivesuperior\", \"sixsuperior\", \"sevensuperior\", \"eightsuperior\",\n  \"ninesuperior\", \"zeroinferior\", \"oneinferior\", \"twoinferior\",\n  \"threeinferior\", \"fourinferior\", \"fiveinferior\", \"sixinferior\",\n  \"seveninferior\", \"eightinferior\", \"nineinferior\", \"centinferior\",\n  \"dollarinferior\", \"periodinferior\", \"commainferior\", \"Agravesmall\",\n  \"Aacutesmall\", \"Acircumflexsmall\", \"Atildesmall\", \"Adieresissmall\",\n  \"Aringsmall\", \"AEsmall\", \"Ccedillasmall\", \"Egravesmall\", \"Eacutesmall\",\n  \"Ecircumflexsmall\", \"Edieresissmall\", \"Igravesmall\", \"Iacutesmall\",\n  \"Icircumflexsmall\", \"Idieresissmall\", \"Ethsmall\", \"Ntildesmall\",\n  \"Ogravesmall\", \"Oacutesmall\", \"Ocircumflexsmall\", \"Otildesmall\",\n  \"Odieresissmall\", \"OEsmall\", \"Oslashsmall\", \"Ugravesmall\", \"Uacutesmall\",\n  \"Ucircumflexsmall\", \"Udieresissmall\", \"Yacutesmall\", \"Thornsmall\",\n  \"Ydieresissmall\", \"001.000\", \"001.001\", \"001.002\", \"001.003\", \"Black\",\n  \"Bold\", \"Book\", \"Light\", \"Medium\", \"Regular\", \"Roman\", \"Semibold\"\n];\n","export let StandardEncoding = [\n  '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '',\n  '', '', '', '', 'space', 'exclam', 'quotedbl', 'numbersign', 'dollar', 'percent', 'ampersand', 'quoteright',\n  'parenleft', 'parenright', 'asterisk', 'plus', 'comma', 'hyphen', 'period', 'slash', 'zero', 'one', 'two',\n  'three', 'four', 'five', 'six', 'seven', 'eight', 'nine', 'colon', 'semicolon', 'less', 'equal', 'greater',\n  'question', 'at', 'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S',\n  'T', 'U', 'V', 'W', 'X', 'Y', 'Z', 'bracketleft', 'backslash', 'bracketright', 'asciicircum', 'underscore',\n  'quoteleft', 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't',\n  'u', 'v', 'w', 'x', 'y', 'z', 'braceleft', 'bar', 'braceright', 'asciitilde', '', '', '', '', '', '', '', '',\n  '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '',\n  'exclamdown', 'cent', 'sterling', 'fraction', 'yen', 'florin', 'section', 'currency', 'quotesingle',\n  'quotedblleft', 'guillemotleft', 'guilsinglleft', 'guilsinglright', 'fi', 'fl', '', 'endash', 'dagger',\n  'daggerdbl', 'periodcentered', '', 'paragraph', 'bullet', 'quotesinglbase', 'quotedblbase', 'quotedblright',\n  'guillemotright', 'ellipsis', 'perthousand', '', 'questiondown', '', 'grave', 'acute', 'circumflex', 'tilde',\n  'macron', 'breve', 'dotaccent', 'dieresis', '', 'ring', 'cedilla', '', 'hungarumlaut', 'ogonek', 'caron',\n  'emdash', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', 'AE', '', 'ordfeminine', '', '', '',\n  '', 'Lslash', 'Oslash', 'OE', 'ordmasculine', '', '', '', '', '', 'ae', '', '', '', 'dotlessi', '', '',\n  'lslash', 'oslash', 'oe', 'germandbls'\n];\n\nexport let ExpertEncoding = [\n  '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '',\n  '', '', '', '', 'space', 'exclamsmall', 'Hungarumlautsmall', '', 'dollaroldstyle', 'dollarsuperior',\n  'ampersandsmall', 'Acutesmall', 'parenleftsuperior', 'parenrightsuperior', 'twodotenleader', 'onedotenleader',\n  'comma', 'hyphen', 'period', 'fraction', 'zerooldstyle', 'oneoldstyle', 'twooldstyle', 'threeoldstyle',\n  'fouroldstyle', 'fiveoldstyle', 'sixoldstyle', 'sevenoldstyle', 'eightoldstyle', 'nineoldstyle', 'colon',\n  'semicolon', 'commasuperior', 'threequartersemdash', 'periodsuperior', 'questionsmall', '', 'asuperior',\n  'bsuperior', 'centsuperior', 'dsuperior', 'esuperior', '', '', 'isuperior', '', '', 'lsuperior', 'msuperior',\n  'nsuperior', 'osuperior', '', '', 'rsuperior', 'ssuperior', 'tsuperior', '', 'ff', 'fi', 'fl', 'ffi', 'ffl',\n  'parenleftinferior', '', 'parenrightinferior', 'Circumflexsmall', 'hyphensuperior', 'Gravesmall', 'Asmall',\n  'Bsmall', 'Csmall', 'Dsmall', 'Esmall', 'Fsmall', 'Gsmall', 'Hsmall', 'Ismall', 'Jsmall', 'Ksmall', 'Lsmall',\n  'Msmall', 'Nsmall', 'Osmall', 'Psmall', 'Qsmall', 'Rsmall', 'Ssmall', 'Tsmall', 'Usmall', 'Vsmall', 'Wsmall',\n  'Xsmall', 'Ysmall', 'Zsmall', 'colonmonetary', 'onefitted', 'rupiah', 'Tildesmall', '', '', '', '', '', '', '',\n  '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '',\n  'exclamdownsmall', 'centoldstyle', 'Lslashsmall', '', '', 'Scaronsmall', 'Zcaronsmall', 'Dieresissmall',\n  'Brevesmall', 'Caronsmall', '', 'Dotaccentsmall', '', '', 'Macronsmall', '', '', 'figuredash', 'hypheninferior',\n  '', '', 'Ogoneksmall', 'Ringsmall', 'Cedillasmall', '', '', '', 'onequarter', 'onehalf', 'threequarters',\n  'questiondownsmall', 'oneeighth', 'threeeighths', 'fiveeighths', 'seveneighths', 'onethird', 'twothirds', '',\n  '', 'zerosuperior', 'onesuperior', 'twosuperior', 'threesuperior', 'foursuperior', 'fivesuperior',\n  'sixsuperior', 'sevensuperior', 'eightsuperior', 'ninesuperior', 'zeroinferior', 'oneinferior', 'twoinferior',\n  'threeinferior', 'fourinferior', 'fiveinferior', 'sixinferior', 'seveninferior', 'eightinferior',\n  'nineinferior', 'centinferior', 'dollarinferior', 'periodinferior', 'commainferior', 'Agravesmall',\n  'Aacutesmall', 'Acircumflexsmall', 'Atildesmall', 'Adieresissmall', 'Aringsmall', 'AEsmall', 'Ccedillasmall',\n  'Egravesmall', 'Eacutesmall', 'Ecircumflexsmall', 'Edieresissmall', 'Igravesmall', 'Iacutesmall',\n  'Icircumflexsmall', 'Idieresissmall', 'Ethsmall', 'Ntildesmall', 'Ogravesmall', 'Oacutesmall',\n  'Ocircumflexsmall', 'Otildesmall', 'Odieresissmall', 'OEsmall', 'Oslashsmall', 'Ugravesmall', 'Uacutesmall',\n  'Ucircumflexsmall', 'Udieresissmall', 'Yacutesmall', 'Thornsmall', 'Ydieresissmall'\n];\n","export let ISOAdobeCharset = [\n  '.notdef', 'space', 'exclam', 'quotedbl', 'numbersign', 'dollar',\n  'percent', 'ampersand', 'quoteright', 'parenleft', 'parenright',\n  'asterisk', 'plus', 'comma', 'hyphen', 'period', 'slash', 'zero',\n  'one', 'two', 'three', 'four', 'five', 'six', 'seven', 'eight',\n  'nine', 'colon', 'semicolon', 'less', 'equal', 'greater', 'question',\n  'at', 'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M',\n  'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z',\n  'bracketleft', 'backslash', 'bracketright', 'asciicircum', 'underscore',\n  'quoteleft', 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l',\n  'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z',\n  'braceleft', 'bar', 'braceright', 'asciitilde', 'exclamdown', 'cent',\n  'sterling', 'fraction', 'yen', 'florin', 'section', 'currency',\n  'quotesingle', 'quotedblleft', 'guillemotleft', 'guilsinglleft',\n  'guilsinglright', 'fi', 'fl', 'endash', 'dagger', 'daggerdbl',\n  'periodcentered', 'paragraph', 'bullet', 'quotesinglbase',\n  'quotedblbase', 'quotedblright', 'guillemotright', 'ellipsis',\n  'perthousand', 'questiondown', 'grave', 'acute', 'circumflex', 'tilde',\n  'macron', 'breve', 'dotaccent', 'dieresis', 'ring', 'cedilla',\n  'hungarumlaut', 'ogonek', 'caron', 'emdash', 'AE', 'ordfeminine',\n  'Lslash', 'Oslash', 'OE', 'ordmasculine', 'ae', 'dotlessi', 'lslash',\n  'oslash', 'oe', 'germandbls', 'onesuperior', 'logicalnot', 'mu',\n  'trademark', 'Eth', 'onehalf', 'plusminus', 'Thorn', 'onequarter',\n  'divide', 'brokenbar', 'degree', 'thorn', 'threequarters', 'twosuperior',\n  'registered', 'minus', 'eth', 'multiply', 'threesuperior', 'copyright',\n  'Aacute', 'Acircumflex', 'Adieresis', 'Agrave', 'Aring', 'Atilde',\n  'Ccedilla', 'Eacute', 'Ecircumflex', 'Edieresis', 'Egrave', 'Iacute',\n  'Icircumflex', 'Idieresis', 'Igrave', 'Ntilde', 'Oacute', 'Ocircumflex',\n  'Odieresis', 'Ograve', 'Otilde', 'Scaron', 'Uacute', 'Ucircumflex',\n  'Udieresis', 'Ugrave', 'Yacute', 'Ydieresis', 'Zcaron', 'aacute',\n  'acircumflex', 'adieresis', 'agrave', 'aring', 'atilde', 'ccedilla',\n  'eacute', 'ecircumflex', 'edieresis', 'egrave', 'iacute', 'icircumflex',\n  'idieresis', 'igrave', 'ntilde', 'oacute', 'ocircumflex', 'odieresis',\n  'ograve', 'otilde', 'scaron', 'uacute', 'ucircumflex', 'udieresis',\n  'ugrave', 'yacute', 'ydieresis', 'zcaron'\n];\n\nexport let ExpertCharset = [\n  '.notdef', 'space', 'exclamsmall', 'Hungarumlautsmall', 'dollaroldstyle',\n  'dollarsuperior', 'ampersandsmall', 'Acutesmall', 'parenleftsuperior',\n  'parenrightsuperior', 'twodotenleader', 'onedotenleader', 'comma',\n  'hyphen', 'period', 'fraction', 'zerooldstyle', 'oneoldstyle',\n  'twooldstyle', 'threeoldstyle', 'fouroldstyle', 'fiveoldstyle',\n  'sixoldstyle', 'sevenoldstyle', 'eightoldstyle', 'nineoldstyle',\n  'colon', 'semicolon', 'commasuperior', 'threequartersemdash',\n  'periodsuperior', 'questionsmall', 'asuperior', 'bsuperior',\n  'centsuperior', 'dsuperior', 'esuperior', 'isuperior', 'lsuperior',\n  'msuperior', 'nsuperior', 'osuperior', 'rsuperior', 'ssuperior',\n  'tsuperior', 'ff', 'fi', 'fl', 'ffi', 'ffl', 'parenleftinferior',\n  'parenrightinferior', 'Circumflexsmall', 'hyphensuperior', 'Gravesmall',\n  'Asmall', 'Bsmall', 'Csmall', 'Dsmall', 'Esmall', 'Fsmall', 'Gsmall',\n  'Hsmall', 'Ismall', 'Jsmall', 'Ksmall', 'Lsmall', 'Msmall', 'Nsmall',\n  'Osmall', 'Psmall', 'Qsmall', 'Rsmall', 'Ssmall', 'Tsmall', 'Usmall',\n  'Vsmall', 'Wsmall', 'Xsmall', 'Ysmall', 'Zsmall', 'colonmonetary',\n  'onefitted', 'rupiah', 'Tildesmall', 'exclamdownsmall', 'centoldstyle',\n  'Lslashsmall', 'Scaronsmall', 'Zcaronsmall', 'Dieresissmall',\n  'Brevesmall', 'Caronsmall', 'Dotaccentsmall', 'Macronsmall',\n  'figuredash', 'hypheninferior', 'Ogoneksmall', 'Ringsmall',\n  'Cedillasmall', 'onequarter', 'onehalf', 'threequarters',\n  'questiondownsmall', 'oneeighth', 'threeeighths', 'fiveeighths',\n  'seveneighths', 'onethird', 'twothirds', 'zerosuperior', 'onesuperior',\n  'twosuperior', 'threesuperior', 'foursuperior', 'fivesuperior',\n  'sixsuperior', 'sevensuperior', 'eightsuperior', 'ninesuperior',\n  'zeroinferior', 'oneinferior', 'twoinferior', 'threeinferior',\n  'fourinferior', 'fiveinferior', 'sixinferior', 'seveninferior',\n  'eightinferior', 'nineinferior', 'centinferior', 'dollarinferior',\n  'periodinferior', 'commainferior', 'Agravesmall', 'Aacutesmall',\n  'Acircumflexsmall', 'Atildesmall', 'Adieresissmall', 'Aringsmall',\n  'AEsmall', 'Ccedillasmall', 'Egravesmall', 'Eacutesmall',\n  'Ecircumflexsmall', 'Edieresissmall', 'Igravesmall', 'Iacutesmall',\n  'Icircumflexsmall', 'Idieresissmall', 'Ethsmall', 'Ntildesmall',\n  'Ogravesmall', 'Oacutesmall', 'Ocircumflexsmall', 'Otildesmall',\n  'Odieresissmall', 'OEsmall', 'Oslashsmall', 'Ugravesmall', 'Uacutesmall',\n  'Ucircumflexsmall', 'Udieresissmall', 'Yacutesmall', 'Thornsmall',\n  'Ydieresissmall'\n];\n\nexport let ExpertSubsetCharset = [\n  '.notdef', 'space', 'dollaroldstyle', 'dollarsuperior',\n  'parenleftsuperior', 'parenrightsuperior', 'twodotenleader',\n  'onedotenleader', 'comma', 'hyphen', 'period', 'fraction',\n  'zerooldstyle', 'oneoldstyle', 'twooldstyle', 'threeoldstyle',\n  'fouroldstyle', 'fiveoldstyle', 'sixoldstyle', 'sevenoldstyle',\n  'eightoldstyle', 'nineoldstyle', 'colon', 'semicolon', 'commasuperior',\n  'threequartersemdash', 'periodsuperior', 'asuperior', 'bsuperior',\n  'centsuperior', 'dsuperior', 'esuperior', 'isuperior', 'lsuperior',\n  'msuperior', 'nsuperior', 'osuperior', 'rsuperior', 'ssuperior',\n  'tsuperior', 'ff', 'fi', 'fl', 'ffi', 'ffl', 'parenleftinferior',\n  'parenrightinferior', 'hyphensuperior', 'colonmonetary', 'onefitted',\n  'rupiah', 'centoldstyle', 'figuredash', 'hypheninferior', 'onequarter',\n  'onehalf', 'threequarters', 'oneeighth', 'threeeighths', 'fiveeighths',\n  'seveneighths', 'onethird', 'twothirds', 'zerosuperior', 'onesuperior',\n  'twosuperior', 'threesuperior', 'foursuperior', 'fivesuperior',\n  'sixsuperior', 'sevensuperior', 'eightsuperior', 'ninesuperior',\n  'zeroinferior', 'oneinferior', 'twoinferior', 'threeinferior',\n  'fourinferior', 'fiveinferior', 'sixinferior', 'seveninferior',\n  'eightinferior', 'nineinferior', 'centinferior', 'dollarinferior',\n  'periodinferior', 'commainferior'\n];\n","import {Feature} from './opentype';\nimport * as r from 'restructure';\n\n/*******************\n * Variation Store *\n *******************/\n\nlet F2DOT14 = new r.Fixed(16, 'BE', 14);\nlet RegionAxisCoordinates = new r.Struct({\n  startCoord: F2DOT14,\n  peakCoord: F2DOT14,\n  endCoord: F2DOT14\n});\n\nlet VariationRegionList = new r.Struct({\n  axisCount: r.uint16,\n  regionCount: r.uint16,\n  variationRegions: new r.Array(new r.Array(RegionAxisCoordinates, 'axisCount'), 'regionCount')\n});\n\nlet DeltaSet = new r.Struct({\n  shortDeltas: new r.Array(r.int16, t => t.parent.shortDeltaCount),\n  regionDeltas: new r.Array(r.int8, t => t.parent.regionIndexCount - t.parent.shortDeltaCount),\n  deltas: t => t.shortDeltas.concat(t.regionDeltas)\n});\n\nlet ItemVariationData = new r.Struct({\n  itemCount: r.uint16,\n  shortDeltaCount: r.uint16,\n  regionIndexCount: r.uint16,\n  regionIndexes: new r.Array(r.uint16, 'regionIndexCount'),\n  deltaSets: new r.Array(DeltaSet, 'itemCount')\n});\n\nexport let ItemVariationStore = new r.Struct({\n  format: r.uint16,\n  variationRegionList: new r.Pointer(r.uint32, VariationRegionList),\n  variationDataCount: r.uint16,\n  itemVariationData: new r.Array(new r.Pointer(r.uint32, ItemVariationData), 'variationDataCount')\n});\n\n/**********************\n * Feature Variations *\n **********************/\n\nlet ConditionTable = new r.VersionedStruct(r.uint16, {\n  1: {\n    axisIndex: r.uint16,\n    axisIndex: r.uint16,\n    filterRangeMinValue: F2DOT14,\n    filterRangeMaxValue: F2DOT14\n  }\n});\n\nlet ConditionSet = new r.Struct({\n  conditionCount: r.uint16,\n  conditionTable: new r.Array(new r.Pointer(r.uint32, ConditionTable), 'conditionCount')\n});\n\nlet FeatureTableSubstitutionRecord = new r.Struct({\n  featureIndex: r.uint16,\n  alternateFeatureTable: new r.Pointer(r.uint32, Feature, {type: 'parent'})\n});\n\nlet FeatureTableSubstitution = new r.Struct({\n  version: r.fixed32,\n  substitutionCount: r.uint16,\n  substitutions: new r.Array(FeatureTableSubstitutionRecord, 'substitutionCount')\n});\n\nlet FeatureVariationRecord = new r.Struct({\n  conditionSet: new r.Pointer(r.uint32, ConditionSet, {type: 'parent'}),\n  featureTableSubstitution: new r.Pointer(r.uint32, FeatureTableSubstitution, {type: 'parent'})\n});\n\nexport let FeatureVariations = new r.Struct({\n  majorVersion: r.uint16,\n  minorVersion: r.uint16,\n  featureVariationRecordCount: r.uint32,\n  featureVariationRecords: new r.Array(FeatureVariationRecord, 'featureVariationRecordCount')\n});\n","import * as r from 'restructure';\n\n//########################\n// Scripts and Languages #\n//########################\n\nlet LangSysTable = new r.Struct({\n  reserved:         new r.Reserved(r.uint16),\n  reqFeatureIndex:  r.uint16,\n  featureCount:     r.uint16,\n  featureIndexes:   new r.Array(r.uint16, 'featureCount')\n});\n\nlet LangSysRecord = new r.Struct({\n  tag:      new r.String(4),\n  langSys:  new r.Pointer(r.uint16, LangSysTable, { type: 'parent' })\n});\n\nlet Script = new r.Struct({\n  defaultLangSys: new r.Pointer(r.uint16, LangSysTable),\n  count:          r.uint16,\n  langSysRecords: new r.Array(LangSysRecord, 'count')\n});\n\nlet ScriptRecord = new r.Struct({\n  tag:    new r.String(4),\n  script: new r.Pointer(r.uint16, Script, { type: 'parent' })\n});\n\nexport let ScriptList = new r.Array(ScriptRecord, r.uint16);\n\n//#######################\n// Features and Lookups #\n//#######################\n\nlet FeatureParams = new r.Struct({\n  version:    r.uint16, // should be set to 0 according OT spec\n  nameID:     r.uint16, //OT spec: UI Name ID or uiLabelNameId\n});\n\nexport let Feature = new r.Struct({\n  featureParams:      new r.Pointer(r.uint16, FeatureParams),\n  lookupCount:        r.uint16,\n  lookupListIndexes:  new r.Array(r.uint16, 'lookupCount')\n});\n\nlet FeatureRecord = new r.Struct({\n  tag:      new r.String(4),\n  feature:  new r.Pointer(r.uint16, Feature, { type: 'parent' })\n});\n\nexport let FeatureList = new r.Array(FeatureRecord, r.uint16);\n\nlet LookupFlags = new r.Struct({\n  markAttachmentType: r.uint8,\n  flags: new r.Bitfield(r.uint8, [\n    'rightToLeft', 'ignoreBaseGlyphs', 'ignoreLigatures',\n    'ignoreMarks', 'useMarkFilteringSet'\n  ])\n});\n\nexport function LookupList(SubTable) {\n  let Lookup = new r.Struct({\n    lookupType:         r.uint16,\n    flags:              LookupFlags,\n    subTableCount:      r.uint16,\n    subTables:          new r.Array(new r.Pointer(r.uint16, SubTable), 'subTableCount'),\n    markFilteringSet:   new r.Optional(r.uint16, t => t.flags.flags.useMarkFilteringSet)\n  });\n\n  return new r.LazyArray(new r.Pointer(r.uint16, Lookup), r.uint16);\n}\n\n//#################\n// Coverage Table #\n//#################\n\nlet RangeRecord = new r.Struct({\n  start:              r.uint16,\n  end:                r.uint16,\n  startCoverageIndex: r.uint16\n});\n\nexport let Coverage = new r.VersionedStruct(r.uint16, {\n  1: {\n    glyphCount:   r.uint16,\n    glyphs:       new r.Array(r.uint16, 'glyphCount')\n  },\n  2: {\n    rangeCount:   r.uint16,\n    rangeRecords: new r.Array(RangeRecord, 'rangeCount')\n  }\n});\n\n//#########################\n// Class Definition Table #\n//#########################\n\nlet ClassRangeRecord = new r.Struct({\n  start:  r.uint16,\n  end:    r.uint16,\n  class:  r.uint16\n});\n\nexport let ClassDef = new r.VersionedStruct(r.uint16, {\n  1: { // Class array\n    startGlyph:       r.uint16,\n    glyphCount:       r.uint16,\n    classValueArray:  new r.Array(r.uint16, 'glyphCount')\n  },\n  2: { // Class ranges\n    classRangeCount:  r.uint16,\n    classRangeRecord: new r.Array(ClassRangeRecord, 'classRangeCount')\n  }\n});\n\n//###############\n// Device Table #\n//###############\n\nexport let Device = new r.Struct({\n  a: r.uint16, // startSize for hinting Device, outerIndex for VariationIndex\n  b: r.uint16, // endSize for Device, innerIndex for VariationIndex\n  deltaFormat: r.uint16\n});\n\n//#############################################\n// Contextual Substitution/Positioning Tables #\n//#############################################\n\nlet LookupRecord = new r.Struct({\n  sequenceIndex:      r.uint16,\n  lookupListIndex:    r.uint16\n});\n\nlet Rule = new r.Struct({\n  glyphCount:     r.uint16,\n  lookupCount:    r.uint16,\n  input:          new r.Array(r.uint16, t => t.glyphCount - 1),\n  lookupRecords:  new r.Array(LookupRecord, 'lookupCount')\n});\n\nlet RuleSet = new r.Array(new r.Pointer(r.uint16, Rule), r.uint16);\n\nlet ClassRule = new r.Struct({\n  glyphCount:     r.uint16,\n  lookupCount:    r.uint16,\n  classes:        new r.Array(r.uint16, t => t.glyphCount - 1),\n  lookupRecords:  new r.Array(LookupRecord, 'lookupCount')\n});\n\nlet ClassSet = new r.Array(new r.Pointer(r.uint16, ClassRule), r.uint16);\n\nexport let Context = new r.VersionedStruct(r.uint16, {\n  1: { // Simple context\n    coverage:      new r.Pointer(r.uint16, Coverage),\n    ruleSetCount:  r.uint16,\n    ruleSets:      new r.Array(new r.Pointer(r.uint16, RuleSet), 'ruleSetCount')\n  },\n  2: { // Class-based context\n    coverage:      new r.Pointer(r.uint16, Coverage),\n    classDef:      new r.Pointer(r.uint16, ClassDef),\n    classSetCnt:   r.uint16,\n    classSet:      new r.Array(new r.Pointer(r.uint16, ClassSet), 'classSetCnt')\n  },\n  3: {\n    glyphCount:    r.uint16,\n    lookupCount:   r.uint16,\n    coverages:     new r.Array(new r.Pointer(r.uint16, Coverage), 'glyphCount'),\n    lookupRecords: new r.Array(LookupRecord, 'lookupCount')\n  }\n});\n\n//######################################################\n// Chaining Contextual Substitution/Positioning Tables #\n//######################################################\n\nlet ChainRule = new r.Struct({\n  backtrackGlyphCount:  r.uint16,\n  backtrack:            new r.Array(r.uint16, 'backtrackGlyphCount'),\n  inputGlyphCount:      r.uint16,\n  input:                new r.Array(r.uint16, t => t.inputGlyphCount - 1),\n  lookaheadGlyphCount:  r.uint16,\n  lookahead:            new r.Array(r.uint16, 'lookaheadGlyphCount'),\n  lookupCount:          r.uint16,\n  lookupRecords:        new r.Array(LookupRecord, 'lookupCount')\n});\n\nlet ChainRuleSet = new r.Array(new r.Pointer(r.uint16, ChainRule), r.uint16);\n\nexport let ChainingContext = new r.VersionedStruct(r.uint16, {\n  1: { // Simple context glyph substitution\n    coverage:           new r.Pointer(r.uint16, Coverage),\n    chainCount:         r.uint16,\n    chainRuleSets:      new r.Array(new r.Pointer(r.uint16, ChainRuleSet), 'chainCount')\n  },\n\n  2: { // Class-based chaining context\n    coverage:           new r.Pointer(r.uint16, Coverage),\n    backtrackClassDef:  new r.Pointer(r.uint16, ClassDef),\n    inputClassDef:      new r.Pointer(r.uint16, ClassDef),\n    lookaheadClassDef:  new r.Pointer(r.uint16, ClassDef),\n    chainCount:         r.uint16,\n    chainClassSet:      new r.Array(new r.Pointer(r.uint16, ChainRuleSet), 'chainCount')\n  },\n\n  3: { // Coverage-based chaining context\n    backtrackGlyphCount:    r.uint16,\n    backtrackCoverage:      new r.Array(new r.Pointer(r.uint16, Coverage), 'backtrackGlyphCount'),\n    inputGlyphCount:        r.uint16,\n    inputCoverage:          new r.Array(new r.Pointer(r.uint16, Coverage), 'inputGlyphCount'),\n    lookaheadGlyphCount:    r.uint16,\n    lookaheadCoverage:      new r.Array(new r.Pointer(r.uint16, Coverage), 'lookaheadGlyphCount'),\n    lookupCount:            r.uint16,\n    lookupRecords:          new r.Array(LookupRecord, 'lookupCount')\n  }\n});\n","import * as r from 'restructure';\n\nlet VerticalOrigin = new r.Struct({\n  glyphIndex:   r.uint16,\n  vertOriginY:  r.int16\n});\n\nexport default new r.Struct({\n  majorVersion:           r.uint16,\n  minorVersion:           r.uint16,\n  defaultVertOriginY:     r.int16,\n  numVertOriginYMetrics:  r.uint16,\n  metrics:                new r.Array(VerticalOrigin, 'numVertOriginYMetrics')\n});\n","import * as r from 'restructure';\nimport {BigMetrics} from './EBDT';\n\nlet SBitLineMetrics = new r.Struct({\n  ascender: r.int8,\n  descender: r.int8,\n  widthMax: r.uint8,\n  caretSlopeNumerator: r.int8,\n  caretSlopeDenominator: r.int8,\n  caretOffset: r.int8,\n  minOriginSB: r.int8,\n  minAdvanceSB: r.int8,\n  maxBeforeBL: r.int8,\n  minAfterBL: r.int8,\n  pad: new r.Reserved(r.int8, 2)\n});\n\nlet CodeOffsetPair = new r.Struct({\n  glyphCode: r.uint16,\n  offset: r.uint16\n});\n\nlet IndexSubtable = new r.VersionedStruct(r.uint16, {\n  header: {\n    imageFormat: r.uint16,\n    imageDataOffset: r.uint32\n  },\n\n  1: {\n    offsetArray: new r.Array(r.uint32, t => t.parent.lastGlyphIndex - t.parent.firstGlyphIndex + 1)\n  },\n\n  2: {\n    imageSize: r.uint32,\n    bigMetrics: BigMetrics\n  },\n\n  3: {\n    offsetArray: new r.Array(r.uint16, t => t.parent.lastGlyphIndex - t.parent.firstGlyphIndex + 1)\n  },\n\n  4: {\n    numGlyphs: r.uint32,\n    glyphArray: new r.Array(CodeOffsetPair, t => t.numGlyphs + 1)\n  },\n\n  5: {\n    imageSize: r.uint32,\n    bigMetrics: BigMetrics,\n    numGlyphs: r.uint32,\n    glyphCodeArray: new r.Array(r.uint16, 'numGlyphs')\n  }\n});\n\nlet IndexSubtableArray = new r.Struct({\n  firstGlyphIndex: r.uint16,\n  lastGlyphIndex: r.uint16,\n  subtable: new r.Pointer(r.uint32, IndexSubtable)\n});\n\nlet BitmapSizeTable = new r.Struct({\n  indexSubTableArray: new r.Pointer(r.uint32, new r.Array(IndexSubtableArray, 1), { type: 'parent' }),\n  indexTablesSize: r.uint32,\n  numberOfIndexSubTables: r.uint32,\n  colorRef: r.uint32,\n  hori: SBitLineMetrics,\n  vert: SBitLineMetrics,\n  startGlyphIndex: r.uint16,\n  endGlyphIndex: r.uint16,\n  ppemX: r.uint8,\n  ppemY: r.uint8,\n  bitDepth: r.uint8,\n  flags: new r.Bitfield(r.uint8, ['horizontal', 'vertical'])\n});\n\nexport default new r.Struct({\n  version:  r.uint32, // 0x00020000\n  numSizes: r.uint32,\n  sizes:    new r.Array(BitmapSizeTable, 'numSizes')\n});\n","import * as r from 'restructure';\n\nexport let BigMetrics = new r.Struct({\n  height: r.uint8,\n  width: r.uint8,\n  horiBearingX: r.int8,\n  horiBearingY: r.int8,\n  horiAdvance: r.uint8,\n  vertBearingX: r.int8,\n  vertBearingY: r.int8,\n  vertAdvance: r.uint8\n});\n\nexport let SmallMetrics = new r.Struct({\n  height: r.uint8,\n  width: r.uint8,\n  bearingX: r.int8,\n  bearingY: r.int8,\n  advance: r.uint8\n});\n\nlet EBDTComponent = new r.Struct({\n  glyph: r.uint16,\n  xOffset: r.int8,\n  yOffset: r.int8\n});\n\nclass ByteAligned {}\n\nclass BitAligned {}\n\nexport let glyph = new r.VersionedStruct('version', {\n  1: {\n    metrics: SmallMetrics,\n    data: ByteAligned\n  },\n\n  2: {\n    metrics: SmallMetrics,\n    data: BitAligned\n  },\n\n  // format 3 is deprecated\n  // format 4 is not supported by Microsoft\n\n  5: {\n    data: BitAligned\n  },\n\n  6: {\n    metrics: BigMetrics,\n    data: ByteAligned\n  },\n\n  7: {\n    metrics: BigMetrics,\n    data: BitAligned\n  },\n\n  8: {\n    metrics: SmallMetrics,\n    pad: new r.Reserved(r.uint8),\n    numComponents: r.uint16,\n    components: new r.Array(EBDTComponent, 'numComponents')\n  },\n\n  9: {\n    metrics: BigMetrics,\n    pad: new r.Reserved(r.uint8),\n    numComponents: r.uint16,\n    components: new r.Array(EBDTComponent, 'numComponents')\n  },\n\n  17: {\n    metrics: SmallMetrics,\n    dataLen: r.uint32,\n    data: new r.Buffer('dataLen')\n  },\n\n  18: {\n    metrics: BigMetrics,\n    dataLen: r.uint32,\n    data: new r.Buffer('dataLen')\n  },\n\n  19: {\n    dataLen: r.uint32,\n    data: new r.Buffer('dataLen')\n  }\n});\n\n","import * as r from 'restructure';\n\nlet ImageTable = new r.Struct({\n  ppem: r.uint16,\n  resolution: r.uint16,\n  imageOffsets: new r.Array(new r.Pointer(r.uint32, 'void'), t => t.parent.parent.maxp.numGlyphs + 1)\n});\n\n// This is the Apple sbix table, used by the \"Apple Color Emoji\" font.\n// It includes several image tables with images for each bitmap glyph\n// of several different sizes.\nexport default new r.Struct({\n  version: r.uint16,\n  flags: new r.Bitfield(r.uint16, ['renderOutlines']),\n  numImgTables: r.uint32,\n  imageTables: new r.Array(new r.Pointer(r.uint32, ImageTable), 'numImgTables')\n});\n","import * as r from 'restructure';\n\nlet LayerRecord = new r.Struct({\n  gid: r.uint16,          // Glyph ID of layer glyph (must be in z-order from bottom to top).\n  paletteIndex: r.uint16  // Index value to use in the appropriate palette. This value must\n});                       // be less than numPaletteEntries in the CPAL table, except for\n                          // the special case noted below. Each palette entry is 16 bits.\n                          // A palette index of 0xFFFF is a special case indicating that\n                          // the text foreground color should be used.\n\nlet BaseGlyphRecord = new r.Struct({\n  gid: r.uint16,             // Glyph ID of reference glyph. This glyph is for reference only\n                             // and is not rendered for color.\n  firstLayerIndex: r.uint16, // Index (from beginning of the Layer Records) to the layer record.\n                             // There will be numLayers consecutive entries for this base glyph.\n  numLayers: r.uint16\n});\n\nexport default new r.Struct({\n  version: r.uint16,\n  numBaseGlyphRecords: r.uint16,\n  baseGlyphRecord: new r.Pointer(r.uint32, new r.Array(BaseGlyphRecord, 'numBaseGlyphRecords')),\n  layerRecords: new r.Pointer(r.uint32, new r.Array(LayerRecord, 'numLayerRecords'), { lazy: true }),\n  numLayerRecords: r.uint16\n});\n","import * as r from 'restructure';\n\nlet ColorRecord = new r.Struct({\n  blue: r.uint8,\n  green: r.uint8,\n  red: r.uint8,\n  alpha: r.uint8\n});\n\nexport default new r.VersionedStruct(r.uint16, {\n  header: {\n    numPaletteEntries: r.uint16,\n    numPalettes: r.uint16,\n    numColorRecords: r.uint16,\n    colorRecords: new r.Pointer(r.uint32, new r.Array(ColorRecord, 'numColorRecords')),\n    colorRecordIndices: new r.Array(r.uint16, 'numPalettes'),\n  },\n  0: {},\n  1: {\n    offsetPaletteTypeArray: new r.Pointer(r.uint32, new r.Array(r.uint32, 'numPalettes')),\n    offsetPaletteLabelArray: new r.Pointer(r.uint32, new r.Array(r.uint16, 'numPalettes')),\n    offsetPaletteEntryLabelArray: new r.Pointer(r.uint32, new r.Array(r.uint16, 'numPaletteEntries'))\n  }\n});\n","import * as r from 'restructure';\nimport {ScriptList, FeatureList, LookupList, Coverage, ClassDef, Device} from './opentype';\nimport {ItemVariationStore} from './variations';\n\nlet BaseCoord = new r.VersionedStruct(r.uint16, {\n  1: { // Design units only\n    coordinate:   r.int16 // X or Y value, in design units\n  },\n\n  2: { // Design units plus contour point\n    coordinate:     r.int16,   // X or Y value, in design units\n    referenceGlyph: r.uint16,  // GlyphID of control glyph\n    baseCoordPoint: r.uint16   // Index of contour point on the referenceGlyph\n  },\n\n  3: { // Design units plus Device table\n    coordinate:   r.int16,                         // X or Y value, in design units\n    deviceTable:  new r.Pointer(r.uint16, Device)  // Device table for X or Y value\n  }\n});\n\nlet BaseValues = new r.Struct({\n  defaultIndex:   r.uint16,  // Index of default baseline for this script-same index in the BaseTagList\n  baseCoordCount: r.uint16,\n  baseCoords:     new r.Array(new r.Pointer(r.uint16, BaseCoord), 'baseCoordCount')\n});\n\nlet FeatMinMaxRecord = new r.Struct({\n  tag:        new r.String(4),  // 4-byte feature identification tag-must match FeatureTag in FeatureList\n  minCoord:   new r.Pointer(r.uint16, BaseCoord, {type: 'parent'}), // May be NULL\n  maxCoord:   new r.Pointer(r.uint16, BaseCoord, {type: 'parent'})  // May be NULL\n});\n\nlet MinMax = new r.Struct({\n  minCoord:           new r.Pointer(r.uint16, BaseCoord),  // May be NULL\n  maxCoord:           new r.Pointer(r.uint16, BaseCoord),  // May be NULL\n  featMinMaxCount:    r.uint16,                            // May be 0\n  featMinMaxRecords:  new r.Array(FeatMinMaxRecord, 'featMinMaxCount') // In alphabetical order\n});\n\nlet BaseLangSysRecord = new r.Struct({\n  tag:    new r.String(4),  // 4-byte language system identification tag\n  minMax: new r.Pointer(r.uint16, MinMax, {type: 'parent'})\n});\n\nlet BaseScript = new r.Struct({\n  baseValues:         new r.Pointer(r.uint16, BaseValues), // May be NULL\n  defaultMinMax:      new r.Pointer(r.uint16, MinMax),     // May be NULL\n  baseLangSysCount:   r.uint16,                            // May be 0\n  baseLangSysRecords: new r.Array(BaseLangSysRecord, 'baseLangSysCount') // in alphabetical order by BaseLangSysTag\n});\n\nlet BaseScriptRecord = new r.Struct({\n  tag:      new r.String(4),  // 4-byte script identification tag\n  script:   new r.Pointer(r.uint16, BaseScript, {type: 'parent'})\n});\n\nlet BaseScriptList = new r.Array(BaseScriptRecord, r.uint16);\n\n// Array of 4-byte baseline identification tags-must be in alphabetical order\nlet BaseTagList = new r.Array(new r.String(4), r.uint16);\n\nlet Axis = new r.Struct({\n  baseTagList:    new r.Pointer(r.uint16, BaseTagList),  // May be NULL\n  baseScriptList: new r.Pointer(r.uint16, BaseScriptList)\n});\n\nexport default new r.VersionedStruct(r.uint32, {\n  header: {\n    horizAxis:    new r.Pointer(r.uint16, Axis),   // May be NULL\n    vertAxis:     new r.Pointer(r.uint16, Axis)    // May be NULL\n  },\n\n  0x00010000: {},\n  0x00010001: {\n    itemVariationStore: new r.Pointer(r.uint32, ItemVariationStore)\n  }\n});\n","import * as r from 'restructure';\nimport {ScriptList, FeatureList, LookupList, Coverage, ClassDef, Device} from './opentype';\nimport {ItemVariationStore} from './variations';\n\nlet AttachPoint = new r.Array(r.uint16, r.uint16);\nlet AttachList = new r.Struct({\n  coverage:       new r.Pointer(r.uint16, Coverage),\n  glyphCount:     r.uint16,\n  attachPoints:   new r.Array(new r.Pointer(r.uint16, AttachPoint), 'glyphCount')\n});\n\nlet CaretValue = new r.VersionedStruct(r.uint16, {\n  1: { // Design units only\n    coordinate: r.int16\n  },\n\n  2: { // Contour point\n    caretValuePoint: r.uint16\n  },\n\n  3: { // Design units plus Device table\n    coordinate:     r.int16,\n    deviceTable:    new r.Pointer(r.uint16, Device)\n  }\n});\n\nlet LigGlyph = new r.Array(new r.Pointer(r.uint16, CaretValue), r.uint16);\n\nlet LigCaretList = new r.Struct({\n  coverage:       new r.Pointer(r.uint16, Coverage),\n  ligGlyphCount:  r.uint16,\n  ligGlyphs:      new r.Array(new r.Pointer(r.uint16, LigGlyph), 'ligGlyphCount')\n});\n\nlet MarkGlyphSetsDef = new r.Struct({\n  markSetTableFormat: r.uint16,\n  markSetCount:       r.uint16,\n  coverage:           new r.Array(new r.Pointer(r.uint32, Coverage), 'markSetCount')\n});\n\nexport default new r.VersionedStruct(r.uint32, {\n  header: {\n    glyphClassDef:      new r.Pointer(r.uint16, ClassDef),\n    attachList:         new r.Pointer(r.uint16, AttachList),\n    ligCaretList:       new r.Pointer(r.uint16, LigCaretList),\n    markAttachClassDef: new r.Pointer(r.uint16, ClassDef)\n  },\n\n  0x00010000: {},\n  0x00010002: {\n    markGlyphSetsDef:   new r.Pointer(r.uint16, MarkGlyphSetsDef)\n  },\n  0x00010003: {\n    markGlyphSetsDef:   new r.Pointer(r.uint16, MarkGlyphSetsDef),\n    itemVariationStore: new r.Pointer(r.uint32, ItemVariationStore)\n  }\n});\n","import * as r from 'restructure';\nimport {ScriptList, FeatureList, LookupList, Coverage, ClassDef, Device, Context, ChainingContext} from './opentype';\nimport {FeatureVariations} from './variations';\n\nlet ValueFormat = new r.Bitfield(r.uint16, [\n  'xPlacement', 'yPlacement',\n  'xAdvance', 'yAdvance',\n  'xPlaDevice', 'yPlaDevice',\n  'xAdvDevice', 'yAdvDevice'\n]);\n\nlet types = {\n  xPlacement: r.int16,\n  yPlacement: r.int16,\n  xAdvance:   r.int16,\n  yAdvance:   r.int16,\n  xPlaDevice: new r.Pointer(r.uint16, Device, { type: 'global', relativeTo: ctx => ctx.rel }),\n  yPlaDevice: new r.Pointer(r.uint16, Device, { type: 'global', relativeTo: ctx => ctx.rel }),\n  xAdvDevice: new r.Pointer(r.uint16, Device, { type: 'global', relativeTo: ctx => ctx.rel }),\n  yAdvDevice: new r.Pointer(r.uint16, Device, { type: 'global', relativeTo: ctx => ctx.rel })\n};\n\nclass ValueRecord {\n  constructor(key = 'valueFormat') {\n    this.key = key;\n  }\n\n  buildStruct(parent) {\n    let struct = parent;\n    while (!struct[this.key] && struct.parent) {\n      struct = struct.parent;\n    }\n\n    if (!struct[this.key]) return;\n\n    let fields = {};\n    fields.rel = () => struct._startOffset;\n\n    let format = struct[this.key];\n    for (let key in format) {\n      if (format[key]) {\n        fields[key] = types[key];\n      }\n    }\n\n    return new r.Struct(fields);\n  }\n\n  size(val, ctx) {\n    return this.buildStruct(ctx).size(val, ctx);\n  }\n\n  decode(stream, parent) {\n    let res = this.buildStruct(parent).decode(stream, parent);\n    delete res.rel;\n    return res;\n  }\n}\n\nlet PairValueRecord = new r.Struct({\n  secondGlyph:    r.uint16,\n  value1:         new ValueRecord('valueFormat1'),\n  value2:         new ValueRecord('valueFormat2')\n});\n\nlet PairSet = new r.Array(PairValueRecord, r.uint16);\n\nlet Class2Record = new r.Struct({\n  value1: new ValueRecord('valueFormat1'),\n  value2: new ValueRecord('valueFormat2')\n});\n\nlet Anchor = new r.VersionedStruct(r.uint16, {\n  1: { // Design units only\n    xCoordinate:    r.int16,\n    yCoordinate:    r.int16\n  },\n\n  2: { // Design units plus contour point\n    xCoordinate:    r.int16,\n    yCoordinate:    r.int16,\n    anchorPoint:    r.uint16\n  },\n\n  3: { // Design units plus Device tables\n    xCoordinate:    r.int16,\n    yCoordinate:    r.int16,\n    xDeviceTable:   new r.Pointer(r.uint16, Device),\n    yDeviceTable:   new r.Pointer(r.uint16, Device)\n  }\n});\n\nlet EntryExitRecord = new r.Struct({\n  entryAnchor:    new r.Pointer(r.uint16, Anchor, {type: 'parent'}),\n  exitAnchor:     new r.Pointer(r.uint16, Anchor, {type: 'parent'})\n});\n\nlet MarkRecord = new r.Struct({\n  class:      r.uint16,\n  markAnchor: new r.Pointer(r.uint16, Anchor, {type: 'parent'})\n});\n\nlet MarkArray = new r.Array(MarkRecord, r.uint16);\n\nlet BaseRecord  = new r.Array(new r.Pointer(r.uint16, Anchor), t => t.parent.classCount);\nlet BaseArray   = new r.Array(BaseRecord, r.uint16);\n\nlet ComponentRecord = new r.Array(new r.Pointer(r.uint16, Anchor), t => t.parent.parent.classCount);\nlet LigatureAttach  = new r.Array(ComponentRecord, r.uint16);\nlet LigatureArray   = new r.Array(new r.Pointer(r.uint16, LigatureAttach), r.uint16);\n\nlet GPOSLookup = new r.VersionedStruct('lookupType', {\n  1: new r.VersionedStruct(r.uint16, { // Single Adjustment\n    1: { // Single positioning value\n      coverage:       new r.Pointer(r.uint16, Coverage),\n      valueFormat:    ValueFormat,\n      value:          new ValueRecord()\n    },\n    2: {\n      coverage:       new r.Pointer(r.uint16, Coverage),\n      valueFormat:    ValueFormat,\n      valueCount:     r.uint16,\n      values:         new r.LazyArray(new ValueRecord(), 'valueCount')\n    }\n  }),\n\n  2: new r.VersionedStruct(r.uint16, { // Pair Adjustment Positioning\n    1: { // Adjustments for glyph pairs\n      coverage:       new r.Pointer(r.uint16, Coverage),\n      valueFormat1:   ValueFormat,\n      valueFormat2:   ValueFormat,\n      pairSetCount:   r.uint16,\n      pairSets:       new r.LazyArray(new r.Pointer(r.uint16, PairSet), 'pairSetCount')\n    },\n\n    2: { // Class pair adjustment\n      coverage:       new r.Pointer(r.uint16, Coverage),\n      valueFormat1:   ValueFormat,\n      valueFormat2:   ValueFormat,\n      classDef1:      new r.Pointer(r.uint16, ClassDef),\n      classDef2:      new r.Pointer(r.uint16, ClassDef),\n      class1Count:    r.uint16,\n      class2Count:    r.uint16,\n      classRecords:   new r.LazyArray(new r.LazyArray(Class2Record, 'class2Count'), 'class1Count')\n    }\n  }),\n\n  3: { // Cursive Attachment Positioning\n    format:             r.uint16,\n    coverage:           new r.Pointer(r.uint16, Coverage),\n    entryExitCount:     r.uint16,\n    entryExitRecords:   new r.Array(EntryExitRecord, 'entryExitCount')\n  },\n\n  4: { // MarkToBase Attachment Positioning\n    format:             r.uint16,\n    markCoverage:       new r.Pointer(r.uint16, Coverage),\n    baseCoverage:       new r.Pointer(r.uint16, Coverage),\n    classCount:         r.uint16,\n    markArray:          new r.Pointer(r.uint16, MarkArray),\n    baseArray:          new r.Pointer(r.uint16, BaseArray)\n  },\n\n  5: { // MarkToLigature Attachment Positioning\n    format:             r.uint16,\n    markCoverage:       new r.Pointer(r.uint16, Coverage),\n    ligatureCoverage:   new r.Pointer(r.uint16, Coverage),\n    classCount:         r.uint16,\n    markArray:          new r.Pointer(r.uint16, MarkArray),\n    ligatureArray:      new r.Pointer(r.uint16, LigatureArray)\n  },\n\n  6: { // MarkToMark Attachment Positioning\n    format:             r.uint16,\n    mark1Coverage:      new r.Pointer(r.uint16, Coverage),\n    mark2Coverage:      new r.Pointer(r.uint16, Coverage),\n    classCount:         r.uint16,\n    mark1Array:         new r.Pointer(r.uint16, MarkArray),\n    mark2Array:         new r.Pointer(r.uint16, BaseArray)\n  },\n\n  7: Context,          // Contextual positioning\n  8: ChainingContext,  // Chaining contextual positioning\n\n  9: { // Extension Positioning\n    posFormat:   r.uint16,\n    lookupType:  r.uint16,   // cannot also be 9\n    extension:   new r.Pointer(r.uint32, null)\n  }\n});\n\n// Fix circular reference\nGPOSLookup.versions[9].extension.type = GPOSLookup;\n\nexport default new r.VersionedStruct(r.uint32, {\n  header: {\n    scriptList:     new r.Pointer(r.uint16, ScriptList),\n    featureList:    new r.Pointer(r.uint16, FeatureList),\n    lookupList:     new r.Pointer(r.uint16, new LookupList(GPOSLookup))\n  },\n\n  0x00010000: {},\n  0x00010001: {\n    featureVariations: new r.Pointer(r.uint32, FeatureVariations)\n  }\n});\n\n// export GPOSLookup for JSTF table\nexport { GPOSLookup };\n","import * as r from 'restructure';\nimport {ScriptList, FeatureList, LookupList, Coverage, ClassDef, Device, Context, ChainingContext} from './opentype';\nimport {FeatureVariations} from './variations';\n\nlet Sequence = new r.Array(r.uint16, r.uint16);\nlet AlternateSet = Sequence;\n\nlet Ligature = new r.Struct({\n  glyph:      r.uint16,\n  compCount:  r.uint16,\n  components: new r.Array(r.uint16, t => t.compCount - 1)\n});\n\nlet LigatureSet = new r.Array(new r.Pointer(r.uint16, Ligature), r.uint16);\n\nlet GSUBLookup = new r.VersionedStruct('lookupType', {\n  1: new r.VersionedStruct(r.uint16, {// Single Substitution\n    1: {\n      coverage:       new r.Pointer(r.uint16, Coverage),\n      deltaGlyphID:   r.int16\n    },\n    2: {\n      coverage:       new r.Pointer(r.uint16, Coverage),\n      glyphCount:     r.uint16,\n      substitute:     new r.LazyArray(r.uint16, 'glyphCount')\n    }\n  }),\n\n  2: { // Multiple Substitution\n    substFormat:    r.uint16,\n    coverage:       new r.Pointer(r.uint16, Coverage),\n    count:          r.uint16,\n    sequences:      new r.LazyArray(new r.Pointer(r.uint16, Sequence), 'count')\n  },\n\n  3: { // Alternate Substitution\n    substFormat:    r.uint16,\n    coverage:       new r.Pointer(r.uint16, Coverage),\n    count:          r.uint16,\n    alternateSet:   new r.LazyArray(new r.Pointer(r.uint16, AlternateSet), 'count')\n  },\n\n  4: { // Ligature Substitution\n    substFormat:    r.uint16,\n    coverage:       new r.Pointer(r.uint16, Coverage),\n    count:          r.uint16,\n    ligatureSets:   new r.LazyArray(new r.Pointer(r.uint16, LigatureSet), 'count')\n  },\n\n  5: Context,         // Contextual Substitution\n  6: ChainingContext, // Chaining Contextual Substitution\n\n  7: { // Extension Substitution\n    substFormat:   r.uint16,\n    lookupType:    r.uint16,   // cannot also be 7\n    extension:     new r.Pointer(r.uint32, null)\n  },\n\n  8: { // Reverse Chaining Contextual Single Substitution\n    substFormat:            r.uint16,\n    coverage:               new r.Pointer(r.uint16, Coverage),\n    backtrackCoverage:      new r.Array(new r.Pointer(r.uint16, Coverage), 'backtrackGlyphCount'),\n    lookaheadGlyphCount:    r.uint16,\n    lookaheadCoverage:      new r.Array(new r.Pointer(r.uint16, Coverage), 'lookaheadGlyphCount'),\n    glyphCount:             r.uint16,\n    substitutes:            new r.Array(r.uint16, 'glyphCount')\n  }\n});\n\n// Fix circular reference\nGSUBLookup.versions[7].extension.type = GSUBLookup;\n\nexport default new r.VersionedStruct(r.uint32, {\n  header: {\n    scriptList:     new r.Pointer(r.uint16, ScriptList),\n    featureList:    new r.Pointer(r.uint16, FeatureList),\n    lookupList:     new r.Pointer(r.uint16, new LookupList(GSUBLookup))\n  },\n\n  0x00010000: {},\n  0x00010001: {\n    featureVariations: new r.Pointer(r.uint32, FeatureVariations)\n  }\n});\n","import * as r from 'restructure';\nimport { ScriptList, FeatureList, LookupList, Coverage, ClassDef, Device } from './opentype';\nimport { GPOSLookup } from './GPOS';\n\nlet JstfGSUBModList = new r.Array(r.uint16, r.uint16);\n\nlet JstfPriority = new r.Struct({\n  shrinkageEnableGSUB:    new r.Pointer(r.uint16, JstfGSUBModList),\n  shrinkageDisableGSUB:   new r.Pointer(r.uint16, JstfGSUBModList),\n  shrinkageEnableGPOS:    new r.Pointer(r.uint16, JstfGSUBModList),\n  shrinkageDisableGPOS:   new r.Pointer(r.uint16, JstfGSUBModList),\n  shrinkageJstfMax:       new r.Pointer(r.uint16, new LookupList(GPOSLookup)),\n  extensionEnableGSUB:    new r.Pointer(r.uint16, JstfGSUBModList),\n  extensionDisableGSUB:   new r.Pointer(r.uint16, JstfGSUBModList),\n  extensionEnableGPOS:    new r.Pointer(r.uint16, JstfGSUBModList),\n  extensionDisableGPOS:   new r.Pointer(r.uint16, JstfGSUBModList),\n  extensionJstfMax:       new r.Pointer(r.uint16, new LookupList(GPOSLookup))\n});\n\nlet JstfLangSys = new r.Array(new r.Pointer(r.uint16, JstfPriority), r.uint16);\n\nlet JstfLangSysRecord = new r.Struct({\n  tag:         new r.String(4),\n  jstfLangSys: new r.Pointer(r.uint16, JstfLangSys)\n});\n\nlet JstfScript = new r.Struct({\n  extenderGlyphs: new r.Pointer(r.uint16, new r.Array(r.uint16, r.uint16)), // array of glyphs to extend line length\n  defaultLangSys: new r.Pointer(r.uint16, JstfLangSys),\n  langSysCount:   r.uint16,\n  langSysRecords: new r.Array(JstfLangSysRecord, 'langSysCount')\n});\n\nlet JstfScriptRecord = new r.Struct({\n  tag:    new r.String(4),\n  script: new r.Pointer(r.uint16, JstfScript, {type: 'parent'})\n});\n\nexport default new r.Struct({\n  version:     r.uint32,  // should be 0x00010000\n  scriptCount: r.uint16,\n  scriptList:  new r.Array(JstfScriptRecord, 'scriptCount')\n});\n","import * as r from 'restructure';\nimport { resolveLength } from 'restructure';\nimport { ItemVariationStore } from './variations';\n\n// TODO: add this to restructure\nclass VariableSizeNumber {\n  constructor(size) {\n    this._size = size;\n  }\n\n  decode(stream, parent) {\n    switch (this.size(0, parent)) {\n      case 1: return stream.readUInt8();\n      case 2: return stream.readUInt16BE();\n      case 3: return stream.readUInt24BE();\n      case 4: return stream.readUInt32BE();\n    }\n  }\n\n  size(val, parent) {\n    return resolveLength(this._size, null, parent);\n  }\n}\n\nlet MapDataEntry = new r.Struct({\n  entry: new VariableSizeNumber(t => ((t.parent.entryFormat & 0x0030) >> 4) + 1),\n  outerIndex: t => t.entry >> ((t.parent.entryFormat & 0x000F) + 1),\n  innerIndex: t => t.entry & ((1 << ((t.parent.entryFormat & 0x000F) + 1)) - 1)\n});\n\nlet DeltaSetIndexMap = new r.Struct({\n  entryFormat: r.uint16,\n  mapCount: r.uint16,\n  mapData: new r.Array(MapDataEntry, 'mapCount')\n});\n\nexport default new r.Struct({\n  majorVersion: r.uint16,\n  minorVersion: r.uint16,\n  itemVariationStore: new r.Pointer(r.uint32, ItemVariationStore),\n  advanceWidthMapping: new r.Pointer(r.uint32, DeltaSetIndexMap),\n  LSBMapping: new r.Pointer(r.uint32, DeltaSetIndexMap),\n  RSBMapping: new r.Pointer(r.uint32, DeltaSetIndexMap)\n});\n","import * as r from 'restructure';\n\nlet Signature = new r.Struct({\n  format: r.uint32,\n  length: r.uint32,\n  offset: r.uint32\n});\n\nlet SignatureBlock = new r.Struct({\n  reserved:       new r.Reserved(r.uint16, 2),\n  cbSignature:    r.uint32,  // Length (in bytes) of the PKCS#7 packet in pbSignature\n  signature:      new r.Buffer('cbSignature')\n});\n\nexport default new r.Struct({\n  ulVersion:       r.uint32,  // Version number of the DSIG table (0x00000001)\n  usNumSigs:       r.uint16,  // Number of signatures in the table\n  usFlag:          r.uint16,  // Permission flags\n  signatures:      new r.Array(Signature, 'usNumSigs'),\n  signatureBlocks: new r.Array(SignatureBlock, 'usNumSigs')\n});\n","import * as r from 'restructure';\n\nlet GaspRange = new r.Struct({\n  rangeMaxPPEM:       r.uint16,                  // Upper limit of range, in ppem\n  rangeGaspBehavior:  new r.Bitfield(r.uint16, [ // Flags describing desired rasterizer behavior\n    'grayscale', 'gridfit',\n    'symmetricSmoothing', 'symmetricGridfit'     // only in version 1, for ClearType\n  ])\n});\n\nexport default new r.Struct({\n  version:    r.uint16,  // set to 0\n  numRanges:  r.uint16,\n  gaspRanges: new r.Array(GaspRange, 'numRanges') // Sorted by ppem\n});\n","import * as r from 'restructure';\n\nlet DeviceRecord = new r.Struct({\n  pixelSize:      r.uint8,\n  maximumWidth:   r.uint8,\n  widths:         new r.Array(r.uint8, t => t.parent.parent.maxp.numGlyphs)\n});\n\n// The Horizontal Device Metrics table stores integer advance widths scaled to particular pixel sizes\nexport default new r.Struct({\n  version:            r.uint16,\n  numRecords:         r.int16,\n  sizeDeviceRecord:   r.int32,\n  records:            new r.Array(DeviceRecord, 'numRecords')\n});\n","import * as r from 'restructure';\n\nlet KernPair = new r.Struct({\n  left:   r.uint16,\n  right:  r.uint16,\n  value:  r.int16\n});\n\nlet ClassTable = new r.Struct({\n  firstGlyph: r.uint16,\n  nGlyphs: r.uint16,\n  offsets: new r.Array(r.uint16, 'nGlyphs'),\n  max: t => t.offsets.length && Math.max.apply(Math, t.offsets)\n});\n\nlet Kern2Array = new r.Struct({\n  off: t => t._startOffset - t.parent.parent._startOffset,\n  len: t => (((t.parent.leftTable.max - t.off) / t.parent.rowWidth) + 1) * (t.parent.rowWidth / 2),\n  values: new r.LazyArray(r.int16, 'len')\n});\n\nlet KernSubtable = new r.VersionedStruct('format', {\n  0: {\n    nPairs:         r.uint16,\n    searchRange:    r.uint16,\n    entrySelector:  r.uint16,\n    rangeShift:     r.uint16,\n    pairs:          new r.Array(KernPair, 'nPairs')\n  },\n\n  2: {\n    rowWidth:   r.uint16,\n    leftTable:  new r.Pointer(r.uint16, ClassTable, {type: 'parent'}),\n    rightTable: new r.Pointer(r.uint16, ClassTable, {type: 'parent'}),\n    array:      new r.Pointer(r.uint16, Kern2Array, {type: 'parent'})\n  },\n\n  3: {\n    glyphCount:       r.uint16,\n    kernValueCount:   r.uint8,\n    leftClassCount:   r.uint8,\n    rightClassCount:  r.uint8,\n    flags:            r.uint8,\n    kernValue:        new r.Array(r.int16, 'kernValueCount'),\n    leftClass:        new r.Array(r.uint8, 'glyphCount'),\n    rightClass:       new r.Array(r.uint8, 'glyphCount'),\n    kernIndex:        new r.Array(r.uint8, t => t.leftClassCount * t.rightClassCount)\n  }\n});\n\nlet KernTable = new r.VersionedStruct('version', {\n  0: { // Microsoft uses this format\n    subVersion: r.uint16,  // Microsoft has an extra sub-table version number\n    length:     r.uint16,  // Length of the subtable, in bytes\n    format:     r.uint8,   // Format of subtable\n    coverage:   new r.Bitfield(r.uint8, [\n      'horizontal',    // 1 if table has horizontal data, 0 if vertical\n      'minimum',       // If set to 1, the table has minimum values. If set to 0, the table has kerning values.\n      'crossStream',   // If set to 1, kerning is perpendicular to the flow of the text\n      'override'      // If set to 1 the value in this table replaces the accumulated value\n    ]),\n    subtable:   KernSubtable,\n    padding: new r.Reserved(r.uint8, t => t.length - t._currentOffset)\n  },\n  1: { // Apple uses this format\n    length:     r.uint32,\n    coverage:   new r.Bitfield(r.uint8, [\n      null, null, null, null, null,\n      'variation',     // Set if table has variation kerning values\n      'crossStream',   // Set if table has cross-stream kerning values\n      'vertical'      // Set if table has vertical kerning values\n    ]),\n    format:     r.uint8,\n    tupleIndex: r.uint16,\n    subtable:   KernSubtable,\n    padding: new r.Reserved(r.uint8, t => t.length - t._currentOffset)\n  }\n});\n\nexport default new r.VersionedStruct(r.uint16, {\n  0: { // Microsoft Version\n    nTables:    r.uint16,\n    tables:     new r.Array(KernTable, 'nTables')\n  },\n\n  1: { // Apple Version\n    reserved:   new r.Reserved(r.uint16), // the other half of the version number\n    nTables:    r.uint32,\n    tables:     new r.Array(KernTable, 'nTables')\n  }\n});\n","import * as r from 'restructure';\n\n// Linear Threshold table\n// Records the ppem for each glyph at which the scaling becomes linear again,\n// despite instructions effecting the advance width\nexport default new r.Struct({\n  version:    r.uint16,\n  numGlyphs:  r.uint16,\n  yPels:      new r.Array(r.uint8, 'numGlyphs')\n});\n","import * as r from 'restructure';\n\n// PCL 5 Table\n// NOTE: The PCLT table is strongly discouraged for OpenType fonts with TrueType outlines\nexport default new r.Struct({\n  version:              r.uint16,\n  fontNumber:           r.uint32,\n  pitch:                r.uint16,\n  xHeight:              r.uint16,\n  style:                r.uint16,\n  typeFamily:           r.uint16,\n  capHeight:            r.uint16,\n  symbolSet:            r.uint16,\n  typeface:             new r.String(16),\n  characterComplement:  new r.String(8),\n  fileName:             new r.String(6),\n  strokeWeight:         new r.String(1),\n  widthType:            new r.String(1),\n  serifStyle:           r.uint8,\n  reserved:             new r.Reserved(r.uint8)\n});\n","import * as r from 'restructure';\n\n// VDMX tables contain ascender/descender overrides for certain (usually small)\n// sizes. This is needed in order to match font metrics on Windows.\n\nlet Ratio = new r.Struct({\n  bCharSet:       r.uint8,                             // Character set\n  xRatio:         r.uint8,                             // Value to use for x-Ratio\n  yStartRatio:    r.uint8,                             // Starting y-Ratio value\n  yEndRatio:      r.uint8                              // Ending y-Ratio value\n});\n\nlet vTable = new r.Struct({\n  yPelHeight:     r.uint16,                            // yPelHeight to which values apply\n  yMax:           r.int16,                             // Maximum value (in pels) for this yPelHeight\n  yMin:           r.int16                              // Minimum value (in pels) for this yPelHeight\n});\n\nlet VdmxGroup = new r.Struct({\n  recs:           r.uint16,                            // Number of height records in this group\n  startsz:        r.uint8,                             // Starting yPelHeight\n  endsz:          r.uint8,                             // Ending yPelHeight\n  entries:        new r.Array(vTable, 'recs')          // The VDMX records\n});\n\nexport default new r.Struct({\n  version:        r.uint16,                            // Version number (0 or 1)\n  numRecs:        r.uint16,                            // Number of VDMX groups present\n  numRatios:      r.uint16,                            // Number of aspect ratio groupings\n  ratioRanges:    new r.Array(Ratio, 'numRatios'),     // Ratio ranges\n  offsets:        new r.Array(r.uint16, 'numRatios'),  // Offset to the VDMX group for this ratio range\n  groups:         new r.Array(VdmxGroup, 'numRecs')    // The actual VDMX groupings\n});\n","import * as r from 'restructure';\n\n// Vertical Header Table\nexport default new r.Struct({\n  version:                r.uint16,  // Version number of the Vertical Header Table\n  ascent:                 r.int16,   // The vertical typographic ascender for this font\n  descent:                r.int16,   // The vertical typographic descender for this font\n  lineGap:                r.int16,   // The vertical typographic line gap for this font\n  advanceHeightMax:       r.int16,   // The maximum advance height measurement found in the font\n  minTopSideBearing:      r.int16,   // The minimum top side bearing measurement found in the font\n  minBottomSideBearing:   r.int16,   // The minimum bottom side bearing measurement found in the font\n  yMaxExtent:             r.int16,\n  caretSlopeRise:         r.int16,   // Caret slope (rise/run)\n  caretSlopeRun:          r.int16,\n  caretOffset:            r.int16,   // Set value equal to 0 for nonslanted fonts\n  reserved:               new r.Reserved(r.int16, 4),\n  metricDataFormat:       r.int16,   // Set to 0\n  numberOfMetrics:        r.uint16   // Number of advance heights in the Vertical Metrics table\n});\n","import * as r from 'restructure';\n\nlet VmtxEntry = new r.Struct({\n  advance: r.uint16,  // The advance height of the glyph\n  bearing: r.int16    // The top sidebearing of the glyph\n});\n\n// Vertical Metrics Table\nexport default new r.Struct({\n  metrics:  new r.LazyArray(VmtxEntry, t => t.parent.vhea.numberOfMetrics),\n  bearings: new r.LazyArray(r.int16, t => t.parent.maxp.numGlyphs - t.parent.vhea.numberOfMetrics)\n});\n","import * as r from 'restructure';\n\nlet shortFrac = new r.Fixed(16, 'BE', 14);\n\nlet Correspondence = new r.Struct({\n  fromCoord: shortFrac,\n  toCoord: shortFrac\n});\n\nlet Segment = new r.Struct({\n  pairCount: r.uint16,\n  correspondence: new r.Array(Correspondence, 'pairCount')\n});\n\nexport default new r.Struct({\n  version: r.fixed32,\n  axisCount: r.uint32,\n  segment: new r.Array(Segment, 'axisCount')\n});\n","import * as r from 'restructure';\nimport { LookupTable } from './aat';\n\nlet BslnSubtable = new r.VersionedStruct('format', {\n  0: { // Distance-based, no mapping\n    deltas: new r.Array(r.int16, 32)\n  },\n\n  1: { // Distance-based, with mapping\n    deltas: new r.Array(r.int16, 32),\n    mappingData: new LookupTable(r.uint16)\n  },\n\n  2: { // Control point-based, no mapping\n    standardGlyph: r.uint16,\n    controlPoints: new r.Array(r.uint16, 32)\n  },\n\n  3: { // Control point-based, with mapping\n    standardGlyph: r.uint16,\n    controlPoints: new r.Array(r.uint16, 32),\n    mappingData: new LookupTable(r.uint16)\n  }\n});\n\nexport default new r.Struct({\n  version: r.fixed32,\n  format: r.uint16,\n  defaultBaseline: r.uint16,\n  subtable: BslnSubtable\n});\n","import * as r from 'restructure';\n\nclass UnboundedArrayAccessor {\n  constructor(type, stream, parent) {\n    this.type = type;\n    this.stream = stream;\n    this.parent = parent;\n    this.base = this.stream.pos;\n    this._items = [];\n  }\n\n  getItem(index) {\n    if (this._items[index] == null) {\n      let pos = this.stream.pos;\n      this.stream.pos = this.base + this.type.size(null, this.parent) * index;\n      this._items[index] = this.type.decode(this.stream, this.parent);\n      this.stream.pos = pos;\n    }\n\n    return this._items[index];\n  }\n\n  inspect() {\n    return `[UnboundedArray ${this.type.constructor.name}]`;\n  }\n}\n\nexport class UnboundedArray extends r.Array {\n  constructor(type) {\n    super(type, 0);\n  }\n\n  decode(stream, parent) {\n    return new UnboundedArrayAccessor(this.type, stream, parent);\n  }\n}\n\nexport let LookupTable = function(ValueType = r.uint16) {\n  // Helper class that makes internal structures invisible to pointers\n  class Shadow {\n    constructor(type) {\n      this.type = type;\n    }\n\n    decode(stream, ctx) {\n      ctx = ctx.parent.parent;\n      return this.type.decode(stream, ctx);\n    }\n\n    size(val, ctx) {\n      ctx = ctx.parent.parent;\n      return this.type.size(val, ctx);\n    }\n\n    encode(stream, val, ctx) {\n      ctx = ctx.parent.parent;\n      return this.type.encode(stream, val, ctx);\n    }\n  }\n\n  ValueType = new Shadow(ValueType);\n\n  let BinarySearchHeader = new r.Struct({\n    unitSize: r.uint16,\n    nUnits: r.uint16,\n    searchRange: r.uint16,\n    entrySelector: r.uint16,\n    rangeShift: r.uint16\n  });\n\n  let LookupSegmentSingle = new r.Struct({\n    lastGlyph: r.uint16,\n    firstGlyph: r.uint16,\n    value: ValueType\n  });\n\n  let LookupSegmentArray = new r.Struct({\n    lastGlyph: r.uint16,\n    firstGlyph: r.uint16,\n    values: new r.Pointer(r.uint16, new r.Array(ValueType, t => t.lastGlyph - t.firstGlyph + 1), {type: 'parent'})\n  });\n\n  let LookupSingle = new r.Struct({\n    glyph: r.uint16,\n    value: ValueType\n  });\n\n  return new r.VersionedStruct(r.uint16, {\n    0: {\n      values: new UnboundedArray(ValueType) // length == number of glyphs maybe?\n    },\n    2: {\n      binarySearchHeader: BinarySearchHeader,\n      segments: new r.Array(LookupSegmentSingle, t => t.binarySearchHeader.nUnits)\n    },\n    4: {\n      binarySearchHeader: BinarySearchHeader,\n      segments: new r.Array(LookupSegmentArray, t => t.binarySearchHeader.nUnits)\n    },\n    6: {\n      binarySearchHeader: BinarySearchHeader,\n      segments: new r.Array(LookupSingle, t => t.binarySearchHeader.nUnits)\n    },\n    8: {\n      firstGlyph: r.uint16,\n      count: r.uint16,\n      values: new r.Array(ValueType, 'count')\n    }\n  });\n};\n\nexport function StateTable(entryData = {}, lookupType = r.uint16) {\n  let entry = Object.assign({\n    newState: r.uint16,\n    flags: r.uint16\n  }, entryData);\n\n  let Entry = new r.Struct(entry);\n  let StateArray = new UnboundedArray(new r.Array(r.uint16, t => t.nClasses));\n\n  let StateHeader = new r.Struct({\n    nClasses: r.uint32,\n    classTable: new r.Pointer(r.uint32, new LookupTable(lookupType)),\n    stateArray: new r.Pointer(r.uint32, StateArray),\n    entryTable: new r.Pointer(r.uint32, new UnboundedArray(Entry))\n  });\n\n  return StateHeader;\n}\n\n// This is the old version of the StateTable structure\nexport function StateTable1(entryData = {}, lookupType = r.uint16) {\n  let ClassLookupTable = new r.Struct({\n    version() { return 8; }, // simulate LookupTable\n    firstGlyph: r.uint16,\n    values: new r.Array(r.uint8, r.uint16)\n  });\n\n  let entry = Object.assign({\n    newStateOffset: r.uint16,\n    // convert offset to stateArray index\n    newState: t => (t.newStateOffset - (t.parent.stateArray.base - t.parent._startOffset)) / t.parent.nClasses,\n    flags: r.uint16\n  }, entryData);\n\n  let Entry = new r.Struct(entry);\n  let StateArray = new UnboundedArray(new r.Array(r.uint8, t => t.nClasses));\n\n  let StateHeader1 = new r.Struct({\n    nClasses: r.uint16,\n    classTable: new r.Pointer(r.uint16, ClassLookupTable),\n    stateArray: new r.Pointer(r.uint16, StateArray),\n    entryTable: new r.Pointer(r.uint16, new UnboundedArray(Entry))\n  });\n\n  return StateHeader1;\n}\n","import * as r from 'restructure';\n\nlet Setting = new r.Struct({\n  setting: r.uint16,\n  nameIndex: r.int16,\n  name: t => t.parent.parent.parent.name.records.fontFeatures[t.nameIndex]\n});\n\nlet FeatureName = new r.Struct({\n  feature: r.uint16,\n  nSettings: r.uint16,\n  settingTable: new r.Pointer(r.uint32, new r.Array(Setting, 'nSettings'), { type: 'parent' }),\n  featureFlags: new r.Bitfield(r.uint8, [\n    null, null, null, null, null, null,\n    'hasDefault', 'exclusive'\n  ]),\n  defaultSetting: r.uint8,\n  nameIndex: r.int16,\n  name: t => t.parent.parent.name.records.fontFeatures[t.nameIndex]\n});\n\nexport default new r.Struct({\n  version: r.fixed32,\n  featureNameCount: r.uint16,\n  reserved1: new r.Reserved(r.uint16),\n  reserved2: new r.Reserved(r.uint32),\n  featureNames: new r.Array(FeatureName, 'featureNameCount')\n});\n","import * as r from 'restructure';\n\nlet Axis = new r.Struct({\n  axisTag: new r.String(4),\n  minValue: r.fixed32,\n  defaultValue: r.fixed32,\n  maxValue: r.fixed32,\n  flags: r.uint16,\n  nameID: r.uint16,\n  name: t => t.parent.parent.name.records.fontFeatures[t.nameID]\n});\n\nlet Instance = new r.Struct({\n  nameID: r.uint16,\n  name: t => t.parent.parent.name.records.fontFeatures[t.nameID],\n  flags: r.uint16,\n  coord: new r.Array(r.fixed32, t => t.parent.axisCount),\n  postscriptNameID: new r.Optional(r.uint16, t => t.parent.instanceSize - t._currentOffset > 0)\n});\n\nexport default new r.Struct({\n  version: r.fixed32,\n  offsetToData: r.uint16,\n  countSizePairs: r.uint16,\n  axisCount: r.uint16,\n  axisSize: r.uint16,\n  instanceCount: r.uint16,\n  instanceSize: r.uint16,\n  axis: new r.Array(Axis, 'axisCount'),\n  instance: new r.Array(Instance, 'instanceCount')\n});\n","import * as r from 'restructure';\n\nlet shortFrac = new r.Fixed(16, 'BE', 14);\nclass Offset {\n  static decode(stream, parent) {\n    // In short format, offsets are multiplied by 2.\n    // This doesn't seem to be documented by Apple, but it\n    // is implemented this way in Freetype.\n    return parent.flags\n      ? stream.readUInt32BE()\n      : stream.readUInt16BE() * 2;\n  }\n}\n\nlet gvar = new r.Struct({\n  version: r.uint16,\n  reserved: new r.Reserved(r.uint16),\n  axisCount: r.uint16,\n  globalCoordCount: r.uint16,\n  globalCoords: new r.Pointer(r.uint32, new r.Array(new r.Array(shortFrac, 'axisCount'), 'globalCoordCount')),\n  glyphCount: r.uint16,\n  flags: r.uint16,\n  offsetToData: r.uint32,\n  offsets: new r.Array(new r.Pointer(Offset, 'void', { relativeTo: ctx => ctx.offsetToData, allowNull: false }), t => t.glyphCount + 1)\n});\n\nexport default gvar;\n","import * as r from 'restructure';\nimport { LookupTable, StateTable1 } from './aat';\n\nlet ClassTable = new r.Struct({\n  length: r.uint16,\n  coverage: r.uint16,\n  subFeatureFlags: r.uint32,\n  stateTable: new StateTable1\n});\n\nlet WidthDeltaRecord = new r.Struct({\n  justClass: r.uint32,\n  beforeGrowLimit: r.fixed32,\n  beforeShrinkLimit: r.fixed32,\n  afterGrowLimit: r.fixed32,\n  afterShrinkLimit: r.fixed32,\n  growFlags: r.uint16,\n  shrinkFlags: r.uint16\n});\n\nlet WidthDeltaCluster = new r.Array(WidthDeltaRecord, r.uint32);\n\nlet ActionData = new r.VersionedStruct('actionType', {\n  0: { // Decomposition action\n    lowerLimit: r.fixed32,\n    upperLimit: r.fixed32,\n    order: r.uint16,\n    glyphs: new r.Array(r.uint16, r.uint16)\n  },\n\n  1: { // Unconditional add glyph action\n    addGlyph: r.uint16\n  },\n\n  2: { // Conditional add glyph action\n    substThreshold: r.fixed32,\n    addGlyph: r.uint16,\n    substGlyph: r.uint16\n  },\n\n  3: {}, // Stretch glyph action (no data, not supported by CoreText)\n\n  4: { // Ductile glyph action (not supported by CoreText)\n    variationAxis: r.uint32,\n    minimumLimit: r.fixed32,\n    noStretchValue: r.fixed32,\n    maximumLimit: r.fixed32\n  },\n\n  5: { // Repeated add glyph action\n    flags: r.uint16,\n    glyph: r.uint16\n  }\n});\n\nlet Action = new r.Struct({\n  actionClass: r.uint16,\n  actionType: r.uint16,\n  actionLength: r.uint32,\n  actionData: ActionData,\n  padding: new r.Reserved(r.uint8, t => t.actionLength - t._currentOffset)\n});\n\nlet PostcompensationAction = new r.Array(Action, r.uint32);\nlet PostCompensationTable = new r.Struct({\n  lookupTable: new LookupTable(new r.Pointer(r.uint16, PostcompensationAction))\n});\n\nlet JustificationTable = new r.Struct({\n  classTable: new r.Pointer(r.uint16, ClassTable, { type: 'parent' }),\n  wdcOffset: r.uint16,\n  postCompensationTable: new r.Pointer(r.uint16, PostCompensationTable, { type: 'parent' }),\n  widthDeltaClusters: new LookupTable(new r.Pointer(r.uint16, WidthDeltaCluster, { type: 'parent', relativeTo: ctx => ctx.wdcOffset }))\n});\n\nexport default new r.Struct({\n  version: r.uint32,\n  format: r.uint16,\n  horizontal: new r.Pointer(r.uint16, JustificationTable),\n  vertical: new r.Pointer(r.uint16, JustificationTable)\n});\n","import * as r from 'restructure';\nimport { UnboundedArray, LookupTable, StateTable } from './aat';\n\nlet LigatureData = {\n  action: r.uint16\n};\n\nlet ContextualData = {\n  markIndex: r.uint16,\n  currentIndex: r.uint16\n};\n\nlet InsertionData = {\n  currentInsertIndex: r.uint16,\n  markedInsertIndex: r.uint16\n};\n\nlet SubstitutionTable = new r.Struct({\n  items: new UnboundedArray(new r.Pointer(r.uint32, new LookupTable))\n});\n\nlet SubtableData = new r.VersionedStruct('type', {\n  0: { // Indic Rearrangement Subtable\n    stateTable: new StateTable\n  },\n\n  1: { // Contextual Glyph Substitution Subtable\n    stateTable: new StateTable(ContextualData),\n    substitutionTable: new r.Pointer(r.uint32, SubstitutionTable)\n  },\n\n  2: { // Ligature subtable\n    stateTable: new StateTable(LigatureData),\n    ligatureActions: new r.Pointer(r.uint32, new UnboundedArray(r.uint32)),\n    components: new r.Pointer(r.uint32, new UnboundedArray(r.uint16)),\n    ligatureList: new r.Pointer(r.uint32, new UnboundedArray(r.uint16))\n  },\n\n  4: { // Non-contextual Glyph Substitution Subtable\n    lookupTable: new LookupTable\n  },\n\n  5: { // Glyph Insertion Subtable\n    stateTable: new StateTable(InsertionData),\n    insertionActions: new r.Pointer(r.uint32, new UnboundedArray(r.uint16))\n  }\n});\n\nlet Subtable = new r.Struct({\n  length: r.uint32,\n  coverage: r.uint24,\n  type: r.uint8,\n  subFeatureFlags: r.uint32,\n  table: SubtableData,\n  padding: new r.Reserved(r.uint8, t => t.length - t._currentOffset)\n});\n\nlet FeatureEntry = new r.Struct({\n  featureType:    r.uint16,\n  featureSetting: r.uint16,\n  enableFlags:    r.uint32,\n  disableFlags:   r.uint32\n});\n\nlet MorxChain = new r.Struct({\n  defaultFlags:     r.uint32,\n  chainLength:      r.uint32,\n  nFeatureEntries:  r.uint32,\n  nSubtables:       r.uint32,\n  features:         new r.Array(FeatureEntry, 'nFeatureEntries'),\n  subtables:        new r.Array(Subtable, 'nSubtables')\n});\n\nexport default new r.Struct({\n  version:  r.uint16,\n  unused:   new r.Reserved(r.uint16),\n  nChains:  r.uint32,\n  chains:   new r.Array(MorxChain, 'nChains')\n});\n","import * as r from 'restructure';\nimport { LookupTable } from './aat';\n\nlet OpticalBounds = new r.Struct({\n  left: r.int16,\n  top: r.int16,\n  right: r.int16,\n  bottom: r.int16\n});\n\nexport default new r.Struct({\n  version: r.fixed32,\n  format: r.uint16,\n  lookupTable: new LookupTable(OpticalBounds)\n});\n","import { binarySearch } from './utils';\nimport { encodingExists, getEncoding, getEncodingMapping } from './encodings';\nimport { cache } from './decorators';\nimport { range } from './utils';\n\nexport default class CmapProcessor {\n  constructor(cmapTable) {\n    // Attempt to find a Unicode cmap first\n    this.encoding = null;\n    this.cmap = this.findSubtable(cmapTable, [\n      // 32-bit subtables\n      [3, 10],\n      [0, 6],\n      [0, 4],\n\n      // 16-bit subtables\n      [3, 1],\n      [0, 3],\n      [0, 2],\n      [0, 1],\n      [0, 0]\n    ]);\n\n    // If not unicode cmap was found, take the first table with a supported encoding.\n    if (!this.cmap) {\n      for (let cmap of cmapTable.tables) {\n        let encoding = getEncoding(cmap.platformID, cmap.encodingID, cmap.table.language - 1);\n        let mapping = getEncodingMapping(encoding);\n        if (mapping) {\n          this.cmap = cmap.table;\n          this.encoding = mapping;\n        }\n      }\n    }\n\n    if (!this.cmap) {\n      throw new Error(\"Could not find a supported cmap table\");\n    }\n\n    this.uvs = this.findSubtable(cmapTable, [[0, 5]]);\n    if (this.uvs && this.uvs.version !== 14) {\n      this.uvs = null;\n    }\n  }\n\n  findSubtable(cmapTable, pairs) {\n    for (let [platformID, encodingID] of pairs) {\n      for (let cmap of cmapTable.tables) {\n        if (cmap.platformID === platformID && cmap.encodingID === encodingID) {\n          return cmap.table;\n        }\n      }\n    }\n\n    return null;\n  }\n\n  lookup(codepoint, variationSelector) {\n    // If there is no Unicode cmap in this font, we need to re-encode\n    // the codepoint in the encoding that the cmap supports.\n    if (this.encoding) {\n      codepoint = this.encoding.get(codepoint) || codepoint;\n\n      // Otherwise, try to get a Unicode variation selector for this codepoint if one is provided.\n    } else if (variationSelector) {\n      let gid = this.getVariationSelector(codepoint, variationSelector);\n      if (gid) {\n        return gid;\n      }\n    }\n\n    let cmap = this.cmap;\n    switch (cmap.version) {\n      case 0:\n        return cmap.codeMap.get(codepoint) || 0;\n\n      case 4: {\n        let min = 0;\n        let max = cmap.segCount - 1;\n        while (min <= max) {\n          let mid = (min + max) >> 1;\n\n          if (codepoint < cmap.startCode.get(mid)) {\n            max = mid - 1;\n          } else if (codepoint > cmap.endCode.get(mid)) {\n            min = mid + 1;\n          } else {\n            let rangeOffset = cmap.idRangeOffset.get(mid);\n            let gid;\n\n            if (rangeOffset === 0) {\n              gid = codepoint + cmap.idDelta.get(mid);\n            } else {\n              let index = rangeOffset / 2 + (codepoint - cmap.startCode.get(mid)) - (cmap.segCount - mid);\n              gid = cmap.glyphIndexArray.get(index) || 0;\n              if (gid !== 0) {\n                gid += cmap.idDelta.get(mid);\n              }\n            }\n\n            return gid & 0xffff;\n          }\n        }\n\n        return 0;\n      }\n\n      case 8:\n        throw new Error('TODO: cmap format 8');\n\n      case 6:\n      case 10:\n        return cmap.glyphIndices.get(codepoint - cmap.firstCode) || 0;\n\n      case 12:\n      case 13: {\n        let min = 0;\n        let max = cmap.nGroups - 1;\n        while (min <= max) {\n          let mid = (min + max) >> 1;\n          let group = cmap.groups.get(mid);\n\n          if (codepoint < group.startCharCode) {\n            max = mid - 1;\n          } else if (codepoint > group.endCharCode) {\n            min = mid + 1;\n          } else {\n            if (cmap.version === 12) {\n              return group.glyphID + (codepoint - group.startCharCode);\n            } else {\n              return group.glyphID;\n            }\n          }\n        }\n\n        return 0;\n      }\n\n      case 14:\n        throw new Error('TODO: cmap format 14');\n\n      default:\n        throw new Error(`Unknown cmap format ${cmap.version}`);\n    }\n  }\n\n  getVariationSelector(codepoint, variationSelector) {\n    if (!this.uvs) {\n      return 0;\n    }\n\n    let selectors = this.uvs.varSelectors.toArray();\n    let i = binarySearch(selectors, x => variationSelector - x.varSelector);\n    let sel = selectors[i];\n\n    if (i !== -1 && sel.defaultUVS) {\n      i = binarySearch(sel.defaultUVS, x =>\n        codepoint < x.startUnicodeValue ? -1 : codepoint > x.startUnicodeValue + x.additionalCount ? +1 : 0\n      );\n    }\n\n    if (i !== -1 && sel.nonDefaultUVS) {\n      i = binarySearch(sel.nonDefaultUVS, x => codepoint - x.unicodeValue);\n      if (i !== -1) {\n        return sel.nonDefaultUVS[i].glyphID;\n      }\n    }\n\n    return 0;\n  }\n\n  @cache\n  getCharacterSet() {\n    let cmap = this.cmap;\n    switch (cmap.version) {\n      case 0:\n        return range(0, cmap.codeMap.length);\n\n      case 4: {\n        let res = [];\n        let endCodes = cmap.endCode.toArray();\n        for (let i = 0; i < endCodes.length; i++) {\n          let tail = endCodes[i] + 1;\n          let start = cmap.startCode.get(i);\n          res.push(...range(start, tail));\n        }\n\n        return res;\n      }\n\n      case 8:\n        throw new Error('TODO: cmap format 8');\n\n      case 6:\n      case 10:\n        return range(cmap.firstCode, cmap.firstCode + cmap.glyphIndices.length);\n\n      case 12:\n      case 13: {\n        let res = [];\n        for (let group of cmap.groups.toArray()) {\n          res.push(...range(group.startCharCode, group.endCharCode + 1));\n        }\n\n        return res;\n      }\n\n      case 14:\n        throw new Error('TODO: cmap format 14');\n\n      default:\n        throw new Error(`Unknown cmap format ${cmap.version}`);\n    }\n  }\n\n  @cache\n  codePointsForGlyph(gid) {\n    let cmap = this.cmap;\n    switch (cmap.version) {\n      case 0: {\n        let res = [];\n        for (let i = 0; i < 256; i++) {\n          if (cmap.codeMap.get(i) === gid) {\n            res.push(i);\n          }\n        }\n\n        return res;\n      }\n\n      case 4: {\n        let res = [];\n        for (let i = 0; i < cmap.segCount; i++) {\n          let end = cmap.endCode.get(i);\n          let start = cmap.startCode.get(i);\n          let rangeOffset = cmap.idRangeOffset.get(i);\n          let delta = cmap.idDelta.get(i);\n\n          for (var c = start; c <= end; c++) {\n            let g = 0;\n            if (rangeOffset === 0) {\n              g = c + delta;\n            } else {\n              let index = rangeOffset / 2 + (c - start) - (cmap.segCount - i);\n              g = cmap.glyphIndexArray.get(index) || 0;\n              if (g !== 0) {\n                g += delta;\n              }\n            }\n\n            if (g === gid) {\n              res.push(c);\n            }\n          }\n        }\n\n        return res;\n      }\n\n      case 12: {\n        let res = [];\n        for (let group of cmap.groups.toArray()) {\n          if (gid >= group.glyphID && gid <= group.glyphID + (group.endCharCode - group.startCharCode)) {\n            res.push(group.startCharCode + (gid - group.glyphID));\n          }\n        }\n\n        return res;\n      }\n\n      case 13: {\n        let res = [];\n        for (let group of cmap.groups.toArray()) {\n          if (gid === group.glyphID) {\n            res.push(...range(group.startCharCode, group.endCharCode + 1));\n          }\n        }\n\n        return res;\n      }\n\n      default:\n        throw new Error(`Unknown cmap format ${cmap.version}`);\n    }\n  }\n}\n","export function binarySearch(arr, cmp) {\n  let min = 0;\n  let max = arr.length - 1;\n  while (min <= max) {\n    let mid = (min + max) >> 1;\n    let res = cmp(arr[mid]);\n\n    if (res < 0) {\n      max = mid - 1;\n    } else if (res > 0) {\n      min = mid + 1;\n    } else {\n      return mid;\n    }\n  }\n\n  return -1;\n}\n\nexport function range(index, end) {\n  let range = [];\n  while (index < end) {\n    range.push(index++);\n  }\n  return range;\n}\n\nexport const asciiDecoder = new TextDecoder('ascii');\n\n// Based on https://github.com/niklasvh/base64-arraybuffer. MIT license.\nconst CHARS = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';\nconst LOOKUP = new Uint8Array(256);\nfor (let i = 0; i < CHARS.length; i++) {\n  LOOKUP[CHARS.charCodeAt(i)] = i;\n}\n\nexport function decodeBase64(base64) {\n  let bufferLength = base64.length * 0.75;\n\n  if (base64[base64.length - 1] === '=') {\n    bufferLength--;\n    if (base64[base64.length - 2] === '=') {\n      bufferLength--;\n    }\n  }\n\n  let bytes = new Uint8Array(bufferLength);\n  let p = 0;\n\n  for (let i = 0, len = base64.length; i < len; i += 4) {\n    let encoded1 = LOOKUP[base64.charCodeAt(i)];\n    let encoded2 = LOOKUP[base64.charCodeAt(i + 1)];\n    let encoded3 = LOOKUP[base64.charCodeAt(i + 2)];\n    let encoded4 = LOOKUP[base64.charCodeAt(i + 3)];\n\n    bytes[p++] = (encoded1 << 2) | (encoded2 >> 4);\n    bytes[p++] = ((encoded2 & 15) << 4) | (encoded3 >> 2);\n    bytes[p++] = ((encoded3 & 3) << 6) | (encoded4 & 63);\n  }\n\n  return bytes;\n}\n","import KernProcessor from './KernProcessor';\nimport UnicodeLayoutEngine from './UnicodeLayoutEngine';\nimport GlyphRun from './GlyphRun';\nimport GlyphPosition from './GlyphPosition';\nimport * as Script from './Script';\nimport AATLayoutEngine from '../aat/AATLayoutEngine';\nimport OTLayoutEngine from '../opentype/OTLayoutEngine';\n\nexport default class LayoutEngine {\n  constructor(font) {\n    this.font = font;\n    this.unicodeLayoutEngine = null;\n    this.kernProcessor = null;\n\n    // Choose an advanced layout engine. We try the AAT morx table first since more\n    // scripts are currently supported because the shaping logic is built into the font.\n    if (this.font.morx) {\n      this.engine = new AATLayoutEngine(this.font);\n\n    } else if (this.font.GSUB || this.font.GPOS) {\n      this.engine = new OTLayoutEngine(this.font);\n    }\n  }\n\n  layout(string, features, script, language, direction) {\n    // Make the features parameter optional\n    if (typeof features === 'string') {\n      direction = language;\n      language = script;\n      script = features;\n      features = [];\n    }\n\n    // Map string to glyphs if needed\n    if (typeof string === 'string') {\n      // Attempt to detect the script from the string if not provided.\n      if (script == null) {\n        script = Script.forString(string);\n      }\n\n      var glyphs = this.font.glyphsForString(string);\n    } else {\n      // Attempt to detect the script from the glyph code points if not provided.\n      if (script == null) {\n        let codePoints = [];\n        for (let glyph of string) {\n          codePoints.push(...glyph.codePoints);\n        }\n\n        script = Script.forCodePoints(codePoints);\n      }\n\n      var glyphs = string;\n    }\n\n    let glyphRun = new GlyphRun(glyphs, features, script, language, direction);\n\n    // Return early if there are no glyphs\n    if (glyphs.length === 0) {\n      glyphRun.positions = [];\n      return glyphRun;\n    }\n\n    // Setup the advanced layout engine\n    if (this.engine && this.engine.setup) {\n      this.engine.setup(glyphRun);\n    }\n\n    // Substitute and position the glyphs\n    this.substitute(glyphRun);\n    this.position(glyphRun);\n\n    this.hideDefaultIgnorables(glyphRun.glyphs, glyphRun.positions);\n\n    // Let the layout engine clean up any state it might have\n    if (this.engine && this.engine.cleanup) {\n      this.engine.cleanup();\n    }\n\n    return glyphRun;\n  }\n\n  substitute(glyphRun) {\n    // Call the advanced layout engine to make substitutions\n    if (this.engine && this.engine.substitute) {\n      this.engine.substitute(glyphRun);\n    }\n  }\n\n  position(glyphRun) {\n    // Get initial glyph positions\n    glyphRun.positions = glyphRun.glyphs.map(glyph => new GlyphPosition(glyph.advanceWidth));\n    let positioned = null;\n\n    // Call the advanced layout engine. Returns the features applied.\n    if (this.engine && this.engine.position) {\n      positioned = this.engine.position(glyphRun);\n    }\n\n    // if there is no GPOS table, use unicode properties to position marks.\n    if (!positioned && (!this.engine || this.engine.fallbackPosition)) {\n      if (!this.unicodeLayoutEngine) {\n        this.unicodeLayoutEngine = new UnicodeLayoutEngine(this.font);\n      }\n\n      this.unicodeLayoutEngine.positionGlyphs(glyphRun.glyphs, glyphRun.positions);\n    }\n\n    // if kerning is not supported by GPOS, do kerning with the TrueType/AAT kern table\n    if ((!positioned || !positioned.kern) && glyphRun.features.kern !== false && this.font.kern) {\n      if (!this.kernProcessor) {\n        this.kernProcessor = new KernProcessor(this.font);\n      }\n\n      this.kernProcessor.process(glyphRun.glyphs, glyphRun.positions);\n      glyphRun.features.kern = true;\n    }\n  }\n\n  hideDefaultIgnorables(glyphs, positions) {\n    let space = this.font.glyphForCodePoint(0x20);\n    for (let i = 0; i < glyphs.length; i++) {\n      if (this.isDefaultIgnorable(glyphs[i].codePoints[0])) {\n        glyphs[i] = space;\n        positions[i].xAdvance = 0;\n        positions[i].yAdvance = 0;\n      }\n    }\n  }\n\n  isDefaultIgnorable(ch) {\n    // From DerivedCoreProperties.txt in the Unicode database,\n    // minus U+115F, U+1160, U+3164 and U+FFA0, which is what\n    // Harfbuzz and Uniscribe do.\n    let plane = ch >> 16;\n    if (plane === 0) {\n      // BMP\n      switch (ch >> 8) {\n      \tcase 0x00: return ch === 0x00AD;\n      \tcase 0x03: return ch === 0x034F;\n      \tcase 0x06: return ch === 0x061C;\n      \tcase 0x17: return 0x17B4 <= ch && ch <= 0x17B5;\n      \tcase 0x18: return 0x180B <= ch && ch <= 0x180E;\n      \tcase 0x20: return (0x200B <= ch && ch <= 0x200F) || (0x202A <= ch && ch <= 0x202E) || (0x2060 <= ch && ch <= 0x206F);\n      \tcase 0xFE: return (0xFE00 <= ch && ch <= 0xFE0F) || ch === 0xFEFF;\n      \tcase 0xFF: return 0xFFF0 <= ch && ch <= 0xFFF8;\n      \tdefault:   return false;\n      }\n    } else {\n      // Other planes\n      switch (plane) {\n      \tcase 0x01: return (0x1BCA0 <= ch && ch <= 0x1BCA3) || (0x1D173 <= ch && ch <= 0x1D17A);\n      \tcase 0x0E: return 0xE0000 <= ch && ch <= 0xE0FFF;\n      \tdefault:   return false;\n      }\n    }\n  }\n\n  getAvailableFeatures(script, language) {\n    let features = [];\n\n    if (this.engine) {\n      features.push(...this.engine.getAvailableFeatures(script, language));\n    }\n\n    if (this.font.kern && features.indexOf('kern') === -1) {\n      features.push('kern');\n    }\n\n    return features;\n  }\n\n  stringsForGlyph(gid) {\n    let result = new Set;\n\n    let codePoints = this.font._cmapProcessor.codePointsForGlyph(gid);\n    for (let codePoint of codePoints) {\n      result.add(String.fromCodePoint(codePoint));\n    }\n\n    if (this.engine && this.engine.stringsForGlyph) {\n      for (let string of this.engine.stringsForGlyph(gid)) {\n        result.add(string);\n      }\n    }\n\n    return Array.from(result);\n  }\n}\n","import {binarySearch} from '../utils';\n\nexport default class KernProcessor {\n  constructor(font) {\n    this.kern = font.kern;\n  }\n\n  process(glyphs, positions) {\n    for (let glyphIndex = 0; glyphIndex < glyphs.length - 1; glyphIndex++) {\n      let left = glyphs[glyphIndex].id;\n      let right = glyphs[glyphIndex + 1].id;\n      positions[glyphIndex].xAdvance += this.getKerning(left, right);\n    }\n  }\n\n  getKerning(left, right) {\n    let res = 0;\n\n    for (let table of this.kern.tables) {\n      if (table.coverage.crossStream) {\n        continue;\n      }\n\n      switch (table.version) {\n        case 0:\n          if (!table.coverage.horizontal) {\n            continue;\n          }\n\n          break;\n        case 1:\n          if (table.coverage.vertical || table.coverage.variation) {\n            continue;\n          }\n\n          break;\n        default:\n          throw new Error(`Unsupported kerning table version ${table.version}`);\n      }\n\n      let val = 0;\n      let s = table.subtable;\n      switch (table.format) {\n        case 0:\n          let pairIdx = binarySearch(s.pairs, function (pair) {\n            return (left - pair.left) || (right - pair.right);\n          });\n\n          if (pairIdx >= 0) {\n            val = s.pairs[pairIdx].value;\n          }\n\n          break;\n\n        case 2:\n          let leftOffset = 0, rightOffset = 0;\n          if (left >= s.leftTable.firstGlyph && left < s.leftTable.firstGlyph + s.leftTable.nGlyphs) {\n            leftOffset = s.leftTable.offsets[left - s.leftTable.firstGlyph];\n          } else {\n            leftOffset = s.array.off;\n          }\n\n          if (right >= s.rightTable.firstGlyph && right < s.rightTable.firstGlyph + s.rightTable.nGlyphs) {\n            rightOffset = s.rightTable.offsets[right - s.rightTable.firstGlyph];\n          }\n\n          let index = (leftOffset + rightOffset - s.array.off) / 2;\n          val = s.array.values.get(index);\n          break;\n\n        case 3:\n          if (left >= s.glyphCount || right >= s.glyphCount) {\n            return 0;\n          }\n\n          val = s.kernValue[s.kernIndex[s.leftClass[left] * s.rightClassCount + s.rightClass[right]]];\n          break;\n\n        default:\n          throw new Error(`Unsupported kerning sub-table format ${table.format}`);\n      }\n\n      // Microsoft supports the override flag, which resets the result\n      // Otherwise, the sum of the results from all subtables is returned\n      if (table.coverage.override) {\n        res = val;\n      } else {\n        res += val;\n      }\n    }\n\n    return res;\n  }\n}\n","import {getCombiningClass} from 'unicode-properties';\n\n/**\n * This class is used when GPOS does not define 'mark' or 'mkmk' features\n * for positioning marks relative to base glyphs. It uses the unicode\n * combining class property to position marks.\n *\n * Based on code from Harfbuzz, thanks!\n * https://github.com/behdad/harfbuzz/blob/master/src/hb-ot-shape-fallback.cc\n */\nexport default class UnicodeLayoutEngine {\n  constructor(font) {\n    this.font = font;\n  }\n\n  positionGlyphs(glyphs, positions) {\n    // find each base + mark cluster, and position the marks relative to the base\n    let clusterStart = 0;\n    let clusterEnd = 0;\n    for (let index = 0; index < glyphs.length; index++) {\n      let glyph = glyphs[index];\n      if (glyph.isMark) { // TODO: handle ligatures\n        clusterEnd = index;\n      } else {\n        if (clusterStart !== clusterEnd) {\n          this.positionCluster(glyphs, positions, clusterStart, clusterEnd);\n        }\n\n        clusterStart = clusterEnd = index;\n      }\n    }\n\n    if (clusterStart !== clusterEnd) {\n      this.positionCluster(glyphs, positions, clusterStart, clusterEnd);\n    }\n\n    return positions;\n  }\n\n  positionCluster(glyphs, positions, clusterStart, clusterEnd) {\n    let base = glyphs[clusterStart];\n    let baseBox = base.cbox.copy();\n\n    // adjust bounding box for ligature glyphs\n    if (base.codePoints.length > 1) {\n      // LTR. TODO: RTL support.\n      baseBox.minX += ((base.codePoints.length - 1) * baseBox.width) / base.codePoints.length;\n    }\n\n    let xOffset = -positions[clusterStart].xAdvance;\n    let yOffset = 0;\n    let yGap = this.font.unitsPerEm / 16;\n\n    // position each of the mark glyphs relative to the base glyph\n    for (let index = clusterStart + 1; index <= clusterEnd; index++) {\n      let mark = glyphs[index];\n      let markBox = mark.cbox;\n      let position = positions[index];\n\n      let combiningClass = this.getCombiningClass(mark.codePoints[0]);\n\n      if (combiningClass !== 'Not_Reordered') {\n        position.xOffset = position.yOffset = 0;\n\n        // x positioning\n        switch (combiningClass) {\n          case 'Double_Above':\n          case 'Double_Below':\n            // LTR. TODO: RTL support.\n            position.xOffset += baseBox.minX - markBox.width / 2 - markBox.minX;\n            break;\n\n          case 'Attached_Below_Left':\n          case 'Below_Left':\n          case 'Above_Left':\n            // left align\n            position.xOffset += baseBox.minX - markBox.minX;\n            break;\n\n          case 'Attached_Above_Right':\n          case 'Below_Right':\n          case 'Above_Right':\n            // right align\n            position.xOffset += baseBox.maxX - markBox.width - markBox.minX;\n            break;\n\n          default: // Attached_Below, Attached_Above, Below, Above, other\n            // center align\n            position.xOffset += baseBox.minX + (baseBox.width - markBox.width) / 2 - markBox.minX;\n        }\n\n        // y positioning\n        switch (combiningClass) {\n          case 'Double_Below':\n          case 'Below_Left':\n          case 'Below':\n          case 'Below_Right':\n          case 'Attached_Below_Left':\n          case 'Attached_Below':\n            // add a small gap between the glyphs if they are not attached\n            if (combiningClass === 'Attached_Below_Left' || combiningClass === 'Attached_Below') {\n              baseBox.minY += yGap;\n            }\n\n            position.yOffset = -baseBox.minY - markBox.maxY;\n            baseBox.minY += markBox.height;\n            break;\n\n          case 'Double_Above':\n          case 'Above_Left':\n          case 'Above':\n          case 'Above_Right':\n          case 'Attached_Above':\n          case 'Attached_Above_Right':\n            // add a small gap between the glyphs if they are not attached\n            if (combiningClass === 'Attached_Above' || combiningClass === 'Attached_Above_Right') {\n              baseBox.maxY += yGap;\n            }\n\n            position.yOffset = baseBox.maxY - markBox.minY;\n            baseBox.maxY += markBox.height;\n            break;\n        }\n\n        position.xAdvance = position.yAdvance = 0;\n        position.xOffset += xOffset;\n        position.yOffset += yOffset;\n\n      } else {\n        xOffset -= position.xAdvance;\n        yOffset -= position.yAdvance;\n      }\n    }\n\n    return;\n  }\n\n  getCombiningClass(codePoint) {\n    let combiningClass = getCombiningClass(codePoint);\n\n    // Thai / Lao need some per-character work\n    if ((codePoint & ~0xff) === 0x0e00) {\n      if (combiningClass === 'Not_Reordered') {\n        switch (codePoint) {\n          case 0x0e31:\n          case 0x0e34:\n          case 0x0e35:\n          case 0x0e36:\n          case 0x0e37:\n          case 0x0e47:\n          case 0x0e4c:\n          case 0x0e3d:\n          case 0x0e4e:\n            return 'Above_Right';\n\n          case 0x0eb1:\n          case 0x0eb4:\n          case 0x0eb5:\n          case 0x0eb6:\n          case 0x0eb7:\n          case 0x0ebb:\n          case 0x0ecc:\n          case 0x0ecd:\n            return 'Above';\n\n          case 0x0ebc:\n            return 'Below';\n        }\n      } else if (codePoint === 0x0e3a) { // virama\n        return 'Below_Right';\n      }\n    }\n\n    switch (combiningClass) {\n      // Hebrew\n\n      case 'CCC10': // sheva\n      case 'CCC11': // hataf segol\n      case 'CCC12': // hataf patah\n      case 'CCC13': // hataf qamats\n      case 'CCC14': // hiriq\n      case 'CCC15': // tsere\n      case 'CCC16': // segol\n      case 'CCC17': // patah\n      case 'CCC18': // qamats\n      case 'CCC20': // qubuts\n      case 'CCC22': // meteg\n        return 'Below';\n\n      case 'CCC23': // rafe\n        return 'Attached_Above';\n\n      case 'CCC24': // shin dot\n        return 'Above_Right';\n\n      case 'CCC25': // sin dot\n      case 'CCC19': // holam\n        return 'Above_Left';\n\n      case 'CCC26': // point varika\n        return 'Above';\n\n      case 'CCC21': // dagesh\n        break;\n\n      // Arabic and Syriac\n\n      case 'CCC27': // fathatan\n      case 'CCC28': // dammatan\n      case 'CCC30': // fatha\n      case 'CCC31': // damma\n      case 'CCC33': // shadda\n      case 'CCC34': // sukun\n      case 'CCC35': // superscript alef\n      case 'CCC36': // superscript alaph\n        return 'Above';\n\n      case 'CCC29': // kasratan\n      case 'CCC32': // kasra\n        return 'Below';\n\n      // Thai\n\n      case 'CCC103': // sara u / sara uu\n        return 'Below_Right';\n\n      case 'CCC107': // mai\n        return 'Above_Right';\n\n      // Lao\n\n      case 'CCC118': // sign u / sign uu\n        return 'Below';\n\n      case 'CCC122': // mai\n        return 'Above';\n\n      // Tibetan\n\n      case 'CCC129': // sign aa\n      case 'CCC132': // sign u\n        return 'Below';\n\n      case 'CCC130': // sign i\n        return 'Above';\n    }\n\n    return combiningClass;\n  }\n}\n","import BBox from '../glyph/BBox';\nimport * as Script from '../layout/Script';\n\n/**\n * Represents a run of Glyph and GlyphPosition objects.\n * Returned by the font layout method.\n */\nexport default class GlyphRun {\n  constructor(glyphs, features, script, language, direction) {\n    /**\n     * An array of Glyph objects in the run\n     * @type {Glyph[]}\n     */\n    this.glyphs = glyphs;\n\n    /**\n     * An array of GlyphPosition objects for each glyph in the run\n     * @type {GlyphPosition[]}\n     */\n    this.positions = null;\n\n    /**\n     * The script that was requested for shaping. This was either passed in or detected automatically.\n     * @type {string}\n     */\n    this.script = script;\n\n    /**\n     * The language requested for shaping, as passed in. If `null`, the default language for the\n     * script was used.\n     * @type {string}\n     */\n    this.language = language || null;\n\n    /**\n     * The direction requested for shaping, as passed in (either ltr or rtl).\n     * If `null`, the default direction of the script is used.\n     * @type {string}\n     */\n    this.direction = direction || Script.direction(script);\n\n    /**\n     * The features requested during shaping. This is a combination of user\n     * specified features and features chosen by the shaper.\n     * @type {object}\n     */\n    this.features = {};\n\n    // Convert features to an object\n    if (Array.isArray(features)) {\n      for (let tag of features) {\n        this.features[tag] = true;\n      }\n    } else if (typeof features === 'object') {\n      this.features = features;\n    }\n  }\n\n  /**\n   * The total advance width of the run.\n   * @type {number}\n   */\n  get advanceWidth() {\n    let width = 0;\n    for (let position of this.positions) {\n      width += position.xAdvance;\n    }\n\n    return width;\n  }\n\n /**\n  * The total advance height of the run.\n  * @type {number}\n  */\n  get advanceHeight() {\n    let height = 0;\n    for (let position of this.positions) {\n      height += position.yAdvance;\n    }\n\n    return height;\n  }\n\n /**\n  * The bounding box containing all glyphs in the run.\n  * @type {BBox}\n  */\n  get bbox() {\n    let bbox = new BBox;\n\n    let x = 0;\n    let y = 0;\n    for (let index = 0; index < this.glyphs.length; index++) {\n      let glyph = this.glyphs[index];\n      let p = this.positions[index];\n      let b = glyph.bbox;\n\n      bbox.addPoint(b.minX + x + p.xOffset, b.minY + y + p.yOffset);\n      bbox.addPoint(b.maxX + x + p.xOffset, b.maxY + y + p.yOffset);\n\n      x += p.xAdvance;\n      y += p.yAdvance;\n    }\n\n    return bbox;\n  }\n}\n","/**\n * Represents a glyph bounding box\n */\nexport default class BBox {\n  constructor(minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity) {\n    /**\n     * The minimum X position in the bounding box\n     * @type {number}\n     */\n    this.minX = minX;\n\n    /**\n     * The minimum Y position in the bounding box\n     * @type {number}\n     */\n    this.minY = minY;\n\n    /**\n     * The maxmimum X position in the bounding box\n     * @type {number}\n     */\n    this.maxX = maxX;\n\n    /**\n     * The maxmimum Y position in the bounding box\n     * @type {number}\n     */\n    this.maxY = maxY;\n  }\n\n  /**\n   * The width of the bounding box\n   * @type {number}\n   */\n  get width() {\n    return this.maxX - this.minX;\n  }\n\n  /**\n   * The height of the bounding box\n   * @type {number}\n   */\n  get height() {\n    return this.maxY - this.minY;\n  }\n\n  addPoint(x, y) {\n    if (Math.abs(x) !== Infinity) {\n      if (x < this.minX) {\n        this.minX = x;\n      }\n\n      if (x > this.maxX) {\n        this.maxX = x;\n      }\n    }\n\n    if (Math.abs(y) !== Infinity) {\n      if (y < this.minY) {\n        this.minY = y;\n      }\n\n      if (y > this.maxY) {\n        this.maxY = y;\n      }\n    }\n  }\n\n  copy() {\n    return new BBox(this.minX, this.minY, this.maxX, this.maxY);\n  }\n}\n","import {getScript} from 'unicode-properties';\n\n// This maps the Unicode Script property to an OpenType script tag\n// Data from http://www.microsoft.com/typography/otspec/scripttags.htm\n// and http://www.unicode.org/Public/UNIDATA/PropertyValueAliases.txt.\nconst UNICODE_SCRIPTS = {\n  Caucasian_Albanian: 'aghb',\n  Arabic: 'arab',\n  Imperial_Aramaic: 'armi',\n  Armenian: 'armn',\n  Avestan: 'avst',\n  Balinese: 'bali',\n  Bamum: 'bamu',\n  Bassa_Vah: 'bass',\n  Batak: 'batk',\n  Bengali: ['bng2', 'beng'],\n  Bopomofo: 'bopo',\n  Brahmi: 'brah',\n  Braille: 'brai',\n  Buginese: 'bugi',\n  Buhid: 'buhd',\n  Chakma: 'cakm',\n  Canadian_Aboriginal: 'cans',\n  Carian: 'cari',\n  Cham: 'cham',\n  Cherokee: 'cher',\n  Coptic: 'copt',\n  Cypriot: 'cprt',\n  Cyrillic: 'cyrl',\n  Devanagari: ['dev2', 'deva'],\n  Deseret: 'dsrt',\n  Duployan: 'dupl',\n  Egyptian_Hieroglyphs: 'egyp',\n  Elbasan: 'elba',\n  Ethiopic: 'ethi',\n  Georgian: 'geor',\n  Glagolitic: 'glag',\n  Gothic: 'goth',\n  Grantha: 'gran',\n  Greek: 'grek',\n  Gujarati: ['gjr2', 'gujr'],\n  Gurmukhi: ['gur2', 'guru'],\n  Hangul: 'hang',\n  Han: 'hani',\n  Hanunoo: 'hano',\n  Hebrew: 'hebr',\n  Hiragana: 'hira',\n  Pahawh_Hmong: 'hmng',\n  Katakana_Or_Hiragana: 'hrkt',\n  Old_Italic: 'ital',\n  Javanese: 'java',\n  Kayah_Li: 'kali',\n  Katakana: 'kana',\n  Kharoshthi: 'khar',\n  Khmer: 'khmr',\n  Khojki: 'khoj',\n  Kannada: ['knd2', 'knda'],\n  Kaithi: 'kthi',\n  Tai_Tham: 'lana',\n  Lao: 'lao ',\n  Latin: 'latn',\n  Lepcha: 'lepc',\n  Limbu: 'limb',\n  Linear_A: 'lina',\n  Linear_B: 'linb',\n  Lisu: 'lisu',\n  Lycian: 'lyci',\n  Lydian: 'lydi',\n  Mahajani: 'mahj',\n  Mandaic: 'mand',\n  Manichaean: 'mani',\n  Mende_Kikakui: 'mend',\n  Meroitic_Cursive: 'merc',\n  Meroitic_Hieroglyphs: 'mero',\n  Malayalam: ['mlm2', 'mlym'],\n  Modi: 'modi',\n  Mongolian: 'mong',\n  Mro: 'mroo',\n  Meetei_Mayek: 'mtei',\n  Myanmar: ['mym2', 'mymr'],\n  Old_North_Arabian: 'narb',\n  Nabataean: 'nbat',\n  Nko: 'nko ',\n  Ogham: 'ogam',\n  Ol_Chiki: 'olck',\n  Old_Turkic: 'orkh',\n  Oriya: ['ory2', 'orya'],\n  Osmanya: 'osma',\n  Palmyrene: 'palm',\n  Pau_Cin_Hau: 'pauc',\n  Old_Permic: 'perm',\n  Phags_Pa: 'phag',\n  Inscriptional_Pahlavi: 'phli',\n  Psalter_Pahlavi: 'phlp',\n  Phoenician: 'phnx',\n  Miao: 'plrd',\n  Inscriptional_Parthian: 'prti',\n  Rejang: 'rjng',\n  Runic: 'runr',\n  Samaritan: 'samr',\n  Old_South_Arabian: 'sarb',\n  Saurashtra: 'saur',\n  Shavian: 'shaw',\n  Sharada: 'shrd',\n  Siddham: 'sidd',\n  Khudawadi: 'sind',\n  Sinhala: 'sinh',\n  Sora_Sompeng: 'sora',\n  Sundanese: 'sund',\n  Syloti_Nagri: 'sylo',\n  Syriac: 'syrc',\n  Tagbanwa: 'tagb',\n  Takri: 'takr',\n  Tai_Le: 'tale',\n  New_Tai_Lue: 'talu',\n  Tamil: ['tml2', 'taml'],\n  Tai_Viet: 'tavt',\n  Telugu: ['tel2', 'telu'],\n  Tifinagh: 'tfng',\n  Tagalog: 'tglg',\n  Thaana: 'thaa',\n  Thai: 'thai',\n  Tibetan: 'tibt',\n  Tirhuta: 'tirh',\n  Ugaritic: 'ugar',\n  Vai: 'vai ',\n  Warang_Citi: 'wara',\n  Old_Persian: 'xpeo',\n  Cuneiform: 'xsux',\n  Yi: 'yi  ',\n  Inherited: 'zinh',\n  Common: 'zyyy',\n  Unknown: 'zzzz'\n};\n\nconst OPENTYPE_SCRIPTS = {};\nfor (let script in UNICODE_SCRIPTS) {\n  let tag = UNICODE_SCRIPTS[script];\n  if (Array.isArray(tag)) {\n    for (let t of tag) {\n      OPENTYPE_SCRIPTS[t] = script;\n    }\n  } else {\n    OPENTYPE_SCRIPTS[tag] = script;\n  }\n}\n\nexport function fromUnicode(script) {\n  return UNICODE_SCRIPTS[script];\n}\n\nexport function fromOpenType(tag) {\n  return OPENTYPE_SCRIPTS[tag];\n}\n\nexport function forString(string) {\n  let len = string.length;\n  let idx = 0;\n  while (idx < len) {\n    let code = string.charCodeAt(idx++);\n\n    // Check if this is a high surrogate\n    if (0xd800 <= code && code <= 0xdbff && idx < len) {\n      let next = string.charCodeAt(idx);\n\n      // Check if this is a low surrogate\n      if (0xdc00 <= next && next <= 0xdfff) {\n        idx++;\n        code = ((code & 0x3FF) << 10) + (next & 0x3FF) + 0x10000;\n      }\n    }\n\n    let script = getScript(code);\n    if (script !== 'Common' && script !== 'Inherited' && script !== 'Unknown') {\n      return UNICODE_SCRIPTS[script];\n    }\n  }\n\n  return UNICODE_SCRIPTS.Unknown;\n}\n\nexport function forCodePoints(codePoints) {\n  for (let i = 0; i < codePoints.length; i++) {\n    let codePoint = codePoints[i];\n    let script = getScript(codePoint);\n    if (script !== 'Common' && script !== 'Inherited' && script !== 'Unknown') {\n      return UNICODE_SCRIPTS[script];\n    }\n  }\n\n  return UNICODE_SCRIPTS.Unknown;\n}\n\n// The scripts in this map are written from right to left\nconst RTL = {\n  arab: true,   // Arabic\n  hebr: true,   // Hebrew\n  syrc: true,   // Syriac\n  thaa: true,   // Thaana\n  cprt: true,   // Cypriot Syllabary\n  khar: true,   // Kharosthi\n  phnx: true,   // Phoenician\n  'nko ': true, // N'Ko\n  lydi: true,   // Lydian\n  avst: true,   // Avestan\n  armi: true,   // Imperial Aramaic\n  phli: true,   // Inscriptional Pahlavi\n  prti: true,   // Inscriptional Parthian\n  sarb: true,   // Old South Arabian\n  orkh: true,   // Old Turkic, Orkhon Runic\n  samr: true,   // Samaritan\n  mand: true,   // Mandaic, Mandaean\n  merc: true,   // Meroitic Cursive\n  mero: true,   // Meroitic Hieroglyphs\n\n  // Unicode 7.0 (not listed on http://www.microsoft.com/typography/otspec/scripttags.htm)\n  mani: true,   // Manichaean\n  mend: true,   // Mende Kikakui\n  nbat: true,   // Nabataean\n  narb: true,   // Old North Arabian\n  palm: true,   // Palmyrene\n  phlp: true    // Psalter Pahlavi\n};\n\nexport function direction(script) {\n  if (RTL[script]) {\n    return 'rtl';\n  }\n\n  return 'ltr';\n}\n","/**\n * Represents positioning information for a glyph in a GlyphRun.\n */\nexport default class GlyphPosition {\n  constructor(xAdvance = 0, yAdvance = 0, xOffset = 0, yOffset = 0) {\n    /**\n     * The amount to move the virtual pen in the X direction after rendering this glyph.\n     * @type {number}\n     */\n    this.xAdvance = xAdvance;\n\n    /**\n     * The amount to move the virtual pen in the Y direction after rendering this glyph.\n     * @type {number}\n     */\n    this.yAdvance = yAdvance;\n\n    /**\n     * The offset from the pen position in the X direction at which to render this glyph.\n     * @type {number}\n     */\n    this.xOffset = xOffset;\n\n    /**\n     * The offset from the pen position in the Y direction at which to render this glyph.\n     * @type {number}\n     */\n    this.yOffset = yOffset;\n  }\n}\n","import * as AATFeatureMap from './AATFeatureMap';\nimport * as Script from '../layout/Script';\nimport AATMorxProcessor from './AATMorxProcessor';\n\nexport default class AATLayoutEngine {\n  constructor(font) {\n    this.font = font;\n    this.morxProcessor = new AATMorxProcessor(font);\n    this.fallbackPosition = false;\n  }\n\n  substitute(glyphRun) {\n    // AAT expects the glyphs to be in visual order prior to morx processing,\n    // so reverse the glyphs if the script is right-to-left.\n    if (glyphRun.direction === 'rtl') {\n      glyphRun.glyphs.reverse();\n    }\n\n    this.morxProcessor.process(glyphRun.glyphs, AATFeatureMap.mapOTToAAT(glyphRun.features));\n  }\n\n  getAvailableFeatures(script, language) {\n    return AATFeatureMap.mapAATToOT(this.morxProcessor.getSupportedFeatures());\n  }\n\n  stringsForGlyph(gid) {\n    let glyphStrings = this.morxProcessor.generateInputs(gid);\n    let result = new Set;\n\n    for (let glyphs of glyphStrings) {\n      this._addStrings(glyphs, 0, result, '');\n    }\n\n    return result;\n  }\n\n  _addStrings(glyphs, index, strings, string) {\n    let codePoints = this.font._cmapProcessor.codePointsForGlyph(glyphs[index]);\n\n    for (let codePoint of codePoints) {\n      let s = string + String.fromCodePoint(codePoint);\n      if (index < glyphs.length - 1) {\n        this._addStrings(glyphs, index + 1, strings, s);\n      } else {\n        strings.add(s);\n      }\n    }\n  }\n}\n","// see https://developer.apple.com/fonts/TrueType-Reference-Manual/RM09/AppendixF.html\n// and /System/Library/Frameworks/CoreText.framework/Versions/A/Headers/SFNTLayoutTypes.h on a Mac\nconst features = {\n  allTypographicFeatures: {\n    code: 0,\n    exclusive: false,\n    allTypeFeatures: 0\n  },\n  ligatures: {\n    code: 1,\n    exclusive: false,\n    requiredLigatures: 0,\n    commonLigatures: 2,\n    rareLigatures: 4,\n    // logos: 6\n    rebusPictures: 8,\n    diphthongLigatures: 10,\n    squaredLigatures: 12,\n    abbrevSquaredLigatures: 14,\n    symbolLigatures: 16,\n    contextualLigatures: 18,\n    historicalLigatures: 20\n  },\n  cursiveConnection: {\n    code: 2,\n    exclusive: true,\n    unconnected: 0,\n    partiallyConnected: 1,\n    cursive: 2\n  },\n  letterCase: {\n    code: 3,\n    exclusive: true\n  },\n    // upperAndLowerCase: 0          # deprecated\n    // allCaps: 1                    # deprecated\n    // allLowerCase: 2               # deprecated\n    // smallCaps: 3                  # deprecated\n    // initialCaps: 4                # deprecated\n    // initialCapsAndSmallCaps: 5    # deprecated\n  verticalSubstitution: {\n    code: 4,\n    exclusive: false,\n    substituteVerticalForms: 0\n  },\n  linguisticRearrangement: {\n    code: 5,\n    exclusive: false,\n    linguisticRearrangement: 0\n  },\n  numberSpacing: {\n    code: 6,\n    exclusive: true,\n    monospacedNumbers: 0,\n    proportionalNumbers: 1,\n    thirdWidthNumbers: 2,\n    quarterWidthNumbers: 3\n  },\n  smartSwash: {\n    code: 8,\n    exclusive: false,\n    wordInitialSwashes: 0,\n    wordFinalSwashes: 2,\n    // lineInitialSwashes: 4\n    // lineFinalSwashes: 6\n    nonFinalSwashes: 8\n  },\n  diacritics: {\n    code: 9,\n    exclusive: true,\n    showDiacritics: 0,\n    hideDiacritics: 1,\n    decomposeDiacritics: 2\n  },\n  verticalPosition: {\n    code: 10,\n    exclusive: true,\n    normalPosition: 0,\n    superiors: 1,\n    inferiors: 2,\n    ordinals: 3,\n    scientificInferiors: 4\n  },\n  fractions: {\n    code: 11,\n    exclusive: true,\n    noFractions: 0,\n    verticalFractions: 1,\n    diagonalFractions: 2\n  },\n  overlappingCharacters: {\n    code: 13,\n    exclusive: false,\n    preventOverlap: 0\n  },\n  typographicExtras: {\n    code: 14,\n    exclusive: false,\n    // hyphensToEmDash: 0\n    // hyphenToEnDash: 2\n    slashedZero: 4\n  },\n    // formInterrobang: 6\n    // smartQuotes: 8\n    // periodsToEllipsis: 10\n  mathematicalExtras: {\n    code: 15,\n    exclusive: false,\n    // hyphenToMinus: 0\n    // asteristoMultiply: 2\n    // slashToDivide: 4\n    // inequalityLigatures: 6\n    // exponents: 8\n    mathematicalGreek: 10\n  },\n  ornamentSets: {\n    code: 16,\n    exclusive: true,\n    noOrnaments: 0,\n    dingbats: 1,\n    piCharacters: 2,\n    fleurons: 3,\n    decorativeBorders: 4,\n    internationalSymbols: 5,\n    mathSymbols: 6\n  },\n  characterAlternatives: {\n    code: 17,\n    exclusive: true,\n    noAlternates: 0\n  },\n    // user defined options\n  designComplexity: {\n    code: 18,\n    exclusive: true,\n    designLevel1: 0,\n    designLevel2: 1,\n    designLevel3: 2,\n    designLevel4: 3,\n    designLevel5: 4\n  },\n  styleOptions: {\n    code: 19,\n    exclusive: true,\n    noStyleOptions: 0,\n    displayText: 1,\n    engravedText: 2,\n    illuminatedCaps: 3,\n    titlingCaps: 4,\n    tallCaps: 5\n  },\n  characterShape: {\n    code: 20,\n    exclusive: true,\n    traditionalCharacters: 0,\n    simplifiedCharacters: 1,\n    JIS1978Characters: 2,\n    JIS1983Characters: 3,\n    JIS1990Characters: 4,\n    traditionalAltOne: 5,\n    traditionalAltTwo: 6,\n    traditionalAltThree: 7,\n    traditionalAltFour: 8,\n    traditionalAltFive: 9,\n    expertCharacters: 10,\n    JIS2004Characters: 11,\n    hojoCharacters: 12,\n    NLCCharacters: 13,\n    traditionalNamesCharacters: 14\n  },\n  numberCase: {\n    code: 21,\n    exclusive: true,\n    lowerCaseNumbers: 0,\n    upperCaseNumbers: 1\n  },\n  textSpacing: {\n    code: 22,\n    exclusive: true,\n    proportionalText: 0,\n    monospacedText: 1,\n    halfWidthText: 2,\n    thirdWidthText: 3,\n    quarterWidthText: 4,\n    altProportionalText: 5,\n    altHalfWidthText: 6\n  },\n  transliteration: {\n    code: 23,\n    exclusive: true,\n    noTransliteration: 0\n  },\n    // hanjaToHangul: 1\n    // hiraganaToKatakana: 2\n    // katakanaToHiragana: 3\n    // kanaToRomanization: 4\n    // romanizationToHiragana: 5\n    // romanizationToKatakana: 6\n    // hanjaToHangulAltOne: 7\n    // hanjaToHangulAltTwo: 8\n    // hanjaToHangulAltThree: 9\n  annotation: {\n    code: 24,\n    exclusive: true,\n    noAnnotation: 0,\n    boxAnnotation: 1,\n    roundedBoxAnnotation: 2,\n    circleAnnotation: 3,\n    invertedCircleAnnotation: 4,\n    parenthesisAnnotation: 5,\n    periodAnnotation: 6,\n    romanNumeralAnnotation: 7,\n    diamondAnnotation: 8,\n    invertedBoxAnnotation: 9,\n    invertedRoundedBoxAnnotation: 10\n  },\n  kanaSpacing: {\n    code: 25,\n    exclusive: true,\n    fullWidthKana: 0,\n    proportionalKana: 1\n  },\n  ideographicSpacing: {\n    code: 26,\n    exclusive: true,\n    fullWidthIdeographs: 0,\n    proportionalIdeographs: 1,\n    halfWidthIdeographs: 2\n  },\n  unicodeDecomposition: {\n    code: 27,\n    exclusive: false,\n    canonicalComposition: 0,\n    compatibilityComposition: 2,\n    transcodingComposition: 4\n  },\n  rubyKana: {\n    code: 28,\n    exclusive: false,\n    // noRubyKana: 0     # deprecated - use rubyKanaOff instead\n    // rubyKana: 1     # deprecated - use rubyKanaOn instead\n    rubyKana: 2\n  },\n  CJKSymbolAlternatives: {\n    code: 29,\n    exclusive: true,\n    noCJKSymbolAlternatives: 0,\n    CJKSymbolAltOne: 1,\n    CJKSymbolAltTwo: 2,\n    CJKSymbolAltThree: 3,\n    CJKSymbolAltFour: 4,\n    CJKSymbolAltFive: 5\n  },\n  ideographicAlternatives: {\n    code: 30,\n    exclusive: true,\n    noIdeographicAlternatives: 0,\n    ideographicAltOne: 1,\n    ideographicAltTwo: 2,\n    ideographicAltThree: 3,\n    ideographicAltFour: 4,\n    ideographicAltFive: 5\n  },\n  CJKVerticalRomanPlacement: {\n    code: 31,\n    exclusive: true,\n    CJKVerticalRomanCentered: 0,\n    CJKVerticalRomanHBaseline: 1\n  },\n  italicCJKRoman: {\n    code: 32,\n    exclusive: false,\n    // noCJKItalicRoman: 0     # deprecated - use CJKItalicRomanOff instead\n    // CJKItalicRoman: 1     # deprecated - use CJKItalicRomanOn instead\n    CJKItalicRoman: 2\n  },\n  caseSensitiveLayout: {\n    code: 33,\n    exclusive: false,\n    caseSensitiveLayout: 0,\n    caseSensitiveSpacing: 2\n  },\n  alternateKana: {\n    code: 34,\n    exclusive: false,\n    alternateHorizKana: 0,\n    alternateVertKana: 2\n  },\n  stylisticAlternatives: {\n    code: 35,\n    exclusive: false,\n    noStylisticAlternates: 0,\n    stylisticAltOne: 2,\n    stylisticAltTwo: 4,\n    stylisticAltThree: 6,\n    stylisticAltFour: 8,\n    stylisticAltFive: 10,\n    stylisticAltSix: 12,\n    stylisticAltSeven: 14,\n    stylisticAltEight: 16,\n    stylisticAltNine: 18,\n    stylisticAltTen: 20,\n    stylisticAltEleven: 22,\n    stylisticAltTwelve: 24,\n    stylisticAltThirteen: 26,\n    stylisticAltFourteen: 28,\n    stylisticAltFifteen: 30,\n    stylisticAltSixteen: 32,\n    stylisticAltSeventeen: 34,\n    stylisticAltEighteen: 36,\n    stylisticAltNineteen: 38,\n    stylisticAltTwenty: 40\n  },\n  contextualAlternates: {\n    code: 36,\n    exclusive: false,\n    contextualAlternates: 0,\n    swashAlternates: 2,\n    contextualSwashAlternates: 4\n  },\n  lowerCase: {\n    code: 37,\n    exclusive: true,\n    defaultLowerCase: 0,\n    lowerCaseSmallCaps: 1,\n    lowerCasePetiteCaps: 2\n  },\n  upperCase: {\n    code: 38,\n    exclusive: true,\n    defaultUpperCase: 0,\n    upperCaseSmallCaps: 1,\n    upperCasePetiteCaps: 2\n  },\n  languageTag: { // indices into ltag table\n    code: 39,\n    exclusive: true\n  },\n  CJKRomanSpacing: {\n    code: 103,\n    exclusive: true,\n    halfWidthCJKRoman: 0,\n    proportionalCJKRoman: 1,\n    defaultCJKRoman: 2,\n    fullWidthCJKRoman: 3\n  }\n};\n\nconst feature = (name, selector) => [features[name].code, features[name][selector]];\n\nconst OTMapping = {\n  rlig: feature('ligatures', 'requiredLigatures'),\n  clig: feature('ligatures', 'contextualLigatures'),\n  dlig: feature('ligatures', 'rareLigatures'),\n  hlig: feature('ligatures', 'historicalLigatures'),\n  liga: feature('ligatures', 'commonLigatures'),\n  hist: feature('ligatures', 'historicalLigatures'), // ??\n\n  smcp: feature('lowerCase', 'lowerCaseSmallCaps'),\n  pcap: feature('lowerCase', 'lowerCasePetiteCaps'),\n\n  frac: feature('fractions', 'diagonalFractions'),\n  dnom: feature('fractions', 'diagonalFractions'), // ??\n  numr: feature('fractions', 'diagonalFractions'), // ??\n  afrc: feature('fractions', 'verticalFractions'),\n  // aalt\n  // abvf, abvm, abvs, akhn, blwf, blwm, blws, cfar, cjct, cpsp, falt, isol, jalt, ljmo, mset?\n  // ltra, ltrm, nukt, pref, pres, pstf, psts, rand, rkrf, rphf, rtla, rtlm, size, tjmo, tnum?\n  // unic, vatu, vhal, vjmo, vpal, vrt2\n  // dist -> trak table?\n  // kern, vkrn -> kern table\n  // lfbd + opbd + rtbd -> opbd table?\n  // mark, mkmk -> acnt table?\n  // locl -> languageTag + ltag table\n\n  case: feature('caseSensitiveLayout', 'caseSensitiveLayout'), // also caseSensitiveSpacing\n  ccmp: feature('unicodeDecomposition', 'canonicalComposition'), // compatibilityComposition?\n  cpct: feature('CJKVerticalRomanPlacement', 'CJKVerticalRomanCentered'), // guess..., probably not given below\n  valt: feature('CJKVerticalRomanPlacement', 'CJKVerticalRomanCentered'),\n  swsh: feature('contextualAlternates', 'swashAlternates'),\n  cswh: feature('contextualAlternates', 'contextualSwashAlternates'),\n  curs: feature('cursiveConnection', 'cursive'), // ??\n  c2pc: feature('upperCase', 'upperCasePetiteCaps'),\n  c2sc: feature('upperCase', 'upperCaseSmallCaps'),\n\n  init: feature('smartSwash', 'wordInitialSwashes'), // ??\n  fin2: feature('smartSwash', 'wordFinalSwashes'), // ??\n  medi: feature('smartSwash', 'nonFinalSwashes'), // ??\n  med2: feature('smartSwash', 'nonFinalSwashes'), // ??\n  fin3: feature('smartSwash', 'wordFinalSwashes'), // ??\n  fina: feature('smartSwash', 'wordFinalSwashes'), // ??\n\n  pkna: feature('kanaSpacing', 'proportionalKana'),\n  half: feature('textSpacing', 'halfWidthText'), // also HalfWidthCJKRoman, HalfWidthIdeographs?\n  halt: feature('textSpacing', 'altHalfWidthText'),\n\n  hkna: feature('alternateKana', 'alternateHorizKana'),\n  vkna: feature('alternateKana', 'alternateVertKana'),\n  // hngl: feature 'transliteration', 'hanjaToHangulSelector' # deprecated\n\n  ital: feature('italicCJKRoman', 'CJKItalicRoman'),\n  lnum: feature('numberCase', 'upperCaseNumbers'),\n  onum: feature('numberCase', 'lowerCaseNumbers'),\n  mgrk: feature('mathematicalExtras', 'mathematicalGreek'),\n\n  // nalt: not enough info. what type of annotation?\n  // ornm: ditto, which ornament style?\n\n  calt: feature('contextualAlternates', 'contextualAlternates'), // or more?\n  vrt2: feature('verticalSubstitution', 'substituteVerticalForms'), // oh... below?\n  vert: feature('verticalSubstitution', 'substituteVerticalForms'),\n  tnum: feature('numberSpacing', 'monospacedNumbers'),\n  pnum: feature('numberSpacing', 'proportionalNumbers'),\n  sups: feature('verticalPosition', 'superiors'),\n  subs: feature('verticalPosition', 'inferiors'),\n  ordn: feature('verticalPosition', 'ordinals'),\n  pwid: feature('textSpacing', 'proportionalText'),\n  hwid: feature('textSpacing', 'halfWidthText'),\n  qwid: feature('textSpacing', 'quarterWidthText'), // also QuarterWidthNumbers?\n  twid: feature('textSpacing', 'thirdWidthText'), // also ThirdWidthNumbers?\n  fwid: feature('textSpacing', 'proportionalText'), //??\n  palt: feature('textSpacing', 'altProportionalText'),\n  trad: feature('characterShape', 'traditionalCharacters'),\n  smpl: feature('characterShape', 'simplifiedCharacters'),\n  jp78: feature('characterShape', 'JIS1978Characters'),\n  jp83: feature('characterShape', 'JIS1983Characters'),\n  jp90: feature('characterShape', 'JIS1990Characters'),\n  jp04: feature('characterShape', 'JIS2004Characters'),\n  expt: feature('characterShape', 'expertCharacters'),\n  hojo: feature('characterShape', 'hojoCharacters'),\n  nlck: feature('characterShape', 'NLCCharacters'),\n  tnam: feature('characterShape', 'traditionalNamesCharacters'),\n  ruby: feature('rubyKana', 'rubyKana'),\n  titl: feature('styleOptions', 'titlingCaps'),\n  zero: feature('typographicExtras', 'slashedZero'),\n\n  ss01: feature('stylisticAlternatives', 'stylisticAltOne'),\n  ss02: feature('stylisticAlternatives', 'stylisticAltTwo'),\n  ss03: feature('stylisticAlternatives', 'stylisticAltThree'),\n  ss04: feature('stylisticAlternatives', 'stylisticAltFour'),\n  ss05: feature('stylisticAlternatives', 'stylisticAltFive'),\n  ss06: feature('stylisticAlternatives', 'stylisticAltSix'),\n  ss07: feature('stylisticAlternatives', 'stylisticAltSeven'),\n  ss08: feature('stylisticAlternatives', 'stylisticAltEight'),\n  ss09: feature('stylisticAlternatives', 'stylisticAltNine'),\n  ss10: feature('stylisticAlternatives', 'stylisticAltTen'),\n  ss11: feature('stylisticAlternatives', 'stylisticAltEleven'),\n  ss12: feature('stylisticAlternatives', 'stylisticAltTwelve'),\n  ss13: feature('stylisticAlternatives', 'stylisticAltThirteen'),\n  ss14: feature('stylisticAlternatives', 'stylisticAltFourteen'),\n  ss15: feature('stylisticAlternatives', 'stylisticAltFifteen'),\n  ss16: feature('stylisticAlternatives', 'stylisticAltSixteen'),\n  ss17: feature('stylisticAlternatives', 'stylisticAltSeventeen'),\n  ss18: feature('stylisticAlternatives', 'stylisticAltEighteen'),\n  ss19: feature('stylisticAlternatives', 'stylisticAltNineteen'),\n  ss20: feature('stylisticAlternatives', 'stylisticAltTwenty')\n};\n\n  // salt: feature 'stylisticAlternatives', 'stylisticAltOne' # hmm, which one to choose\n\n// Add cv01-cv99 features\nfor (let i = 1; i <= 99; i++) {\n  OTMapping[`cv${`00${i}`.slice(-2)}`] = [features.characterAlternatives.code, i];\n}\n\n// create inverse mapping\nlet AATMapping = {};\nfor (let ot in OTMapping) {\n  let aat = OTMapping[ot];\n  if (AATMapping[aat[0]] == null) {\n    AATMapping[aat[0]] = {};\n  }\n\n  AATMapping[aat[0]][aat[1]] = ot;\n}\n\n// Maps an array of OpenType features to AAT features\n// in the form of {featureType:{featureSetting:true}}\nexport function mapOTToAAT(features) {\n  let res = {};\n  for (let k in features) {\n    let r;\n    if (r = OTMapping[k]) {\n      if (res[r[0]] == null) {\n        res[r[0]] = {};\n      }\n\n      res[r[0]][r[1]] = features[k];\n    }\n  }\n\n  return res;\n}\n\n// Maps strings in a [featureType, featureSetting]\n// to their equivalent number codes\nfunction mapFeatureStrings(f) {\n  let [type, setting] = f;\n  if (isNaN(type)) {\n    var typeCode = features[type] && features[type].code;\n  } else {\n    var typeCode = type;\n  }\n\n  if (isNaN(setting)) {\n    var settingCode = features[type] && features[type][setting];\n  } else {\n    var settingCode = setting;\n  }\n\n  return [typeCode, settingCode];\n}\n\n// Maps AAT features to an array of OpenType features\n// Supports both arrays in the form of [[featureType, featureSetting]]\n// and objects in the form of {featureType:{featureSetting:true}}\n// featureTypes and featureSettings can be either strings or number codes\nexport function mapAATToOT(features) {\n  let res = {};\n  if (Array.isArray(features)) {\n    for (let k = 0; k < features.length; k++) {\n      let r;\n      let f = mapFeatureStrings(features[k]);\n      if (r = AATMapping[f[0]] && AATMapping[f[0]][f[1]]) {\n        res[r] = true;\n      }\n    }\n\n  } else if (typeof features === 'object') {\n    for (let type in features) {\n      let feature = features[type];\n      for (let setting in feature) {\n        let r;\n        let f = mapFeatureStrings([type, setting]);\n        if (feature[setting] && (r = AATMapping[f[0]] && AATMapping[f[0]][f[1]])) {\n          res[r] = true;\n        }\n      }\n    }\n  }\n\n  return Object.keys(res);\n}\n","import AATStateMachine from './AATStateMachine';\nimport AATLookupTable from './AATLookupTable';\nimport {cache} from '../decorators';\n\n// indic replacement flags\nconst MARK_FIRST = 0x8000;\nconst MARK_LAST  = 0x2000;\nconst VERB       = 0x000F;\n\n// contextual substitution and glyph insertion flag\nconst SET_MARK = 0x8000;\n\n// ligature entry flags\nconst SET_COMPONENT  = 0x8000;\nconst PERFORM_ACTION = 0x2000;\n\n// ligature action masks\nconst LAST_MASK   = 0x80000000;\nconst STORE_MASK  = 0x40000000;\nconst OFFSET_MASK = 0x3FFFFFFF;\n\nconst VERTICAL_ONLY           = 0x800000;\nconst REVERSE_DIRECTION       = 0x400000;\nconst HORIZONTAL_AND_VERTICAL = 0x200000;\n\n// glyph insertion flags\nconst CURRENT_IS_KASHIDA_LIKE = 0x2000;\nconst MARKED_IS_KASHIDA_LIKE  = 0x1000;\nconst CURRENT_INSERT_BEFORE   = 0x0800;\nconst MARKED_INSERT_BEFORE    = 0x0400;\nconst CURRENT_INSERT_COUNT    = 0x03E0;\nconst MARKED_INSERT_COUNT     = 0x001F;\n\nexport default class AATMorxProcessor {\n  constructor(font) {\n    this.processIndicRearragement = this.processIndicRearragement.bind(this);\n    this.processContextualSubstitution = this.processContextualSubstitution.bind(this);\n    this.processLigature = this.processLigature.bind(this);\n    this.processNoncontextualSubstitutions = this.processNoncontextualSubstitutions.bind(this);\n    this.processGlyphInsertion = this.processGlyphInsertion.bind(this);\n    this.font = font;\n    this.morx = font.morx;\n    this.inputCache = null;\n  }\n\n  // Processes an array of glyphs and applies the specified features\n  // Features should be in the form of {featureType:{featureSetting:boolean}}\n  process(glyphs, features = {}) {\n    for (let chain of this.morx.chains) {\n      let flags = chain.defaultFlags;\n\n      // enable/disable the requested features\n      for (let feature of chain.features) {\n        let f;\n        if (f = features[feature.featureType]) {\n          if (f[feature.featureSetting]) {\n            flags &= feature.disableFlags;\n            flags |= feature.enableFlags;\n          } else if (f[feature.featureSetting] === false) {\n            flags |= ~feature.disableFlags;\n            flags &= ~feature.enableFlags;\n          }\n        }\n      }\n\n      for (let subtable of chain.subtables) {\n        if (subtable.subFeatureFlags & flags) {\n          this.processSubtable(subtable, glyphs);\n        }\n      }\n    }\n\n    // remove deleted glyphs\n    let index = glyphs.length - 1;\n    while (index >= 0) {\n      if (glyphs[index].id === 0xffff) {\n        glyphs.splice(index, 1);\n      }\n\n      index--;\n    }\n\n    return glyphs;\n  }\n\n  processSubtable(subtable, glyphs) {\n    this.subtable = subtable;\n    this.glyphs = glyphs;\n    if (this.subtable.type === 4) {\n      this.processNoncontextualSubstitutions(this.subtable, this.glyphs);\n      return;\n    }\n\n    this.ligatureStack = [];\n    this.markedGlyph = null;\n    this.firstGlyph = null;\n    this.lastGlyph = null;\n    this.markedIndex = null;\n\n    let stateMachine = this.getStateMachine(subtable);\n    let process = this.getProcessor();\n\n    let reverse = !!(this.subtable.coverage & REVERSE_DIRECTION);\n    return stateMachine.process(this.glyphs, reverse, process);\n  }\n\n  @cache\n  getStateMachine(subtable) {\n    return new AATStateMachine(subtable.table.stateTable);\n  }\n\n  getProcessor() {\n    switch (this.subtable.type) {\n      case 0:\n        return this.processIndicRearragement;\n      case 1:\n        return this.processContextualSubstitution;\n      case 2:\n        return this.processLigature;\n      case 4:\n        return this.processNoncontextualSubstitutions;\n      case 5:\n        return this.processGlyphInsertion;\n      default:\n        throw new Error(`Invalid morx subtable type: ${this.subtable.type}`);\n    }\n  }\n\n  processIndicRearragement(glyph, entry, index) {\n    if (entry.flags & MARK_FIRST) {\n      this.firstGlyph = index;\n    }\n\n    if (entry.flags & MARK_LAST) {\n      this.lastGlyph = index;\n    }\n\n    reorderGlyphs(this.glyphs, entry.flags & VERB, this.firstGlyph, this.lastGlyph);\n  }\n\n  processContextualSubstitution(glyph, entry, index) {\n    let subsitutions = this.subtable.table.substitutionTable.items;\n    if (entry.markIndex !== 0xffff) {\n      let lookup = subsitutions.getItem(entry.markIndex);\n      let lookupTable = new AATLookupTable(lookup);\n      glyph = this.glyphs[this.markedGlyph];\n      var gid = lookupTable.lookup(glyph.id);\n      if (gid) {\n        this.glyphs[this.markedGlyph] = this.font.getGlyph(gid, glyph.codePoints);\n      }\n    }\n\n    if (entry.currentIndex !== 0xffff) {\n      let lookup = subsitutions.getItem(entry.currentIndex);\n      let lookupTable = new AATLookupTable(lookup);\n      glyph = this.glyphs[index];\n      var gid = lookupTable.lookup(glyph.id);\n      if (gid) {\n        this.glyphs[index] = this.font.getGlyph(gid, glyph.codePoints);\n      }\n    }\n\n    if (entry.flags & SET_MARK) {\n      this.markedGlyph = index;\n    }\n  }\n\n  processLigature(glyph, entry, index) {\n    if (entry.flags & SET_COMPONENT) {\n      this.ligatureStack.push(index);\n    }\n\n    if (entry.flags & PERFORM_ACTION) {\n      let actions = this.subtable.table.ligatureActions;\n      let components = this.subtable.table.components;\n      let ligatureList = this.subtable.table.ligatureList;\n\n      let actionIndex = entry.action;\n      let last = false;\n      let ligatureIndex = 0;\n      let codePoints = [];\n      let ligatureGlyphs = [];\n\n      while (!last) {\n        let componentGlyph = this.ligatureStack.pop();\n        codePoints.unshift(...this.glyphs[componentGlyph].codePoints);\n\n        let action = actions.getItem(actionIndex++);\n        last = !!(action & LAST_MASK);\n        let store = !!(action & STORE_MASK);\n        let offset = (action & OFFSET_MASK) << 2 >> 2; // sign extend 30 to 32 bits\n        offset += this.glyphs[componentGlyph].id;\n\n        let component = components.getItem(offset);\n        ligatureIndex += component;\n\n        if (last || store) {\n          let ligatureEntry = ligatureList.getItem(ligatureIndex);\n          this.glyphs[componentGlyph] = this.font.getGlyph(ligatureEntry, codePoints);\n          ligatureGlyphs.push(componentGlyph);\n          ligatureIndex = 0;\n          codePoints = [];\n        } else {\n          this.glyphs[componentGlyph] = this.font.getGlyph(0xffff);\n        }\n      }\n\n      // Put ligature glyph indexes back on the stack\n      this.ligatureStack.push(...ligatureGlyphs);\n    }\n  }\n\n  processNoncontextualSubstitutions(subtable, glyphs, index) {\n    let lookupTable = new AATLookupTable(subtable.table.lookupTable);\n\n    for (index = 0; index < glyphs.length; index++) {\n      let glyph = glyphs[index];\n      if (glyph.id !== 0xffff) {\n        let gid = lookupTable.lookup(glyph.id);\n        if (gid) { // 0 means do nothing\n          glyphs[index] = this.font.getGlyph(gid, glyph.codePoints);\n        }\n      }\n    }\n  }\n\n  _insertGlyphs(glyphIndex, insertionActionIndex, count, isBefore) {\n    let insertions = [];\n    while (count--) {\n      let gid = this.subtable.table.insertionActions.getItem(insertionActionIndex++);\n      insertions.push(this.font.getGlyph(gid));\n    }\n\n    if (!isBefore) {\n      glyphIndex++;\n    }\n\n    this.glyphs.splice(glyphIndex, 0, ...insertions);\n  }\n\n  processGlyphInsertion(glyph, entry, index) {\n    if (entry.flags & SET_MARK) {\n      this.markedIndex = index;\n    }\n\n    if (entry.markedInsertIndex !== 0xffff) {\n      let count = (entry.flags & MARKED_INSERT_COUNT) >>> 5;\n      let isBefore = !!(entry.flags & MARKED_INSERT_BEFORE);\n      this._insertGlyphs(this.markedIndex, entry.markedInsertIndex, count, isBefore);\n    }\n\n    if (entry.currentInsertIndex !== 0xffff) {\n      let count = (entry.flags & CURRENT_INSERT_COUNT) >>> 5;\n      let isBefore = !!(entry.flags & CURRENT_INSERT_BEFORE);\n      this._insertGlyphs(index, entry.currentInsertIndex, count, isBefore);\n    }\n  }\n\n  getSupportedFeatures() {\n    let features = [];\n    for (let chain of this.morx.chains) {\n      for (let feature of chain.features) {\n        features.push([feature.featureType, feature.featureSetting]);\n      }\n    }\n\n    return features;\n  }\n\n  generateInputs(gid) {\n    if (!this.inputCache) {\n      this.generateInputCache();\n    }\n\n    return this.inputCache[gid] || [];\n  }\n\n  generateInputCache() {\n    this.inputCache = {};\n\n    for (let chain of this.morx.chains) {\n      let flags = chain.defaultFlags;\n\n      for (let subtable of chain.subtables) {\n        if (subtable.subFeatureFlags & flags) {\n          this.generateInputsForSubtable(subtable);\n        }\n      }\n    }\n  }\n\n  generateInputsForSubtable(subtable) {\n    // Currently, only supporting ligature subtables.\n    if (subtable.type !== 2) {\n      return;\n    }\n\n    let reverse = !!(subtable.coverage & REVERSE_DIRECTION);\n    if (reverse) {\n      throw new Error('Reverse subtable, not supported.');\n    }\n\n    this.subtable = subtable;\n    this.ligatureStack = [];\n\n    let stateMachine = this.getStateMachine(subtable);\n    let process = this.getProcessor();\n\n    let input = [];\n    let stack = [];\n    this.glyphs = [];\n\n    stateMachine.traverse({\n      enter: (glyph, entry) => {\n        let glyphs = this.glyphs;\n        stack.push({\n          glyphs: glyphs.slice(),\n          ligatureStack: this.ligatureStack.slice()\n        });\n\n        // Add glyph to input and glyphs to process.\n        let g = this.font.getGlyph(glyph);\n        input.push(g);\n        glyphs.push(input[input.length - 1]);\n\n        // Process ligature substitution\n        process(glyphs[glyphs.length - 1], entry, glyphs.length - 1);\n\n        // Add input to result if only one matching (non-deleted) glyph remains.\n        let count = 0;\n        let found = 0;\n        for (let i = 0; i < glyphs.length && count <= 1; i++) {\n          if (glyphs[i].id !== 0xffff) {\n            count++;\n            found = glyphs[i].id;\n          }\n        }\n\n        if (count === 1) {\n          let result = input.map(g => g.id);\n          let cache = this.inputCache[found];\n          if (cache) {\n            cache.push(result);\n          } else {\n            this.inputCache[found] = [result];\n          }\n        }\n      },\n\n      exit: () => {\n        ({glyphs: this.glyphs, ligatureStack: this.ligatureStack} = stack.pop());\n        input.pop();\n      }\n    });\n  }\n}\n\n// swaps the glyphs in rangeA with those in rangeB\n// reverse the glyphs inside those ranges if specified\n// ranges are in [offset, length] format\nfunction swap(glyphs, rangeA, rangeB, reverseA = false, reverseB = false) {\n  let end = glyphs.splice(rangeB[0] - (rangeB[1] - 1), rangeB[1]);\n  if (reverseB) {\n    end.reverse();\n  }\n\n  let start = glyphs.splice(rangeA[0], rangeA[1], ...end);\n  if (reverseA) {\n    start.reverse();\n  }\n\n  glyphs.splice(rangeB[0] - (rangeA[1] - 1), 0, ...start);\n  return glyphs;\n}\n\nfunction reorderGlyphs(glyphs, verb, firstGlyph, lastGlyph) {\n  let length = lastGlyph - firstGlyph + 1;\n  switch (verb) {\n    case 0: // no change\n      return glyphs;\n\n    case 1: // Ax => xA\n      return swap(glyphs, [firstGlyph, 1], [lastGlyph, 0]);\n\n    case 2: // xD => Dx\n      return swap(glyphs, [firstGlyph, 0], [lastGlyph, 1]);\n\n    case 3: // AxD => DxA\n      return swap(glyphs, [firstGlyph, 1], [lastGlyph, 1]);\n\n    case 4: // ABx => xAB\n      return swap(glyphs, [firstGlyph, 2], [lastGlyph, 0]);\n\n    case 5: // ABx => xBA\n      return swap(glyphs, [firstGlyph, 2], [lastGlyph, 0], true, false);\n\n    case 6: // xCD => CDx\n      return swap(glyphs, [firstGlyph, 0], [lastGlyph, 2]);\n\n    case 7: // xCD => DCx\n      return swap(glyphs, [firstGlyph, 0], [lastGlyph, 2], false, true);\n\n    case 8: // AxCD => CDxA\n      return swap(glyphs, [firstGlyph, 1], [lastGlyph, 2]);\n\n    case 9: // AxCD => DCxA\n      return swap(glyphs, [firstGlyph, 1], [lastGlyph, 2], false, true);\n\n    case 10: // ABxD => DxAB\n      return swap(glyphs, [firstGlyph, 2], [lastGlyph, 1]);\n\n    case 11: // ABxD => DxBA\n      return swap(glyphs, [firstGlyph, 2], [lastGlyph, 1], true, false);\n\n    case 12: // ABxCD => CDxAB\n      return swap(glyphs, [firstGlyph, 2], [lastGlyph, 2]);\n\n    case 13: // ABxCD => CDxBA\n      return swap(glyphs, [firstGlyph, 2], [lastGlyph, 2], true, false);\n\n    case 14: // ABxCD => DCxAB\n      return swap(glyphs, [firstGlyph, 2], [lastGlyph, 2], false, true);\n\n    case 15: // ABxCD => DCxBA\n      return swap(glyphs, [firstGlyph, 2], [lastGlyph, 2], true, true);\n\n    default:\n      throw new Error(`Unknown verb: ${verb}`);\n  }\n}\n","import AATLookupTable from './AATLookupTable';\n\nconst START_OF_TEXT_STATE = 0;\nconst START_OF_LINE_STATE = 1;\n\nconst END_OF_TEXT_CLASS = 0;\nconst OUT_OF_BOUNDS_CLASS = 1;\nconst DELETED_GLYPH_CLASS = 2;\nconst END_OF_LINE_CLASS = 3;\n\nconst DONT_ADVANCE = 0x4000;\n\nexport default class AATStateMachine {\n  constructor(stateTable) {\n    this.stateTable = stateTable;\n    this.lookupTable = new AATLookupTable(stateTable.classTable);\n  }\n\n  process(glyphs, reverse, processEntry) {\n    let currentState = START_OF_TEXT_STATE; // START_OF_LINE_STATE is used for kashida glyph insertions sometimes I think?\n    let index = reverse ? glyphs.length - 1 : 0;\n    let dir = reverse ? -1 : 1;\n\n    while ((dir === 1 && index <= glyphs.length) || (dir === -1 && index >= -1)) {\n      let glyph = null;\n      let classCode = OUT_OF_BOUNDS_CLASS;\n      let shouldAdvance = true;\n\n      if (index === glyphs.length || index === -1) {\n        classCode = END_OF_TEXT_CLASS;\n      } else {\n        glyph = glyphs[index];\n        if (glyph.id === 0xffff) { // deleted glyph\n          classCode = DELETED_GLYPH_CLASS;\n        } else {\n          classCode = this.lookupTable.lookup(glyph.id);\n          if (classCode == null) {\n            classCode = OUT_OF_BOUNDS_CLASS;\n          }\n        }\n      }\n\n      let row = this.stateTable.stateArray.getItem(currentState);\n      let entryIndex = row[classCode];\n      let entry = this.stateTable.entryTable.getItem(entryIndex);\n\n      if (classCode !== END_OF_TEXT_CLASS && classCode !==  DELETED_GLYPH_CLASS) {\n        processEntry(glyph, entry, index);\n        shouldAdvance = !(entry.flags & DONT_ADVANCE);\n      }\n\n      currentState = entry.newState;\n      if (shouldAdvance) {\n        index += dir;\n      }\n    }\n\n    return glyphs;\n  }\n\n  /**\n   * Performs a depth-first traversal of the glyph strings\n   * represented by the state machine.\n   */\n  traverse(opts, state = 0, visited = new Set) {\n    if (visited.has(state)) {\n      return;\n    }\n\n    visited.add(state);\n\n    let {nClasses, stateArray, entryTable} = this.stateTable;\n    let row = stateArray.getItem(state);\n\n    // Skip predefined classes\n    for (let classCode = 4; classCode < nClasses; classCode++) {\n      let entryIndex = row[classCode];\n      let entry = entryTable.getItem(entryIndex);\n\n      // Try all glyphs in the class\n      for (let glyph of this.lookupTable.glyphsForValue(classCode)) {\n        if (opts.enter) {\n          opts.enter(glyph, entry);\n        }\n\n        if (entry.newState !== 0) {\n          this.traverse(opts, entry.newState, visited);\n        }\n\n        if (opts.exit) {\n          opts.exit(glyph, entry);\n        }\n      }\n    }\n  }\n}\n","import {cache} from '../decorators';\nimport {range} from '../utils';\n\nexport default class AATLookupTable {\n  constructor(table) {\n    this.table = table;\n  }\n\n  lookup(glyph) {\n    switch (this.table.version) {\n      case 0: // simple array format\n        return this.table.values.getItem(glyph);\n\n      case 2: // segment format\n      case 4: {\n        let min = 0;\n        let max = this.table.binarySearchHeader.nUnits - 1;\n\n        while (min <= max) {\n          var mid = (min + max) >> 1;\n          var seg = this.table.segments[mid];\n\n          // special end of search value\n          if (seg.firstGlyph === 0xffff) {\n            return null;\n          }\n\n          if (glyph < seg.firstGlyph) {\n            max = mid - 1;\n          } else if (glyph > seg.lastGlyph) {\n            min = mid + 1;\n          } else {\n            if (this.table.version === 2) {\n              return seg.value;\n            } else {\n              return seg.values[glyph - seg.firstGlyph];\n            }\n          }\n        }\n\n        return null;\n      }\n\n      case 6: { // lookup single\n        let min = 0;\n        let max = this.table.binarySearchHeader.nUnits - 1;\n\n        while (min <= max) {\n          var mid = (min + max) >> 1;\n          var seg = this.table.segments[mid];\n\n          // special end of search value\n          if (seg.glyph === 0xffff) {\n            return null;\n          }\n\n          if (glyph < seg.glyph) {\n            max = mid - 1;\n          } else if (glyph > seg.glyph) {\n            min = mid + 1;\n          } else {\n            return seg.value;\n          }\n        }\n\n        return null;\n      }\n\n      case 8: // lookup trimmed\n        return this.table.values[glyph - this.table.firstGlyph];\n\n      default:\n        throw new Error(`Unknown lookup table format: ${this.table.version}`);\n    }\n  }\n\n  @cache\n  glyphsForValue(classValue) {\n    let res = [];\n\n    switch (this.table.version) {\n      case 2: // segment format\n      case 4: {\n        for (let segment of this.table.segments) {\n          if ((this.table.version === 2 && segment.value === classValue)) {\n            res.push(...range(segment.firstGlyph, segment.lastGlyph + 1));\n          } else {\n            for (let index = 0; index < segment.values.length; index++) {\n              if (segment.values[index] === classValue) {\n                res.push(segment.firstGlyph + index);\n              }\n            }\n          }\n        }\n\n        break;\n      }\n\n      case 6: { // lookup single\n        for (let segment of this.table.segments) {\n          if (segment.value === classValue) {\n            res.push(segment.glyph);\n          }\n        }\n\n        break;\n      }\n\n      case 8: { // lookup trimmed\n        for (let i = 0; i < this.table.values.length; i++) {\n          if (this.table.values[i] === classValue) {\n            res.push(this.table.firstGlyph + i);\n          }\n        }\n\n        break;\n      }\n\n      default:\n        throw new Error(`Unknown lookup table format: ${this.table.version}`);\n    }\n\n    return res;\n  }\n}\n","import ShapingPlan from './ShapingPlan';\nimport * as Shapers from './shapers';\nimport GlyphInfo from './GlyphInfo';\nimport GSUBProcessor from './GSUBProcessor';\nimport GPOSProcessor from './GPOSProcessor';\n\nexport default class OTLayoutEngine {\n  constructor(font) {\n    this.font = font;\n    this.glyphInfos = null;\n    this.plan = null;\n    this.GSUBProcessor = null;\n    this.GPOSProcessor = null;\n    this.fallbackPosition = true;\n\n    if (font.GSUB) {\n      this.GSUBProcessor = new GSUBProcessor(font, font.GSUB);\n    }\n\n    if (font.GPOS) {\n      this.GPOSProcessor = new GPOSProcessor(font, font.GPOS);\n    }\n  }\n\n  setup(glyphRun) {\n    // Map glyphs to GlyphInfo objects so data can be passed between\n    // GSUB and GPOS without mutating the real (shared) Glyph objects.\n    this.glyphInfos = glyphRun.glyphs.map(glyph => new GlyphInfo(this.font, glyph.id, [...glyph.codePoints]));\n\n    // Select a script based on what is available in GSUB/GPOS.\n    let script = null;\n    if (this.GPOSProcessor) {\n      script = this.GPOSProcessor.selectScript(glyphRun.script, glyphRun.language, glyphRun.direction);\n    }\n\n    if (this.GSUBProcessor) {\n      script = this.GSUBProcessor.selectScript(glyphRun.script, glyphRun.language, glyphRun.direction);\n    }\n\n    // Choose a shaper based on the script, and setup a shaping plan.\n    // This determines which features to apply to which glyphs.\n    this.shaper = Shapers.choose(script);\n    this.plan = new ShapingPlan(this.font, script, glyphRun.direction);\n    this.shaper.plan(this.plan, this.glyphInfos, glyphRun.features);\n\n    // Assign chosen features to output glyph run\n    for (let key in this.plan.allFeatures) {\n      glyphRun.features[key] = true;\n    }\n  }\n\n  substitute(glyphRun) {\n    if (this.GSUBProcessor) {\n      this.plan.process(this.GSUBProcessor, this.glyphInfos);\n\n      // Map glyph infos back to normal Glyph objects\n      glyphRun.glyphs = this.glyphInfos.map(glyphInfo => this.font.getGlyph(glyphInfo.id, glyphInfo.codePoints));\n    }\n  }\n\n  position(glyphRun) {\n    if (this.shaper.zeroMarkWidths === 'BEFORE_GPOS') {\n      this.zeroMarkAdvances(glyphRun.positions);\n    }\n\n    if (this.GPOSProcessor) {\n      this.plan.process(this.GPOSProcessor, this.glyphInfos, glyphRun.positions);\n    }\n\n    if (this.shaper.zeroMarkWidths === 'AFTER_GPOS') {\n      this.zeroMarkAdvances(glyphRun.positions);\n    }\n\n    // Reverse the glyphs and positions if the script is right-to-left\n    if (glyphRun.direction === 'rtl') {\n      glyphRun.glyphs.reverse();\n      glyphRun.positions.reverse();\n    }\n\n    return this.GPOSProcessor && this.GPOSProcessor.features;\n  }\n\n  zeroMarkAdvances(positions) {\n    for (let i = 0; i < this.glyphInfos.length; i++) {\n      if (this.glyphInfos[i].isMark) {\n        positions[i].xAdvance = 0;\n        positions[i].yAdvance = 0;\n      }\n    }\n  }\n\n  cleanup() {\n    this.glyphInfos = null;\n    this.plan = null;\n    this.shaper = null;\n  }\n\n  getAvailableFeatures(script, language) {\n    let features = [];\n\n    if (this.GSUBProcessor) {\n      this.GSUBProcessor.selectScript(script, language);\n      features.push(...Object.keys(this.GSUBProcessor.features));\n    }\n\n    if (this.GPOSProcessor) {\n      this.GPOSProcessor.selectScript(script, language);\n      features.push(...Object.keys(this.GPOSProcessor.features));\n    }\n\n    return features;\n  }\n}\n","import * as Script from '../layout/Script';\n\n/**\n * ShapingPlans are used by the OpenType shapers to store which\n * features should by applied, and in what order to apply them.\n * The features are applied in groups called stages. A feature\n * can be applied globally to all glyphs, or locally to only\n * specific glyphs.\n *\n * @private\n */\nexport default class ShapingPlan {\n  constructor(font, script, direction) {\n    this.font = font;\n    this.script = script;\n    this.direction = direction;\n    this.stages = [];\n    this.globalFeatures = {};\n    this.allFeatures = {};\n  }\n\n  /**\n   * Adds the given features to the last stage.\n   * Ignores features that have already been applied.\n   */\n  _addFeatures(features, global) {\n    let stageIndex = this.stages.length - 1;\n    let stage = this.stages[stageIndex];\n    for (let feature of features) {\n      if (this.allFeatures[feature] == null) {\n        stage.push(feature);\n        this.allFeatures[feature] = stageIndex;\n\n        if (global) {\n          this.globalFeatures[feature] = true;\n        }\n      }\n    }\n  }\n\n  /**\n   * Add features to the last stage\n   */\n  add(arg, global = true) {\n    if (this.stages.length === 0) {\n      this.stages.push([]);\n    }\n\n    if (typeof arg === 'string') {\n      arg = [arg];\n    }\n\n    if (Array.isArray(arg)) {\n      this._addFeatures(arg, global);\n    } else if (typeof arg === 'object') {\n      this._addFeatures(arg.global || [], true);\n      this._addFeatures(arg.local || [], false);\n    } else {\n      throw new Error(\"Unsupported argument to ShapingPlan#add\");\n    }\n  }\n\n  /**\n   * Add a new stage\n   */\n  addStage(arg, global) {\n    if (typeof arg === 'function') {\n      this.stages.push(arg, []);\n    } else {\n      this.stages.push([]);\n      this.add(arg, global);\n    }\n  }\n\n  setFeatureOverrides(features) {\n    if (Array.isArray(features)) {\n      this.add(features);\n    } else if (typeof features === 'object') {\n      for (let tag in features) {\n        if (features[tag]) {\n          this.add(tag);\n        } else if (this.allFeatures[tag] != null) {\n          let stage = this.stages[this.allFeatures[tag]];\n          stage.splice(stage.indexOf(tag), 1);\n          delete this.allFeatures[tag];\n          delete this.globalFeatures[tag];\n        }\n      }\n    }\n  }\n\n  /**\n   * Assigns the global features to the given glyphs\n   */\n  assignGlobalFeatures(glyphs) {\n    for (let glyph of glyphs) {\n      for (let feature in this.globalFeatures) {\n        glyph.features[feature] = true;\n      }\n    }\n  }\n\n  /**\n   * Executes the planned stages using the given OTProcessor\n   */\n  process(processor, glyphs, positions) {\n    for (let stage of this.stages) {\n      if (typeof stage === 'function') {\n        if (!positions) {\n          stage(this.font, glyphs, this);\n        }\n\n      } else if (stage.length > 0) {\n        processor.applyFeatures(stage, glyphs, positions);\n      }\n    }\n  }\n}\n","import DefaultShaper from './DefaultShaper';\nimport ArabicShaper from './ArabicShaper';\nimport HangulShaper from './HangulShaper';\nimport IndicShaper from './IndicShaper';\nimport UniversalShaper from './UniversalShaper';\n\nconst SHAPERS = {\n  arab: ArabicShaper,    // Arabic\n  mong: ArabicShaper,    // Mongolian\n  syrc: ArabicShaper,    // Syriac\n  'nko ': ArabicShaper,  // N'Ko\n  phag: ArabicShaper,    // Phags Pa\n  mand: ArabicShaper,    // Mandaic\n  mani: ArabicShaper,    // Manichaean\n  phlp: ArabicShaper,    // Psalter Pahlavi\n\n  hang: HangulShaper,    // Hangul\n\n  bng2: IndicShaper,     // Bengali\n  beng: IndicShaper,     // Bengali\n  dev2: IndicShaper,     // Devanagari\n  deva: IndicShaper,     // Devanagari\n  gjr2: IndicShaper,     // Gujarati\n  gujr: IndicShaper,     // Gujarati\n  guru: IndicShaper,     // Gurmukhi\n  gur2: IndicShaper,     // Gurmukhi\n  knda: IndicShaper,     // Kannada\n  knd2: IndicShaper,     // Kannada\n  mlm2: IndicShaper,     // Malayalam\n  mlym: IndicShaper,     // Malayalam\n  ory2: IndicShaper,     // Oriya\n  orya: IndicShaper,     // Oriya\n  taml: IndicShaper,     // Tamil\n  tml2: IndicShaper,     // Tamil\n  telu: IndicShaper,     // Telugu\n  tel2: IndicShaper,     // Telugu\n  khmr: IndicShaper,     // Khmer\n\n  bali: UniversalShaper, // Balinese\n  batk: UniversalShaper, // Batak\n  brah: UniversalShaper, // Brahmi\n  bugi: UniversalShaper, // Buginese\n  buhd: UniversalShaper, // Buhid\n  cakm: UniversalShaper, // Chakma\n  cham: UniversalShaper, // Cham\n  dupl: UniversalShaper, // Duployan\n  egyp: UniversalShaper, // Egyptian Hieroglyphs\n  gran: UniversalShaper, // Grantha\n  hano: UniversalShaper, // Hanunoo\n  java: UniversalShaper, // Javanese\n  kthi: UniversalShaper, // Kaithi\n  kali: UniversalShaper, // Kayah Li\n  khar: UniversalShaper, // Kharoshthi\n  khoj: UniversalShaper, // Khojki\n  sind: UniversalShaper, // Khudawadi\n  lepc: UniversalShaper, // Lepcha\n  limb: UniversalShaper, // Limbu\n  mahj: UniversalShaper, // Mahajani\n  // mand: UniversalShaper, // Mandaic\n  // mani: UniversalShaper, // Manichaean\n  mtei: UniversalShaper, // Meitei Mayek\n  modi: UniversalShaper, // Modi\n  // mong: UniversalShaper, // Mongolian\n  // 'nko ': UniversalShaper, // NKo\n  hmng: UniversalShaper, // Pahawh Hmong\n  // phag: UniversalShaper, // Phags-pa\n  // phlp: UniversalShaper, // Psalter Pahlavi\n  rjng: UniversalShaper, // Rejang\n  saur: UniversalShaper, // Saurashtra\n  shrd: UniversalShaper, // Sharada\n  sidd: UniversalShaper, // Siddham\n  sinh: IndicShaper, // Sinhala\n  sund: UniversalShaper, // Sundanese\n  sylo: UniversalShaper, // Syloti Nagri\n  tglg: UniversalShaper, // Tagalog\n  tagb: UniversalShaper, // Tagbanwa\n  tale: UniversalShaper, // Tai Le\n  lana: UniversalShaper, // Tai Tham\n  tavt: UniversalShaper, // Tai Viet\n  takr: UniversalShaper, // Takri\n  tibt: UniversalShaper, // Tibetan\n  tfng: UniversalShaper, // Tifinagh\n  tirh: UniversalShaper, // Tirhuta\n\n  latn: DefaultShaper,   // Latin\n  DFLT: DefaultShaper    // Default\n};\n\nexport function choose(script) {\n  if (!Array.isArray(script)) {\n    script = [script];\n  }\n\n  for (let s of script) {\n    let shaper = SHAPERS[s];\n    if (shaper) {\n      return shaper;\n    }\n  }\n\n  return DefaultShaper;\n}\n","import {isDigit} from 'unicode-properties';\n\nconst VARIATION_FEATURES = ['rvrn'];\nconst COMMON_FEATURES = ['ccmp', 'locl', 'rlig', 'mark', 'mkmk'];\nconst FRACTIONAL_FEATURES = ['frac', 'numr', 'dnom'];\nconst HORIZONTAL_FEATURES = ['calt', 'clig', 'liga', 'rclt', 'curs', 'kern'];\nconst VERTICAL_FEATURES = ['vert'];\nconst DIRECTIONAL_FEATURES = {\n  ltr: ['ltra', 'ltrm'],\n  rtl: ['rtla', 'rtlm']\n};\n\nexport default class DefaultShaper {\n  static zeroMarkWidths = 'AFTER_GPOS';\n  static plan(plan, glyphs, features) {\n    // Plan the features we want to apply\n    this.planPreprocessing(plan);\n    this.planFeatures(plan);\n    this.planPostprocessing(plan, features);\n\n    // Assign the global features to all the glyphs\n    plan.assignGlobalFeatures(glyphs);\n\n    // Assign local features to glyphs\n    this.assignFeatures(plan, glyphs);\n  }\n\n  static planPreprocessing(plan) {\n    plan.add({\n      global: [...VARIATION_FEATURES, ...DIRECTIONAL_FEATURES[plan.direction]],\n      local: FRACTIONAL_FEATURES\n    });\n  }\n\n  static planFeatures(plan) {\n    // Do nothing by default. Let subclasses override this.\n  }\n\n  static planPostprocessing(plan, userFeatures) {\n    plan.add([...COMMON_FEATURES, ...HORIZONTAL_FEATURES]);\n    plan.setFeatureOverrides(userFeatures);\n  }\n\n  static assignFeatures(plan, glyphs) {\n    // Enable contextual fractions\n    for (let i = 0; i < glyphs.length; i++) {\n      let glyph = glyphs[i];\n      if (glyph.codePoints[0] === 0x2044) { // fraction slash\n        let start = i;\n        let end = i + 1;\n\n        // Apply numerator\n        while (start > 0 && isDigit(glyphs[start - 1].codePoints[0])) {\n          glyphs[start - 1].features.numr = true;\n          glyphs[start - 1].features.frac = true;\n          start--;\n        }\n\n        // Apply denominator\n        while (end < glyphs.length && isDigit(glyphs[end].codePoints[0])) {\n          glyphs[end].features.dnom = true;\n          glyphs[end].features.frac = true;\n          end++;\n        }\n\n        // Apply fraction slash\n        glyph.features.frac = true;\n        i = end - 1;\n      }\n    }\n  }\n}\n","import DefaultShaper from './DefaultShaper';\nimport {getCategory} from 'unicode-properties';\nimport UnicodeTrie from 'unicode-trie';\nimport { decodeBase64 } from '../../utils';\n\nconst trie = new UnicodeTrie(decodeBase64(require('fs').readFileSync(__dirname + '/data.trie', 'base64')));\nconst FEATURES = ['isol', 'fina', 'fin2', 'fin3', 'medi', 'med2', 'init'];\n\nconst ShapingClasses = {\n  Non_Joining: 0,\n  Left_Joining: 1,\n  Right_Joining: 2,\n  Dual_Joining: 3,\n  Join_Causing: 3,\n  ALAPH: 4,\n  'DALATH RISH': 5,\n  Transparent: 6\n};\n\nconst ISOL = 'isol';\nconst FINA = 'fina';\nconst FIN2 = 'fin2';\nconst FIN3 = 'fin3';\nconst MEDI = 'medi';\nconst MED2 = 'med2';\nconst INIT = 'init';\nconst NONE = null;\n\n// Each entry is [prevAction, curAction, nextState]\nconst STATE_TABLE = [\n  //   Non_Joining,        Left_Joining,       Right_Joining,     Dual_Joining,           ALAPH,            DALATH RISH\n  // State 0: prev was U,  not willing to join.\n  [ [ NONE, NONE, 0 ],  [ NONE, ISOL, 2 ],  [ NONE, ISOL, 1 ],  [ NONE, ISOL, 2 ],  [ NONE, ISOL, 1 ],  [ NONE, ISOL, 6 ] ],\n\n  // State 1: prev was R or ISOL/ALAPH,  not willing to join.\n  [ [ NONE, NONE, 0 ],  [ NONE, ISOL, 2 ],  [ NONE, ISOL, 1 ],  [ NONE, ISOL, 2 ],  [ NONE, FIN2, 5 ],  [ NONE, ISOL, 6 ] ],\n\n  // State 2: prev was D/L in ISOL form,  willing to join.\n  [ [ NONE, NONE, 0 ],  [ NONE, ISOL, 2 ],  [ INIT, FINA, 1 ],  [ INIT, FINA, 3 ],  [ INIT, FINA, 4 ],  [ INIT, FINA, 6 ] ],\n\n  // State 3: prev was D in FINA form,  willing to join.\n  [ [ NONE, NONE, 0 ],  [ NONE, ISOL, 2 ],  [ MEDI, FINA, 1 ],  [ MEDI, FINA, 3 ],  [ MEDI, FINA, 4 ],  [ MEDI, FINA, 6 ] ],\n\n  // State 4: prev was FINA ALAPH,  not willing to join.\n  [ [ NONE, NONE, 0 ],  [ NONE, ISOL, 2 ],  [ MED2, ISOL, 1 ],  [ MED2, ISOL, 2 ],  [ MED2, FIN2, 5 ],  [ MED2, ISOL, 6 ] ],\n\n  // State 5: prev was FIN2/FIN3 ALAPH,  not willing to join.\n  [ [ NONE, NONE, 0 ],  [ NONE, ISOL, 2 ],  [ ISOL, ISOL, 1 ],  [ ISOL, ISOL, 2 ],  [ ISOL, FIN2, 5 ],  [ ISOL, ISOL, 6 ] ],\n\n  // State 6: prev was DALATH/RISH,  not willing to join.\n  [ [ NONE, NONE, 0 ],  [ NONE, ISOL, 2 ],  [ NONE, ISOL, 1 ],  [ NONE, ISOL, 2 ],  [ NONE, FIN3, 5 ],  [ NONE, ISOL, 6 ] ]\n];\n\n/**\n * This is a shaper for Arabic, and other cursive scripts.\n * It uses data from ArabicShaping.txt in the Unicode database,\n * compiled to a UnicodeTrie by generate-data.coffee.\n *\n * The shaping state machine was ported from Harfbuzz.\n * https://github.com/behdad/harfbuzz/blob/master/src/hb-ot-shape-complex-arabic.cc\n */\nexport default class ArabicShaper extends DefaultShaper {\n  static planFeatures(plan) {\n    plan.add(['ccmp', 'locl']);\n    for (let i = 0; i < FEATURES.length; i++) {\n      let feature = FEATURES[i];\n      plan.addStage(feature, false);\n    }\n\n    plan.addStage('mset');\n  }\n\n  static assignFeatures(plan, glyphs) {\n    super.assignFeatures(plan, glyphs);\n\n    let prev = -1;\n    let state = 0;\n    let actions = [];\n\n    // Apply the state machine to map glyphs to features\n    for (let i = 0; i < glyphs.length; i++) {\n      let curAction, prevAction;\n      var glyph = glyphs[i];\n      let type = getShapingClass(glyph.codePoints[0]);\n      if (type === ShapingClasses.Transparent) {\n        actions[i] = NONE;\n        continue;\n      }\n\n      [prevAction, curAction, state] = STATE_TABLE[state][type];\n\n      if (prevAction !== NONE && prev !== -1) {\n        actions[prev] = prevAction;\n      }\n\n      actions[i] = curAction;\n      prev = i;\n    }\n\n    // Apply the chosen features to their respective glyphs\n    for (let index = 0; index < glyphs.length; index++) {\n      let feature;\n      var glyph = glyphs[index];\n      if (feature = actions[index]) {\n        glyph.features[feature] = true;\n      }\n    }\n  }\n}\n\nfunction getShapingClass(codePoint) {\n  let res = trie.get(codePoint);\n  if (res) {\n    return res - 1;\n  }\n\n  let category = getCategory(codePoint);\n  if (category === 'Mn' || category === 'Me' || category === 'Cf') {\n    return ShapingClasses.Transparent;\n  }\n\n  return ShapingClasses.Non_Joining;\n}\n","import DefaultShaper from './DefaultShaper';\nimport GlyphInfo from '../GlyphInfo';\n\n/**\n * This is a shaper for the Hangul script, used by the Korean language.\n * It does the following:\n *   - decompose if unsupported by the font:\n *     <LV>   -> <L,V>\n *     <LVT>  -> <L,V,T>\n *     <LV,T> -> <L,V,T>\n *\n *   - compose if supported by the font:\n *     <L,V>   -> <LV>\n *     <L,V,T> -> <LVT>\n *     <LV,T>  -> <LVT>\n *\n *   - reorder tone marks (S is any valid syllable):\n *     <S, M> -> <M, S>\n *\n *   - apply ljmo, vjmo, and tjmo OpenType features to decomposed Jamo sequences.\n *\n * This logic is based on the following documents:\n *   - http://www.microsoft.com/typography/OpenTypeDev/hangul/intro.htm\n *   - http://ktug.org/~nomos/harfbuzz-hangul/hangulshaper.pdf\n */\nexport default class HangulShaper extends DefaultShaper {\n  static zeroMarkWidths = 'NONE';\n  static planFeatures(plan) {\n    plan.add(['ljmo', 'vjmo', 'tjmo'], false);\n  }\n\n  static assignFeatures(plan, glyphs) {\n    let state = 0;\n    let i = 0;\n    while (i < glyphs.length) {\n      let action;\n      let glyph = glyphs[i];\n      let code = glyph.codePoints[0];\n      let type = getType(code);\n\n      [ action, state ] = STATE_TABLE[state][type];\n\n      switch (action) {\n        case DECOMPOSE:\n          // Decompose the composed syllable if it is not supported by the font.\n          if (!plan.font.hasGlyphForCodePoint(code)) {\n            i = decompose(glyphs, i, plan.font);\n          }\n          break;\n\n        case COMPOSE:\n          // Found a decomposed syllable. Try to compose if supported by the font.\n          i = compose(glyphs, i, plan.font);\n          break;\n\n        case TONE_MARK:\n          // Got a valid syllable, followed by a tone mark. Move the tone mark to the beginning of the syllable.\n          reorderToneMark(glyphs, i, plan.font);\n          break;\n\n        case INVALID:\n          // Tone mark has no valid syllable to attach to, so insert a dotted circle\n          i = insertDottedCircle(glyphs, i, plan.font);\n          break;\n      }\n\n      i++;\n    }\n  }\n}\n\nconst HANGUL_BASE  = 0xac00;\nconst HANGUL_END   = 0xd7a4;\nconst HANGUL_COUNT = HANGUL_END - HANGUL_BASE + 1;\nconst L_BASE  = 0x1100; // lead\nconst V_BASE  = 0x1161; // vowel\nconst T_BASE  = 0x11a7; // trail\nconst L_COUNT = 19;\nconst V_COUNT = 21;\nconst T_COUNT = 28;\nconst L_END   = L_BASE + L_COUNT - 1;\nconst V_END   = V_BASE + V_COUNT - 1;\nconst T_END   = T_BASE + T_COUNT - 1;\nconst DOTTED_CIRCLE = 0x25cc;\n\nconst isL    = code => 0x1100 <= code && code <= 0x115f || 0xa960 <= code && code <= 0xa97c;\nconst isV    = code => 0x1160 <= code && code <= 0x11a7 || 0xd7b0 <= code && code <= 0xd7c6;\nconst isT    = code => 0x11a8 <= code && code <= 0x11ff || 0xd7cb <= code && code <= 0xd7fb;\nconst isTone = code => 0x302e <= code && code <= 0x302f;\nconst isLVT  = code => HANGUL_BASE <= code && code <= HANGUL_END;\nconst isLV   = code => (code - HANGUL_BASE) < HANGUL_COUNT && (code - HANGUL_BASE) % T_COUNT === 0;\nconst isCombiningL = code => L_BASE <= code && code <= L_END;\nconst isCombiningV = code => V_BASE <= code && code <= V_END;\nconst isCombiningT = code => T_BASE + 1 && 1 <= code && code <= T_END;\n\n// Character categories\nconst X   = 0; // Other character\nconst L   = 1; // Leading consonant\nconst V   = 2; // Medial vowel\nconst T   = 3; // Trailing consonant\nconst LV  = 4; // Composed <LV> syllable\nconst LVT = 5; // Composed <LVT> syllable\nconst M   = 6; // Tone mark\n\n// This function classifies a character using the above categories.\nfunction getType(code) {\n  if (isL(code))    { return L; }\n  if (isV(code))    { return V; }\n  if (isT(code))    { return T; }\n  if (isLV(code))   { return LV; }\n  if (isLVT(code))  { return LVT; }\n  if (isTone(code)) { return M; }\n  return X;\n}\n\n// State machine actions\nconst NO_ACTION = 0;\nconst DECOMPOSE = 1;\nconst COMPOSE   = 2;\nconst TONE_MARK = 4;\nconst INVALID   = 5;\n\n// Build a state machine that accepts valid syllables, and applies actions along the way.\n// The logic this is implementing is documented at the top of the file.\nconst STATE_TABLE = [\n  //       X                 L                 V                T                  LV                LVT               M\n  // State 0: start state\n  [ [ NO_ACTION, 0 ], [ NO_ACTION, 1 ], [ NO_ACTION, 0 ], [ NO_ACTION, 0 ], [ DECOMPOSE, 2 ], [ DECOMPOSE, 3 ], [  INVALID, 0  ] ],\n\n  // State 1: <L>\n  [ [ NO_ACTION, 0 ], [ NO_ACTION, 1 ], [  COMPOSE, 2  ], [ NO_ACTION, 0 ], [ DECOMPOSE, 2 ], [ DECOMPOSE, 3 ], [  INVALID, 0  ] ],\n\n  // State 2: <L,V> or <LV>\n  [ [ NO_ACTION, 0 ], [ NO_ACTION, 1 ], [ NO_ACTION, 0 ], [  COMPOSE, 3  ], [ DECOMPOSE, 2 ], [ DECOMPOSE, 3 ], [ TONE_MARK, 0 ] ],\n\n  // State 3: <L,V,T> or <LVT>\n  [ [ NO_ACTION, 0 ], [ NO_ACTION, 1 ], [ NO_ACTION, 0 ], [ NO_ACTION, 0 ], [ DECOMPOSE, 2 ], [ DECOMPOSE, 3 ], [ TONE_MARK, 0 ] ]\n];\n\nfunction getGlyph(font, code, features) {\n  return new GlyphInfo(font, font.glyphForCodePoint(code).id, [code], features);\n}\n\nfunction decompose(glyphs, i, font) {\n  let glyph = glyphs[i];\n  let code = glyph.codePoints[0];\n\n  let s = code - HANGUL_BASE;\n  let t = T_BASE + s % T_COUNT;\n  s = s / T_COUNT | 0;\n  let l = L_BASE + s / V_COUNT | 0;\n  let v = V_BASE + s % V_COUNT;\n\n  // Don't decompose if all of the components are not available\n  if (!font.hasGlyphForCodePoint(l) ||\n      !font.hasGlyphForCodePoint(v) ||\n      (t !== T_BASE && !font.hasGlyphForCodePoint(t))) {\n    return i;\n  }\n\n  // Replace the current glyph with decomposed L, V, and T glyphs,\n  // and apply the proper OpenType features to each component.\n  let ljmo = getGlyph(font, l, glyph.features);\n  ljmo.features.ljmo = true;\n\n  let vjmo = getGlyph(font, v, glyph.features);\n  vjmo.features.vjmo = true;\n\n  let insert = [ ljmo, vjmo ];\n\n  if (t > T_BASE) {\n    let tjmo = getGlyph(font, t, glyph.features);\n    tjmo.features.tjmo = true;\n    insert.push(tjmo);\n  }\n\n  glyphs.splice(i, 1, ...insert);\n  return i + insert.length - 1;\n}\n\nfunction compose(glyphs, i, font) {\n  let glyph = glyphs[i];\n  let code = glyphs[i].codePoints[0];\n  let type = getType(code);\n\n  let prev = glyphs[i - 1].codePoints[0];\n  let prevType = getType(prev);\n\n  // Figure out what type of syllable we're dealing with\n  let lv, ljmo, vjmo, tjmo;\n  if (prevType === LV && type === T) {\n    // <LV,T>\n    lv = prev;\n    tjmo = glyph;\n  } else {\n    if (type === V) {\n      // <L,V>\n      ljmo = glyphs[i - 1];\n      vjmo = glyph;\n    } else {\n      // <L,V,T>\n      ljmo = glyphs[i - 2];\n      vjmo = glyphs[i - 1];\n      tjmo = glyph;\n    }\n\n    let l = ljmo.codePoints[0];\n    let v = vjmo.codePoints[0];\n\n    // Make sure L and V are combining characters\n    if (isCombiningL(l) && isCombiningV(v)) {\n      lv = HANGUL_BASE + ((l - L_BASE) * V_COUNT + (v - V_BASE)) * T_COUNT;\n    }\n  }\n\n  let t = (tjmo && tjmo.codePoints[0]) || T_BASE;\n  if ((lv != null) && (t === T_BASE || isCombiningT(t))) {\n    let s = lv + (t - T_BASE);\n\n    // Replace with a composed glyph if supported by the font,\n    // otherwise apply the proper OpenType features to each component.\n    if (font.hasGlyphForCodePoint(s)) {\n      let del = prevType === V ? 3 : 2;\n      glyphs.splice(i - del + 1, del, getGlyph(font, s, glyph.features));\n      return i - del + 1;\n    }\n  }\n\n  // Didn't compose (either a non-combining component or unsupported by font).\n  if (ljmo) { ljmo.features.ljmo = true; }\n  if (vjmo) { vjmo.features.vjmo = true; }\n  if (tjmo) { tjmo.features.tjmo = true; }\n\n  if (prevType === LV) {\n    // Sequence was originally <L,V>, which got combined earlier.\n    // Either the T was non-combining, or the LVT glyph wasn't supported.\n    // Decompose the glyph again and apply OT features.\n    decompose(glyphs, i - 1, font);\n    return i + 1;\n  }\n\n  return i;\n}\n\nfunction getLength(code) {\n  switch (getType(code)) {\n    case LV:\n    case LVT:\n      return 1;\n    case V:\n      return 2;\n    case T:\n      return 3;\n  }\n}\n\nfunction reorderToneMark(glyphs, i, font) {\n  let glyph = glyphs[i];\n  let code = glyphs[i].codePoints[0];\n\n  // Move tone mark to the beginning of the previous syllable, unless it is zero width\n  if (font.glyphForCodePoint(code).advanceWidth === 0) { return; }\n\n  let prev = glyphs[i - 1].codePoints[0];\n  let len = getLength(prev);\n\n  glyphs.splice(i, 1);\n  return glyphs.splice(i - len, 0, glyph);\n}\n\nfunction insertDottedCircle(glyphs, i, font) {\n  let glyph = glyphs[i];\n  let code = glyphs[i].codePoints[0];\n\n  if (font.hasGlyphForCodePoint(DOTTED_CIRCLE)) {\n    let dottedCircle = getGlyph(font, DOTTED_CIRCLE, glyph.features);\n\n    // If the tone mark is zero width, insert the dotted circle before, otherwise after\n    let idx = font.glyphForCodePoint(code).advanceWidth === 0 ? i : i + 1;\n    glyphs.splice(idx, 0, dottedCircle);\n    i++;\n  }\n\n  return i;\n}\n","import {isMark} from 'unicode-properties';\nimport OTProcessor from './OTProcessor';\n\nexport default class GlyphInfo {\n  constructor(font, id, codePoints = [], features) {\n    this._font = font;\n    this.codePoints = codePoints;\n    this.id = id;\n\n    this.features = {};\n    if (Array.isArray(features)) {\n      for (let i = 0; i < features.length; i++) {\n        let feature = features[i];\n        this.features[feature] = true;\n      }\n    } else if (typeof features === 'object') {\n      Object.assign(this.features, features);\n    }\n\n    this.ligatureID = null;\n    this.ligatureComponent = null;\n    this.isLigated = false;\n    this.cursiveAttachment = null;\n    this.markAttachment = null;\n    this.shaperInfo = null;\n    this.substituted = false;\n    this.isMultiplied = false;\n  }\n\n  get id() {\n    return this._id;\n  }\n\n  set id(id) {\n    this._id = id;\n    this.substituted = true;\n\n    let GDEF = this._font.GDEF;\n    if (GDEF && GDEF.glyphClassDef) {\n      // TODO: clean this up\n      let classID = OTProcessor.prototype.getClassID(id, GDEF.glyphClassDef);\n      this.isBase = classID === 1;\n      this.isLigature = classID === 2;\n      this.isMark = classID === 3;\n      this.markAttachmentType = GDEF.markAttachClassDef ? OTProcessor.prototype.getClassID(id, GDEF.markAttachClassDef) : 0;\n    } else {\n      this.isMark = this.codePoints.length > 0 && this.codePoints.every(isMark);\n      this.isBase = !this.isMark;\n      this.isLigature = this.codePoints.length > 1;\n      this.markAttachmentType = 0;\n    }\n  }\n\n  copy() {\n    return new GlyphInfo(this._font, this.id, this.codePoints, this.features);\n  }\n}\n","import GlyphIterator from './GlyphIterator';\nimport * as Script from '../layout/Script';\n\nconst DEFAULT_SCRIPTS = ['DFLT', 'dflt', 'latn'];\n\nexport default class OTProcessor {\n  constructor(font, table) {\n    this.font = font;\n    this.table = table;\n\n    this.script = null;\n    this.scriptTag = null;\n\n    this.language = null;\n    this.languageTag = null;\n\n    this.features = {};\n    this.lookups = {};\n\n    // Setup variation substitutions\n    this.variationsIndex = font._variationProcessor\n      ? this.findVariationsIndex(font._variationProcessor.normalizedCoords)\n      : -1;\n\n    // initialize to default script + language\n    this.selectScript();\n\n    // current context (set by applyFeatures)\n    this.glyphs = [];\n    this.positions = []; // only used by GPOS\n    this.ligatureID = 1;\n    this.currentFeature = null;\n  }\n\n  findScript(script) {\n    if (this.table.scriptList == null) {\n      return null;\n    }\n\n    if (!Array.isArray(script)) {\n      script = [script];\n    }\n\n    for (let s of script) {\n      for (let entry of this.table.scriptList) {\n        if (entry.tag === s) {\n          return entry;\n        }\n      }\n    }\n\n    return null;\n  }\n\n  selectScript(script, language, direction) {\n    let changed = false;\n    let entry;\n    if (!this.script || script !== this.scriptTag) {\n      entry = this.findScript(script);\n      if (!entry) {\n        entry = this.findScript(DEFAULT_SCRIPTS);\n      }\n\n      if (!entry) {\n        return this.scriptTag;\n      }\n\n      this.scriptTag = entry.tag;\n      this.script = entry.script;\n      this.language = null;\n      this.languageTag = null;\n      changed = true;\n    }\n\n    if (!direction || direction !== this.direction) {\n      this.direction = direction || Script.direction(script);\n    }\n\n    if (language && language.length < 4) {\n      language += ' '.repeat(4 - language.length);\n    }\n\n    if (!language || language !== this.languageTag) {\n      this.language = null;\n\n      for (let lang of this.script.langSysRecords) {\n        if (lang.tag === language) {\n          this.language = lang.langSys;\n          this.languageTag = lang.tag;\n          break;\n        }\n      }\n\n      if (!this.language) {\n        this.language = this.script.defaultLangSys;\n        this.languageTag = null;\n      }\n\n      changed = true;\n    }\n\n    // Build a feature lookup table\n    if (changed) {\n      this.features = {};\n      if (this.language) {\n        for (let featureIndex of this.language.featureIndexes) {\n          let record = this.table.featureList[featureIndex];\n          let substituteFeature = this.substituteFeatureForVariations(featureIndex);\n          this.features[record.tag] = substituteFeature || record.feature;\n        }\n      }\n    }\n\n    return this.scriptTag;\n  }\n\n  lookupsForFeatures(userFeatures = [], exclude) {\n    let lookups = [];\n    for (let tag of userFeatures) {\n      let feature = this.features[tag];\n      if (!feature) {\n        continue;\n      }\n\n      for (let lookupIndex of feature.lookupListIndexes) {\n        if (exclude && exclude.indexOf(lookupIndex) !== -1) {\n          continue;\n        }\n\n        lookups.push({\n          feature: tag,\n          index: lookupIndex,\n          lookup: this.table.lookupList.get(lookupIndex)\n        });\n      }\n    }\n\n    lookups.sort((a, b) => a.index - b.index);\n    return lookups;\n  }\n\n  substituteFeatureForVariations(featureIndex) {\n    if (this.variationsIndex === -1) {\n      return null;\n    }\n\n    let record = this.table.featureVariations.featureVariationRecords[this.variationsIndex];\n    let substitutions = record.featureTableSubstitution.substitutions;\n    for (let substitution of substitutions) {\n      if (substitution.featureIndex === featureIndex) {\n        return substitution.alternateFeatureTable;\n      }\n    }\n\n    return null;\n  }\n\n  findVariationsIndex(coords) {\n    let variations = this.table.featureVariations;\n    if (!variations) {\n      return -1;\n    }\n\n    let records = variations.featureVariationRecords;\n    for (let i = 0; i < records.length; i++) {\n      let conditions = records[i].conditionSet.conditionTable;\n      if (this.variationConditionsMatch(conditions, coords)) {\n        return i;\n      }\n    }\n\n    return -1;\n  }\n\n  variationConditionsMatch(conditions, coords) {\n    return conditions.every(condition => {\n      let coord = condition.axisIndex < coords.length ? coords[condition.axisIndex] : 0;\n      return condition.filterRangeMinValue <= coord && coord <= condition.filterRangeMaxValue;\n    });\n  }\n\n  applyFeatures(userFeatures, glyphs, advances) {\n    let lookups = this.lookupsForFeatures(userFeatures);\n    this.applyLookups(lookups, glyphs, advances);\n  }\n\n  applyLookups(lookups, glyphs, positions) {\n    this.glyphs = glyphs;\n    this.positions = positions;\n    this.glyphIterator = new GlyphIterator(glyphs);\n\n    for (let { feature, lookup } of lookups) {\n      this.currentFeature = feature;\n      this.glyphIterator.reset(lookup.flags);\n\n      while (this.glyphIterator.index < glyphs.length) {\n        if (!(feature in this.glyphIterator.cur.features)) {\n          this.glyphIterator.next();\n          continue;\n        }\n\n        for (let table of lookup.subTables) {\n          let res = this.applyLookup(lookup.lookupType, table);\n          if (res) {\n            break;\n          }\n        }\n\n        this.glyphIterator.next();\n      }\n    }\n  }\n\n  applyLookup(lookup, table) {\n    throw new Error(\"applyLookup must be implemented by subclasses\");\n  }\n\n  applyLookupList(lookupRecords) {\n    let options = this.glyphIterator.options;\n    let glyphIndex = this.glyphIterator.index;\n\n    for (let lookupRecord of lookupRecords) {\n      // Reset flags and find glyph index for this lookup record\n      this.glyphIterator.reset(options, glyphIndex);\n      this.glyphIterator.increment(lookupRecord.sequenceIndex);\n\n      // Get the lookup and setup flags for subtables\n      let lookup = this.table.lookupList.get(lookupRecord.lookupListIndex);\n      this.glyphIterator.reset(lookup.flags, this.glyphIterator.index);\n\n      // Apply lookup subtables until one matches\n      for (let table of lookup.subTables) {\n        if (this.applyLookup(lookup.lookupType, table)) {\n          break;\n        }\n      }\n    }\n\n    this.glyphIterator.reset(options, glyphIndex);\n    return true;\n  }\n\n  coverageIndex(coverage, glyph) {\n    if (glyph == null) {\n      glyph = this.glyphIterator.cur.id;\n    }\n\n    switch (coverage.version) {\n      case 1:\n        return coverage.glyphs.indexOf(glyph);\n\n      case 2:\n        for (let range of coverage.rangeRecords) {\n          if (range.start <= glyph && glyph <= range.end) {\n            return range.startCoverageIndex + glyph - range.start;\n          }\n        }\n\n        break;\n    }\n\n    return -1;\n  }\n\n  match(sequenceIndex, sequence, fn, matched) {\n    let pos = this.glyphIterator.index;\n    let glyph = this.glyphIterator.increment(sequenceIndex);\n    let idx = 0;\n\n    while (idx < sequence.length && glyph && fn(sequence[idx], glyph)) {\n      if (matched) {\n        matched.push(this.glyphIterator.index);\n      }\n\n      idx++;\n      glyph = this.glyphIterator.next();\n    }\n\n    this.glyphIterator.index = pos;\n    if (idx < sequence.length) {\n      return false;\n    }\n\n    return matched || true;\n  }\n\n  sequenceMatches(sequenceIndex, sequence) {\n    return this.match(sequenceIndex, sequence, (component, glyph) => component === glyph.id);\n  }\n\n  sequenceMatchIndices(sequenceIndex, sequence) {\n    return this.match(sequenceIndex, sequence, (component, glyph) => {\n      // If the current feature doesn't apply to this glyph,\n      if (!(this.currentFeature in glyph.features)) {\n        return false;\n      }\n\n      return component === glyph.id;\n    }, []);\n  }\n\n  coverageSequenceMatches(sequenceIndex, sequence) {\n    return this.match(sequenceIndex, sequence, (coverage, glyph) =>\n      this.coverageIndex(coverage, glyph.id) >= 0\n    );\n  }\n\n  getClassID(glyph, classDef) {\n    switch (classDef.version) {\n      case 1: // Class array\n        let i = glyph - classDef.startGlyph;\n        if (i >= 0 && i < classDef.classValueArray.length) {\n          return classDef.classValueArray[i];\n        }\n\n        break;\n\n      case 2:\n        for (let range of classDef.classRangeRecord) {\n          if (range.start <= glyph && glyph <= range.end) {\n            return range.class;\n          }\n        }\n\n        break;\n    }\n\n    return 0;\n  }\n\n  classSequenceMatches(sequenceIndex, sequence, classDef) {\n    return this.match(sequenceIndex, sequence, (classID, glyph) =>\n      classID === this.getClassID(glyph.id, classDef)\n    );\n  }\n\n  applyContext(table) {\n    let index, set;\n    switch (table.version) {\n      case 1:\n        index = this.coverageIndex(table.coverage);\n        if (index === -1) {\n          return false;\n        }\n\n        set = table.ruleSets[index];\n        for (let rule of set) {\n          if (this.sequenceMatches(1, rule.input)) {\n            return this.applyLookupList(rule.lookupRecords);\n          }\n        }\n\n        break;\n\n      case 2:\n        if (this.coverageIndex(table.coverage) === -1) {\n          return false;\n        }\n\n        index = this.getClassID(this.glyphIterator.cur.id, table.classDef);\n        if (index === -1) {\n          return false;\n        }\n\n        set = table.classSet[index];\n        for (let rule of set) {\n          if (this.classSequenceMatches(1, rule.classes, table.classDef)) {\n            return this.applyLookupList(rule.lookupRecords);\n          }\n        }\n\n        break;\n\n      case 3:\n        if (this.coverageSequenceMatches(0, table.coverages)) {\n          return this.applyLookupList(table.lookupRecords);\n        }\n\n        break;\n    }\n\n    return false;\n  }\n\n  applyChainingContext(table) {\n    let index;\n    switch (table.version) {\n      case 1:\n        index = this.coverageIndex(table.coverage);\n        if (index === -1) {\n          return false;\n        }\n\n        let set = table.chainRuleSets[index];\n        for (let rule of set) {\n          if (this.sequenceMatches(-rule.backtrack.length, rule.backtrack)\n            && this.sequenceMatches(1, rule.input)\n            && this.sequenceMatches(1 + rule.input.length, rule.lookahead)) {\n            return this.applyLookupList(rule.lookupRecords);\n          }\n        }\n\n        break;\n\n      case 2:\n        if (this.coverageIndex(table.coverage) === -1) {\n          return false;\n        }\n\n        index = this.getClassID(this.glyphIterator.cur.id, table.inputClassDef);\n        let rules = table.chainClassSet[index];\n        if (!rules) {\n          return false;\n        }\n\n        for (let rule of rules) {\n          if (this.classSequenceMatches(-rule.backtrack.length, rule.backtrack, table.backtrackClassDef) &&\n            this.classSequenceMatches(1, rule.input, table.inputClassDef) &&\n            this.classSequenceMatches(1 + rule.input.length, rule.lookahead, table.lookaheadClassDef)) {\n            return this.applyLookupList(rule.lookupRecords);\n          }\n        }\n\n        break;\n\n      case 3:\n        if (this.coverageSequenceMatches(-table.backtrackGlyphCount, table.backtrackCoverage) &&\n          this.coverageSequenceMatches(0, table.inputCoverage) &&\n          this.coverageSequenceMatches(table.inputGlyphCount, table.lookaheadCoverage)) {\n          return this.applyLookupList(table.lookupRecords);\n        }\n\n        break;\n    }\n\n    return false;\n  }\n}\n","export default class GlyphIterator {\n  constructor(glyphs, options) {\n    this.glyphs = glyphs;\n    this.reset(options);\n  }\n\n  reset(options = {}, index = 0) {\n    this.options = options;\n    this.flags = options.flags || {};\n    this.markAttachmentType = options.markAttachmentType || 0;\n    this.index = index;\n  }\n\n  get cur() {\n    return this.glyphs[this.index] || null;\n  }\n\n  shouldIgnore(glyph) {\n    return (this.flags.ignoreMarks && glyph.isMark) ||\n           (this.flags.ignoreBaseGlyphs && glyph.isBase) ||\n           (this.flags.ignoreLigatures && glyph.isLigature) ||\n           (this.markAttachmentType && glyph.isMark && glyph.markAttachmentType !== this.markAttachmentType);\n  }\n\n  move(dir) {\n    this.index += dir;\n    while (0 <= this.index && this.index < this.glyphs.length && this.shouldIgnore(this.glyphs[this.index])) {\n      this.index += dir;\n    }\n\n    if (0 > this.index || this.index >= this.glyphs.length) {\n      return null;\n    }\n\n    return this.glyphs[this.index];\n  }\n\n  next() {\n    return this.move(+1);\n  }\n\n  prev() {\n    return this.move(-1);\n  }\n\n  peek(count = 1) {\n    let idx = this.index;\n    let res = this.increment(count);\n    this.index = idx;\n    return res;\n  }\n\n  peekIndex(count = 1) {\n    let idx = this.index;\n    this.increment(count);\n    let res = this.index;\n    this.index = idx;\n    return res;\n  }\n\n  increment(count = 1) {\n    let dir = count < 0 ? -1 : 1;\n    count = Math.abs(count);\n    while (count--) {\n      this.move(dir);\n    }\n\n    return this.glyphs[this.index];\n  }\n}\n","import DefaultShaper from './DefaultShaper';\nimport StateMachine from 'dfa';\nimport UnicodeTrie from 'unicode-trie';\nimport {getCategory} from 'unicode-properties';\nimport * as Script from '../../layout/Script';\nimport GlyphInfo from '../GlyphInfo';\nimport indicMachine from './indic.json';\nimport useData from './use.json';\nimport {\n  CATEGORIES,\n  POSITIONS,\n  CONSONANT_FLAGS,\n  JOINER_FLAGS,\n  HALANT_OR_COENG_FLAGS, INDIC_CONFIGS,\n  INDIC_DECOMPOSITIONS\n} from './indic-data';\nimport { decodeBase64 } from '../../utils';\n\nconst {decompositions} = useData;\nconst trie = new UnicodeTrie(decodeBase64(require('fs').readFileSync(__dirname + '/indic.trie', 'base64')));\nconst stateMachine = new StateMachine(indicMachine);\n\n/**\n * The IndicShaper supports indic scripts e.g. Devanagari, Kannada, etc.\n * Based on code from Harfbuzz: https://github.com/behdad/harfbuzz/blob/master/src/hb-ot-shape-complex-indic.cc\n */\nexport default class IndicShaper extends DefaultShaper {\n  static zeroMarkWidths = 'NONE';\n  static planFeatures(plan) {\n    plan.addStage(setupSyllables);\n\n    plan.addStage(['locl', 'ccmp']);\n\n    plan.addStage(initialReordering);\n\n    plan.addStage('nukt');\n    plan.addStage('akhn');\n    plan.addStage('rphf', false);\n    plan.addStage('rkrf');\n    plan.addStage('pref', false);\n    plan.addStage('blwf', false);\n    plan.addStage('abvf', false);\n    plan.addStage('half', false);\n    plan.addStage('pstf', false);\n    plan.addStage('vatu');\n    plan.addStage('cjct');\n    plan.addStage('cfar', false);\n\n    plan.addStage(finalReordering);\n\n    plan.addStage({\n      local: ['init'],\n      global: ['pres', 'abvs', 'blws', 'psts', 'haln', 'dist', 'abvm', 'blwm', 'calt', 'clig']\n    });\n\n    // Setup the indic config for the selected script\n    plan.unicodeScript = Script.fromOpenType(plan.script);\n    plan.indicConfig = INDIC_CONFIGS[plan.unicodeScript] || INDIC_CONFIGS.Default;\n    plan.isOldSpec = plan.indicConfig.hasOldSpec && plan.script[plan.script.length - 1] !== '2';\n\n    // TODO: turn off kern (Khmer) and liga features.\n  }\n\n  static assignFeatures(plan, glyphs) {\n    // Decompose split matras\n    // TODO: do this in a more general unicode normalizer\n    for (let i = glyphs.length - 1; i >= 0; i--) {\n      let codepoint = glyphs[i].codePoints[0];\n      let d = INDIC_DECOMPOSITIONS[codepoint] || decompositions[codepoint];\n      if (d) {\n        let decomposed = d.map(c => {\n          let g = plan.font.glyphForCodePoint(c);\n          return new GlyphInfo(plan.font, g.id, [c], glyphs[i].features);\n        });\n\n        glyphs.splice(i, 1, ...decomposed);\n      }\n    }\n  }\n}\n\nfunction indicCategory(glyph) {\n  return trie.get(glyph.codePoints[0]) >> 8;\n}\n\nfunction indicPosition(glyph) {\n  return 1 << (trie.get(glyph.codePoints[0]) & 0xff);\n}\n\nclass IndicInfo {\n  constructor(category, position, syllableType, syllable) {\n    this.category = category;\n    this.position = position;\n    this.syllableType = syllableType;\n    this.syllable = syllable;\n  }\n}\n\nfunction setupSyllables(font, glyphs) {\n  let syllable = 0;\n  let last = 0;\n  for (let [start, end, tags] of stateMachine.match(glyphs.map(indicCategory))) {\n    if (start > last) {\n      ++syllable;\n      for (let i = last; i < start; i++) {\n        glyphs[i].shaperInfo = new IndicInfo(CATEGORIES.X, POSITIONS.End, 'non_indic_cluster', syllable);\n      }\n    }\n\n    ++syllable;\n\n    // Create shaper info\n    for (let i = start; i <= end; i++) {\n      glyphs[i].shaperInfo = new IndicInfo(\n        1 << indicCategory(glyphs[i]),\n        indicPosition(glyphs[i]),\n        tags[0],\n        syllable\n      );\n    }\n\n    last = end + 1;\n  }\n\n  if (last < glyphs.length) {\n    ++syllable;\n    for (let i = last; i < glyphs.length; i++) {\n      glyphs[i].shaperInfo = new IndicInfo(CATEGORIES.X, POSITIONS.End, 'non_indic_cluster', syllable);\n    }\n  }\n}\n\nfunction isConsonant(glyph) {\n  return glyph.shaperInfo.category & CONSONANT_FLAGS;\n}\n\nfunction isJoiner(glyph) {\n  return glyph.shaperInfo.category & JOINER_FLAGS;\n}\n\nfunction isHalantOrCoeng(glyph) {\n  return glyph.shaperInfo.category & HALANT_OR_COENG_FLAGS;\n}\n\nfunction wouldSubstitute(glyphs, feature) {\n  for (let glyph of glyphs) {\n    glyph.features = {[feature]: true};\n  }\n\n  let GSUB = glyphs[0]._font._layoutEngine.engine.GSUBProcessor;\n  GSUB.applyFeatures([feature], glyphs);\n\n  return glyphs.length === 1;\n}\n\nfunction consonantPosition(font, consonant, virama) {\n  let glyphs = [virama, consonant, virama];\n  if (wouldSubstitute(glyphs.slice(0, 2), 'blwf') || wouldSubstitute(glyphs.slice(1, 3), 'blwf')) {\n    return POSITIONS.Below_C;\n  } else if (wouldSubstitute(glyphs.slice(0, 2), 'pstf') || wouldSubstitute(glyphs.slice(1, 3), 'pstf')) {\n    return POSITIONS.Post_C;\n  } else if (wouldSubstitute(glyphs.slice(0, 2), 'pref') || wouldSubstitute(glyphs.slice(1, 3), 'pref')) {\n    return POSITIONS.Post_C;\n  }\n\n  return POSITIONS.Base_C;\n}\n\nfunction initialReordering(font, glyphs, plan) {\n  let indicConfig = plan.indicConfig;\n  let features = font._layoutEngine.engine.GSUBProcessor.features;\n\n  let dottedCircle = font.glyphForCodePoint(0x25cc).id;\n  let virama = font.glyphForCodePoint(indicConfig.virama).id;\n  if (virama) {\n    let info = new GlyphInfo(font, virama, [indicConfig.virama]);\n    for (let i = 0; i < glyphs.length; i++) {\n      if (glyphs[i].shaperInfo.position === POSITIONS.Base_C) {\n        glyphs[i].shaperInfo.position = consonantPosition(font, glyphs[i].copy(), info);\n      }\n    }\n  }\n\n  for (let start = 0, end = nextSyllable(glyphs, 0); start < glyphs.length; start = end, end = nextSyllable(glyphs, start)) {\n    let {category, syllableType} = glyphs[start].shaperInfo;\n\n    if (syllableType === 'symbol_cluster' || syllableType === 'non_indic_cluster') {\n      continue;\n    }\n\n    if (syllableType === 'broken_cluster' && dottedCircle) {\n      let g = new GlyphInfo(font, dottedCircle, [0x25cc]);\n      g.shaperInfo = new IndicInfo(\n        1 << indicCategory(g),\n        indicPosition(g),\n        glyphs[start].shaperInfo.syllableType,\n        glyphs[start].shaperInfo.syllable\n      );\n\n      // Insert after possible Repha.\n      let i = start;\n      while (i < end && glyphs[i].shaperInfo.category === CATEGORIES.Repha) {\n        i++;\n      }\n\n      glyphs.splice(i++, 0, g);\n      end++;\n    }\n\n    // 1. Find base consonant:\n    //\n    // The shaping engine finds the base consonant of the syllable, using the\n    // following algorithm: starting from the end of the syllable, move backwards\n    // until a consonant is found that does not have a below-base or post-base\n    // form (post-base forms have to follow below-base forms), or that is not a\n    // pre-base reordering Ra, or arrive at the first consonant. The consonant\n    // stopped at will be the base.\n\n    let base = end;\n    let limit = start;\n    let hasReph = false;\n\n    // If the syllable starts with Ra + Halant (in a script that has Reph)\n    // and has more than one consonant, Ra is excluded from candidates for\n    // base consonants.\n    if (indicConfig.rephPos !== POSITIONS.Ra_To_Become_Reph &&\n      features.rphf &&\n      start + 3 <= end && (\n        (indicConfig.rephMode === 'Implicit' && !isJoiner(glyphs[start + 2])) ||\n        (indicConfig.rephMode === 'Explicit' && glyphs[start + 2].shaperInfo.category === CATEGORIES.ZWJ)\n      )\n    ) {\n      // See if it matches the 'rphf' feature.\n      let g = [glyphs[start].copy(), glyphs[start + 1].copy(), glyphs[start + 2].copy()];\n      if (wouldSubstitute(g.slice(0, 2), 'rphf') || (indicConfig.rephMode === 'Explicit' && wouldSubstitute(g, 'rphf'))) {\n        limit += 2;\n        while (limit < end && isJoiner(glyphs[limit])) {\n          limit++;\n        }\n        base = start;\n        hasReph = true;\n      }\n    } else if (indicConfig.rephMode === 'Log_Repha' && glyphs[start].shaperInfo.category === CATEGORIES.Repha) {\n      limit++;\n      while (limit < end && isJoiner(glyphs[limit])) {\n        limit++;\n      }\n      base = start;\n      hasReph = true;\n    }\n\n    switch (indicConfig.basePos) {\n      case 'Last': {\n        // starting from the end of the syllable, move backwards\n        let i = end;\n        let seenBelow = false;\n\n        do {\n          let info = glyphs[--i].shaperInfo;\n\n          // until a consonant is found\n          if (isConsonant(glyphs[i])) {\n            // that does not have a below-base or post-base form\n            // (post-base forms have to follow below-base forms),\n            if (info.position !== POSITIONS.Below_C && (info.position !== POSITIONS.Post_C || seenBelow)) {\n              base = i;\n              break;\n            }\n\n            // or that is not a pre-base reordering Ra,\n            //\n            // IMPLEMENTATION NOTES:\n            //\n            // Our pre-base reordering Ra's are marked POS_POST_C, so will be skipped\n            // by the logic above already.\n            //\n\n            // or arrive at the first consonant. The consonant stopped at will\n            // be the base.\n            if (info.position === POSITIONS.Below_C) {\n              seenBelow = true;\n            }\n\n            base = i;\n          } else if (start < i && info.category === CATEGORIES.ZWJ && glyphs[i - 1].shaperInfo.category === CATEGORIES.H) {\n            // A ZWJ after a Halant stops the base search, and requests an explicit\n            // half form.\n            // A ZWJ before a Halant, requests a subjoined form instead, and hence\n            // search continues.  This is particularly important for Bengali\n            // sequence Ra,H,Ya that should form Ya-Phalaa by subjoining Ya.\n            break;\n          }\n        } while (i > limit);\n        break;\n      }\n\n      case 'First': {\n        // The first consonant is always the base.\n        base = start;\n\n        // Mark all subsequent consonants as below.\n        for (let i = base + 1; i < end; i++) {\n          if (isConsonant(glyphs[i])) {\n            glyphs[i].shaperInfo.position = POSITIONS.Below_C;\n          }\n        }\n      }\n    }\n\n    // If the syllable starts with Ra + Halant (in a script that has Reph)\n    // and has more than one consonant, Ra is excluded from candidates for\n    // base consonants.\n    //\n    //  Only do this for unforced Reph. (ie. not for Ra,H,ZWJ)\n    if (hasReph && base === start && limit - base <= 2) {\n      hasReph = false;\n    }\n\n    // 2. Decompose and reorder Matras:\n    //\n    // Each matra and any syllable modifier sign in the cluster are moved to the\n    // appropriate position relative to the consonant(s) in the cluster. The\n    // shaping engine decomposes two- or three-part matras into their constituent\n    // parts before any repositioning. Matra characters are classified by which\n    // consonant in a conjunct they have affinity for and are reordered to the\n    // following positions:\n    //\n    //   o Before first half form in the syllable\n    //   o After subjoined consonants\n    //   o After post-form consonant\n    //   o After main consonant (for above marks)\n    //\n    // IMPLEMENTATION NOTES:\n    //\n    // The normalize() routine has already decomposed matras for us, so we don't\n    // need to worry about that.\n\n    // 3.  Reorder marks to canonical order:\n    //\n    // Adjacent nukta and halant or nukta and vedic sign are always repositioned\n    // if necessary, so that the nukta is first.\n    //\n    // IMPLEMENTATION NOTES:\n    //\n    // We don't need to do this: the normalize() routine already did this for us.\n\n    // Reorder characters\n\n    for (let i = start; i < base; i++) {\n      let info = glyphs[i].shaperInfo;\n      info.position = Math.min(POSITIONS.Pre_C, info.position);\n    }\n\n    if (base < end) {\n      glyphs[base].shaperInfo.position = POSITIONS.Base_C;\n    }\n\n    // Mark final consonants.  A final consonant is one appearing after a matra,\n    // like in Khmer.\n    for (let i = base + 1; i < end; i++) {\n      if (glyphs[i].shaperInfo.category === CATEGORIES.M) {\n        for (let j = i + 1; j < end; j++) {\n          if (isConsonant(glyphs[j])) {\n            glyphs[j].shaperInfo.position = POSITIONS.Final_C;\n            break;\n          }\n        }\n        break;\n      }\n    }\n\n    // Handle beginning Ra\n    if (hasReph) {\n      glyphs[start].shaperInfo.position = POSITIONS.Ra_To_Become_Reph;\n    }\n\n    // For old-style Indic script tags, move the first post-base Halant after\n    // last consonant.\n    //\n    // Reports suggest that in some scripts Uniscribe does this only if there\n    // is *not* a Halant after last consonant already (eg. Kannada), while it\n    // does it unconditionally in other scripts (eg. Malayalam).  We don't\n    // currently know about other scripts, so we single out Malayalam for now.\n    //\n    // Kannada test case:\n    // U+0C9A,U+0CCD,U+0C9A,U+0CCD\n    // With some versions of Lohit Kannada.\n    // https://bugs.freedesktop.org/show_bug.cgi?id=59118\n    //\n    // Malayalam test case:\n    // U+0D38,U+0D4D,U+0D31,U+0D4D,U+0D31,U+0D4D\n    // With lohit-ttf-20121122/Lohit-Malayalam.ttf\n    if (plan.isOldSpec) {\n      let disallowDoubleHalants = plan.unicodeScript !== 'Malayalam';\n      for (let i = base + 1; i < end; i++) {\n        if (glyphs[i].shaperInfo.category === CATEGORIES.H) {\n          let j;\n          for (j = end - 1; j > i; j--) {\n            if (isConsonant(glyphs[j]) || (disallowDoubleHalants && glyphs[j].shaperInfo.category === CATEGORIES.H)) {\n              break;\n            }\n          }\n\n          if (glyphs[j].shaperInfo.category !== CATEGORIES.H && j > i) {\n            // Move Halant to after last consonant.\n            let t = glyphs[i];\n            glyphs.splice(i, 0, ...glyphs.splice(i + 1, j - i));\n            glyphs[j] = t;\n          }\n\n          break;\n        }\n      }\n    }\n\n    // Attach misc marks to previous char to move with them.\n    let lastPos = POSITIONS.Start;\n    for (let i = start; i < end; i++) {\n      let info = glyphs[i].shaperInfo;\n      if (info.category & (JOINER_FLAGS | CATEGORIES.N | CATEGORIES.RS | CATEGORIES.CM | HALANT_OR_COENG_FLAGS & info.category)) {\n        info.position = lastPos;\n        if (info.category === CATEGORIES.H && info.position === POSITIONS.Pre_M) {\n          // Uniscribe doesn't move the Halant with Left Matra.\n          // TEST: U+092B,U+093F,U+094DE\n          // We follow.  This is important for the Sinhala\n          // U+0DDA split matra since it decomposes to U+0DD9,U+0DCA\n          // where U+0DD9 is a left matra and U+0DCA is the virama.\n          // We don't want to move the virama with the left matra.\n          // TEST: U+0D9A,U+0DDA\n          for (let j = i; j > start; j--) {\n            if (glyphs[j - 1].shaperInfo.position !== POSITIONS.Pre_M) {\n              info.position = glyphs[j - 1].shaperInfo.position;\n              break;\n            }\n          }\n        }\n      } else if (info.position !== POSITIONS.SMVD) {\n        lastPos = info.position;\n      }\n    }\n\n    // For post-base consonants let them own anything before them\n    // since the last consonant or matra.\n    let last = base;\n    for (let i = base + 1; i < end; i++) {\n      if (isConsonant(glyphs[i])) {\n        for (let j = last + 1; j < i; j++) {\n          if (glyphs[j].shaperInfo.position < POSITIONS.SMVD) {\n            glyphs[j].shaperInfo.position = glyphs[i].shaperInfo.position;\n          }\n        }\n        last = i;\n      } else if (glyphs[i].shaperInfo.category === CATEGORIES.M) {\n        last = i;\n      }\n    }\n\n    let arr = glyphs.slice(start, end);\n    arr.sort((a, b) => a.shaperInfo.position - b.shaperInfo.position);\n    glyphs.splice(start, arr.length, ...arr);\n\n    // Find base again\n    for (let i = start; i < end; i++) {\n      if (glyphs[i].shaperInfo.position === POSITIONS.Base_C) {\n        base = i;\n        break;\n      }\n    }\n\n    // Setup features now\n\n    // Reph\n    for (let i = start; i < end && glyphs[i].shaperInfo.position === POSITIONS.Ra_To_Become_Reph; i++) {\n      glyphs[i].features.rphf = true;\n    }\n\n    // Pre-base\n    let blwf = !plan.isOldSpec && indicConfig.blwfMode === 'Pre_And_Post';\n    for (let i = start; i < base; i++) {\n      glyphs[i].features.half = true;\n      if (blwf) {\n        glyphs[i].features.blwf = true;\n      }\n    }\n\n    // Post-base\n    for (let i = base + 1; i < end; i++) {\n      glyphs[i].features.abvf = true;\n      glyphs[i].features.pstf = true;\n      glyphs[i].features.blwf = true;\n    }\n\n    if (plan.isOldSpec && plan.unicodeScript === 'Devanagari') {\n      // Old-spec eye-lash Ra needs special handling.  From the\n      // spec:\n      //\n      // \"The feature 'below-base form' is applied to consonants\n      // having below-base forms and following the base consonant.\n      // The exception is vattu, which may appear below half forms\n      // as well as below the base glyph. The feature 'below-base\n      // form' will be applied to all such occurrences of Ra as well.\"\n      //\n      // Test case: U+0924,U+094D,U+0930,U+094d,U+0915\n      // with Sanskrit 2003 font.\n      //\n      // However, note that Ra,Halant,ZWJ is the correct way to\n      // request eyelash form of Ra, so we wouldbn't inhibit it\n      // in that sequence.\n      //\n      // Test case: U+0924,U+094D,U+0930,U+094d,U+200D,U+0915\n      for (let i = start; i + 1 < base; i++) {\n        if (glyphs[i].shaperInfo.category === CATEGORIES.Ra &&\n          glyphs[i + 1].shaperInfo.category === CATEGORIES.H &&\n          (i + 1 === base || glyphs[i + 2].shaperInfo.category === CATEGORIES.ZWJ)\n        ) {\n          glyphs[i].features.blwf = true;\n          glyphs[i + 1].features.blwf = true;\n        }\n      }\n    }\n\n    let prefLen = 2;\n    if (features.pref && base + prefLen < end) {\n      // Find a Halant,Ra sequence and mark it for pre-base reordering processing.\n      for (let i = base + 1; i + prefLen - 1 < end; i++) {\n        let g = [glyphs[i].copy(), glyphs[i + 1].copy()];\n        if (wouldSubstitute(g, 'pref')) {\n          for (let j = 0; j < prefLen; j++) {\n            glyphs[i++].features.pref = true;\n          }\n\n          // Mark the subsequent stuff with 'cfar'.  Used in Khmer.\n          // Read the feature spec.\n          // This allows distinguishing the following cases with MS Khmer fonts:\n          // U+1784,U+17D2,U+179A,U+17D2,U+1782\n          // U+1784,U+17D2,U+1782,U+17D2,U+179A\n          if (features.cfar) {\n            for (; i < end; i++) {\n              glyphs[i].features.cfar = true;\n            }\n          }\n\n          break;\n        }\n      }\n    }\n\n    // Apply ZWJ/ZWNJ effects\n    for (let i = start + 1; i < end; i++) {\n      if (isJoiner(glyphs[i])) {\n        let nonJoiner = glyphs[i].shaperInfo.category === CATEGORIES.ZWNJ;\n        let j = i;\n\n        do {\n          j--;\n\n          // ZWJ/ZWNJ should disable CJCT.  They do that by simply\n          // being there, since we don't skip them for the CJCT\n          // feature (ie. F_MANUAL_ZWJ)\n\n          // A ZWNJ disables HALF.\n          if (nonJoiner) {\n            delete glyphs[j].features.half;\n          }\n        } while (j > start && !isConsonant(glyphs[j]));\n      }\n    }\n  }\n}\n\nfunction finalReordering(font, glyphs, plan) {\n  let indicConfig = plan.indicConfig;\n  let features = font._layoutEngine.engine.GSUBProcessor.features;\n\n  for (let start = 0, end = nextSyllable(glyphs, 0); start < glyphs.length; start = end, end = nextSyllable(glyphs, start)) {\n    // 4. Final reordering:\n    //\n    // After the localized forms and basic shaping forms GSUB features have been\n    // applied (see below), the shaping engine performs some final glyph\n    // reordering before applying all the remaining font features to the entire\n    // cluster.\n\n    let tryPref = !!features.pref;\n\n    // Find base again\n    let base = start;\n    for (; base < end; base++) {\n      if (glyphs[base].shaperInfo.position >= POSITIONS.Base_C) {\n        if (tryPref && base + 1 < end) {\n          for (let i = base + 1; i < end; i++) {\n            if (glyphs[i].features.pref) {\n              if (!(glyphs[i].substituted && glyphs[i].isLigated && !glyphs[i].isMultiplied)) {\n                // Ok, this was a 'pref' candidate but didn't form any.\n                // Base is around here...\n                base = i;\n                while (base < end && isHalantOrCoeng(glyphs[base])) {\n                  base++;\n                }\n                glyphs[base].shaperInfo.position = POSITIONS.BASE_C;\n                tryPref = false;\n              }\n              break;\n            }\n          }\n        }\n\n        // For Malayalam, skip over unformed below- (but NOT post-) forms.\n        if (plan.unicodeScript === 'Malayalam') {\n          for (let i = base + 1; i < end; i++) {\n            while (i < end && isJoiner(glyphs[i])) {\n              i++;\n            }\n\n            if (i === end || !isHalantOrCoeng(glyphs[i])) {\n              break;\n            }\n\n            i++; // Skip halant.\n            while (i < end && isJoiner(glyphs[i])) {\n              i++;\n            }\n\n            if (i < end && isConsonant(glyphs[i]) && glyphs[i].shaperInfo.position === POSITIONS.Below_C) {\n              base = i;\n              glyphs[base].shaperInfo.position = POSITIONS.Base_C;\n            }\n          }\n        }\n\n        if (start < base && glyphs[base].shaperInfo.position > POSITIONS.Base_C) {\n          base--;\n        }\n        break;\n      }\n    }\n\n    if (base === end && start < base && glyphs[base - 1].shaperInfo.category === CATEGORIES.ZWJ) {\n      base--;\n    }\n\n    if (base < end) {\n      while (start < base && glyphs[base].shaperInfo.category & (CATEGORIES.N | HALANT_OR_COENG_FLAGS)) {\n        base--;\n      }\n    }\n\n    // o Reorder matras:\n    //\n    // If a pre-base matra character had been reordered before applying basic\n    // features, the glyph can be moved closer to the main consonant based on\n    // whether half-forms had been formed. Actual position for the matra is\n    // defined as after last standalone halant glyph, after initial matra\n    // position and before the main consonant. If ZWJ or ZWNJ follow this\n    // halant, position is moved after it.\n    //\n\n    if (start + 1 < end && start < base) { // Otherwise there can't be any pre-base matra characters.\n      // If we lost track of base, alas, position before last thingy.\n      let newPos = base === end ? base - 2 : base - 1;\n\n      // Malayalam / Tamil do not have \"half\" forms or explicit virama forms.\n      // The glyphs formed by 'half' are Chillus or ligated explicit viramas.\n      // We want to position matra after them.\n      if (plan.unicodeScript !== 'Malayalam' && plan.unicodeScript !== 'Tamil') {\n        while (newPos > start && !(glyphs[newPos].shaperInfo.category & (CATEGORIES.M | HALANT_OR_COENG_FLAGS))) {\n          newPos--;\n        }\n\n        // If we found no Halant we are done.\n        // Otherwise only proceed if the Halant does\n        // not belong to the Matra itself!\n        if (isHalantOrCoeng(glyphs[newPos]) && glyphs[newPos].shaperInfo.position !== POSITIONS.Pre_M) {\n          // If ZWJ or ZWNJ follow this halant, position is moved after it.\n          if (newPos + 1 < end && isJoiner(glyphs[newPos + 1])) {\n            newPos++;\n          }\n        } else {\n          newPos = start; // No move.\n        }\n      }\n\n      if (start < newPos && glyphs[newPos].shaperInfo.position !== POSITIONS.Pre_M) {\n        // Now go see if there's actually any matras...\n        for (let i = newPos; i > start; i--) {\n          if (glyphs[i - 1].shaperInfo.position === POSITIONS.Pre_M) {\n            let oldPos = i - 1;\n            if (oldPos < base && base <= newPos) { // Shouldn't actually happen.\n              base--;\n            }\n\n            let tmp = glyphs[oldPos];\n            glyphs.splice(oldPos, 0, ...glyphs.splice(oldPos + 1, newPos - oldPos));\n            glyphs[newPos] = tmp;\n\n            newPos--;\n          }\n        }\n      }\n    }\n\n    // o Reorder reph:\n    //\n    // Rephs original position is always at the beginning of the syllable,\n    // (i.e. it is not reordered at the character reordering stage). However,\n    // it will be reordered according to the basic-forms shaping results.\n    // Possible positions for reph, depending on the script, are; after main,\n    // before post-base consonant forms, and after post-base consonant forms.\n\n    // Two cases:\n    //\n    // - If repha is encoded as a sequence of characters (Ra,H or Ra,H,ZWJ), then\n    //   we should only move it if the sequence ligated to the repha form.\n    //\n    // - If repha is encoded separately and in the logical position, we should only\n    //   move it if it did NOT ligate.  If it ligated, it's probably the font trying\n    //   to make it work without the reordering.\n    if (start + 1 < end &&\n      glyphs[start].shaperInfo.position === POSITIONS.Ra_To_Become_Reph &&\n      (glyphs[start].shaperInfo.category === CATEGORIES.Repha) !== (glyphs[start].isLigated && !glyphs[start].isMultiplied)\n    ) {\n      let newRephPos;\n      let rephPos = indicConfig.rephPos;\n      let found = false;\n\n      // 1. If reph should be positioned after post-base consonant forms,\n      //    proceed to step 5.\n      if (rephPos !== POSITIONS.After_Post) {\n        //  2. If the reph repositioning class is not after post-base: target\n        //     position is after the first explicit halant glyph between the\n        //     first post-reph consonant and last main consonant. If ZWJ or ZWNJ\n        //     are following this halant, position is moved after it. If such\n        //     position is found, this is the target position. Otherwise,\n        //     proceed to the next step.\n        //\n        //     Note: in old-implementation fonts, where classifications were\n        //     fixed in shaping engine, there was no case where reph position\n        //     will be found on this step.\n        newRephPos = start + 1;\n        while (newRephPos < base && !isHalantOrCoeng(glyphs[newRephPos])) {\n          newRephPos++;\n        }\n\n        if (newRephPos < base && isHalantOrCoeng(glyphs[newRephPos])) {\n          // ->If ZWJ or ZWNJ are following this halant, position is moved after it.\n          if (newRephPos + 1 < base && isJoiner(glyphs[newRephPos + 1])) {\n            newRephPos++;\n          }\n\n          found = true;\n        }\n\n        // 3. If reph should be repositioned after the main consonant: find the\n        //    first consonant not ligated with main, or find the first\n        //    consonant that is not a potential pre-base reordering Ra.\n        if (!found && rephPos === POSITIONS.After_Main) {\n          newRephPos = base;\n          while (newRephPos + 1 < end && glyphs[newRephPos + 1].shaperInfo.position <= POSITIONS.After_Main) {\n            newRephPos++;\n          }\n\n          found = newRephPos < end;\n        }\n\n        // 4. If reph should be positioned before post-base consonant, find\n        //    first post-base classified consonant not ligated with main. If no\n        //    consonant is found, the target position should be before the\n        //    first matra, syllable modifier sign or vedic sign.\n        //\n        // This is our take on what step 4 is trying to say (and failing, BADLY).\n        if (!found && rephPos === POSITIONS.After_Sub) {\n          newRephPos = base;\n          while (newRephPos + 1 < end && !(glyphs[newRephPos + 1].shaperInfo.position & (POSITIONS.Post_C | POSITIONS.After_Post | POSITIONS.SMVD))) {\n            newRephPos++;\n          }\n\n          found = newRephPos < end;\n        }\n      }\n\n      //  5. If no consonant is found in steps 3 or 4, move reph to a position\n      //     immediately before the first post-base matra, syllable modifier\n      //     sign or vedic sign that has a reordering class after the intended\n      //     reph position. For example, if the reordering position for reph\n      //     is post-main, it will skip above-base matras that also have a\n      //     post-main position.\n      if (!found) {\n        // Copied from step 2.\n        newRephPos = start + 1;\n        while (newRephPos < base && !isHalantOrCoeng(glyphs[newRephPos])) {\n          newRephPos++;\n        }\n\n        if (newRephPos < base && isHalantOrCoeng(glyphs[newRephPos])) {\n          // ->If ZWJ or ZWNJ are following this halant, position is moved after it.\n          if (newRephPos + 1 < base && isJoiner(glyphs[newRephPos + 1])) {\n            newRephPos++;\n          }\n\n          found = true;\n        }\n      }\n\n      // 6. Otherwise, reorder reph to the end of the syllable.\n      if (!found) {\n        newRephPos = end - 1;\n        while (newRephPos > start && glyphs[newRephPos].shaperInfo.position === POSITIONS.SMVD) {\n          newRephPos--;\n        }\n\n        // If the Reph is to be ending up after a Matra,Halant sequence,\n        // position it before that Halant so it can interact with the Matra.\n        // However, if it's a plain Consonant,Halant we shouldn't do that.\n        // Uniscribe doesn't do this.\n        // TEST: U+0930,U+094D,U+0915,U+094B,U+094D\n        if (isHalantOrCoeng(glyphs[newRephPos])) {\n          for (let i = base + 1; i < newRephPos; i++) {\n            if (glyphs[i].shaperInfo.category === CATEGORIES.M) {\n              newRephPos--;\n            }\n          }\n        }\n      }\n\n      let reph = glyphs[start];\n      glyphs.splice(start, 0, ...glyphs.splice(start + 1, newRephPos - start));\n      glyphs[newRephPos] = reph;\n\n      if (start < base && base <= newRephPos) {\n        base--;\n      }\n    }\n\n    // o Reorder pre-base reordering consonants:\n    //\n    // If a pre-base reordering consonant is found, reorder it according to\n    // the following rules:\n    if (tryPref && base + 1 < end) {\n      for (let i = base + 1; i < end; i++) {\n        if (glyphs[i].features.pref) {\n           // 1. Only reorder a glyph produced by substitution during application\n           //    of the <pref> feature. (Note that a font may shape a Ra consonant with\n           //    the feature generally but block it in certain contexts.)\n\n          // Note: We just check that something got substituted.  We don't check that\n          // the <pref> feature actually did it...\n          //\n          // Reorder pref only if it ligated.\n          if (glyphs[i].isLigated && !glyphs[i].isMultiplied) {\n            // 2. Try to find a target position the same way as for pre-base matra.\n            //    If it is found, reorder pre-base consonant glyph.\n            //\n            // 3. If position is not found, reorder immediately before main\n            //    consonant.\n            let newPos = base;\n\n            // Malayalam / Tamil do not have \"half\" forms or explicit virama forms.\n            // The glyphs formed by 'half' are Chillus or ligated explicit viramas.\n            // We want to position matra after them.\n            if (plan.unicodeScript !== 'Malayalam' && plan.unicodeScript !== 'Tamil') {\n              while (newPos > start && !(glyphs[newPos - 1].shaperInfo.category & (CATEGORIES.M | HALANT_OR_COENG_FLAGS))) {\n                newPos--;\n              }\n\n              // In Khmer coeng model, a H,Ra can go *after* matras.  If it goes after a\n              // split matra, it should be reordered to *before* the left part of such matra.\n              if (newPos > start && glyphs[newPos - 1].shaperInfo.category === CATEGORIES.M) {\n                let oldPos = i;\n                for (let j = base + 1; j < oldPos; j++) {\n                  if (glyphs[j].shaperInfo.category === CATEGORIES.M) {\n                    newPos--;\n                    break;\n                  }\n                }\n              }\n            }\n\n            if (newPos > start && isHalantOrCoeng(glyphs[newPos - 1])) {\n              // -> If ZWJ or ZWNJ follow this halant, position is moved after it.\n              if (newPos < end && isJoiner(glyphs[newPos])) {\n                newPos++;\n              }\n            }\n\n            let oldPos = i;\n            let tmp = glyphs[oldPos];\n            glyphs.splice(newPos + 1, 0, ...glyphs.splice(newPos, oldPos - newPos));\n            glyphs[newPos] = tmp;\n\n            if (newPos <= base && base < oldPos) {\n              base++;\n            }\n          }\n\n          break;\n        }\n      }\n    }\n\n    // Apply 'init' to the Left Matra if it's a word start.\n    if (glyphs[start].shaperInfo.position === POSITIONS.Pre_M && (!start || !/Cf|Mn/.test(getCategory(glyphs[start - 1].codePoints[0])))) {\n      glyphs[start].features.init = true;\n    }\n  }\n}\n\nfunction nextSyllable(glyphs, start) {\n  if (start >= glyphs.length) return start;\n  let syllable = glyphs[start].shaperInfo.syllable;\n  while (++start < glyphs.length && glyphs[start].shaperInfo.syllable === syllable);\n  return start;\n}\n","{\"stateTable\":[[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,2,3,4,5,6,7,8,9,0,10,11,11,12,13,14,15,16,17],[0,0,0,18,19,20,21,22,23,0,24,0,0,25,26,0,0,27,0],[0,0,0,28,29,30,31,32,33,0,34,0,0,35,36,0,0,37,0],[0,0,0,38,5,7,7,8,9,0,10,0,0,0,13,0,0,16,0],[0,39,0,0,0,40,41,0,9,0,10,0,0,0,42,0,39,0,0],[0,0,0,0,43,44,44,8,9,0,0,0,0,12,43,0,0,0,0],[0,0,0,0,43,44,44,8,9,0,0,0,0,0,43,0,0,0,0],[0,0,0,45,46,47,48,49,9,0,10,0,0,0,42,0,0,0,0],[0,0,0,0,0,50,0,0,51,0,10,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,52,0,0,0,0,0,0,0,0],[0,0,0,53,54,55,56,57,58,0,59,0,0,60,61,0,0,62,0],[0,0,0,4,5,7,7,8,9,0,10,0,0,0,13,0,0,16,0],[0,63,64,0,0,40,41,0,9,0,10,0,0,0,42,0,63,0,0],[0,2,3,4,5,6,7,8,9,0,10,11,11,12,13,0,2,16,0],[0,0,0,18,65,20,21,22,23,0,24,0,0,25,26,0,0,27,0],[0,0,0,0,66,67,67,8,9,0,10,0,0,0,68,0,0,0,0],[0,0,0,69,0,70,70,0,71,0,72,0,0,0,0,0,0,0,0],[0,0,0,73,19,74,74,22,23,0,24,0,0,0,26,0,0,27,0],[0,75,0,0,0,76,77,0,23,0,24,0,0,0,78,0,75,0,0],[0,0,0,0,79,80,80,22,23,0,0,0,0,25,79,0,0,0,0],[0,0,0,18,19,20,74,22,23,0,24,0,0,25,26,0,0,27,0],[0,0,0,81,82,83,84,85,23,0,24,0,0,0,78,0,0,0,0],[0,0,0,0,0,86,0,0,87,0,24,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,88,0,0,0,0,0,0,0,0],[0,0,0,18,19,74,74,22,23,0,24,0,0,0,26,0,0,27,0],[0,89,90,0,0,76,77,0,23,0,24,0,0,0,78,0,89,0,0],[0,0,0,0,91,92,92,22,23,0,24,0,0,0,93,0,0,0,0],[0,0,0,94,29,95,31,32,33,0,34,0,0,0,36,0,0,37,0],[0,96,0,0,0,97,98,0,33,0,34,0,0,0,99,0,96,0,0],[0,0,0,0,100,101,101,32,33,0,0,0,0,35,100,0,0,0,0],[0,0,0,0,100,101,101,32,33,0,0,0,0,0,100,0,0,0,0],[0,0,0,102,103,104,105,106,33,0,34,0,0,0,99,0,0,0,0],[0,0,0,0,0,107,0,0,108,0,34,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,109,0,0,0,0,0,0,0,0],[0,0,0,28,29,95,31,32,33,0,34,0,0,0,36,0,0,37,0],[0,110,111,0,0,97,98,0,33,0,34,0,0,0,99,0,110,0,0],[0,0,0,0,112,113,113,32,33,0,34,0,0,0,114,0,0,0,0],[0,0,0,0,5,7,7,8,9,0,10,0,0,0,13,0,0,16,0],[0,0,0,115,116,117,118,8,9,0,10,0,0,119,120,0,0,16,0],[0,0,0,0,0,121,121,0,9,0,10,0,0,0,42,0,0,0,0],[0,39,0,122,0,123,123,8,9,0,10,0,0,0,42,0,39,0,0],[0,124,64,0,0,0,0,0,0,0,0,0,0,0,0,0,124,0,0],[0,39,0,0,0,121,125,0,9,0,10,0,0,0,42,0,39,0,0],[0,0,0,0,0,126,126,8,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,46,47,48,49,9,0,10,0,0,0,42,0,0,0,0],[0,0,0,0,0,47,47,49,9,0,10,0,0,0,42,0,0,0,0],[0,0,0,0,0,127,127,49,9,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,128,127,127,49,9,0,0,0,0,0,0,0,0,0,0],[0,0,0,129,130,131,132,133,9,0,10,0,0,0,42,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,10,0,0,0,0,0,0,0,0],[0,0,0,0,0,50,0,0,0,0,10,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,134,0,0,0,0,0,0,0,0],[0,0,0,135,54,56,56,57,58,0,59,0,0,0,61,0,0,62,0],[0,136,0,0,0,137,138,0,58,0,59,0,0,0,139,0,136,0,0],[0,0,0,0,140,141,141,57,58,0,0,0,0,60,140,0,0,0,0],[0,0,0,0,140,141,141,57,58,0,0,0,0,0,140,0,0,0,0],[0,0,0,142,143,144,145,146,58,0,59,0,0,0,139,0,0,0,0],[0,0,0,0,0,147,0,0,148,0,59,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,149,0,0,0,0,0,0,0,0],[0,0,0,53,54,56,56,57,58,0,59,0,0,0,61,0,0,62,0],[0,150,151,0,0,137,138,0,58,0,59,0,0,0,139,0,150,0,0],[0,0,0,0,152,153,153,57,58,0,59,0,0,0,154,0,0,0,0],[0,0,0,155,116,156,157,8,9,0,10,0,0,158,120,0,0,16,0],[0,0,0,0,0,121,121,0,9,0,10,0,0,0,0,0,0,0,0],[0,75,3,4,5,159,160,8,161,0,162,0,11,12,163,0,75,16,0],[0,0,0,0,0,40,164,0,9,0,10,0,0,0,42,0,0,0,0],[0,0,0,0,165,44,44,8,9,0,0,0,0,0,165,0,0,0,0],[0,124,64,0,0,40,164,0,9,0,10,0,0,0,42,0,124,0,0],[0,0,0,0,0,70,70,0,71,0,72,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,71,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,166,0,0,167,0,72,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,168,0,0,0,0,0,0,0,0],[0,0,0,0,19,74,74,22,23,0,24,0,0,0,26,0,0,27,0],[0,0,0,0,79,80,80,22,23,0,0,0,0,0,79,0,0,0,0],[0,0,0,169,170,171,172,22,23,0,24,0,0,173,174,0,0,27,0],[0,0,0,0,0,175,175,0,23,0,24,0,0,0,78,0,0,0,0],[0,75,0,176,0,177,177,22,23,0,24,0,0,0,78,0,75,0,0],[0,178,90,0,0,0,0,0,0,0,0,0,0,0,0,0,178,0,0],[0,75,0,0,0,175,179,0,23,0,24,0,0,0,78,0,75,0,0],[0,0,0,0,0,180,180,22,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,82,83,84,85,23,0,24,0,0,0,78,0,0,0,0],[0,0,0,0,0,83,83,85,23,0,24,0,0,0,78,0,0,0,0],[0,0,0,0,0,181,181,85,23,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,182,181,181,85,23,0,0,0,0,0,0,0,0,0,0],[0,0,0,183,184,185,186,187,23,0,24,0,0,0,78,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,24,0,0,0,0,0,0,0,0],[0,0,0,0,0,86,0,0,0,0,24,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,188,0,0,0,0,0,0,0,0],[0,0,0,189,170,190,191,22,23,0,24,0,0,192,174,0,0,27,0],[0,0,0,0,0,175,175,0,23,0,24,0,0,0,0,0,0,0,0],[0,0,0,0,0,76,193,0,23,0,24,0,0,0,78,0,0,0,0],[0,0,0,0,194,80,80,22,23,0,0,0,0,0,194,0,0,0,0],[0,178,90,0,0,76,193,0,23,0,24,0,0,0,78,0,178,0,0],[0,0,0,0,29,95,31,32,33,0,34,0,0,0,36,0,0,37,0],[0,0,0,0,100,101,101,32,33,0,0,0,0,0,100,0,0,0,0],[0,0,0,195,196,197,198,32,33,0,34,0,0,199,200,0,0,37,0],[0,0,0,0,0,201,201,0,33,0,34,0,0,0,99,0,0,0,0],[0,96,0,202,0,203,203,32,33,0,34,0,0,0,99,0,96,0,0],[0,204,111,0,0,0,0,0,0,0,0,0,0,0,0,0,204,0,0],[0,96,0,0,0,201,205,0,33,0,34,0,0,0,99,0,96,0,0],[0,0,0,0,0,206,206,32,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,103,104,105,106,33,0,34,0,0,0,99,0,0,0,0],[0,0,0,0,0,104,104,106,33,0,34,0,0,0,99,0,0,0,0],[0,0,0,0,0,207,207,106,33,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,208,207,207,106,33,0,0,0,0,0,0,0,0,0,0],[0,0,0,209,210,211,212,213,33,0,34,0,0,0,99,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,34,0,0,0,0,0,0,0,0],[0,0,0,0,0,107,0,0,0,0,34,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,214,0,0,0,0,0,0,0,0],[0,0,0,215,196,216,217,32,33,0,34,0,0,218,200,0,0,37,0],[0,0,0,0,0,201,201,0,33,0,34,0,0,0,0,0,0,0,0],[0,0,0,0,0,97,219,0,33,0,34,0,0,0,99,0,0,0,0],[0,0,0,0,220,101,101,32,33,0,0,0,0,0,220,0,0,0,0],[0,204,111,0,0,97,219,0,33,0,34,0,0,0,99,0,204,0,0],[0,0,0,221,116,222,222,8,9,0,10,0,0,0,120,0,0,16,0],[0,223,0,0,0,40,224,0,9,0,10,0,0,0,42,0,223,0,0],[0,0,0,0,225,44,44,8,9,0,0,0,0,119,225,0,0,0,0],[0,0,0,115,116,117,222,8,9,0,10,0,0,119,120,0,0,16,0],[0,0,0,115,116,222,222,8,9,0,10,0,0,0,120,0,0,16,0],[0,226,64,0,0,40,224,0,9,0,10,0,0,0,42,0,226,0,0],[0,0,0,0,0,0,0,0,9,0,0,0,0,0,0,0,0,0,0],[0,39,0,0,0,121,121,0,9,0,10,0,0,0,42,0,39,0,0],[0,0,0,0,0,44,44,8,9,0,0,0,0,0,0,0,0,0,0],[0,0,0,227,0,228,229,0,9,0,10,0,0,230,0,0,0,0,0],[0,39,0,122,0,121,121,0,9,0,10,0,0,0,42,0,39,0,0],[0,0,0,0,0,0,0,8,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,231,231,49,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,232,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,130,131,132,133,9,0,10,0,0,0,42,0,0,0,0],[0,0,0,0,0,131,131,133,9,0,10,0,0,0,42,0,0,0,0],[0,0,0,0,0,233,233,133,9,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,234,233,233,133,9,0,0,0,0,0,0,0,0,0,0],[0,0,0,235,236,237,238,239,9,0,10,0,0,0,42,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,54,56,56,57,58,0,59,0,0,0,61,0,0,62,0],[0,0,0,240,241,242,243,57,58,0,59,0,0,244,245,0,0,62,0],[0,0,0,0,0,246,246,0,58,0,59,0,0,0,139,0,0,0,0],[0,136,0,247,0,248,248,57,58,0,59,0,0,0,139,0,136,0,0],[0,249,151,0,0,0,0,0,0,0,0,0,0,0,0,0,249,0,0],[0,136,0,0,0,246,250,0,58,0,59,0,0,0,139,0,136,0,0],[0,0,0,0,0,251,251,57,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,143,144,145,146,58,0,59,0,0,0,139,0,0,0,0],[0,0,0,0,0,144,144,146,58,0,59,0,0,0,139,0,0,0,0],[0,0,0,0,0,252,252,146,58,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,253,252,252,146,58,0,0,0,0,0,0,0,0,0,0],[0,0,0,254,255,256,257,258,58,0,59,0,0,0,139,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,59,0,0,0,0,0,0,0,0],[0,0,0,0,0,147,0,0,0,0,59,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,259,0,0,0,0,0,0,0,0],[0,0,0,260,241,261,262,57,58,0,59,0,0,263,245,0,0,62,0],[0,0,0,0,0,246,246,0,58,0,59,0,0,0,0,0,0,0,0],[0,0,0,0,0,137,264,0,58,0,59,0,0,0,139,0,0,0,0],[0,0,0,0,265,141,141,57,58,0,0,0,0,0,265,0,0,0,0],[0,249,151,0,0,137,264,0,58,0,59,0,0,0,139,0,249,0,0],[0,0,0,221,116,222,222,8,9,0,10,0,0,0,120,0,0,16,0],[0,0,0,0,225,44,44,8,9,0,0,0,0,158,225,0,0,0,0],[0,0,0,155,116,156,222,8,9,0,10,0,0,158,120,0,0,16,0],[0,0,0,155,116,222,222,8,9,0,10,0,0,0,120,0,0,16,0],[0,0,0,0,43,266,266,8,161,0,24,0,0,12,267,0,0,0,0],[0,75,0,176,43,268,268,269,161,0,24,0,0,0,267,0,75,0,0],[0,0,0,0,0,270,0,0,271,0,162,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,272,0,0,0,0,0,0,0,0],[0,273,274,0,0,40,41,0,9,0,10,0,0,0,42,0,273,0,0],[0,0,0,40,0,123,123,8,9,0,10,0,0,0,42,0,0,0,0],[0,0,0,0,0,121,275,0,9,0,10,0,0,0,42,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,72,0,0,0,0,0,0,0,0],[0,0,0,0,0,166,0,0,0,0,72,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,276,0,0,0,0,0,0,0,0],[0,0,0,277,170,278,278,22,23,0,24,0,0,0,174,0,0,27,0],[0,279,0,0,0,76,280,0,23,0,24,0,0,0,78,0,279,0,0],[0,0,0,0,281,80,80,22,23,0,0,0,0,173,281,0,0,0,0],[0,0,0,169,170,171,278,22,23,0,24,0,0,173,174,0,0,27,0],[0,0,0,169,170,278,278,22,23,0,24,0,0,0,174,0,0,27,0],[0,282,90,0,0,76,280,0,23,0,24,0,0,0,78,0,282,0,0],[0,0,0,0,0,0,0,0,23,0,0,0,0,0,0,0,0,0,0],[0,75,0,0,0,175,175,0,23,0,24,0,0,0,78,0,75,0,0],[0,0,0,0,0,80,80,22,23,0,0,0,0,0,0,0,0,0,0],[0,0,0,283,0,284,285,0,23,0,24,0,0,286,0,0,0,0,0],[0,75,0,176,0,175,175,0,23,0,24,0,0,0,78,0,75,0,0],[0,0,0,0,0,0,0,22,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,287,287,85,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,288,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,184,185,186,187,23,0,24,0,0,0,78,0,0,0,0],[0,0,0,0,0,185,185,187,23,0,24,0,0,0,78,0,0,0,0],[0,0,0,0,0,289,289,187,23,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,290,289,289,187,23,0,0,0,0,0,0,0,0,0,0],[0,0,0,291,292,293,294,295,23,0,24,0,0,0,78,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,277,170,278,278,22,23,0,24,0,0,0,174,0,0,27,0],[0,0,0,0,281,80,80,22,23,0,0,0,0,192,281,0,0,0,0],[0,0,0,189,170,190,278,22,23,0,24,0,0,192,174,0,0,27,0],[0,0,0,189,170,278,278,22,23,0,24,0,0,0,174,0,0,27,0],[0,0,0,76,0,177,177,22,23,0,24,0,0,0,78,0,0,0,0],[0,0,0,0,0,175,296,0,23,0,24,0,0,0,78,0,0,0,0],[0,0,0,297,196,298,298,32,33,0,34,0,0,0,200,0,0,37,0],[0,299,0,0,0,97,300,0,33,0,34,0,0,0,99,0,299,0,0],[0,0,0,0,301,101,101,32,33,0,0,0,0,199,301,0,0,0,0],[0,0,0,195,196,197,298,32,33,0,34,0,0,199,200,0,0,37,0],[0,0,0,195,196,298,298,32,33,0,34,0,0,0,200,0,0,37,0],[0,302,111,0,0,97,300,0,33,0,34,0,0,0,99,0,302,0,0],[0,0,0,0,0,0,0,0,33,0,0,0,0,0,0,0,0,0,0],[0,96,0,0,0,201,201,0,33,0,34,0,0,0,99,0,96,0,0],[0,0,0,0,0,101,101,32,33,0,0,0,0,0,0,0,0,0,0],[0,0,0,303,0,304,305,0,33,0,34,0,0,306,0,0,0,0,0],[0,96,0,202,0,201,201,0,33,0,34,0,0,0,99,0,96,0,0],[0,0,0,0,0,0,0,32,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,307,307,106,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,308,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,210,211,212,213,33,0,34,0,0,0,99,0,0,0,0],[0,0,0,0,0,211,211,213,33,0,34,0,0,0,99,0,0,0,0],[0,0,0,0,0,309,309,213,33,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,310,309,309,213,33,0,0,0,0,0,0,0,0,0,0],[0,0,0,311,312,313,314,315,33,0,34,0,0,0,99,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,297,196,298,298,32,33,0,34,0,0,0,200,0,0,37,0],[0,0,0,0,301,101,101,32,33,0,0,0,0,218,301,0,0,0,0],[0,0,0,215,196,216,298,32,33,0,34,0,0,218,200,0,0,37,0],[0,0,0,215,196,298,298,32,33,0,34,0,0,0,200,0,0,37,0],[0,0,0,97,0,203,203,32,33,0,34,0,0,0,99,0,0,0,0],[0,0,0,0,0,201,316,0,33,0,34,0,0,0,99,0,0,0,0],[0,0,0,0,116,222,222,8,9,0,10,0,0,0,120,0,0,16,0],[0,0,0,0,225,44,44,8,9,0,0,0,0,0,225,0,0,0,0],[0,0,0,317,318,319,320,8,9,0,10,0,0,321,322,0,0,16,0],[0,223,0,323,0,123,123,8,9,0,10,0,0,0,42,0,223,0,0],[0,223,0,0,0,121,324,0,9,0,10,0,0,0,42,0,223,0,0],[0,0,0,325,318,326,327,8,9,0,10,0,0,328,322,0,0,16,0],[0,0,0,64,0,121,121,0,9,0,10,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,9,0,0,0,0,230,0,0,0,0,0],[0,0,0,227,0,228,121,0,9,0,10,0,0,230,0,0,0,0,0],[0,0,0,227,0,121,121,0,9,0,10,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,49,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,46,0,0],[0,0,0,0,0,329,329,133,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,330,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,236,237,238,239,9,0,10,0,0,0,42,0,0,0,0],[0,0,0,0,0,237,237,239,9,0,10,0,0,0,42,0,0,0,0],[0,0,0,0,0,331,331,239,9,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,332,331,331,239,9,0,0,0,0,0,0,0,0,0,0],[0,0,0,333,40,121,334,0,9,0,10,0,0,0,42,0,0,0,0],[0,0,0,335,241,336,336,57,58,0,59,0,0,0,245,0,0,62,0],[0,337,0,0,0,137,338,0,58,0,59,0,0,0,139,0,337,0,0],[0,0,0,0,339,141,141,57,58,0,0,0,0,244,339,0,0,0,0],[0,0,0,240,241,242,336,57,58,0,59,0,0,244,245,0,0,62,0],[0,0,0,240,241,336,336,57,58,0,59,0,0,0,245,0,0,62,0],[0,340,151,0,0,137,338,0,58,0,59,0,0,0,139,0,340,0,0],[0,0,0,0,0,0,0,0,58,0,0,0,0,0,0,0,0,0,0],[0,136,0,0,0,246,246,0,58,0,59,0,0,0,139,0,136,0,0],[0,0,0,0,0,141,141,57,58,0,0,0,0,0,0,0,0,0,0],[0,0,0,341,0,342,343,0,58,0,59,0,0,344,0,0,0,0,0],[0,136,0,247,0,246,246,0,58,0,59,0,0,0,139,0,136,0,0],[0,0,0,0,0,0,0,57,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,345,345,146,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,346,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,255,256,257,258,58,0,59,0,0,0,139,0,0,0,0],[0,0,0,0,0,256,256,258,58,0,59,0,0,0,139,0,0,0,0],[0,0,0,0,0,347,347,258,58,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,348,347,347,258,58,0,0,0,0,0,0,0,0,0,0],[0,0,0,349,350,351,352,353,58,0,59,0,0,0,139,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,335,241,336,336,57,58,0,59,0,0,0,245,0,0,62,0],[0,0,0,0,339,141,141,57,58,0,0,0,0,263,339,0,0,0,0],[0,0,0,260,241,261,336,57,58,0,59,0,0,263,245,0,0,62,0],[0,0,0,260,241,336,336,57,58,0,59,0,0,0,245,0,0,62,0],[0,0,0,137,0,248,248,57,58,0,59,0,0,0,139,0,0,0,0],[0,0,0,0,0,246,354,0,58,0,59,0,0,0,139,0,0,0,0],[0,0,0,0,0,126,126,8,23,0,0,0,0,0,0,0,0,0,0],[0,355,90,0,0,121,125,0,9,0,10,0,0,0,42,0,355,0,0],[0,0,0,0,0,356,356,269,23,0,0,0,0,0,0,0,0,0,0],[0,0,0,357,358,359,360,361,161,0,162,0,0,0,362,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,162,0,0,0,0,0,0,0,0],[0,0,0,0,0,270,0,0,0,0,162,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,363,0,0,0,0,0,0,0,0],[0,0,0,364,116,365,366,8,161,0,162,0,0,367,120,0,0,16,0],[0,0,0,0,0,368,368,0,161,0,162,0,0,0,0,0,0,0,0],[0,0,0,40,0,121,121,0,9,0,10,0,0,0,42,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,170,278,278,22,23,0,24,0,0,0,174,0,0,27,0],[0,0,0,0,281,80,80,22,23,0,0,0,0,0,281,0,0,0,0],[0,0,0,369,370,371,372,22,23,0,24,0,0,373,374,0,0,27,0],[0,279,0,375,0,177,177,22,23,0,24,0,0,0,78,0,279,0,0],[0,279,0,0,0,175,376,0,23,0,24,0,0,0,78,0,279,0,0],[0,0,0,377,370,378,379,22,23,0,24,0,0,380,374,0,0,27,0],[0,0,0,90,0,175,175,0,23,0,24,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,23,0,0,0,0,286,0,0,0,0,0],[0,0,0,283,0,284,175,0,23,0,24,0,0,286,0,0,0,0,0],[0,0,0,283,0,175,175,0,23,0,24,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,85,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,82,0,0],[0,0,0,0,0,381,381,187,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,382,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,292,293,294,295,23,0,24,0,0,0,78,0,0,0,0],[0,0,0,0,0,293,293,295,23,0,24,0,0,0,78,0,0,0,0],[0,0,0,0,0,383,383,295,23,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,384,383,383,295,23,0,0,0,0,0,0,0,0,0,0],[0,0,0,385,76,175,386,0,23,0,24,0,0,0,78,0,0,0,0],[0,0,0,76,0,175,175,0,23,0,24,0,0,0,78,0,0,0,0],[0,0,0,0,196,298,298,32,33,0,34,0,0,0,200,0,0,37,0],[0,0,0,0,301,101,101,32,33,0,0,0,0,0,301,0,0,0,0],[0,0,0,387,388,389,390,32,33,0,34,0,0,391,392,0,0,37,0],[0,299,0,393,0,203,203,32,33,0,34,0,0,0,99,0,299,0,0],[0,299,0,0,0,201,394,0,33,0,34,0,0,0,99,0,299,0,0],[0,0,0,395,388,396,397,32,33,0,34,0,0,398,392,0,0,37,0],[0,0,0,111,0,201,201,0,33,0,34,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,33,0,0,0,0,306,0,0,0,0,0],[0,0,0,303,0,304,201,0,33,0,34,0,0,306,0,0,0,0,0],[0,0,0,303,0,201,201,0,33,0,34,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,106,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,103,0,0],[0,0,0,0,0,399,399,213,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,400,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,312,313,314,315,33,0,34,0,0,0,99,0,0,0,0],[0,0,0,0,0,313,313,315,33,0,34,0,0,0,99,0,0,0,0],[0,0,0,0,0,401,401,315,33,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,402,401,401,315,33,0,0,0,0,0,0,0,0,0,0],[0,0,0,403,97,201,404,0,33,0,34,0,0,0,99,0,0,0,0],[0,0,0,97,0,201,201,0,33,0,34,0,0,0,99,0,0,0,0],[0,0,0,405,318,406,406,8,9,0,10,0,0,0,322,0,0,16,0],[0,407,0,0,0,40,408,0,9,0,10,0,0,0,42,0,407,0,0],[0,0,0,0,409,44,44,8,9,0,0,0,0,321,409,0,0,0,0],[0,0,0,317,318,319,406,8,9,0,10,0,0,321,322,0,0,16,0],[0,0,0,317,318,406,406,8,9,0,10,0,0,0,322,0,0,16,0],[0,410,64,0,0,40,408,0,9,0,10,0,0,0,42,0,410,0,0],[0,223,0,0,0,121,121,0,9,0,10,0,0,0,42,0,223,0,0],[0,223,0,323,0,121,121,0,9,0,10,0,0,0,42,0,223,0,0],[0,0,0,405,318,406,406,8,9,0,10,0,0,0,322,0,0,16,0],[0,0,0,0,409,44,44,8,9,0,0,0,0,328,409,0,0,0,0],[0,0,0,325,318,326,406,8,9,0,10,0,0,328,322,0,0,16,0],[0,0,0,325,318,406,406,8,9,0,10,0,0,0,322,0,0,16,0],[0,0,0,0,0,0,0,133,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,130,0,0],[0,0,0,0,0,411,411,239,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,412,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,40,121,334,0,9,0,10,0,0,0,42,0,0,0,0],[0,0,0,0,413,0,0,0,9,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,241,336,336,57,58,0,59,0,0,0,245,0,0,62,0],[0,0,0,0,339,141,141,57,58,0,0,0,0,0,339,0,0,0,0],[0,0,0,414,415,416,417,57,58,0,59,0,0,418,419,0,0,62,0],[0,337,0,420,0,248,248,57,58,0,59,0,0,0,139,0,337,0,0],[0,337,0,0,0,246,421,0,58,0,59,0,0,0,139,0,337,0,0],[0,0,0,422,415,423,424,57,58,0,59,0,0,425,419,0,0,62,0],[0,0,0,151,0,246,246,0,58,0,59,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,58,0,0,0,0,344,0,0,0,0,0],[0,0,0,341,0,342,246,0,58,0,59,0,0,344,0,0,0,0,0],[0,0,0,341,0,246,246,0,58,0,59,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,146,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,143,0,0],[0,0,0,0,0,426,426,258,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,427,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,350,351,352,353,58,0,59,0,0,0,139,0,0,0,0],[0,0,0,0,0,351,351,353,58,0,59,0,0,0,139,0,0,0,0],[0,0,0,0,0,428,428,353,58,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,429,428,428,353,58,0,0,0,0,0,0,0,0,0,0],[0,0,0,430,137,246,431,0,58,0,59,0,0,0,139,0,0,0,0],[0,0,0,137,0,246,246,0,58,0,59,0,0,0,139,0,0,0,0],[0,0,0,432,116,433,434,8,161,0,162,0,0,435,120,0,0,16,0],[0,0,0,0,0,180,180,269,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,358,359,360,361,161,0,162,0,0,0,362,0,0,0,0],[0,0,0,0,0,359,359,361,161,0,162,0,0,0,362,0,0,0,0],[0,0,0,0,0,436,436,361,161,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,437,436,436,361,161,0,0,0,0,0,0,0,0,0,0],[0,0,0,438,439,440,441,442,161,0,162,0,0,0,362,0,0,0,0],[0,443,274,0,0,0,0,0,0,0,0,0,0,0,0,0,443,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,444,116,445,445,8,161,0,162,0,0,0,120,0,0,16,0],[0,0,0,0,225,44,44,8,161,0,0,0,0,367,225,0,0,0,0],[0,0,0,364,116,365,445,8,161,0,162,0,0,367,120,0,0,16,0],[0,0,0,364,116,445,445,8,161,0,162,0,0,0,120,0,0,16,0],[0,0,0,0,0,0,0,0,161,0,0,0,0,0,0,0,0,0,0],[0,0,0,446,370,447,447,22,23,0,24,0,0,0,374,0,0,27,0],[0,448,0,0,0,76,449,0,23,0,24,0,0,0,78,0,448,0,0],[0,0,0,0,450,80,80,22,23,0,0,0,0,373,450,0,0,0,0],[0,0,0,369,370,371,447,22,23,0,24,0,0,373,374,0,0,27,0],[0,0,0,369,370,447,447,22,23,0,24,0,0,0,374,0,0,27,0],[0,451,90,0,0,76,449,0,23,0,24,0,0,0,78,0,451,0,0],[0,279,0,0,0,175,175,0,23,0,24,0,0,0,78,0,279,0,0],[0,279,0,375,0,175,175,0,23,0,24,0,0,0,78,0,279,0,0],[0,0,0,446,370,447,447,22,23,0,24,0,0,0,374,0,0,27,0],[0,0,0,0,450,80,80,22,23,0,0,0,0,380,450,0,0,0,0],[0,0,0,377,370,378,447,22,23,0,24,0,0,380,374,0,0,27,0],[0,0,0,377,370,447,447,22,23,0,24,0,0,0,374,0,0,27,0],[0,0,0,0,0,0,0,187,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,184,0,0],[0,0,0,0,0,452,452,295,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,453,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,76,175,386,0,23,0,24,0,0,0,78,0,0,0,0],[0,0,0,0,454,0,0,0,23,0,0,0,0,0,0,0,0,0,0],[0,0,0,455,388,456,456,32,33,0,34,0,0,0,392,0,0,37,0],[0,457,0,0,0,97,458,0,33,0,34,0,0,0,99,0,457,0,0],[0,0,0,0,459,101,101,32,33,0,0,0,0,391,459,0,0,0,0],[0,0,0,387,388,389,456,32,33,0,34,0,0,391,392,0,0,37,0],[0,0,0,387,388,456,456,32,33,0,34,0,0,0,392,0,0,37,0],[0,460,111,0,0,97,458,0,33,0,34,0,0,0,99,0,460,0,0],[0,299,0,0,0,201,201,0,33,0,34,0,0,0,99,0,299,0,0],[0,299,0,393,0,201,201,0,33,0,34,0,0,0,99,0,299,0,0],[0,0,0,455,388,456,456,32,33,0,34,0,0,0,392,0,0,37,0],[0,0,0,0,459,101,101,32,33,0,0,0,0,398,459,0,0,0,0],[0,0,0,395,388,396,456,32,33,0,34,0,0,398,392,0,0,37,0],[0,0,0,395,388,456,456,32,33,0,34,0,0,0,392,0,0,37,0],[0,0,0,0,0,0,0,213,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,210,0,0],[0,0,0,0,0,461,461,315,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,462,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,97,201,404,0,33,0,34,0,0,0,99,0,0,0,0],[0,0,0,0,463,0,0,0,33,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,318,406,406,8,9,0,10,0,0,0,322,0,0,16,0],[0,0,0,0,409,44,44,8,9,0,0,0,0,0,409,0,0,0,0],[0,0,0,464,465,466,467,8,9,0,10,0,0,468,469,0,0,16,0],[0,407,0,470,0,123,123,8,9,0,10,0,0,0,42,0,407,0,0],[0,407,0,0,0,121,471,0,9,0,10,0,0,0,42,0,407,0,0],[0,0,0,472,465,473,474,8,9,0,10,0,0,475,469,0,0,16,0],[0,0,0,0,0,0,0,239,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,236,0,0],[0,0,0,0,0,0,476,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,477,415,478,478,57,58,0,59,0,0,0,419,0,0,62,0],[0,479,0,0,0,137,480,0,58,0,59,0,0,0,139,0,479,0,0],[0,0,0,0,481,141,141,57,58,0,0,0,0,418,481,0,0,0,0],[0,0,0,414,415,416,478,57,58,0,59,0,0,418,419,0,0,62,0],[0,0,0,414,415,478,478,57,58,0,59,0,0,0,419,0,0,62,0],[0,482,151,0,0,137,480,0,58,0,59,0,0,0,139,0,482,0,0],[0,337,0,0,0,246,246,0,58,0,59,0,0,0,139,0,337,0,0],[0,337,0,420,0,246,246,0,58,0,59,0,0,0,139,0,337,0,0],[0,0,0,477,415,478,478,57,58,0,59,0,0,0,419,0,0,62,0],[0,0,0,0,481,141,141,57,58,0,0,0,0,425,481,0,0,0,0],[0,0,0,422,415,423,478,57,58,0,59,0,0,425,419,0,0,62,0],[0,0,0,422,415,478,478,57,58,0,59,0,0,0,419,0,0,62,0],[0,0,0,0,0,0,0,258,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,255,0,0],[0,0,0,0,0,483,483,353,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,484,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,137,246,431,0,58,0,59,0,0,0,139,0,0,0,0],[0,0,0,0,485,0,0,0,58,0,0,0,0,0,0,0,0,0,0],[0,0,0,444,116,445,445,8,161,0,162,0,0,0,120,0,0,16,0],[0,0,0,0,225,44,44,8,161,0,0,0,0,435,225,0,0,0,0],[0,0,0,432,116,433,445,8,161,0,162,0,0,435,120,0,0,16,0],[0,0,0,432,116,445,445,8,161,0,162,0,0,0,120,0,0,16,0],[0,0,0,0,0,486,486,361,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,487,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,439,440,441,442,161,0,162,0,0,0,362,0,0,0,0],[0,0,0,0,0,440,440,442,161,0,162,0,0,0,362,0,0,0,0],[0,0,0,0,0,488,488,442,161,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,489,488,488,442,161,0,0,0,0,0,0,0,0,0,0],[0,0,0,490,491,492,493,494,161,0,162,0,0,0,362,0,0,0,0],[0,0,0,495,0,496,497,0,161,0,162,0,0,498,0,0,0,0,0],[0,0,0,0,116,445,445,8,161,0,162,0,0,0,120,0,0,16,0],[0,0,0,0,225,44,44,8,161,0,0,0,0,0,225,0,0,0,0],[0,0,0,0,370,447,447,22,23,0,24,0,0,0,374,0,0,27,0],[0,0,0,0,450,80,80,22,23,0,0,0,0,0,450,0,0,0,0],[0,0,0,499,500,501,502,22,23,0,24,0,0,503,504,0,0,27,0],[0,448,0,505,0,177,177,22,23,0,24,0,0,0,78,0,448,0,0],[0,448,0,0,0,175,506,0,23,0,24,0,0,0,78,0,448,0,0],[0,0,0,507,500,508,509,22,23,0,24,0,0,510,504,0,0,27,0],[0,0,0,0,0,0,0,295,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,292,0,0],[0,0,0,0,0,0,511,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,388,456,456,32,33,0,34,0,0,0,392,0,0,37,0],[0,0,0,0,459,101,101,32,33,0,0,0,0,0,459,0,0,0,0],[0,0,0,512,513,514,515,32,33,0,34,0,0,516,517,0,0,37,0],[0,457,0,518,0,203,203,32,33,0,34,0,0,0,99,0,457,0,0],[0,457,0,0,0,201,519,0,33,0,34,0,0,0,99,0,457,0,0],[0,0,0,520,513,521,522,32,33,0,34,0,0,523,517,0,0,37,0],[0,0,0,0,0,0,0,315,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,312,0,0],[0,0,0,0,0,0,524,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,525,465,526,526,8,9,0,10,0,0,0,469,0,0,16,0],[0,527,0,0,0,40,528,0,9,0,10,0,0,0,42,0,527,0,0],[0,0,0,0,529,44,44,8,9,0,0,0,0,468,529,0,0,0,0],[0,0,0,464,465,466,526,8,9,0,10,0,0,468,469,0,0,16,0],[0,0,0,464,465,526,526,8,9,0,10,0,0,0,469,0,0,16,0],[0,530,64,0,0,40,528,0,9,0,10,0,0,0,42,0,530,0,0],[0,407,0,0,0,121,121,0,9,0,10,0,0,0,42,0,407,0,0],[0,407,0,470,0,121,121,0,9,0,10,0,0,0,42,0,407,0,0],[0,0,0,525,465,526,526,8,9,0,10,0,0,0,469,0,0,16,0],[0,0,0,0,529,44,44,8,9,0,0,0,0,475,529,0,0,0,0],[0,0,0,472,465,473,526,8,9,0,10,0,0,475,469,0,0,16,0],[0,0,0,472,465,526,526,8,9,0,10,0,0,0,469,0,0,16,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,40,0,0],[0,0,0,0,415,478,478,57,58,0,59,0,0,0,419,0,0,62,0],[0,0,0,0,481,141,141,57,58,0,0,0,0,0,481,0,0,0,0],[0,0,0,531,532,533,534,57,58,0,59,0,0,535,536,0,0,62,0],[0,479,0,537,0,248,248,57,58,0,59,0,0,0,139,0,479,0,0],[0,479,0,0,0,246,538,0,58,0,59,0,0,0,139,0,479,0,0],[0,0,0,539,532,540,541,57,58,0,59,0,0,542,536,0,0,62,0],[0,0,0,0,0,0,0,353,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,350,0,0],[0,0,0,0,0,0,543,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,361,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,358,0,0],[0,0,0,0,0,544,544,442,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,545,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,491,492,493,494,161,0,162,0,0,0,362,0,0,0,0],[0,0,0,0,0,492,492,494,161,0,162,0,0,0,362,0,0,0,0],[0,0,0,0,0,546,546,494,161,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,547,546,546,494,161,0,0,0,0,0,0,0,0,0,0],[0,0,0,548,549,368,550,0,161,0,162,0,0,0,362,0,0,0,0],[0,0,0,274,0,368,368,0,161,0,162,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,161,0,0,0,0,498,0,0,0,0,0],[0,0,0,495,0,496,368,0,161,0,162,0,0,498,0,0,0,0,0],[0,0,0,495,0,368,368,0,161,0,162,0,0,0,0,0,0,0,0],[0,0,0,551,500,552,552,22,23,0,24,0,0,0,504,0,0,27,0],[0,553,0,0,0,76,554,0,23,0,24,0,0,0,78,0,553,0,0],[0,0,0,0,555,80,80,22,23,0,0,0,0,503,555,0,0,0,0],[0,0,0,499,500,501,552,22,23,0,24,0,0,503,504,0,0,27,0],[0,0,0,499,500,552,552,22,23,0,24,0,0,0,504,0,0,27,0],[0,556,90,0,0,76,554,0,23,0,24,0,0,0,78,0,556,0,0],[0,448,0,0,0,175,175,0,23,0,24,0,0,0,78,0,448,0,0],[0,448,0,505,0,175,175,0,23,0,24,0,0,0,78,0,448,0,0],[0,0,0,551,500,552,552,22,23,0,24,0,0,0,504,0,0,27,0],[0,0,0,0,555,80,80,22,23,0,0,0,0,510,555,0,0,0,0],[0,0,0,507,500,508,552,22,23,0,24,0,0,510,504,0,0,27,0],[0,0,0,507,500,552,552,22,23,0,24,0,0,0,504,0,0,27,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,76,0,0],[0,0,0,557,513,558,558,32,33,0,34,0,0,0,517,0,0,37,0],[0,559,0,0,0,97,560,0,33,0,34,0,0,0,99,0,559,0,0],[0,0,0,0,561,101,101,32,33,0,0,0,0,516,561,0,0,0,0],[0,0,0,512,513,514,558,32,33,0,34,0,0,516,517,0,0,37,0],[0,0,0,512,513,558,558,32,33,0,34,0,0,0,517,0,0,37,0],[0,562,111,0,0,97,560,0,33,0,34,0,0,0,99,0,562,0,0],[0,457,0,0,0,201,201,0,33,0,34,0,0,0,99,0,457,0,0],[0,457,0,518,0,201,201,0,33,0,34,0,0,0,99,0,457,0,0],[0,0,0,557,513,558,558,32,33,0,34,0,0,0,517,0,0,37,0],[0,0,0,0,561,101,101,32,33,0,0,0,0,523,561,0,0,0,0],[0,0,0,520,513,521,558,32,33,0,34,0,0,523,517,0,0,37,0],[0,0,0,520,513,558,558,32,33,0,34,0,0,0,517,0,0,37,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,97,0,0],[0,0,0,0,465,526,526,8,9,0,10,0,0,0,469,0,0,16,0],[0,0,0,0,529,44,44,8,9,0,0,0,0,0,529,0,0,0,0],[0,0,0,563,66,564,565,8,9,0,10,0,0,566,68,0,0,16,0],[0,527,0,567,0,123,123,8,9,0,10,0,0,0,42,0,527,0,0],[0,527,0,0,0,121,568,0,9,0,10,0,0,0,42,0,527,0,0],[0,0,0,569,66,570,571,8,9,0,10,0,0,572,68,0,0,16,0],[0,0,0,573,532,574,574,57,58,0,59,0,0,0,536,0,0,62,0],[0,575,0,0,0,137,576,0,58,0,59,0,0,0,139,0,575,0,0],[0,0,0,0,577,141,141,57,58,0,0,0,0,535,577,0,0,0,0],[0,0,0,531,532,533,574,57,58,0,59,0,0,535,536,0,0,62,0],[0,0,0,531,532,574,574,57,58,0,59,0,0,0,536,0,0,62,0],[0,578,151,0,0,137,576,0,58,0,59,0,0,0,139,0,578,0,0],[0,479,0,0,0,246,246,0,58,0,59,0,0,0,139,0,479,0,0],[0,479,0,537,0,246,246,0,58,0,59,0,0,0,139,0,479,0,0],[0,0,0,573,532,574,574,57,58,0,59,0,0,0,536,0,0,62,0],[0,0,0,0,577,141,141,57,58,0,0,0,0,542,577,0,0,0,0],[0,0,0,539,532,540,574,57,58,0,59,0,0,542,536,0,0,62,0],[0,0,0,539,532,574,574,57,58,0,59,0,0,0,536,0,0,62,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,137,0,0],[0,0,0,0,0,0,0,442,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,439,0,0],[0,0,0,0,0,579,579,494,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,580,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,549,368,550,0,161,0,162,0,0,0,362,0,0,0,0],[0,0,0,0,0,368,368,0,161,0,162,0,0,0,362,0,0,0,0],[0,0,0,0,581,0,0,0,161,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,500,552,552,22,23,0,24,0,0,0,504,0,0,27,0],[0,0,0,0,555,80,80,22,23,0,0,0,0,0,555,0,0,0,0],[0,0,0,582,91,583,584,22,23,0,24,0,0,585,93,0,0,27,0],[0,553,0,586,0,177,177,22,23,0,24,0,0,0,78,0,553,0,0],[0,553,0,0,0,175,587,0,23,0,24,0,0,0,78,0,553,0,0],[0,0,0,588,91,589,590,22,23,0,24,0,0,591,93,0,0,27,0],[0,0,0,0,513,558,558,32,33,0,34,0,0,0,517,0,0,37,0],[0,0,0,0,561,101,101,32,33,0,0,0,0,0,561,0,0,0,0],[0,0,0,592,112,593,594,32,33,0,34,0,0,595,114,0,0,37,0],[0,559,0,596,0,203,203,32,33,0,34,0,0,0,99,0,559,0,0],[0,559,0,0,0,201,597,0,33,0,34,0,0,0,99,0,559,0,0],[0,0,0,598,112,599,600,32,33,0,34,0,0,601,114,0,0,37,0],[0,0,0,602,66,67,67,8,9,0,10,0,0,0,68,0,0,16,0],[0,0,0,0,165,44,44,8,9,0,0,0,0,566,165,0,0,0,0],[0,0,0,563,66,564,67,8,9,0,10,0,0,566,68,0,0,16,0],[0,0,0,563,66,67,67,8,9,0,10,0,0,0,68,0,0,16,0],[0,527,0,0,0,121,121,0,9,0,10,0,0,0,42,0,527,0,0],[0,527,0,567,0,121,121,0,9,0,10,0,0,0,42,0,527,0,0],[0,0,0,602,66,67,67,8,9,0,10,0,0,0,68,0,0,16,0],[0,0,0,0,165,44,44,8,9,0,0,0,0,572,165,0,0,0,0],[0,0,0,569,66,570,67,8,9,0,10,0,0,572,68,0,0,16,0],[0,0,0,569,66,67,67,8,9,0,10,0,0,0,68,0,0,16,0],[0,0,0,0,532,574,574,57,58,0,59,0,0,0,536,0,0,62,0],[0,0,0,0,577,141,141,57,58,0,0,0,0,0,577,0,0,0,0],[0,0,0,603,152,604,605,57,58,0,59,0,0,606,154,0,0,62,0],[0,575,0,607,0,248,248,57,58,0,59,0,0,0,139,0,575,0,0],[0,575,0,0,0,246,608,0,58,0,59,0,0,0,139,0,575,0,0],[0,0,0,609,152,610,611,57,58,0,59,0,0,612,154,0,0,62,0],[0,0,0,0,0,0,0,494,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,491,0,0],[0,0,0,0,0,0,613,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,614,91,92,92,22,23,0,24,0,0,0,93,0,0,27,0],[0,0,0,0,194,80,80,22,23,0,0,0,0,585,194,0,0,0,0],[0,0,0,582,91,583,92,22,23,0,24,0,0,585,93,0,0,27,0],[0,0,0,582,91,92,92,22,23,0,24,0,0,0,93,0,0,27,0],[0,553,0,0,0,175,175,0,23,0,24,0,0,0,78,0,553,0,0],[0,553,0,586,0,175,175,0,23,0,24,0,0,0,78,0,553,0,0],[0,0,0,614,91,92,92,22,23,0,24,0,0,0,93,0,0,27,0],[0,0,0,0,194,80,80,22,23,0,0,0,0,591,194,0,0,0,0],[0,0,0,588,91,589,92,22,23,0,24,0,0,591,93,0,0,27,0],[0,0,0,588,91,92,92,22,23,0,24,0,0,0,93,0,0,27,0],[0,0,0,615,112,113,113,32,33,0,34,0,0,0,114,0,0,37,0],[0,0,0,0,220,101,101,32,33,0,0,0,0,595,220,0,0,0,0],[0,0,0,592,112,593,113,32,33,0,34,0,0,595,114,0,0,37,0],[0,0,0,592,112,113,113,32,33,0,34,0,0,0,114,0,0,37,0],[0,559,0,0,0,201,201,0,33,0,34,0,0,0,99,0,559,0,0],[0,559,0,596,0,201,201,0,33,0,34,0,0,0,99,0,559,0,0],[0,0,0,615,112,113,113,32,33,0,34,0,0,0,114,0,0,37,0],[0,0,0,0,220,101,101,32,33,0,0,0,0,601,220,0,0,0,0],[0,0,0,598,112,599,113,32,33,0,34,0,0,601,114,0,0,37,0],[0,0,0,598,112,113,113,32,33,0,34,0,0,0,114,0,0,37,0],[0,0,0,0,66,67,67,8,9,0,10,0,0,0,68,0,0,16,0],[0,0,0,616,152,153,153,57,58,0,59,0,0,0,154,0,0,62,0],[0,0,0,0,265,141,141,57,58,0,0,0,0,606,265,0,0,0,0],[0,0,0,603,152,604,153,57,58,0,59,0,0,606,154,0,0,62,0],[0,0,0,603,152,153,153,57,58,0,59,0,0,0,154,0,0,62,0],[0,575,0,0,0,246,246,0,58,0,59,0,0,0,139,0,575,0,0],[0,575,0,607,0,246,246,0,58,0,59,0,0,0,139,0,575,0,0],[0,0,0,616,152,153,153,57,58,0,59,0,0,0,154,0,0,62,0],[0,0,0,0,265,141,141,57,58,0,0,0,0,612,265,0,0,0,0],[0,0,0,609,152,610,153,57,58,0,59,0,0,612,154,0,0,62,0],[0,0,0,609,152,153,153,57,58,0,59,0,0,0,154,0,0,62,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,549,0,0],[0,0,0,0,91,92,92,22,23,0,24,0,0,0,93,0,0,27,0],[0,0,0,0,112,113,113,32,33,0,34,0,0,0,114,0,0,37,0],[0,0,0,0,152,153,153,57,58,0,59,0,0,0,154,0,0,62,0]],\"accepting\":[false,true,true,true,true,true,false,false,true,true,true,true,true,true,true,true,true,true,true,true,false,true,true,true,true,true,true,true,true,true,false,true,true,true,true,true,true,true,true,true,true,true,false,true,false,true,true,false,false,true,true,true,true,true,true,false,false,true,true,true,true,true,true,true,true,true,true,false,true,true,false,true,true,true,false,true,true,true,false,true,false,true,true,false,false,true,true,true,true,true,true,true,false,true,true,false,true,true,true,false,true,false,true,true,false,false,true,true,true,true,true,true,true,false,true,true,true,false,true,true,true,false,true,false,true,true,false,false,false,true,true,false,false,true,true,true,true,true,true,false,true,false,true,true,false,false,true,true,true,true,true,true,true,false,true,true,false,true,true,true,true,true,true,true,true,true,true,true,true,true,true,false,true,true,true,false,true,false,true,true,false,false,false,true,true,false,false,true,true,true,false,true,true,true,true,true,true,false,true,true,true,false,true,false,true,true,false,false,false,true,true,false,false,true,true,true,false,true,true,true,true,true,false,true,true,true,true,true,false,true,true,false,false,false,false,true,true,false,false,true,true,true,false,true,true,true,false,true,false,true,true,false,false,false,true,true,false,false,true,true,true,false,true,true,true,true,false,true,false,true,true,true,true,true,true,true,true,true,false,true,true,true,true,true,false,true,true,false,false,false,false,true,true,false,false,true,true,true,false,true,true,true,true,true,false,true,true,false,false,false,false,true,true,false,false,true,true,true,true,false,true,true,true,true,true,true,false,true,true,false,false,false,false,true,false,true,false,true,true,true,true,true,false,true,true,false,false,false,false,true,true,false,false,true,true,true,false,true,true,false,false,true,false,true,true,false,true,true,false,true,true,false,true,true,true,true,true,true,false,true,true,false,false,false,false,true,false,true,true,false,true,true,true,true,true,true,false,true,true,false,false,false,false,true,false,true,false,true,true,true,true,false,false,false,true,true,false,true,true,true,true,true,true,false,true,true,false,false,false,false,true,false,true,false,true,true,false,false,true,true,false,false,true,true,true,false,true,false,true,true,true,true,false,false,false,true,false,true,true,true,true,false,false,false,true,true,false,true,true,true,true,true,true,false,true,true,false,true,false,true,true,true,true,false,false,false,false,false,false,false,true,true,false,false,true,true,false,true,true,true,true,false,true,true,true,true,true,true,false,true,true,false,true,true,false,true,true,true,true,true,true,false,true,true,false,true,false,true,true,true,true,true,true,false,true,true,true,true,true,true,false,true,true,false,false,false,false,false,true,true,false,true,false,true,true,true,true,true,false,true,true,true,true,true,false,true,true,true,true,true,false,true,true,true,false,true,true,true,true,false,false,false,true,false,true,true,true,true,true,false,true,true,true,false,true,true,true,true,true,false,true,true,true,true,false,true,true,true,true,true,false,true,true,false,true,true,true],\"tags\":[[],[\"broken_cluster\"],[\"consonant_syllable\"],[\"vowel_syllable\"],[\"broken_cluster\"],[\"broken_cluster\"],[],[],[\"broken_cluster\"],[\"broken_cluster\"],[\"broken_cluster\"],[\"standalone_cluster\"],[\"broken_cluster\"],[\"broken_cluster\"],[\"broken_cluster\"],[\"consonant_syllable\"],[\"broken_cluster\"],[\"symbol_cluster\"],[\"consonant_syllable\"],[\"consonant_syllable\"],[],[\"consonant_syllable\"],[\"consonant_syllable\"],[\"consonant_syllable\"],[\"consonant_syllable\"],[\"consonant_syllable\"],[\"consonant_syllable\"],[\"consonant_syllable\"],[\"vowel_syllable\"],[\"vowel_syllable\"],[],[\"vowel_syllable\"],[\"vowel_syllable\"],[\"vowel_syllable\"],[\"vowel_syllable\"],[\"vowel_syllable\"],[\"vowel_syllable\"],[\"vowel_syllable\"],[\"broken_cluster\"],[\"broken_cluster\"],[\"broken_cluster\"],[\"broken_cluster\"],[],[\"broken_cluster\"],[],[\"broken_cluster\"],[\"broken_cluster\"],[],[],[\"broken_cluster\"],[\"broken_cluster\"],[\"broken_cluster\"],[\"broken_cluster\"],[\"standalone_cluster\"],[\"standalone_cluster\"],[],[],[\"standalone_cluster\"],[\"standalone_cluster\"],[\"standalone_cluster\"],[\"standalone_cluster\"],[\"standalone_cluster\"],[\"standalone_cluster\"],[\"broken_cluster\"],[\"broken_cluster\"],[\"consonant_syllable\",\"broken_cluster\"],[\"broken_cluster\"],[],[\"broken_cluster\"],[\"symbol_cluster\"],[],[\"symbol_cluster\"],[\"symbol_cluster\"],[\"consonant_syllable\"],[],[\"consonant_syllable\"],[\"consonant_syllable\"],[\"consonant_syllable\"],[],[\"consonant_syllable\"],[],[\"consonant_syllable\"],[\"consonant_syllable\"],[],[],[\"consonant_syllable\"],[\"consonant_syllable\"],[\"consonant_syllable\"],[\"consonant_syllable\"],[\"consonant_syllable\"],[\"consonant_syllable\"],[\"consonant_syllable\"],[],[\"consonant_syllable\"],[\"vowel_syllable\"],[],[\"vowel_syllable\"],[\"vowel_syllable\"],[\"vowel_syllable\"],[],[\"vowel_syllable\"],[],[\"vowel_syllable\"],[\"vowel_syllable\"],[],[],[\"vowel_syllable\"],[\"vowel_syllable\"],[\"vowel_syllable\"],[\"vowel_syllable\"],[\"vowel_syllable\"],[\"vowel_syllable\"],[\"vowel_syllable\"],[],[\"vowel_syllable\"],[\"broken_cluster\"],[\"broken_cluster\"],[],[\"broken_cluster\"],[\"broken_cluster\"],[\"broken_cluster\"],[],[\"broken_cluster\"],[],[\"broken_cluster\"],[\"broken_cluster\"],[],[],[],[\"broken_cluster\"],[\"broken_cluster\"],[],[],[\"broken_cluster\"],[\"broken_cluster\"],[\"standalone_cluster\"],[\"standalone_cluster\"],[\"standalone_cluster\"],[\"standalone_cluster\"],[],[\"standalone_cluster\"],[],[\"standalone_cluster\"],[\"standalone_cluster\"],[],[],[\"standalone_cluster\"],[\"standalone_cluster\"],[\"standalone_cluster\"],[\"standalone_cluster\"],[\"standalone_cluster\"],[\"standalone_cluster\"],[\"standalone_cluster\"],[],[\"standalone_cluster\"],[\"broken_cluster\"],[],[\"broken_cluster\"],[\"broken_cluster\"],[\"consonant_syllable\"],[\"consonant_syllable\"],[\"consonant_syllable\",\"broken_cluster\"],[\"consonant_syllable\",\"broken_cluster\"],[\"broken_cluster\"],[\"broken_cluster\"],[\"broken_cluster\"],[\"symbol_cluster\"],[\"symbol_cluster\"],[\"symbol_cluster\"],[\"consonant_syllable\"],[\"consonant_syllable\"],[],[\"consonant_syllable\"],[\"consonant_syllable\"],[\"consonant_syllable\"],[],[\"consonant_syllable\"],[],[\"consonant_syllable\"],[\"consonant_syllable\"],[],[],[],[\"consonant_syllable\"],[\"consonant_syllable\"],[],[],[\"consonant_syllable\"],[\"consonant_syllable\"],[\"consonant_syllable\"],[],[\"consonant_syllable\"],[\"consonant_syllable\"],[\"consonant_syllable\"],[\"consonant_syllable\"],[\"vowel_syllable\"],[\"vowel_syllable\"],[],[\"vowel_syllable\"],[\"vowel_syllable\"],[\"vowel_syllable\"],[],[\"vowel_syllable\"],[],[\"vowel_syllable\"],[\"vowel_syllable\"],[],[],[],[\"vowel_syllable\"],[\"vowel_syllable\"],[],[],[\"vowel_syllable\"],[\"vowel_syllable\"],[\"vowel_syllable\"],[],[\"vowel_syllable\"],[\"vowel_syllable\"],[\"vowel_syllable\"],[\"vowel_syllable\"],[\"broken_cluster\"],[],[\"broken_cluster\"],[\"broken_cluster\"],[\"broken_cluster\"],[\"broken_cluster\"],[\"broken_cluster\"],[],[\"broken_cluster\"],[\"broken_cluster\"],[],[],[],[],[\"broken_cluster\"],[\"broken_cluster\"],[],[],[\"broken_cluster\"],[\"standalone_cluster\"],[\"standalone_cluster\"],[],[\"standalone_cluster\"],[\"standalone_cluster\"],[\"standalone_cluster\"],[],[\"standalone_cluster\"],[],[\"standalone_cluster\"],[\"standalone_cluster\"],[],[],[],[\"standalone_cluster\"],[\"standalone_cluster\"],[],[],[\"standalone_cluster\"],[\"standalone_cluster\"],[\"standalone_cluster\"],[],[\"standalone_cluster\"],[\"standalone_cluster\"],[\"standalone_cluster\"],[\"standalone_cluster\"],[],[\"broken_cluster\"],[],[\"consonant_syllable\",\"broken_cluster\"],[\"consonant_syllable\",\"broken_cluster\"],[\"consonant_syllable\",\"broken_cluster\"],[\"consonant_syllable\",\"broken_cluster\"],[\"consonant_syllable\",\"broken_cluster\"],[\"consonant_syllable\",\"broken_cluster\"],[\"broken_cluster\"],[\"symbol_cluster\"],[\"consonant_syllable\"],[],[\"consonant_syllable\"],[\"consonant_syllable\"],[\"consonant_syllable\"],[\"consonant_syllable\"],[\"consonant_syllable\"],[],[\"consonant_syllable\"],[\"consonant_syllable\"],[],[],[],[],[\"consonant_syllable\"],[\"consonant_syllable\"],[],[],[\"consonant_syllable\"],[\"consonant_syllable\"],[\"vowel_syllable\"],[],[\"vowel_syllable\"],[\"vowel_syllable\"],[\"vowel_syllable\"],[\"vowel_syllable\"],[\"vowel_syllable\"],[],[\"vowel_syllable\"],[\"vowel_syllable\"],[],[],[],[],[\"vowel_syllable\"],[\"vowel_syllable\"],[],[],[\"vowel_syllable\"],[\"vowel_syllable\"],[\"broken_cluster\"],[\"broken_cluster\"],[],[\"broken_cluster\"],[\"broken_cluster\"],[\"broken_cluster\"],[\"broken_cluster\"],[\"broken_cluster\"],[\"broken_cluster\"],[],[\"broken_cluster\"],[\"broken_cluster\"],[],[],[],[],[\"broken_cluster\"],[],[\"standalone_cluster\"],[],[\"standalone_cluster\"],[\"standalone_cluster\"],[\"standalone_cluster\"],[\"standalone_cluster\"],[\"standalone_cluster\"],[],[\"standalone_cluster\"],[\"standalone_cluster\"],[],[],[],[],[\"standalone_cluster\"],[\"standalone_cluster\"],[],[],[\"standalone_cluster\"],[\"standalone_cluster\"],[\"consonant_syllable\",\"broken_cluster\"],[],[\"consonant_syllable\",\"broken_cluster\"],[\"consonant_syllable\",\"broken_cluster\"],[],[],[\"consonant_syllable\",\"broken_cluster\"],[],[\"consonant_syllable\",\"broken_cluster\"],[\"consonant_syllable\",\"broken_cluster\"],[],[\"consonant_syllable\",\"broken_cluster\"],[\"consonant_syllable\",\"broken_cluster\"],[],[\"consonant_syllable\"],[\"consonant_syllable\"],[],[\"consonant_syllable\"],[\"consonant_syllable\"],[\"consonant_syllable\"],[\"consonant_syllable\"],[\"consonant_syllable\"],[\"consonant_syllable\"],[],[\"consonant_syllable\"],[\"consonant_syllable\"],[],[],[],[],[\"consonant_syllable\"],[],[\"vowel_syllable\"],[\"vowel_syllable\"],[],[\"vowel_syllable\"],[\"vowel_syllable\"],[\"vowel_syllable\"],[\"vowel_syllable\"],[\"vowel_syllable\"],[\"vowel_syllable\"],[],[\"vowel_syllable\"],[\"vowel_syllable\"],[],[],[],[],[\"vowel_syllable\"],[],[\"broken_cluster\"],[],[\"broken_cluster\"],[\"broken_cluster\"],[\"broken_cluster\"],[\"broken_cluster\"],[],[],[],[\"standalone_cluster\"],[\"standalone_cluster\"],[],[\"standalone_cluster\"],[\"standalone_cluster\"],[\"standalone_cluster\"],[\"standalone_cluster\"],[\"standalone_cluster\"],[\"standalone_cluster\"],[],[\"standalone_cluster\"],[\"standalone_cluster\"],[],[],[],[],[\"standalone_cluster\"],[],[\"consonant_syllable\",\"broken_cluster\"],[],[\"consonant_syllable\",\"broken_cluster\"],[\"consonant_syllable\",\"broken_cluster\"],[],[],[\"consonant_syllable\",\"broken_cluster\"],[\"consonant_syllable\",\"broken_cluster\"],[],[],[\"consonant_syllable\",\"broken_cluster\"],[\"consonant_syllable\",\"broken_cluster\"],[\"consonant_syllable\",\"broken_cluster\"],[],[\"consonant_syllable\"],[],[\"consonant_syllable\"],[\"consonant_syllable\"],[\"consonant_syllable\"],[\"consonant_syllable\"],[],[],[],[\"vowel_syllable\"],[],[\"vowel_syllable\"],[\"vowel_syllable\"],[\"vowel_syllable\"],[\"vowel_syllable\"],[],[],[],[\"broken_cluster\"],[\"broken_cluster\"],[],[\"broken_cluster\"],[\"broken_cluster\"],[\"broken_cluster\"],[\"broken_cluster\"],[\"broken_cluster\"],[\"broken_cluster\"],[],[\"broken_cluster\"],[\"broken_cluster\"],[],[\"standalone_cluster\"],[],[\"standalone_cluster\"],[\"standalone_cluster\"],[\"standalone_cluster\"],[\"standalone_cluster\"],[],[],[],[],[],[],[],[\"consonant_syllable\",\"broken_cluster\"],[\"consonant_syllable\",\"broken_cluster\"],[],[],[\"consonant_syllable\",\"broken_cluster\"],[\"consonant_syllable\",\"broken_cluster\"],[],[\"consonant_syllable\",\"broken_cluster\"],[\"consonant_syllable\",\"broken_cluster\"],[\"consonant_syllable\"],[\"consonant_syllable\"],[],[\"consonant_syllable\"],[\"consonant_syllable\"],[\"consonant_syllable\"],[\"consonant_syllable\"],[\"consonant_syllable\"],[\"consonant_syllable\"],[],[\"consonant_syllable\"],[\"consonant_syllable\"],[],[\"vowel_syllable\"],[\"vowel_syllable\"],[],[\"vowel_syllable\"],[\"vowel_syllable\"],[\"vowel_syllable\"],[\"vowel_syllable\"],[\"vowel_syllable\"],[\"vowel_syllable\"],[],[\"vowel_syllable\"],[\"vowel_syllable\"],[],[\"broken_cluster\"],[],[\"broken_cluster\"],[\"broken_cluster\"],[\"broken_cluster\"],[\"broken_cluster\"],[\"standalone_cluster\"],[\"standalone_cluster\"],[],[\"standalone_cluster\"],[\"standalone_cluster\"],[\"standalone_cluster\"],[\"standalone_cluster\"],[\"standalone_cluster\"],[\"standalone_cluster\"],[],[\"standalone_cluster\"],[\"standalone_cluster\"],[],[],[],[],[],[\"consonant_syllable\",\"broken_cluster\"],[\"consonant_syllable\",\"broken_cluster\"],[],[\"consonant_syllable\"],[],[\"consonant_syllable\"],[\"consonant_syllable\"],[\"consonant_syllable\"],[\"consonant_syllable\"],[\"vowel_syllable\"],[],[\"vowel_syllable\"],[\"vowel_syllable\"],[\"vowel_syllable\"],[\"vowel_syllable\"],[\"broken_cluster\"],[],[\"broken_cluster\"],[\"broken_cluster\"],[\"broken_cluster\"],[\"broken_cluster\"],[\"broken_cluster\"],[],[\"broken_cluster\"],[\"broken_cluster\"],[\"standalone_cluster\"],[],[\"standalone_cluster\"],[\"standalone_cluster\"],[\"standalone_cluster\"],[\"standalone_cluster\"],[],[],[],[\"consonant_syllable\"],[],[\"consonant_syllable\"],[\"consonant_syllable\"],[\"consonant_syllable\"],[\"consonant_syllable\"],[\"consonant_syllable\"],[],[\"consonant_syllable\"],[\"consonant_syllable\"],[\"vowel_syllable\"],[],[\"vowel_syllable\"],[\"vowel_syllable\"],[\"vowel_syllable\"],[\"vowel_syllable\"],[\"vowel_syllable\"],[],[\"vowel_syllable\"],[\"vowel_syllable\"],[\"broken_cluster\"],[\"standalone_cluster\"],[],[\"standalone_cluster\"],[\"standalone_cluster\"],[\"standalone_cluster\"],[\"standalone_cluster\"],[\"standalone_cluster\"],[],[\"standalone_cluster\"],[\"standalone_cluster\"],[],[\"consonant_syllable\"],[\"vowel_syllable\"],[\"standalone_cluster\"]]}","{\"categories\":[\"O\",\"IND\",\"S\",\"GB\",\"B\",\"FM\",\"CGJ\",\"VMAbv\",\"VMPst\",\"VAbv\",\"VPst\",\"CMBlw\",\"VPre\",\"VBlw\",\"H\",\"VMBlw\",\"CMAbv\",\"MBlw\",\"CS\",\"R\",\"SUB\",\"MPst\",\"MPre\",\"FAbv\",\"FPst\",\"FBlw\",\"null\",\"SMAbv\",\"SMBlw\",\"VMPre\",\"ZWNJ\",\"ZWJ\",\"WJ\",\"M\",\"VS\",\"N\",\"HN\",\"MAbv\"],\"decompositions\":{\"2507\":[2503,2494],\"2508\":[2503,2519],\"2888\":[2887,2902],\"2891\":[2887,2878],\"2892\":[2887,2903],\"3018\":[3014,3006],\"3019\":[3015,3006],\"3020\":[3014,3031],\"3144\":[3142,3158],\"3264\":[3263,3285],\"3271\":[3270,3285],\"3272\":[3270,3286],\"3274\":[3270,3266],\"3275\":[3270,3266,3285],\"3402\":[3398,3390],\"3403\":[3399,3390],\"3404\":[3398,3415],\"3546\":[3545,3530],\"3548\":[3545,3535],\"3549\":[3545,3535,3530],\"3550\":[3545,3551],\"3635\":[3661,3634],\"3763\":[3789,3762],\"3955\":[3953,3954],\"3957\":[3953,3956],\"3958\":[4018,3968],\"3959\":[4018,3953,3968],\"3960\":[4019,3968],\"3961\":[4019,3953,3968],\"3969\":[3953,3968],\"6971\":[6970,6965],\"6973\":[6972,6965],\"6976\":[6974,6965],\"6977\":[6975,6965],\"6979\":[6978,6965],\"69934\":[69937,69927],\"69935\":[69938,69927],\"70475\":[70471,70462],\"70476\":[70471,70487],\"70843\":[70841,70842],\"70844\":[70841,70832],\"70846\":[70841,70845],\"71098\":[71096,71087],\"71099\":[71097,71087]},\"stateTable\":[[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[2,2,3,4,4,5,0,6,7,8,9,10,11,12,13,14,15,16,0,17,18,11,19,20,21,22,0,0,0,23,0,0,2,0,0,24,0,25],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,26,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,27,28,0,0,0,0,0,27,0,0,0],[0,0,0,0,0,29,0,30,31,32,33,34,35,36,37,38,39,40,0,0,41,35,42,43,44,45,0,0,0,46,0,0,0,0,39,0,0,47],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,5,0,6,7,0,0,0,0,0,0,14,0,0,0,0,0,0,0,20,21,22,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,5,0,0,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,20,21,22,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,5,0,6,7,8,9,0,0,12,0,14,0,0,0,0,0,0,0,20,21,22,0,0,0,23,0,0,0,0,0,0,0,0],[0,0,0,0,0,5,0,6,7,0,9,0,0,0,0,14,0,0,0,0,0,0,0,20,21,22,0,0,0,23,0,0,0,0,0,0,0,0],[0,0,0,0,0,5,0,6,7,8,9,10,11,12,13,14,0,16,0,0,18,11,19,20,21,22,0,0,0,23,0,0,0,0,0,0,0,25],[0,0,0,0,0,5,0,6,7,8,9,0,11,12,0,14,0,0,0,0,0,0,0,20,21,22,0,0,0,23,0,0,0,0,0,0,0,0],[0,0,0,0,0,5,0,6,7,0,9,0,0,12,0,14,0,0,0,0,0,0,0,20,21,22,0,0,0,23,0,0,0,0,0,0,0,0],[0,0,0,0,18,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,5,0,0,7,0,0,0,0,0,0,14,0,0,0,0,0,0,0,20,21,22,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,5,0,6,7,8,9,10,11,12,13,14,15,16,0,0,18,11,19,20,21,22,0,0,0,23,0,0,0,0,0,0,0,25],[0,0,0,0,0,5,0,6,7,8,9,0,11,12,0,14,0,0,0,0,0,11,0,20,21,22,0,0,0,23,0,0,0,0,0,0,0,0],[0,0,0,4,4,5,0,6,7,8,9,10,11,12,13,14,15,16,0,0,18,11,19,20,21,22,0,0,0,23,0,0,0,0,0,0,0,25],[0,0,0,0,0,5,0,6,7,8,9,48,11,12,13,14,48,16,0,0,18,11,19,20,21,22,0,0,0,23,0,0,0,0,49,0,0,25],[0,0,0,0,0,5,0,6,7,8,9,0,11,12,0,14,0,16,0,0,0,11,0,20,21,22,0,0,0,23,0,0,0,0,0,0,0,25],[0,0,0,0,0,5,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,20,21,22,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,5,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,21,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,5,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,21,22,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,5,0,6,7,0,0,0,0,0,0,14,0,0,0,0,0,0,0,20,21,22,0,0,0,23,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,50,0,51,0],[0,0,0,0,0,5,0,6,7,8,9,0,11,12,0,14,0,16,0,0,0,11,0,20,21,22,0,0,0,23,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,27,28,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,28,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,29,0,30,31,0,0,0,0,0,0,38,0,0,0,0,0,0,0,43,44,45,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,29,0,0,31,0,0,0,0,0,0,0,0,0,0,0,0,0,0,43,44,45,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,29,0,30,31,32,33,0,0,36,0,38,0,0,0,0,0,0,0,43,44,45,0,0,0,46,0,0,0,0,0,0,0,0],[0,0,0,0,0,29,0,30,31,0,33,0,0,0,0,38,0,0,0,0,0,0,0,43,44,45,0,0,0,46,0,0,0,0,0,0,0,0],[0,0,0,0,0,29,0,30,31,32,33,34,35,36,37,38,0,40,0,0,41,35,42,43,44,45,0,0,0,46,0,0,0,0,0,0,0,47],[0,0,0,0,0,29,0,30,31,32,33,0,35,36,0,38,0,0,0,0,0,0,0,43,44,45,0,0,0,46,0,0,0,0,0,0,0,0],[0,0,0,0,0,29,0,30,31,0,33,0,0,36,0,38,0,0,0,0,0,0,0,43,44,45,0,0,0,46,0,0,0,0,0,0,0,0],[0,0,0,0,41,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,29,0,0,31,0,0,0,0,0,0,38,0,0,0,0,0,0,0,43,44,45,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,29,0,30,31,32,33,34,35,36,37,38,39,40,0,0,41,35,42,43,44,45,0,0,0,46,0,0,0,0,0,0,0,47],[0,0,0,0,0,29,0,30,31,32,33,0,35,36,0,38,0,0,0,0,0,35,0,43,44,45,0,0,0,46,0,0,0,0,0,0,0,0],[0,0,0,0,0,29,0,30,31,32,33,52,35,36,37,38,52,40,0,0,41,35,42,43,44,45,0,0,0,46,0,0,0,0,53,0,0,47],[0,0,0,0,0,29,0,30,31,32,33,0,35,36,0,38,0,40,0,0,0,35,0,43,44,45,0,0,0,46,0,0,0,0,0,0,0,47],[0,0,0,0,0,29,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,43,44,45,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,29,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,44,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,29,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,44,45,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,29,0,30,31,0,0,0,0,0,0,38,0,0,0,0,0,0,0,43,44,45,0,0,0,46,0,0,0,0,0,0,0,0],[0,0,0,0,0,29,0,30,31,32,33,0,35,36,0,38,0,40,0,0,0,35,0,43,44,45,0,0,0,46,0,0,0,0,0,0,0,0],[0,0,0,0,0,5,0,6,7,8,9,48,11,12,13,14,0,16,0,0,18,11,19,20,21,22,0,0,0,23,0,0,0,0,0,0,0,25],[0,0,0,0,0,5,0,6,7,8,9,48,11,12,13,14,48,16,0,0,18,11,19,20,21,22,0,0,0,23,0,0,0,0,0,0,0,25],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,51,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,54,0,0],[0,0,0,0,0,29,0,30,31,32,33,52,35,36,37,38,0,40,0,0,41,35,42,43,44,45,0,0,0,46,0,0,0,0,0,0,0,47],[0,0,0,0,0,29,0,30,31,32,33,52,35,36,37,38,52,40,0,0,41,35,42,43,44,45,0,0,0,46,0,0,0,0,0,0,0,47],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,50,0,51,0]],\"accepting\":[false,true,true,true,true,true,true,true,true,true,true,true,true,false,true,true,true,true,true,true,true,true,true,true,true,true,true,true,true,true,true,true,true,true,true,true,true,true,true,true,true,true,true,true,true,true,true,true,true,true,true,true,true,true,true],\"tags\":[[],[\"broken_cluster\"],[\"independent_cluster\"],[\"symbol_cluster\"],[\"standard_cluster\"],[\"broken_cluster\"],[\"broken_cluster\"],[\"broken_cluster\"],[\"broken_cluster\"],[\"broken_cluster\"],[\"broken_cluster\"],[\"broken_cluster\"],[\"broken_cluster\"],[],[\"broken_cluster\"],[\"broken_cluster\"],[\"broken_cluster\"],[\"broken_cluster\"],[\"broken_cluster\"],[\"broken_cluster\"],[\"broken_cluster\"],[\"broken_cluster\"],[\"broken_cluster\"],[\"broken_cluster\"],[\"numeral_cluster\"],[\"broken_cluster\"],[\"independent_cluster\"],[\"symbol_cluster\"],[\"symbol_cluster\"],[\"standard_cluster\"],[\"standard_cluster\"],[\"standard_cluster\"],[\"standard_cluster\"],[\"standard_cluster\"],[\"standard_cluster\"],[\"standard_cluster\"],[\"standard_cluster\"],[\"virama_terminated_cluster\"],[\"standard_cluster\"],[\"standard_cluster\"],[\"standard_cluster\"],[\"standard_cluster\"],[\"standard_cluster\"],[\"standard_cluster\"],[\"standard_cluster\"],[\"standard_cluster\"],[\"standard_cluster\"],[\"standard_cluster\"],[\"broken_cluster\"],[\"broken_cluster\"],[\"numeral_cluster\"],[\"number_joiner_terminated_cluster\"],[\"standard_cluster\"],[\"standard_cluster\"],[\"numeral_cluster\"]]}","// Cateories used in the OpenType spec:\n// https://www.microsoft.com/typography/otfntdev/devanot/shaping.aspx\nexport const CATEGORIES = {\n  X: 1 << 0,\n  C: 1 << 1,\n  V: 1 << 2,\n  N: 1 << 3,\n  H: 1 << 4,\n  ZWNJ: 1 << 5,\n  ZWJ: 1 << 6,\n  M: 1 << 7,\n  SM: 1 << 8,\n  VD: 1 << 9,\n  A: 1 << 10,\n  Placeholder: 1 << 11,\n  Dotted_Circle: 1 << 12,\n  RS: 1 << 13,    // Register Shifter, used in Khmer OT spec.\n  Coeng: 1 << 14, // Khmer-style Virama.\n  Repha: 1 << 15, // Atomically-encoded logical or visual repha.\n  Ra: 1 << 16,\n  CM: 1 << 17,    // Consonant-Medial.\n  Symbol: 1 << 18 // Avagraha, etc that take marks (SM,A,VD).\n};\n\n// Visual positions in a syllable from left to right.\nexport const POSITIONS = {\n  Start: 1 << 0,\n\n  Ra_To_Become_Reph: 1 << 1,\n  Pre_M: 1 << 2,\n  Pre_C: 1 << 3,\n\n  Base_C: 1 << 4,\n  After_Main: 1 << 5,\n\n  Above_C: 1 << 6,\n\n  Before_Sub: 1 << 7,\n  Below_C: 1 << 8,\n  After_Sub: 1 << 9,\n\n  Before_Post: 1 << 10,\n  Post_C: 1 << 11,\n  After_Post: 1 << 12,\n\n  Final_C: 1 << 13,\n  SMVD: 1 << 14,\n\n  End: 1 << 15\n};\n\nexport const CONSONANT_FLAGS = CATEGORIES.C | CATEGORIES.Ra | CATEGORIES.CM | CATEGORIES.V | CATEGORIES.Placeholder | CATEGORIES.Dotted_Circle;\nexport const JOINER_FLAGS = CATEGORIES.ZWJ | CATEGORIES.ZWNJ;\nexport const HALANT_OR_COENG_FLAGS = CATEGORIES.H | CATEGORIES.Coeng;\n\nexport const INDIC_CONFIGS = {\n  Default: {\n    hasOldSpec: false,\n    virama: 0,\n    basePos: 'Last',\n    rephPos: POSITIONS.Before_Post,\n    rephMode: 'Implicit',\n    blwfMode: 'Pre_And_Post'\n  },\n\n  Devanagari: {\n    hasOldSpec: true,\n    virama: 0x094D,\n    basePos: 'Last',\n    rephPos: POSITIONS.Before_Post,\n    rephMode: 'Implicit',\n    blwfMode: 'Pre_And_Post'\n  },\n\n  Bengali: {\n    hasOldSpec: true,\n    virama: 0x09CD,\n    basePos: 'Last',\n    rephPos: POSITIONS.After_Sub,\n    rephMode: 'Implicit',\n    blwfMode: 'Pre_And_Post'\n  },\n\n  Gurmukhi: {\n    hasOldSpec: true,\n    virama: 0x0A4D,\n    basePos: 'Last',\n    rephPos: POSITIONS.Before_Sub,\n    rephMode: 'Implicit',\n    blwfMode: 'Pre_And_Post'\n  },\n\n  Gujarati: {\n    hasOldSpec: true,\n    virama: 0x0ACD,\n    basePos: 'Last',\n    rephPos: POSITIONS.Before_Post,\n    rephMode: 'Implicit',\n    blwfMode: 'Pre_And_Post'\n  },\n\n  Oriya: {\n    hasOldSpec: true,\n    virama: 0x0B4D,\n    basePos: 'Last',\n    rephPos: POSITIONS.After_Main,\n    rephMode: 'Implicit',\n    blwfMode: 'Pre_And_Post'\n  },\n\n  Tamil: {\n    hasOldSpec: true,\n    virama: 0x0BCD,\n    basePos: 'Last',\n    rephPos: POSITIONS.After_Post,\n    rephMode: 'Implicit',\n    blwfMode: 'Pre_And_Post'\n  },\n\n  Telugu: {\n    hasOldSpec: true,\n    virama: 0x0C4D,\n    basePos: 'Last',\n    rephPos: POSITIONS.After_Post,\n    rephMode: 'Explicit',\n    blwfMode: 'Post_Only'\n  },\n\n  Kannada: {\n    hasOldSpec: true,\n    virama: 0x0CCD,\n    basePos: 'Last',\n    rephPos: POSITIONS.After_Post,\n    rephMode: 'Implicit',\n    blwfMode: 'Post_Only'\n  },\n\n  Malayalam: {\n    hasOldSpec: true,\n    virama: 0x0D4D,\n    basePos: 'Last',\n    rephPos: POSITIONS.After_Main,\n    rephMode: 'Log_Repha',\n    blwfMode: 'Pre_And_Post'\n  },\n\n  // Handled by UniversalShaper\n  // Sinhala: {\n  //   hasOldSpec: false,\n  //   virama: 0x0DCA,\n  //   basePos: 'Last_Sinhala',\n  //   rephPos: POSITIONS.After_Main,\n  //   rephMode: 'Explicit',\n  //   blwfMode: 'Pre_And_Post'\n  // },\n\n  Khmer: {\n    hasOldSpec: false,\n    virama: 0x17D2,\n    basePos: 'First',\n    rephPos: POSITIONS.Ra_To_Become_Reph,\n    rephMode: 'Vis_Repha',\n    blwfMode: 'Pre_And_Post'\n  }\n};\n\n// Additional decompositions that aren't in Unicode\nexport const INDIC_DECOMPOSITIONS = {\n  // Khmer\n  0x17BE: [0x17C1, 0x17BE],\n  0x17BF: [0x17C1, 0x17BF],\n  0x17C0: [0x17C1, 0x17C0],\n  0x17C4: [0x17C1, 0x17C4],\n  0x17C5: [0x17C1, 0x17C5]\n};\n","import DefaultShaper from './DefaultShaper';\nimport StateMachine from 'dfa';\nimport UnicodeTrie from 'unicode-trie';\nimport GlyphInfo from '../GlyphInfo';\nimport useData from './use.json';\nimport { decodeBase64 } from '../../utils';\n\nconst {categories, decompositions} = useData;\nconst trie = new UnicodeTrie(decodeBase64(require('fs').readFileSync(__dirname + '/use.trie', 'base64')));\nconst stateMachine = new StateMachine(useData);\n\n/**\n * This shaper is an implementation of the Universal Shaping Engine, which\n * uses Unicode data to shape a number of scripts without a dedicated shaping engine.\n * See https://www.microsoft.com/typography/OpenTypeDev/USE/intro.htm.\n */\nexport default class UniversalShaper extends DefaultShaper {\n  static zeroMarkWidths = 'BEFORE_GPOS';\n  static planFeatures(plan) {\n    plan.addStage(setupSyllables);\n\n    // Default glyph pre-processing group\n    plan.addStage(['locl', 'ccmp', 'nukt', 'akhn']);\n\n    // Reordering group\n    plan.addStage(clearSubstitutionFlags);\n    plan.addStage(['rphf'], false);\n    plan.addStage(recordRphf);\n    plan.addStage(clearSubstitutionFlags);\n    plan.addStage(['pref']);\n    plan.addStage(recordPref);\n\n    // Orthographic unit shaping group\n    plan.addStage(['rkrf', 'abvf', 'blwf', 'half', 'pstf', 'vatu', 'cjct']);\n    plan.addStage(reorder);\n\n    // Topographical features\n    // Scripts that need this are handled by the Arabic shaper, not implemented here for now.\n    // plan.addStage(['isol', 'init', 'medi', 'fina', 'med2', 'fin2', 'fin3'], false);\n\n    // Standard topographic presentation and positional feature application\n    plan.addStage(['abvs', 'blws', 'pres', 'psts', 'dist', 'abvm', 'blwm']);\n  }\n\n  static assignFeatures(plan, glyphs) {\n    // Decompose split vowels\n    // TODO: do this in a more general unicode normalizer\n    for (let i = glyphs.length - 1; i >= 0; i--) {\n      let codepoint = glyphs[i].codePoints[0];\n      if (decompositions[codepoint]) {\n        let decomposed = decompositions[codepoint].map(c => {\n          let g = plan.font.glyphForCodePoint(c);\n          return new GlyphInfo(plan.font, g.id, [c], glyphs[i].features);\n        });\n\n        glyphs.splice(i, 1, ...decomposed);\n      }\n    }\n  }\n}\n\nfunction useCategory(glyph) {\n  return trie.get(glyph.codePoints[0]);\n}\n\nclass USEInfo {\n  constructor(category, syllableType, syllable) {\n    this.category = category;\n    this.syllableType = syllableType;\n    this.syllable = syllable;\n  }\n}\n\nfunction setupSyllables(font, glyphs) {\n  let syllable = 0;\n  for (let [start, end, tags] of stateMachine.match(glyphs.map(useCategory))) {\n    ++syllable;\n\n    // Create shaper info\n    for (let i = start; i <= end; i++) {\n      glyphs[i].shaperInfo = new USEInfo(categories[useCategory(glyphs[i])], tags[0], syllable);\n    }\n\n    // Assign rphf feature\n    let limit = glyphs[start].shaperInfo.category === 'R' ? 1 : Math.min(3, end - start);\n    for (let i = start; i < start + limit; i++) {\n      glyphs[i].features.rphf = true;\n    }\n  }\n}\n\nfunction clearSubstitutionFlags(font, glyphs) {\n  for (let glyph of glyphs) {\n    glyph.substituted = false;\n  }\n}\n\nfunction recordRphf(font, glyphs) {\n  for (let glyph of glyphs) {\n    if (glyph.substituted && glyph.features.rphf) {\n      // Mark a substituted repha.\n      glyph.shaperInfo.category = 'R';\n    }\n  }\n}\n\nfunction recordPref(font, glyphs) {\n  for (let glyph of glyphs) {\n    if (glyph.substituted) {\n      // Mark a substituted pref as VPre, as they behave the same way.\n      glyph.shaperInfo.category = 'VPre';\n    }\n  }\n}\n\nfunction reorder(font, glyphs) {\n  let dottedCircle = font.glyphForCodePoint(0x25cc).id;\n\n  for (let start = 0, end = nextSyllable(glyphs, 0); start < glyphs.length; start = end, end = nextSyllable(glyphs, start)) {\n    let i, j;\n    let info = glyphs[start].shaperInfo;\n    let type = info.syllableType;\n\n    // Only a few syllable types need reordering.\n    if (type !== 'virama_terminated_cluster' && type !== 'standard_cluster' && type !== 'broken_cluster') {\n      continue;\n    }\n\n    // Insert a dotted circle glyph in broken clusters.\n    if (type === 'broken_cluster' && dottedCircle) {\n      let g = new GlyphInfo(font, dottedCircle, [0x25cc]);\n      g.shaperInfo = info;\n\n      // Insert after possible Repha.\n      for (i = start; i < end && glyphs[i].shaperInfo.category === 'R'; i++);\n      glyphs.splice(++i, 0, g);\n      end++;\n    }\n\n    // Move things forward.\n    if (info.category === 'R' && end - start > 1) {\n      // Got a repha. Reorder it to after first base, before first halant.\n      for (i = start + 1; i < end; i++) {\n        info = glyphs[i].shaperInfo;\n        if (isBase(info) || isHalant(glyphs[i])) {\n          // If we hit a halant, move before it; otherwise it's a base: move to it's\n          // place, and shift things in between backward.\n          if (isHalant(glyphs[i])) {\n            i--;\n          }\n\n          glyphs.splice(start, 0, ...glyphs.splice(start + 1, i - start), glyphs[i]);\n          break;\n        }\n      }\n    }\n\n    // Move things back.\n    for (i = start, j = end; i < end; i++) {\n      info = glyphs[i].shaperInfo;\n      if (isBase(info) || isHalant(glyphs[i])) {\n        // If we hit a halant, move after it; otherwise it's a base: move to it's\n        // place, and shift things in between backward.\n        j = isHalant(glyphs[i]) ? i + 1 : i;\n      } else if ((info.category === 'VPre' || info.category === 'VMPre') && j < i) {\n        glyphs.splice(j, 1, glyphs[i], ...glyphs.splice(j, i - j));\n      }\n    }\n  }\n}\n\nfunction nextSyllable(glyphs, start) {\n  if (start >= glyphs.length) return start;\n  let syllable = glyphs[start].shaperInfo.syllable;\n  while (++start < glyphs.length && glyphs[start].shaperInfo.syllable === syllable);\n  return start;\n}\n\nfunction isHalant(glyph) {\n  return glyph.shaperInfo.category === 'H' && !glyph.isLigated;\n}\n\nfunction isBase(info) {\n  return info.category === 'B' || info.category === 'GB';\n}\n","import OTProcessor from './OTProcessor';\nimport GlyphInfo from './GlyphInfo';\n\nexport default class GSUBProcessor extends OTProcessor {\n  applyLookup(lookupType, table) {\n    switch (lookupType) {\n      case 1: { // Single Substitution\n        let index = this.coverageIndex(table.coverage);\n        if (index === -1) {\n          return false;\n        }\n\n        let glyph = this.glyphIterator.cur;\n        switch (table.version) {\n          case 1:\n            glyph.id = (glyph.id + table.deltaGlyphID) & 0xffff;\n            break;\n\n          case 2:\n            glyph.id = table.substitute.get(index);\n            break;\n        }\n\n        return true;\n      }\n\n      case 2: { // Multiple Substitution\n        let index = this.coverageIndex(table.coverage);\n        if (index !== -1) {\n          let sequence = table.sequences.get(index);\n\n          if (sequence.length === 0) {\n            // If the sequence length is zero, delete the glyph.\n            // The OpenType spec disallows this, but seems like Harfbuzz and Uniscribe allow it.\n            this.glyphs.splice(this.glyphIterator.index, 1);\n            return true;\n          }\n\n          this.glyphIterator.cur.id = sequence[0];\n          this.glyphIterator.cur.ligatureComponent = 0;\n\n          let features = this.glyphIterator.cur.features;\n          let curGlyph = this.glyphIterator.cur;\n          let replacement = sequence.slice(1).map((gid, i) => {\n            let glyph = new GlyphInfo(this.font, gid, undefined, features);\n            glyph.shaperInfo = curGlyph.shaperInfo;\n            glyph.isLigated = curGlyph.isLigated;\n            glyph.ligatureComponent = i + 1;\n            glyph.substituted = true;\n            glyph.isMultiplied = true;\n            return glyph;\n          });\n\n          this.glyphs.splice(this.glyphIterator.index + 1, 0, ...replacement);\n          return true;\n        }\n\n        return false;\n      }\n\n      case 3: { // Alternate Substitution\n        let index = this.coverageIndex(table.coverage);\n        if (index !== -1) {\n          let USER_INDEX = 0; // TODO\n          this.glyphIterator.cur.id = table.alternateSet.get(index)[USER_INDEX];\n          return true;\n        }\n\n        return false;\n      }\n\n      case 4: { // Ligature Substitution\n        let index = this.coverageIndex(table.coverage);\n        if (index === -1) {\n          return false;\n        }\n\n        for (let ligature of table.ligatureSets.get(index)) {\n          let matched = this.sequenceMatchIndices(1, ligature.components);\n          if (!matched) {\n            continue;\n          }\n\n          let curGlyph = this.glyphIterator.cur;\n\n          // Concatenate all of the characters the new ligature will represent\n          let characters = curGlyph.codePoints.slice();\n          for (let index of matched) {\n            characters.push(...this.glyphs[index].codePoints);\n          }\n\n          // Create the replacement ligature glyph\n          let ligatureGlyph = new GlyphInfo(this.font, ligature.glyph, characters, curGlyph.features);\n          ligatureGlyph.shaperInfo = curGlyph.shaperInfo;\n          ligatureGlyph.isLigated = true;\n          ligatureGlyph.substituted = true;\n\n          // From Harfbuzz:\n          // - If it *is* a mark ligature, we don't allocate a new ligature id, and leave\n          //   the ligature to keep its old ligature id.  This will allow it to attach to\n          //   a base ligature in GPOS.  Eg. if the sequence is: LAM,LAM,SHADDA,FATHA,HEH,\n          //   and LAM,LAM,HEH for a ligature, they will leave SHADDA and FATHA with a\n          //   ligature id and component value of 2.  Then if SHADDA,FATHA form a ligature\n          //   later, we don't want them to lose their ligature id/component, otherwise\n          //   GPOS will fail to correctly position the mark ligature on top of the\n          //   LAM,LAM,HEH ligature. See https://bugzilla.gnome.org/show_bug.cgi?id=676343\n          //\n          // - If a ligature is formed of components that some of which are also ligatures\n          //   themselves, and those ligature components had marks attached to *their*\n          //   components, we have to attach the marks to the new ligature component\n          //   positions!  Now *that*'s tricky!  And these marks may be following the\n          //   last component of the whole sequence, so we should loop forward looking\n          //   for them and update them.\n          //\n          //   Eg. the sequence is LAM,LAM,SHADDA,FATHA,HEH, and the font first forms a\n          //   'calt' ligature of LAM,HEH, leaving the SHADDA and FATHA with a ligature\n          //   id and component == 1.  Now, during 'liga', the LAM and the LAM-HEH ligature\n          //   form a LAM-LAM-HEH ligature.  We need to reassign the SHADDA and FATHA to\n          //   the new ligature with a component value of 2.\n          //\n          //   This in fact happened to a font...  See https://bugzilla.gnome.org/show_bug.cgi?id=437633\n          let isMarkLigature = curGlyph.isMark;\n          for (let i = 0; i < matched.length && isMarkLigature; i++) {\n            isMarkLigature = this.glyphs[matched[i]].isMark;\n          }\n\n          ligatureGlyph.ligatureID = isMarkLigature ? null : this.ligatureID++;\n\n          let lastLigID = curGlyph.ligatureID;\n          let lastNumComps = curGlyph.codePoints.length;\n          let curComps = lastNumComps;\n          let idx = this.glyphIterator.index + 1;\n\n          // Set ligatureID and ligatureComponent on glyphs that were skipped in the matched sequence.\n          // This allows GPOS to attach marks to the correct ligature components.\n          for (let matchIndex of matched) {\n            // Don't assign new ligature components for mark ligatures (see above)\n            if (isMarkLigature) {\n              idx = matchIndex;\n            } else {\n              while (idx < matchIndex) {\n                var ligatureComponent = curComps - lastNumComps + Math.min(this.glyphs[idx].ligatureComponent || 1, lastNumComps);\n                this.glyphs[idx].ligatureID = ligatureGlyph.ligatureID;\n                this.glyphs[idx].ligatureComponent = ligatureComponent;\n                idx++;\n              }\n            }\n\n            lastLigID = this.glyphs[idx].ligatureID;\n            lastNumComps = this.glyphs[idx].codePoints.length;\n            curComps += lastNumComps;\n            idx++; // skip base glyph\n          }\n\n          // Adjust ligature components for any marks following\n          if (lastLigID && !isMarkLigature) {\n            for (let i = idx; i < this.glyphs.length; i++) {\n              if (this.glyphs[i].ligatureID === lastLigID) {\n                var ligatureComponent = curComps - lastNumComps + Math.min(this.glyphs[i].ligatureComponent || 1, lastNumComps);\n                this.glyphs[i].ligatureComponent = ligatureComponent;\n              } else {\n                break;\n              }\n            }\n          }\n\n          // Delete the matched glyphs, and replace the current glyph with the ligature glyph\n          for (let i = matched.length - 1; i >= 0; i--) {\n            this.glyphs.splice(matched[i], 1);\n          }\n\n          this.glyphs[this.glyphIterator.index] = ligatureGlyph;\n          return true;\n        }\n\n        return false;\n      }\n\n      case 5: // Contextual Substitution\n        return this.applyContext(table);\n\n      case 6: // Chaining Contextual Substitution\n        return this.applyChainingContext(table);\n\n      case 7: // Extension Substitution\n        return this.applyLookup(table.lookupType, table.extension);\n\n      default:\n        throw new Error(`GSUB lookupType ${lookupType} is not supported`);\n    }\n  }\n}\n","import OTProcessor from './OTProcessor';\n\nexport default class GPOSProcessor extends OTProcessor {\n  applyPositionValue(sequenceIndex, value) {\n    let position = this.positions[this.glyphIterator.peekIndex(sequenceIndex)];\n    if (value.xAdvance != null) {\n      position.xAdvance += value.xAdvance;\n    }\n\n    if (value.yAdvance != null) {\n      position.yAdvance += value.yAdvance;\n    }\n\n    if (value.xPlacement != null) {\n      position.xOffset += value.xPlacement;\n    }\n\n    if (value.yPlacement != null) {\n      position.yOffset += value.yPlacement;\n    }\n\n    // Adjustments for font variations\n    let variationProcessor = this.font._variationProcessor;\n    let variationStore = this.font.GDEF && this.font.GDEF.itemVariationStore;\n    if (variationProcessor && variationStore) {\n      if (value.xPlaDevice) {\n        position.xOffset += variationProcessor.getDelta(variationStore, value.xPlaDevice.a, value.xPlaDevice.b);\n      }\n\n      if (value.yPlaDevice) {\n        position.yOffset += variationProcessor.getDelta(variationStore, value.yPlaDevice.a, value.yPlaDevice.b);\n      }\n\n      if (value.xAdvDevice) {\n        position.xAdvance += variationProcessor.getDelta(variationStore, value.xAdvDevice.a, value.xAdvDevice.b);\n      }\n\n      if (value.yAdvDevice) {\n        position.yAdvance += variationProcessor.getDelta(variationStore, value.yAdvDevice.a, value.yAdvDevice.b);\n      }\n    }\n\n    // TODO: device tables\n  }\n\n  applyLookup(lookupType, table) {\n    switch (lookupType) {\n      case 1: { // Single positioning value\n        let index = this.coverageIndex(table.coverage);\n        if (index === -1) {\n          return false;\n        }\n\n        switch (table.version) {\n          case 1:\n            this.applyPositionValue(0, table.value);\n            break;\n\n          case 2:\n            this.applyPositionValue(0, table.values.get(index));\n            break;\n        }\n\n        return true;\n      }\n\n      case 2: { // Pair Adjustment Positioning\n        let nextGlyph = this.glyphIterator.peek();\n        if (!nextGlyph) {\n          return false;\n        }\n\n        let index = this.coverageIndex(table.coverage);\n        if (index === -1) {\n          return false;\n        }\n\n        switch (table.version) {\n          case 1: // Adjustments for glyph pairs\n            let set = table.pairSets.get(index);\n\n            for (let pair of set) {\n              if (pair.secondGlyph === nextGlyph.id) {\n                this.applyPositionValue(0, pair.value1);\n                this.applyPositionValue(1, pair.value2);\n                return true;\n              }\n            }\n\n            return false;\n\n          case 2: // Class pair adjustment\n            let class1 = this.getClassID(this.glyphIterator.cur.id, table.classDef1);\n            let class2 = this.getClassID(nextGlyph.id, table.classDef2);\n            if (class1 === -1 || class2 === -1) {\n              return false;\n            }\n\n            var pair = table.classRecords.get(class1).get(class2);\n            this.applyPositionValue(0, pair.value1);\n            this.applyPositionValue(1, pair.value2);\n            return true;\n        }\n      }\n\n      case 3: { // Cursive Attachment Positioning\n        let nextIndex = this.glyphIterator.peekIndex();\n        let nextGlyph = this.glyphs[nextIndex];\n        if (!nextGlyph) {\n          return false;\n        }\n\n        let curRecord = table.entryExitRecords[this.coverageIndex(table.coverage)];\n        if (!curRecord || !curRecord.exitAnchor) {\n          return false;\n        }\n\n        let nextRecord = table.entryExitRecords[this.coverageIndex(table.coverage, nextGlyph.id)];\n        if (!nextRecord || !nextRecord.entryAnchor) {\n          return false;\n        }\n\n        let entry = this.getAnchor(nextRecord.entryAnchor);\n        let exit = this.getAnchor(curRecord.exitAnchor);\n\n        let cur = this.positions[this.glyphIterator.index];\n        let next = this.positions[nextIndex];\n        let d;\n\n        switch (this.direction) {\n          case 'ltr':\n            cur.xAdvance = exit.x + cur.xOffset;\n\n            d = entry.x + next.xOffset;\n            next.xAdvance -= d;\n            next.xOffset -= d;\n            break;\n\n          case 'rtl':\n            d = exit.x + cur.xOffset;\n            cur.xAdvance -= d;\n            cur.xOffset -= d;\n            next.xAdvance = entry.x + next.xOffset;\n            break;\n        }\n\n        if (this.glyphIterator.flags.rightToLeft) {\n          this.glyphIterator.cur.cursiveAttachment = nextIndex;\n          cur.yOffset = entry.y - exit.y;\n        } else {\n          nextGlyph.cursiveAttachment = this.glyphIterator.index;\n          cur.yOffset = exit.y - entry.y;\n        }\n\n        return true;\n      }\n\n      case 4: { // Mark to base positioning\n        let markIndex = this.coverageIndex(table.markCoverage);\n        if (markIndex === -1) {\n          return false;\n        }\n\n        // search backward for a base glyph\n        let baseGlyphIndex = this.glyphIterator.index;\n        while (--baseGlyphIndex >= 0 && (this.glyphs[baseGlyphIndex].isMark || this.glyphs[baseGlyphIndex].ligatureComponent > 0));\n\n        if (baseGlyphIndex < 0) {\n          return false;\n        }\n\n        let baseIndex = this.coverageIndex(table.baseCoverage, this.glyphs[baseGlyphIndex].id);\n        if (baseIndex === -1) {\n          return false;\n        }\n\n        let markRecord = table.markArray[markIndex];\n        let baseAnchor = table.baseArray[baseIndex][markRecord.class];\n        this.applyAnchor(markRecord, baseAnchor, baseGlyphIndex);\n        return true;\n      }\n\n      case 5: { // Mark to ligature positioning\n        let markIndex = this.coverageIndex(table.markCoverage);\n        if (markIndex === -1) {\n          return false;\n        }\n\n        // search backward for a base glyph\n        let baseGlyphIndex = this.glyphIterator.index;\n        while (--baseGlyphIndex >= 0 && this.glyphs[baseGlyphIndex].isMark);\n\n        if (baseGlyphIndex < 0) {\n          return false;\n        }\n\n        let ligIndex = this.coverageIndex(table.ligatureCoverage, this.glyphs[baseGlyphIndex].id);\n        if (ligIndex === -1) {\n          return false;\n        }\n\n        let ligAttach = table.ligatureArray[ligIndex];\n        let markGlyph = this.glyphIterator.cur;\n        let ligGlyph = this.glyphs[baseGlyphIndex];\n        let compIndex = ligGlyph.ligatureID && ligGlyph.ligatureID === markGlyph.ligatureID && (markGlyph.ligatureComponent > 0)\n          ? Math.min(markGlyph.ligatureComponent, ligGlyph.codePoints.length) - 1\n          : ligGlyph.codePoints.length - 1;\n\n        let markRecord = table.markArray[markIndex];\n        let baseAnchor = ligAttach[compIndex][markRecord.class];\n        this.applyAnchor(markRecord, baseAnchor, baseGlyphIndex);\n        return true;\n      }\n\n      case 6: { // Mark to mark positioning\n        let mark1Index = this.coverageIndex(table.mark1Coverage);\n        if (mark1Index === -1) {\n          return false;\n        }\n\n        // get the previous mark to attach to\n        let prevIndex = this.glyphIterator.peekIndex(-1);\n        let prev = this.glyphs[prevIndex];\n        if (!prev || !prev.isMark) {\n          return false;\n        }\n\n        let cur = this.glyphIterator.cur;\n\n        // The following logic was borrowed from Harfbuzz\n        let good = false;\n        if (cur.ligatureID === prev.ligatureID) {\n          if (!cur.ligatureID) { // Marks belonging to the same base\n            good = true;\n          } else if (cur.ligatureComponent === prev.ligatureComponent) { // Marks belonging to the same ligature component\n            good = true;\n          }\n        } else {\n          // If ligature ids don't match, it may be the case that one of the marks\n          // itself is a ligature, in which case match.\n          if ((cur.ligatureID && !cur.ligatureComponent) || (prev.ligatureID && !prev.ligatureComponent)) {\n            good = true;\n          }\n        }\n\n        if (!good) {\n          return false;\n        }\n\n        let mark2Index = this.coverageIndex(table.mark2Coverage, prev.id);\n        if (mark2Index === -1) {\n          return false;\n        }\n\n        let markRecord = table.mark1Array[mark1Index];\n        let baseAnchor = table.mark2Array[mark2Index][markRecord.class];\n        this.applyAnchor(markRecord, baseAnchor, prevIndex);\n        return true;\n      }\n\n      case 7: // Contextual positioning\n        return this.applyContext(table);\n\n      case 8: // Chaining contextual positioning\n        return this.applyChainingContext(table);\n\n      case 9: // Extension positioning\n        return this.applyLookup(table.lookupType, table.extension);\n\n      default:\n        throw new Error(`Unsupported GPOS table: ${lookupType}`);\n    }\n  }\n\n  applyAnchor(markRecord, baseAnchor, baseGlyphIndex) {\n    let baseCoords = this.getAnchor(baseAnchor);\n    let markCoords = this.getAnchor(markRecord.markAnchor);\n\n    let basePos = this.positions[baseGlyphIndex];\n    let markPos = this.positions[this.glyphIterator.index];\n\n    markPos.xOffset = baseCoords.x - markCoords.x;\n    markPos.yOffset = baseCoords.y - markCoords.y;\n    this.glyphIterator.cur.markAttachment = baseGlyphIndex;\n  }\n\n  getAnchor(anchor) {\n    // TODO: contour point, device tables\n    let x = anchor.xCoordinate;\n    let y = anchor.yCoordinate;\n\n    // Adjustments for font variations\n    let variationProcessor = this.font._variationProcessor;\n    let variationStore = this.font.GDEF && this.font.GDEF.itemVariationStore;\n    if (variationProcessor && variationStore) {\n      if (anchor.xDeviceTable) {\n        x += variationProcessor.getDelta(variationStore, anchor.xDeviceTable.a, anchor.xDeviceTable.b);\n      }\n\n      if (anchor.yDeviceTable) {\n        y += variationProcessor.getDelta(variationStore, anchor.yDeviceTable.a, anchor.yDeviceTable.b);\n      }\n    }\n\n    return { x, y };\n  }\n\n  applyFeatures(userFeatures, glyphs, advances) {\n    super.applyFeatures(userFeatures, glyphs, advances);\n\n    for (var i = 0; i < this.glyphs.length; i++) {\n      this.fixCursiveAttachment(i);\n    }\n\n    this.fixMarkAttachment();\n  }\n\n  fixCursiveAttachment(i) {\n    let glyph = this.glyphs[i];\n    if (glyph.cursiveAttachment != null) {\n      let j = glyph.cursiveAttachment;\n\n      glyph.cursiveAttachment = null;\n      this.fixCursiveAttachment(j);\n\n      this.positions[i].yOffset += this.positions[j].yOffset;\n    }\n  }\n\n  fixMarkAttachment() {\n    for (let i = 0; i < this.glyphs.length; i++) {\n      let glyph = this.glyphs[i];\n      if (glyph.markAttachment != null) {\n        let j = glyph.markAttachment;\n\n        this.positions[i].xOffset += this.positions[j].xOffset;\n        this.positions[i].yOffset += this.positions[j].yOffset;\n\n        if (this.direction === 'ltr') {\n          for (let k = j; k < i; k++) {\n            this.positions[i].xOffset -= this.positions[k].xAdvance;\n            this.positions[i].yOffset -= this.positions[k].yAdvance;\n          }\n        } else {\n          for (let k = j + 1; k < i + 1; k++) {\n            this.positions[i].xOffset += this.positions[k].xAdvance;\n            this.positions[i].yOffset += this.positions[k].yAdvance;\n          }\n        }\n      }\n    }\n  }\n}\n","import Glyph from './Glyph';\nimport Path from './Path';\nimport BBox from './BBox';\nimport * as r from 'restructure';\n\n// The header for both simple and composite glyphs\nlet GlyfHeader = new r.Struct({\n  numberOfContours: r.int16, // if negative, this is a composite glyph\n  xMin:             r.int16,\n  yMin:             r.int16,\n  xMax:             r.int16,\n  yMax:             r.int16\n});\n\n// Flags for simple glyphs\nconst ON_CURVE        = 1 << 0;\nconst X_SHORT_VECTOR  = 1 << 1;\nconst Y_SHORT_VECTOR  = 1 << 2;\nconst REPEAT          = 1 << 3;\nconst SAME_X          = 1 << 4;\nconst SAME_Y          = 1 << 5;\n\n// Flags for composite glyphs\nconst ARG_1_AND_2_ARE_WORDS     = 1 << 0;\nconst ARGS_ARE_XY_VALUES        = 1 << 1;\nconst ROUND_XY_TO_GRID          = 1 << 2;\nconst WE_HAVE_A_SCALE           = 1 << 3;\nconst MORE_COMPONENTS           = 1 << 5;\nconst WE_HAVE_AN_X_AND_Y_SCALE  = 1 << 6;\nconst WE_HAVE_A_TWO_BY_TWO      = 1 << 7;\nconst WE_HAVE_INSTRUCTIONS      = 1 << 8;\nconst USE_MY_METRICS            = 1 << 9;\nconst OVERLAP_COMPOUND          = 1 << 10;\nconst SCALED_COMPONENT_OFFSET   = 1 << 11;\nconst UNSCALED_COMPONENT_OFFSET = 1 << 12;\n\n// Represents a point in a simple glyph\nexport class Point {\n  constructor(onCurve, endContour, x = 0, y = 0) {\n    this.onCurve = onCurve;\n    this.endContour = endContour;\n    this.x = x;\n    this.y = y;\n  }\n\n  copy() {\n    return new Point(this.onCurve, this.endContour, this.x, this.y);\n  }\n}\n\n// Represents a component in a composite glyph\nclass Component {\n  constructor(glyphID, dx, dy) {\n    this.glyphID = glyphID;\n    this.dx = dx;\n    this.dy = dy;\n    this.pos = 0;\n    this.scaleX = this.scaleY = 1;\n    this.scale01 = this.scale10 = 0;\n  }\n}\n\n/**\n * Represents a TrueType glyph.\n */\nexport default class TTFGlyph extends Glyph {\n  type = 'TTF';\n\n  // Parses just the glyph header and returns the bounding box\n  _getCBox(internal) {\n    // We need to decode the glyph if variation processing is requested,\n    // so it's easier just to recompute the path's cbox after decoding.\n    if (this._font._variationProcessor && !internal) {\n      return this.path.cbox;\n    }\n\n    let stream = this._font._getTableStream('glyf');\n    stream.pos += this._font.loca.offsets[this.id];\n    let glyph = GlyfHeader.decode(stream);\n\n    let cbox = new BBox(glyph.xMin, glyph.yMin, glyph.xMax, glyph.yMax);\n    return Object.freeze(cbox);\n  }\n\n  // Parses a single glyph coordinate\n  _parseGlyphCoord(stream, prev, short, same) {\n    if (short) {\n      var val = stream.readUInt8();\n      if (!same) {\n        val = -val;\n      }\n\n      val += prev;\n    } else {\n      if (same) {\n        var val = prev;\n      } else {\n        var val = prev + stream.readInt16BE();\n      }\n    }\n\n    return val;\n  }\n\n  // Decodes the glyph data into points for simple glyphs,\n  // or components for composite glyphs\n  _decode() {\n    let glyfPos = this._font.loca.offsets[this.id];\n    let nextPos = this._font.loca.offsets[this.id + 1];\n\n    // Nothing to do if there is no data for this glyph\n    if (glyfPos === nextPos) { return null; }\n\n    let stream = this._font._getTableStream('glyf');\n    stream.pos += glyfPos;\n    let startPos = stream.pos;\n\n    let glyph = GlyfHeader.decode(stream);\n\n    if (glyph.numberOfContours > 0) {\n      this._decodeSimple(glyph, stream);\n\n    } else if (glyph.numberOfContours < 0) {\n      this._decodeComposite(glyph, stream, startPos);\n    }\n\n    return glyph;\n  }\n\n  _decodeSimple(glyph, stream) {\n    // this is a simple glyph\n    glyph.points = [];\n\n    let endPtsOfContours = new r.Array(r.uint16, glyph.numberOfContours).decode(stream);\n    glyph.instructions = new r.Array(r.uint8, r.uint16).decode(stream);\n\n    let flags = [];\n    let numCoords = endPtsOfContours[endPtsOfContours.length - 1] + 1;\n\n    while (flags.length < numCoords) {\n      var flag = stream.readUInt8();\n      flags.push(flag);\n\n      // check for repeat flag\n      if (flag & REPEAT) {\n        let count = stream.readUInt8();\n        for (let j = 0; j < count; j++) {\n          flags.push(flag);\n        }\n      }\n    }\n\n    for (var i = 0; i < flags.length; i++) {\n      var flag = flags[i];\n      let point = new Point(!!(flag & ON_CURVE), endPtsOfContours.indexOf(i) >= 0, 0, 0);\n      glyph.points.push(point);\n    }\n\n    let px = 0;\n    for (var i = 0; i < flags.length; i++) {\n      var flag = flags[i];\n      glyph.points[i].x = px = this._parseGlyphCoord(stream, px, flag & X_SHORT_VECTOR, flag & SAME_X);\n    }\n\n    let py = 0;\n    for (var i = 0; i < flags.length; i++) {\n      var flag = flags[i];\n      glyph.points[i].y = py = this._parseGlyphCoord(stream, py, flag & Y_SHORT_VECTOR, flag & SAME_Y);\n    }\n\n    if (this._font._variationProcessor) {\n      let points = glyph.points.slice();\n      points.push(...this._getPhantomPoints(glyph));\n\n      this._font._variationProcessor.transformPoints(this.id, points);\n      glyph.phantomPoints = points.slice(-4);\n    }\n\n    return;\n  }\n\n  _decodeComposite(glyph, stream, offset = 0) {\n    // this is a composite glyph\n    glyph.components = [];\n    let haveInstructions = false;\n    let flags = MORE_COMPONENTS;\n\n    while (flags & MORE_COMPONENTS) {\n      flags = stream.readUInt16BE();\n      let gPos = stream.pos - offset;\n      let glyphID = stream.readUInt16BE();\n      if (!haveInstructions) {\n        haveInstructions = (flags & WE_HAVE_INSTRUCTIONS) !== 0;\n      }\n\n      if (flags & ARG_1_AND_2_ARE_WORDS) {\n        var dx = stream.readInt16BE();\n        var dy = stream.readInt16BE();\n      } else {\n        var dx = stream.readInt8();\n        var dy = stream.readInt8();\n      }\n\n      var component = new Component(glyphID, dx, dy);\n      component.pos = gPos;\n\n      if (flags & WE_HAVE_A_SCALE) {\n        // fixed number with 14 bits of fraction\n        component.scaleX =\n        component.scaleY = ((stream.readUInt8() << 24) | (stream.readUInt8() << 16)) / 1073741824;\n\n      } else if (flags & WE_HAVE_AN_X_AND_Y_SCALE) {\n        component.scaleX = ((stream.readUInt8() << 24) | (stream.readUInt8() << 16)) / 1073741824;\n        component.scaleY = ((stream.readUInt8() << 24) | (stream.readUInt8() << 16)) / 1073741824;\n\n      } else if (flags & WE_HAVE_A_TWO_BY_TWO) {\n        component.scaleX  = ((stream.readUInt8() << 24) | (stream.readUInt8() << 16)) / 1073741824;\n        component.scale01 = ((stream.readUInt8() << 24) | (stream.readUInt8() << 16)) / 1073741824;\n        component.scale10 = ((stream.readUInt8() << 24) | (stream.readUInt8() << 16)) / 1073741824;\n        component.scaleY  = ((stream.readUInt8() << 24) | (stream.readUInt8() << 16)) / 1073741824;\n      }\n\n      glyph.components.push(component);\n    }\n\n    if (this._font._variationProcessor) {\n      let points = [];\n      for (let j = 0; j < glyph.components.length; j++) {\n        var component = glyph.components[j];\n        points.push(new Point(true, true, component.dx, component.dy));\n      }\n\n      points.push(...this._getPhantomPoints(glyph));\n\n      this._font._variationProcessor.transformPoints(this.id, points);\n      glyph.phantomPoints = points.splice(-4, 4);\n\n      for (let i = 0; i < points.length; i++) {\n        let point = points[i];\n        glyph.components[i].dx = point.x;\n        glyph.components[i].dy = point.y;\n      }\n    }\n\n    return haveInstructions;\n  }\n\n  _getPhantomPoints(glyph) {\n    let cbox = this._getCBox(true);\n    if (this._metrics == null) {\n      this._metrics = Glyph.prototype._getMetrics.call(this, cbox);\n    }\n\n    let { advanceWidth, advanceHeight, leftBearing, topBearing } = this._metrics;\n\n    return [\n      new Point(false, true, glyph.xMin - leftBearing, 0),\n      new Point(false, true, glyph.xMin - leftBearing + advanceWidth, 0),\n      new Point(false, true, 0, glyph.yMax + topBearing),\n      new Point(false, true, 0, glyph.yMax + topBearing + advanceHeight)\n    ];\n  }\n\n  // Decodes font data, resolves composite glyphs, and returns an array of contours\n  _getContours() {\n    let glyph = this._decode();\n    if (!glyph) {\n      return [];\n    }\n\n    let points = [];\n\n    if (glyph.numberOfContours < 0) {\n      // resolve composite glyphs\n      for (let component of glyph.components) {\n        let contours = this._font.getGlyph(component.glyphID)._getContours();\n        for (let i = 0; i < contours.length; i++) {\n          let contour = contours[i];\n          for (let j = 0; j < contour.length; j++) {\n            let point = contour[j];\n            let x = point.x * component.scaleX + point.y * component.scale01 + component.dx;\n            let y = point.y * component.scaleY + point.x * component.scale10 + component.dy;\n            points.push(new Point(point.onCurve, point.endContour, x, y));\n          }\n        }\n      }\n    } else {\n      points = glyph.points || [];\n    }\n\n    // Recompute and cache metrics if we performed variation processing, and don't have an HVAR table\n    if (glyph.phantomPoints && !this._font.directory.tables.HVAR) {\n      this._metrics.advanceWidth  = glyph.phantomPoints[1].x - glyph.phantomPoints[0].x;\n      this._metrics.advanceHeight = glyph.phantomPoints[3].y - glyph.phantomPoints[2].y;\n      this._metrics.leftBearing   = glyph.xMin - glyph.phantomPoints[0].x;\n      this._metrics.topBearing    = glyph.phantomPoints[2].y - glyph.yMax;\n    }\n\n    let contours = [];\n    let cur = [];\n    for (let k = 0; k < points.length; k++) {\n      var point = points[k];\n      cur.push(point);\n      if (point.endContour) {\n        contours.push(cur);\n        cur = [];\n      }\n    }\n\n    return contours;\n  }\n\n  _getMetrics() {\n    if (this._metrics) {\n      return this._metrics;\n    }\n\n    let cbox = this._getCBox(true);\n    super._getMetrics(cbox);\n\n    if (this._font._variationProcessor && !this._font.HVAR) {\n      // No HVAR table, decode the glyph. This triggers recomputation of metrics.\n      this.path;\n    }\n\n    return this._metrics;\n  }\n\n  // Converts contours to a Path object that can be rendered\n  _getPath() {\n    let contours = this._getContours();\n    let path = new Path;\n\n    for (let i = 0; i < contours.length; i++) {\n      let contour = contours[i];\n      let firstPt = contour[0];\n      let lastPt = contour[contour.length - 1];\n      let start = 0;\n\n      if (firstPt.onCurve) {\n        // The first point will be consumed by the moveTo command, so skip in the loop\n        var curvePt = null;\n        start = 1;\n      } else {\n        if (lastPt.onCurve) {\n          // Start at the last point if the first point is off curve and the last point is on curve\n          firstPt = lastPt;\n        } else {\n          // Start at the middle if both the first and last points are off curve\n          firstPt = new Point(false, false, (firstPt.x + lastPt.x) / 2, (firstPt.y + lastPt.y) / 2);\n        }\n\n        var curvePt = firstPt;\n      }\n\n      path.moveTo(firstPt.x, firstPt.y);\n\n      for (let j = start; j < contour.length; j++) {\n        let pt = contour[j];\n        let prevPt = j === 0 ? firstPt : contour[j - 1];\n\n        if (prevPt.onCurve && pt.onCurve) {\n          path.lineTo(pt.x, pt.y);\n\n        } else if (prevPt.onCurve && !pt.onCurve) {\n          var curvePt = pt;\n\n        } else if (!prevPt.onCurve && !pt.onCurve) {\n          let midX = (prevPt.x + pt.x) / 2;\n          let midY = (prevPt.y + pt.y) / 2;\n          path.quadraticCurveTo(prevPt.x, prevPt.y, midX, midY);\n          var curvePt = pt;\n\n        } else if (!prevPt.onCurve && pt.onCurve) {\n          path.quadraticCurveTo(curvePt.x, curvePt.y, pt.x, pt.y);\n          var curvePt = null;\n\n        } else {\n          throw new Error(\"Unknown TTF path state\");\n        }\n      }\n\n      // Connect the first and last points\n      if (curvePt) {\n        path.quadraticCurveTo(curvePt.x, curvePt.y, firstPt.x, firstPt.y);\n      }\n\n      path.closePath();\n    }\n\n    return path;\n  }\n}\n","import { cache } from '../decorators';\nimport Path from './Path';\nimport {isMark} from 'unicode-properties';\nimport StandardNames from './StandardNames';\n\n/**\n * Glyph objects represent a glyph in the font. They have various properties for accessing metrics and\n * the actual vector path the glyph represents, and methods for rendering the glyph to a graphics context.\n *\n * You do not create glyph objects directly. They are created by various methods on the font object.\n * There are several subclasses of the base Glyph class internally that may be returned depending\n * on the font format, but they all inherit from this class.\n */\nexport default class Glyph {\n  constructor(id, codePoints, font) {\n    /**\n     * The glyph id in the font\n     * @type {number}\n     */\n    this.id = id;\n\n    /**\n     * An array of unicode code points that are represented by this glyph.\n     * There can be multiple code points in the case of ligatures and other glyphs\n     * that represent multiple visual characters.\n     * @type {number[]}\n     */\n    this.codePoints = codePoints;\n    this._font = font;\n\n    // TODO: get this info from GDEF if available\n    this.isMark = this.codePoints.length > 0 && this.codePoints.every(isMark);\n    this.isLigature = this.codePoints.length > 1;\n  }\n\n  _getPath() {\n    return new Path();\n  }\n\n  _getCBox() {\n    return this.path.cbox;\n  }\n\n  _getBBox() {\n    return this.path.bbox;\n  }\n\n  _getTableMetrics(table) {\n    if (this.id < table.metrics.length) {\n      return table.metrics.get(this.id);\n    }\n\n    let metric = table.metrics.get(table.metrics.length - 1);\n    let res = {\n      advance: metric ? metric.advance : 0,\n      bearing: table.bearings.get(this.id - table.metrics.length) || 0\n    };\n\n    return res;\n  }\n\n  _getMetrics(cbox) {\n    if (this._metrics) { return this._metrics; }\n\n    let {advance:advanceWidth, bearing:leftBearing} = this._getTableMetrics(this._font.hmtx);\n\n    // For vertical metrics, use vmtx if available, or fall back to global data from OS/2 or hhea\n    if (this._font.vmtx) {\n      var {advance:advanceHeight, bearing:topBearing} = this._getTableMetrics(this._font.vmtx);\n\n    } else {\n      let os2;\n      if (typeof cbox === 'undefined' || cbox === null) { ({ cbox } = this); }\n\n      if ((os2 = this._font['OS/2']) && os2.version > 0) {\n        var advanceHeight = Math.abs(os2.typoAscender - os2.typoDescender);\n        var topBearing = os2.typoAscender - cbox.maxY;\n\n      } else {\n        let { hhea } = this._font;\n        var advanceHeight = Math.abs(hhea.ascent - hhea.descent);\n        var topBearing = hhea.ascent - cbox.maxY;\n      }\n    }\n\n    if (this._font._variationProcessor && this._font.HVAR) {\n      advanceWidth += this._font._variationProcessor.getAdvanceAdjustment(this.id, this._font.HVAR);\n    }\n\n    return this._metrics = { advanceWidth, advanceHeight, leftBearing, topBearing };\n  }\n\n  /**\n   * The glyphs control box.\n   * This is often the same as the bounding box, but is faster to compute.\n   * Because of the way bezier curves are defined, some of the control points\n   * can be outside of the bounding box. Where `bbox` takes this into account,\n   * `cbox` does not. Thus, cbox is less accurate, but faster to compute.\n   * See [here](http://www.freetype.org/freetype2/docs/glyphs/glyphs-6.html#section-2)\n   * for a more detailed description.\n   *\n   * @type {BBox}\n   */\n  @cache\n  get cbox() {\n    return this._getCBox();\n  }\n\n  /**\n   * The glyphs bounding box, i.e. the rectangle that encloses the\n   * glyph outline as tightly as possible.\n   * @type {BBox}\n   */\n  @cache\n  get bbox() {\n    return this._getBBox();\n  }\n\n  /**\n   * A vector Path object representing the glyph outline.\n   * @type {Path}\n   */\n  @cache\n  get path() {\n    // Cache the path so we only decode it once\n    // Decoding is actually performed by subclasses\n    return this._getPath();\n  }\n\n  /**\n   * Returns a path scaled to the given font size.\n   * @param {number} size\n   * @return {Path}\n   */\n  getScaledPath(size) {\n    let scale = 1 / this._font.unitsPerEm * size;\n    return this.path.scale(scale);\n  }\n\n  /**\n   * The glyph's advance width.\n   * @type {number}\n   */\n  @cache\n  get advanceWidth() {\n    return this._getMetrics().advanceWidth;\n  }\n\n  /**\n   * The glyph's advance height.\n   * @type {number}\n   */\n  @cache\n  get advanceHeight() {\n    return this._getMetrics().advanceHeight;\n  }\n\n  get ligatureCaretPositions() {}\n\n  _getName() {\n    let { post } = this._font;\n    if (!post) {\n      return null;\n    }\n\n    switch (post.version) {\n      case 1:\n        return StandardNames[this.id];\n\n      case 2:\n        let id = post.glyphNameIndex[this.id];\n        if (id < StandardNames.length) {\n          return StandardNames[id];\n        }\n\n        return post.names[id - StandardNames.length];\n\n      case 2.5:\n        return StandardNames[this.id + post.offsets[this.id]];\n\n      case 4:\n        return String.fromCharCode(post.map[this.id]);\n    }\n  }\n\n  /**\n   * The glyph's name\n   * @type {string}\n   */\n  @cache\n  get name() {\n    return this._getName();\n  }\n\n  /**\n   * Renders the glyph to the given graphics context, at the specified font size.\n   * @param {CanvasRenderingContext2d} ctx\n   * @param {number} size\n   */\n  render(ctx, size) {\n    ctx.save();\n\n    let scale = 1 / this._font.head.unitsPerEm * size;\n    ctx.scale(scale, scale);\n\n    let fn = this.path.toFunction();\n    fn(ctx);\n    ctx.fill();\n\n    ctx.restore();\n  }\n}\n","import BBox from './BBox';\n\nconst SVG_COMMANDS = {\n  moveTo: 'M',\n  lineTo: 'L',\n  quadraticCurveTo: 'Q',\n  bezierCurveTo: 'C',\n  closePath: 'Z'\n};\n\n/**\n * Path objects are returned by glyphs and represent the actual\n * vector outlines for each glyph in the font. Paths can be converted\n * to SVG path data strings, or to functions that can be applied to\n * render the path to a graphics context.\n */\nexport default class Path {\n  constructor() {\n    this.commands = [];\n    this._bbox = null;\n    this._cbox = null;\n  }\n\n  /**\n   * Compiles the path to a JavaScript function that can be applied with\n   * a graphics context in order to render the path.\n   * @return {string}\n   */\n  toFunction() {\n    return ctx => {\n      this.commands.forEach(c => {\n        return ctx[c.command].apply(ctx, c.args)\n      })\n    };\n  }\n\n  /**\n   * Converts the path to an SVG path data string\n   * @return {string}\n   */\n  toSVG() {\n    let cmds = this.commands.map(c => {\n      let args = c.args.map(arg => Math.round(arg * 100) / 100);\n      return `${SVG_COMMANDS[c.command]}${args.join(' ')}`;\n    });\n\n    return cmds.join('');\n  }\n\n  /**\n   * Gets the \"control box\" of a path.\n   * This is like the bounding box, but it includes all points including\n   * control points of bezier segments and is much faster to compute than\n   * the real bounding box.\n   * @type {BBox}\n   */\n  get cbox() {\n    if (!this._cbox) {\n      let cbox = new BBox;\n      for (let command of this.commands) {\n        for (let i = 0; i < command.args.length; i += 2) {\n          cbox.addPoint(command.args[i], command.args[i + 1]);\n        }\n      }\n\n      this._cbox = Object.freeze(cbox);\n    }\n\n    return this._cbox;\n  }\n\n  /**\n   * Gets the exact bounding box of the path by evaluating curve segments.\n   * Slower to compute than the control box, but more accurate.\n   * @type {BBox}\n   */\n  get bbox() {\n    if (this._bbox) {\n      return this._bbox;\n    }\n\n    let bbox = new BBox;\n    let cx = 0, cy = 0;\n\n    let f = t => (\n      Math.pow(1 - t, 3) * p0[i]\n        + 3 * Math.pow(1 - t, 2) * t * p1[i]\n        + 3 * (1 - t) * Math.pow(t, 2) * p2[i]\n        + Math.pow(t, 3) * p3[i]\n    );\n\n    for (let c of this.commands) {\n      switch (c.command) {\n        case 'moveTo':\n        case 'lineTo':\n          let [x, y] = c.args;\n          bbox.addPoint(x, y);\n          cx = x;\n          cy = y;\n          break;\n\n        case 'quadraticCurveTo':\n        case 'bezierCurveTo':\n          if (c.command === 'quadraticCurveTo') {\n            // http://fontforge.org/bezier.html\n            var [qp1x, qp1y, p3x, p3y] = c.args;\n            var cp1x = cx + 2 / 3 * (qp1x - cx);    // CP1 = QP0 + 2/3 * (QP1-QP0)\n            var cp1y = cy + 2 / 3 * (qp1y - cy);\n            var cp2x = p3x + 2 / 3 * (qp1x - p3x);  // CP2 = QP2 + 2/3 * (QP1-QP2)\n            var cp2y = p3y + 2 / 3 * (qp1y - p3y);\n          } else {\n            var [cp1x, cp1y, cp2x, cp2y, p3x, p3y] = c.args;\n          }\n\n          // http://blog.hackers-cafe.net/2009/06/how-to-calculate-bezier-curves-bounding.html\n          bbox.addPoint(p3x, p3y);\n\n          var p0 = [cx, cy];\n          var p1 = [cp1x, cp1y];\n          var p2 = [cp2x, cp2y];\n          var p3 = [p3x, p3y];\n\n          for (var i = 0; i <= 1; i++) {\n            let b = 6 * p0[i] - 12 * p1[i] + 6 * p2[i];\n            let a = -3 * p0[i] + 9 * p1[i] - 9 * p2[i] + 3 * p3[i];\n            c = 3 * p1[i] - 3 * p0[i];\n\n            if (a === 0) {\n              if (b === 0) {\n                continue;\n              }\n\n              let t = -c / b;\n              if (0 < t && t < 1) {\n                if (i === 0) {\n                  bbox.addPoint(f(t), bbox.maxY);\n                } else if (i === 1) {\n                  bbox.addPoint(bbox.maxX, f(t));\n                }\n              }\n\n              continue;\n            }\n\n            let b2ac = Math.pow(b, 2) - 4 * c * a;\n            if (b2ac < 0) {\n              continue;\n            }\n\n            let t1 = (-b + Math.sqrt(b2ac)) / (2 * a);\n            if (0 < t1 && t1 < 1) {\n              if (i === 0) {\n                bbox.addPoint(f(t1), bbox.maxY);\n              } else if (i === 1) {\n                bbox.addPoint(bbox.maxX, f(t1));\n              }\n            }\n\n            let t2 = (-b - Math.sqrt(b2ac)) / (2 * a);\n            if (0 < t2 && t2 < 1) {\n              if (i === 0) {\n                bbox.addPoint(f(t2), bbox.maxY);\n              } else if (i === 1) {\n                bbox.addPoint(bbox.maxX, f(t2));\n              }\n            }\n          }\n\n          cx = p3x;\n          cy = p3y;\n          break;\n      }\n    }\n\n    return this._bbox = Object.freeze(bbox);\n  }\n\n  /**\n   * Applies a mapping function to each point in the path.\n   * @param {function} fn\n   * @return {Path}\n   */\n  mapPoints(fn) {\n    let path = new Path;\n\n    for (let c of this.commands) {\n      let args = [];\n      for (let i = 0; i < c.args.length; i += 2) {\n        let [x, y] = fn(c.args[i], c.args[i + 1]);\n        args.push(x, y);\n      }\n\n      path[c.command](...args);\n    }\n\n    return path;\n  }\n\n  /**\n   * Transforms the path by the given matrix.\n   */\n  transform(m0, m1, m2, m3, m4, m5) {\n    return this.mapPoints((x, y) => {\n      const tx = m0 * x + m2 * y + m4;\n      const ty = m1 * x + m3 * y + m5;\n      return [tx, ty];\n    });\n  }\n\n  /**\n   * Translates the path by the given offset.\n   */\n  translate(x, y) {\n    return this.transform(1, 0, 0, 1, x, y);\n  }\n\n  /**\n   * Rotates the path by the given angle (in radians).\n   */\n  rotate(angle) {\n    let cos = Math.cos(angle);\n    let sin = Math.sin(angle);\n    return this.transform(cos, sin, -sin, cos, 0, 0);\n  }\n\n  /**\n   * Scales the path.\n   */\n  scale(scaleX, scaleY = scaleX) {\n    return this.transform(scaleX, 0, 0, scaleY, 0, 0);\n  }\n}\n\nfor (let command of ['moveTo', 'lineTo', 'quadraticCurveTo', 'bezierCurveTo', 'closePath']) {\n  Path.prototype[command] = function(...args) {\n    this._bbox = this._cbox = null;\n    this.commands.push({\n      command,\n      args\n    });\n\n    return this;\n  };\n}\n","export default [\n  '.notdef', '.null', 'nonmarkingreturn', 'space', 'exclam', 'quotedbl', 'numbersign', 'dollar', 'percent',\n  'ampersand', 'quotesingle', 'parenleft', 'parenright', 'asterisk', 'plus', 'comma', 'hyphen', 'period', 'slash',\n  'zero', 'one', 'two', 'three', 'four', 'five', 'six', 'seven', 'eight', 'nine', 'colon', 'semicolon', 'less',\n  'equal', 'greater', 'question', 'at', 'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O',\n  'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z', 'bracketleft', 'backslash', 'bracketright',\n  'asciicircum', 'underscore', 'grave', 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o',\n  'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z', 'braceleft', 'bar', 'braceright', 'asciitilde',\n  'Adieresis', 'Aring', 'Ccedilla', 'Eacute', 'Ntilde', 'Odieresis', 'Udieresis', 'aacute', 'agrave',\n  'acircumflex', 'adieresis', 'atilde', 'aring', 'ccedilla', 'eacute', 'egrave', 'ecircumflex', 'edieresis',\n  'iacute', 'igrave', 'icircumflex', 'idieresis', 'ntilde', 'oacute', 'ograve', 'ocircumflex', 'odieresis',\n  'otilde', 'uacute', 'ugrave', 'ucircumflex', 'udieresis', 'dagger', 'degree', 'cent', 'sterling', 'section',\n  'bullet', 'paragraph', 'germandbls', 'registered', 'copyright', 'trademark', 'acute', 'dieresis', 'notequal',\n  'AE', 'Oslash', 'infinity', 'plusminus', 'lessequal', 'greaterequal', 'yen', 'mu', 'partialdiff', 'summation',\n  'product', 'pi', 'integral', 'ordfeminine', 'ordmasculine', 'Omega', 'ae', 'oslash', 'questiondown',\n  'exclamdown', 'logicalnot', 'radical', 'florin', 'approxequal', 'Delta', 'guillemotleft', 'guillemotright',\n  'ellipsis', 'nonbreakingspace', 'Agrave', 'Atilde', 'Otilde', 'OE', 'oe', 'endash', 'emdash', 'quotedblleft',\n  'quotedblright', 'quoteleft', 'quoteright', 'divide', 'lozenge', 'ydieresis', 'Ydieresis', 'fraction',\n  'currency', 'guilsinglleft', 'guilsinglright', 'fi', 'fl', 'daggerdbl', 'periodcentered', 'quotesinglbase',\n  'quotedblbase', 'perthousand', 'Acircumflex', 'Ecircumflex', 'Aacute', 'Edieresis', 'Egrave', 'Iacute',\n  'Icircumflex', 'Idieresis', 'Igrave', 'Oacute', 'Ocircumflex', 'apple', 'Ograve', 'Uacute', 'Ucircumflex',\n  'Ugrave', 'dotlessi', 'circumflex', 'tilde', 'macron', 'breve', 'dotaccent', 'ring', 'cedilla', 'hungarumlaut',\n  'ogonek', 'caron', 'Lslash', 'lslash', 'Scaron', 'scaron', 'Zcaron', 'zcaron', 'brokenbar', 'Eth', 'eth',\n  'Yacute', 'yacute', 'Thorn', 'thorn', 'minus', 'multiply', 'onesuperior', 'twosuperior', 'threesuperior',\n  'onehalf', 'onequarter', 'threequarters', 'franc', 'Gbreve', 'gbreve', 'Idotaccent', 'Scedilla', 'scedilla',\n  'Cacute', 'cacute', 'Ccaron', 'ccaron', 'dcroat'\n];\n","import Glyph from './Glyph';\nimport Path from './Path';\n\n/**\n * Represents an OpenType PostScript glyph, in the Compact Font Format.\n */\nexport default class CFFGlyph extends Glyph {\n  type = 'CFF';\n\n  _getName() {\n    if (this._font.CFF2) {\n      return super._getName();\n    }\n\n    return this._font['CFF '].getGlyphName(this.id);\n  }\n\n  bias(s) {\n    if (s.length < 1240) {\n      return 107;\n    } else if (s.length < 33900) {\n      return 1131;\n    } else {\n      return 32768;\n    }\n  }\n\n  _getPath() {\n    let cff = this._font.CFF2 || this._font['CFF '];\n    let { stream } = cff;\n    let str = cff.topDict.CharStrings[this.id];\n    let end = str.offset + str.length;\n    stream.pos = str.offset;\n\n    let path = new Path;\n    let stack = [];\n    let trans = [];\n\n    let width = null;\n    let nStems = 0;\n    let x = 0, y = 0;\n    let usedGsubrs;\n    let usedSubrs;\n    let open = false;\n\n    this._usedGsubrs = usedGsubrs = {};\n    this._usedSubrs = usedSubrs = {};\n\n    let gsubrs = cff.globalSubrIndex || [];\n    let gsubrsBias = this.bias(gsubrs);\n\n    let privateDict = cff.privateDictForGlyph(this.id) || {};\n    let subrs = privateDict.Subrs || [];\n    let subrsBias = this.bias(subrs);\n\n    let vstore = cff.topDict.vstore && cff.topDict.vstore.itemVariationStore;\n    let vsindex = privateDict.vsindex;\n    let variationProcessor = this._font._variationProcessor;\n\n    function checkWidth() {\n      if (width == null) {\n        width = stack.shift() + privateDict.nominalWidthX;\n      }\n    }\n\n    function parseStems() {\n      if (stack.length % 2 !== 0) {\n        checkWidth();\n      }\n\n      nStems += stack.length >> 1;\n      return stack.length = 0;\n    }\n\n    function moveTo(x, y) {\n      if (open) {\n        path.closePath();\n      }\n\n      path.moveTo(x, y);\n      open = true;\n    }\n\n    let parse = function () {\n      while (stream.pos < end) {\n        let op = stream.readUInt8();\n        if (op < 32) {\n          let index, subr, phase;\n          let c1x, c1y, c2x, c2y, c3x, c3y;\n          let c4x, c4y, c5x, c5y, c6x, c6y;\n          let pts;\n\n          switch (op) {\n            case 1:  // hstem\n            case 3:  // vstem\n            case 18: // hstemhm\n            case 23: // vstemhm\n              parseStems();\n              break;\n\n            case 4: // vmoveto\n              if (stack.length > 1) {\n                checkWidth();\n              }\n\n              y += stack.shift();\n              moveTo(x, y);\n              break;\n\n            case 5: // rlineto\n              while (stack.length >= 2) {\n                x += stack.shift();\n                y += stack.shift();\n                path.lineTo(x, y);\n              }\n              break;\n\n            case 6: // hlineto\n            case 7: // vlineto\n              phase = op === 6;\n              while (stack.length >= 1) {\n                if (phase) {\n                  x += stack.shift();\n                } else {\n                  y += stack.shift();\n                }\n\n                path.lineTo(x, y);\n                phase = !phase;\n              }\n              break;\n\n            case 8: // rrcurveto\n              while (stack.length > 0) {\n                c1x = x + stack.shift();\n                c1y = y + stack.shift();\n                c2x = c1x + stack.shift();\n                c2y = c1y + stack.shift();\n                x = c2x + stack.shift();\n                y = c2y + stack.shift();\n                path.bezierCurveTo(c1x, c1y, c2x, c2y, x, y);\n              }\n              break;\n\n            case 10: // callsubr\n              index = stack.pop() + subrsBias;\n              subr = subrs[index];\n              if (subr) {\n                usedSubrs[index] = true;\n                let p = stream.pos;\n                let e = end;\n                stream.pos = subr.offset;\n                end = subr.offset + subr.length;\n                parse();\n                stream.pos = p;\n                end = e;\n              }\n              break;\n\n            case 11: // return\n              if (cff.version >= 2) {\n                break;\n              }\n              return;\n\n            case 14: // endchar\n              if (cff.version >= 2) {\n                break;\n              }\n\n              if (stack.length > 0) {\n                checkWidth();\n              }\n\n              if (open) {\n                path.closePath();\n                open = false;\n              }\n              break;\n\n            case 15: { // vsindex\n              if (cff.version < 2) {\n                throw new Error('vsindex operator not supported in CFF v1');\n              }\n\n              vsindex = stack.pop();\n              break;\n            }\n\n            case 16: { // blend\n              if (cff.version < 2) {\n                throw new Error('blend operator not supported in CFF v1');\n              }\n\n              if (!variationProcessor) {\n                throw new Error('blend operator in non-variation font');\n              }\n\n              let blendVector = variationProcessor.getBlendVector(vstore, vsindex);\n              let numBlends = stack.pop();\n              let numOperands = numBlends * blendVector.length;\n              let delta = stack.length - numOperands;\n              let base = delta - numBlends;\n\n              for (let i = 0; i < numBlends; i++) {\n                let sum = stack[base + i];\n                for (let j = 0; j < blendVector.length; j++) {\n                  sum += blendVector[j] * stack[delta++];\n                }\n\n                stack[base + i] = sum;\n              }\n\n              while (numOperands--) {\n                stack.pop();\n              }\n\n              break;\n            }\n\n            case 19: // hintmask\n            case 20: // cntrmask\n              parseStems();\n              stream.pos += (nStems + 7) >> 3;\n              break;\n\n            case 21: // rmoveto\n              if (stack.length > 2) {\n                checkWidth();\n              }\n\n              x += stack.shift();\n              y += stack.shift();\n              moveTo(x, y);\n              break;\n\n            case 22: // hmoveto\n              if (stack.length > 1) {\n                checkWidth();\n              }\n\n              x += stack.shift();\n              moveTo(x, y);\n              break;\n\n            case 24: // rcurveline\n              while (stack.length >= 8) {\n                c1x = x + stack.shift();\n                c1y = y + stack.shift();\n                c2x = c1x + stack.shift();\n                c2y = c1y + stack.shift();\n                x = c2x + stack.shift();\n                y = c2y + stack.shift();\n                path.bezierCurveTo(c1x, c1y, c2x, c2y, x, y);\n              }\n\n              x += stack.shift();\n              y += stack.shift();\n              path.lineTo(x, y);\n              break;\n\n            case 25: // rlinecurve\n              while (stack.length >= 8) {\n                x += stack.shift();\n                y += stack.shift();\n                path.lineTo(x, y);\n              }\n\n              c1x = x + stack.shift();\n              c1y = y + stack.shift();\n              c2x = c1x + stack.shift();\n              c2y = c1y + stack.shift();\n              x = c2x + stack.shift();\n              y = c2y + stack.shift();\n              path.bezierCurveTo(c1x, c1y, c2x, c2y, x, y);\n              break;\n\n            case 26: // vvcurveto\n              if (stack.length % 2) {\n                x += stack.shift();\n              }\n\n              while (stack.length >= 4) {\n                c1x = x;\n                c1y = y + stack.shift();\n                c2x = c1x + stack.shift();\n                c2y = c1y + stack.shift();\n                x = c2x;\n                y = c2y + stack.shift();\n                path.bezierCurveTo(c1x, c1y, c2x, c2y, x, y);\n              }\n              break;\n\n            case 27: // hhcurveto\n              if (stack.length % 2) {\n                y += stack.shift();\n              }\n\n              while (stack.length >= 4) {\n                c1x = x + stack.shift();\n                c1y = y;\n                c2x = c1x + stack.shift();\n                c2y = c1y + stack.shift();\n                x = c2x + stack.shift();\n                y = c2y;\n                path.bezierCurveTo(c1x, c1y, c2x, c2y, x, y);\n              }\n              break;\n\n            case 28: // shortint\n              stack.push(stream.readInt16BE());\n              break;\n\n            case 29: // callgsubr\n              index = stack.pop() + gsubrsBias;\n              subr = gsubrs[index];\n              if (subr) {\n                usedGsubrs[index] = true;\n                let p = stream.pos;\n                let e = end;\n                stream.pos = subr.offset;\n                end = subr.offset + subr.length;\n                parse();\n                stream.pos = p;\n                end = e;\n              }\n              break;\n\n            case 30: // vhcurveto\n            case 31: // hvcurveto\n              phase = op === 31;\n              while (stack.length >= 4) {\n                if (phase) {\n                  c1x = x + stack.shift();\n                  c1y = y;\n                  c2x = c1x + stack.shift();\n                  c2y = c1y + stack.shift();\n                  y = c2y + stack.shift();\n                  x = c2x + (stack.length === 1 ? stack.shift() : 0);\n                } else {\n                  c1x = x;\n                  c1y = y + stack.shift();\n                  c2x = c1x + stack.shift();\n                  c2y = c1y + stack.shift();\n                  x = c2x + stack.shift();\n                  y = c2y + (stack.length === 1 ? stack.shift() : 0);\n                }\n\n                path.bezierCurveTo(c1x, c1y, c2x, c2y, x, y);\n                phase = !phase;\n              }\n              break;\n\n            case 12:\n              op = stream.readUInt8();\n              switch (op) {\n                case 3: // and\n                  let a = stack.pop();\n                  let b = stack.pop();\n                  stack.push(a && b ? 1 : 0);\n                  break;\n\n                case 4: // or\n                  a = stack.pop();\n                  b = stack.pop();\n                  stack.push(a || b ? 1 : 0);\n                  break;\n\n                case 5: // not\n                  a = stack.pop();\n                  stack.push(a ? 0 : 1);\n                  break;\n\n                case 9: // abs\n                  a = stack.pop();\n                  stack.push(Math.abs(a));\n                  break;\n\n                case 10: // add\n                  a = stack.pop();\n                  b = stack.pop();\n                  stack.push(a + b);\n                  break;\n\n                case 11: // sub\n                  a = stack.pop();\n                  b = stack.pop();\n                  stack.push(a - b);\n                  break;\n\n                case 12: // div\n                  a = stack.pop();\n                  b = stack.pop();\n                  stack.push(a / b);\n                  break;\n\n                case 14: // neg\n                  a = stack.pop();\n                  stack.push(-a);\n                  break;\n\n                case 15: // eq\n                  a = stack.pop();\n                  b = stack.pop();\n                  stack.push(a === b ? 1 : 0);\n                  break;\n\n                case 18: // drop\n                  stack.pop();\n                  break;\n\n                case 20: // put\n                  let val = stack.pop();\n                  let idx = stack.pop();\n                  trans[idx] = val;\n                  break;\n\n                case 21: // get\n                  idx = stack.pop();\n                  stack.push(trans[idx] || 0);\n                  break;\n\n                case 22: // ifelse\n                  let s1 = stack.pop();\n                  let s2 = stack.pop();\n                  let v1 = stack.pop();\n                  let v2 = stack.pop();\n                  stack.push(v1 <= v2 ? s1 : s2);\n                  break;\n\n                case 23: // random\n                  stack.push(Math.random());\n                  break;\n\n                case 24: // mul\n                  a = stack.pop();\n                  b = stack.pop();\n                  stack.push(a * b);\n                  break;\n\n                case 26: // sqrt\n                  a = stack.pop();\n                  stack.push(Math.sqrt(a));\n                  break;\n\n                case 27: // dup\n                  a = stack.pop();\n                  stack.push(a, a);\n                  break;\n\n                case 28: // exch\n                  a = stack.pop();\n                  b = stack.pop();\n                  stack.push(b, a);\n                  break;\n\n                case 29: // index\n                  idx = stack.pop();\n                  if (idx < 0) {\n                    idx = 0;\n                  } else if (idx > stack.length - 1) {\n                    idx = stack.length - 1;\n                  }\n\n                  stack.push(stack[idx]);\n                  break;\n\n                case 30: // roll\n                  let n = stack.pop();\n                  let j = stack.pop();\n\n                  if (j >= 0) {\n                    while (j > 0) {\n                      var t = stack[n - 1];\n                      for (let i = n - 2; i >= 0; i--) {\n                        stack[i + 1] = stack[i];\n                      }\n\n                      stack[0] = t;\n                      j--;\n                    }\n                  } else {\n                    while (j < 0) {\n                      var t = stack[0];\n                      for (let i = 0; i <= n; i++) {\n                        stack[i] = stack[i + 1];\n                      }\n\n                      stack[n - 1] = t;\n                      j++;\n                    }\n                  }\n                  break;\n\n                case 34: // hflex\n                  c1x = x + stack.shift();\n                  c1y = y;\n                  c2x = c1x + stack.shift();\n                  c2y = c1y + stack.shift();\n                  c3x = c2x + stack.shift();\n                  c3y = c2y;\n                  c4x = c3x + stack.shift();\n                  c4y = c3y;\n                  c5x = c4x + stack.shift();\n                  c5y = c4y;\n                  c6x = c5x + stack.shift();\n                  c6y = c5y;\n                  x = c6x;\n                  y = c6y;\n\n                  path.bezierCurveTo(c1x, c1y, c2x, c2y, c3x, c3y);\n                  path.bezierCurveTo(c4x, c4y, c5x, c5y, c6x, c6y);\n                  break;\n\n                case 35: // flex\n                  pts = [];\n\n                  for (let i = 0; i <= 5; i++) {\n                    x += stack.shift();\n                    y += stack.shift();\n                    pts.push(x, y);\n                  }\n\n                  path.bezierCurveTo(...pts.slice(0, 6));\n                  path.bezierCurveTo(...pts.slice(6));\n                  stack.shift(); // fd\n                  break;\n\n                case 36: // hflex1\n                  c1x = x + stack.shift();\n                  c1y = y + stack.shift();\n                  c2x = c1x + stack.shift();\n                  c2y = c1y + stack.shift();\n                  c3x = c2x + stack.shift();\n                  c3y = c2y;\n                  c4x = c3x + stack.shift();\n                  c4y = c3y;\n                  c5x = c4x + stack.shift();\n                  c5y = c4y + stack.shift();\n                  c6x = c5x + stack.shift();\n                  c6y = c5y;\n                  x = c6x;\n                  y = c6y;\n\n                  path.bezierCurveTo(c1x, c1y, c2x, c2y, c3x, c3y);\n                  path.bezierCurveTo(c4x, c4y, c5x, c5y, c6x, c6y);\n                  break;\n\n                case 37: // flex1\n                  let startx = x;\n                  let starty = y;\n\n                  pts = [];\n                  for (let i = 0; i <= 4; i++) {\n                    x += stack.shift();\n                    y += stack.shift();\n                    pts.push(x, y);\n                  }\n\n                  if (Math.abs(x - startx) > Math.abs(y - starty)) { // horizontal\n                    x += stack.shift();\n                    y = starty;\n                  } else {\n                    x = startx;\n                    y += stack.shift();\n                  }\n\n                  pts.push(x, y);\n                  path.bezierCurveTo(...pts.slice(0, 6));\n                  path.bezierCurveTo(...pts.slice(6));\n                  break;\n\n                default:\n                  throw new Error(`Unknown op: 12 ${op}`);\n              }\n              break;\n\n            default:\n              throw new Error(`Unknown op: ${op}`);\n          }\n\n        } else if (op < 247) {\n          stack.push(op - 139);\n        } else if (op < 251) {\n          var b1 = stream.readUInt8();\n          stack.push((op - 247) * 256 + b1 + 108);\n        } else if (op < 255) {\n          var b1 = stream.readUInt8();\n          stack.push(-(op - 251) * 256 - b1 - 108);\n        } else {\n          stack.push(stream.readInt32BE() / 65536);\n        }\n      }\n    };\n\n    parse();\n\n    if (open) {\n      path.closePath();\n    }\n\n    return path;\n  }\n}\n","import TTFGlyph from './TTFGlyph';\nimport * as r from 'restructure';\n\nlet SBIXImage = new r.Struct({\n  originX: r.uint16,\n  originY: r.uint16,\n  type: new r.String(4),\n  data: new r.Buffer(t => t.parent.buflen - t._currentOffset)\n});\n\n/**\n * Represents a color (e.g. emoji) glyph in Apple's SBIX format.\n */\nexport default class SBIXGlyph extends TTFGlyph {\n  type = 'SBIX';\n\n  /**\n   * Returns an object representing a glyph image at the given point size.\n   * The object has a data property with a Buffer containing the actual image data,\n   * along with the image type, and origin.\n   *\n   * @param {number} size\n   * @return {object}\n   */\n  getImageForSize(size) {\n    for (let i = 0; i < this._font.sbix.imageTables.length; i++) {\n      var table = this._font.sbix.imageTables[i];\n      if (table.ppem >= size) { break; }\n    }\n\n    let offsets = table.imageOffsets;\n    let start = offsets[this.id];\n    let end = offsets[this.id + 1];\n\n    if (start === end) {\n      return null;\n    }\n\n    this._font.stream.pos = start;\n    return SBIXImage.decode(this._font.stream, {buflen: end - start});\n  }\n\n  render(ctx, size) {\n    let img = this.getImageForSize(size);\n    if (img != null) {\n      let scale = size / this._font.unitsPerEm;\n      ctx.image(img.data, {height: size, x: img.originX, y: (this.bbox.minY - img.originY) * scale});\n    }\n\n    if (this._font.sbix.flags.renderOutlines) {\n      super.render(ctx, size);\n    }\n  }\n}\n","import Glyph from './Glyph';\nimport BBox from './BBox';\n\nclass COLRLayer {\n  constructor(glyph, color) {\n    this.glyph = glyph;\n    this.color = color;\n  }\n}\n\n/**\n * Represents a color (e.g. emoji) glyph in Microsoft's COLR format.\n * Each glyph in this format contain a list of colored layers, each\n * of which  is another vector glyph.\n */\nexport default class COLRGlyph extends Glyph {\n  type = 'COLR';\n\n  _getBBox() {\n    let bbox = new BBox;\n    for (let i = 0; i < this.layers.length; i++) {\n      let layer = this.layers[i];\n      let b = layer.glyph.bbox;\n      bbox.addPoint(b.minX, b.minY);\n      bbox.addPoint(b.maxX, b.maxY);\n    }\n\n    return bbox;\n  }\n\n  /**\n   * Returns an array of objects containing the glyph and color for\n   * each layer in the composite color glyph.\n   * @type {object[]}\n   */\n  get layers() {\n    let cpal = this._font.CPAL;\n    let colr = this._font.COLR;\n    let low = 0;\n    let high = colr.baseGlyphRecord.length - 1;\n\n    while (low <= high) {\n      let mid = (low + high) >> 1;\n      var rec = colr.baseGlyphRecord[mid];\n\n      if (this.id < rec.gid) {\n        high = mid - 1;\n      } else if (this.id > rec.gid) {\n        low = mid + 1;\n      } else {\n        var baseLayer = rec;\n        break;\n      }\n    }\n\n    // if base glyph not found in COLR table,\n    // default to normal glyph from glyf or CFF\n    if (baseLayer == null) {\n      var g = this._font._getBaseGlyph(this.id);\n      var color = {\n        red: 0,\n        green: 0,\n        blue: 0,\n        alpha: 255\n      };\n\n      return [new COLRLayer(g, color)];\n    }\n\n    // otherwise, return an array of all the layers\n    let layers = [];\n    for (let i = baseLayer.firstLayerIndex; i < baseLayer.firstLayerIndex + baseLayer.numLayers; i++) {\n      var rec = colr.layerRecords[i];\n      var color = cpal.colorRecords[rec.paletteIndex];\n      var g = this._font._getBaseGlyph(rec.gid);\n      layers.push(new COLRLayer(g, color));\n    }\n\n    return layers;\n  }\n\n  render(ctx, size) {\n    for (let {glyph, color} of this.layers) {\n      ctx.fillColor([color.red, color.green, color.blue], color.alpha / 255 * 100);\n      glyph.render(ctx, size);\n    }\n\n    return;\n  }\n}\n","const TUPLES_SHARE_POINT_NUMBERS = 0x8000;\nconst TUPLE_COUNT_MASK           = 0x0fff;\nconst EMBEDDED_TUPLE_COORD       = 0x8000;\nconst INTERMEDIATE_TUPLE         = 0x4000;\nconst PRIVATE_POINT_NUMBERS      = 0x2000;\nconst TUPLE_INDEX_MASK           = 0x0fff;\nconst POINTS_ARE_WORDS           = 0x80;\nconst POINT_RUN_COUNT_MASK       = 0x7f;\nconst DELTAS_ARE_ZERO            = 0x80;\nconst DELTAS_ARE_WORDS           = 0x40;\nconst DELTA_RUN_COUNT_MASK       = 0x3f;\n\n/**\n * This class is transforms TrueType glyphs according to the data from\n * the Apple Advanced Typography variation tables (fvar, gvar, and avar).\n * These tables allow infinite adjustments to glyph weight, width, slant,\n * and optical size without the designer needing to specify every exact style.\n *\n * Apple's documentation for these tables is not great, so thanks to the\n * Freetype project for figuring much of this out.\n *\n * @private\n */\nexport default class GlyphVariationProcessor {\n  constructor(font, coords) {\n    this.font = font;\n    this.normalizedCoords = this.normalizeCoords(coords);\n    this.blendVectors = new Map;\n  }\n\n  normalizeCoords(coords) {\n    // the default mapping is linear along each axis, in two segments:\n    // from the minValue to defaultValue, and from defaultValue to maxValue.\n    let normalized = [];\n    for (var i = 0; i < this.font.fvar.axis.length; i++) {\n      let axis = this.font.fvar.axis[i];\n      if (coords[i] < axis.defaultValue) {\n        normalized.push((coords[i] - axis.defaultValue + Number.EPSILON) / (axis.defaultValue - axis.minValue + Number.EPSILON));\n      } else {\n        normalized.push((coords[i] - axis.defaultValue + Number.EPSILON) / (axis.maxValue - axis.defaultValue + Number.EPSILON));\n      }\n    }\n\n    // if there is an avar table, the normalized value is calculated\n    // by interpolating between the two nearest mapped values.\n    if (this.font.avar) {\n      for (var i = 0; i < this.font.avar.segment.length; i++) {\n        let segment = this.font.avar.segment[i];\n        for (let j = 0; j < segment.correspondence.length; j++) {\n          let pair = segment.correspondence[j];\n          if (j >= 1 && normalized[i] < pair.fromCoord) {\n            let prev = segment.correspondence[j - 1];\n            normalized[i] = ((normalized[i] - prev.fromCoord) * (pair.toCoord - prev.toCoord) + Number.EPSILON) /\n              (pair.fromCoord - prev.fromCoord + Number.EPSILON) +\n              prev.toCoord;\n\n            break;\n          }\n        }\n      }\n    }\n\n    return normalized;\n  }\n\n  transformPoints(gid, glyphPoints) {\n    if (!this.font.fvar || !this.font.gvar) { return; }\n\n    let { gvar } = this.font;\n    if (gid >= gvar.glyphCount) { return; }\n\n    let offset = gvar.offsets[gid];\n    if (offset === gvar.offsets[gid + 1]) { return; }\n\n    // Read the gvar data for this glyph\n    let { stream } = this.font;\n    stream.pos = offset;\n    if (stream.pos >= stream.length) {\n      return;\n    }\n\n    let tupleCount = stream.readUInt16BE();\n    let offsetToData = offset + stream.readUInt16BE();\n\n    if (tupleCount & TUPLES_SHARE_POINT_NUMBERS) {\n      var here = stream.pos;\n      stream.pos = offsetToData;\n      var sharedPoints = this.decodePoints();\n      offsetToData = stream.pos;\n      stream.pos = here;\n    }\n\n    let origPoints = glyphPoints.map(pt => pt.copy());\n\n    tupleCount &= TUPLE_COUNT_MASK;\n    for (let i = 0; i < tupleCount; i++) {\n      let tupleDataSize = stream.readUInt16BE();\n      let tupleIndex = stream.readUInt16BE();\n\n      if (tupleIndex & EMBEDDED_TUPLE_COORD) {\n        var tupleCoords = [];\n        for (let a = 0; a < gvar.axisCount; a++) {\n          tupleCoords.push(stream.readInt16BE() / 16384);\n        }\n\n      } else {\n        if ((tupleIndex & TUPLE_INDEX_MASK) >= gvar.globalCoordCount) {\n          throw new Error('Invalid gvar table');\n        }\n\n        var tupleCoords = gvar.globalCoords[tupleIndex & TUPLE_INDEX_MASK];\n      }\n\n      if (tupleIndex & INTERMEDIATE_TUPLE) {\n        var startCoords = [];\n        for (let a = 0; a < gvar.axisCount; a++) {\n          startCoords.push(stream.readInt16BE() / 16384);\n        }\n\n        var endCoords = [];\n        for (let a = 0; a < gvar.axisCount; a++) {\n          endCoords.push(stream.readInt16BE() / 16384);\n        }\n      }\n\n      // Get the factor at which to apply this tuple\n      let factor = this.tupleFactor(tupleIndex, tupleCoords, startCoords, endCoords);\n      if (factor === 0) {\n        offsetToData += tupleDataSize;\n        continue;\n      }\n\n      var here = stream.pos;\n      stream.pos = offsetToData;\n\n      if (tupleIndex & PRIVATE_POINT_NUMBERS) {\n        var points = this.decodePoints();\n      } else {\n        var points = sharedPoints;\n      }\n\n      // points.length = 0 means there are deltas for all points\n      let nPoints = points.length === 0 ? glyphPoints.length : points.length;\n      let xDeltas = this.decodeDeltas(nPoints);\n      let yDeltas = this.decodeDeltas(nPoints);\n\n      if (points.length === 0) { // all points\n        for (let i = 0; i < glyphPoints.length; i++) {\n          var point = glyphPoints[i];\n          point.x += Math.round(xDeltas[i] * factor);\n          point.y += Math.round(yDeltas[i] * factor);\n        }\n      } else {\n        let outPoints = origPoints.map(pt => pt.copy());\n        let hasDelta = glyphPoints.map(() => false);\n\n        for (let i = 0; i < points.length; i++) {\n          let idx = points[i];\n          if (idx < glyphPoints.length) {\n            let point = outPoints[idx];\n            hasDelta[idx] = true;\n\n            point.x += xDeltas[i] * factor;\n            point.y += yDeltas[i] * factor;\n          }\n        }\n\n        this.interpolateMissingDeltas(outPoints, origPoints, hasDelta);\n\n        for (let i = 0; i < glyphPoints.length; i++) {\n          let deltaX = outPoints[i].x - origPoints[i].x;\n          let deltaY = outPoints[i].y - origPoints[i].y;\n\n          glyphPoints[i].x = Math.round(glyphPoints[i].x + deltaX);\n          glyphPoints[i].y = Math.round(glyphPoints[i].y + deltaY);\n        }\n      }\n\n      offsetToData += tupleDataSize;\n      stream.pos = here;\n    }\n  }\n\n  decodePoints() {\n    let stream = this.font.stream;\n    let count = stream.readUInt8();\n\n    if (count & POINTS_ARE_WORDS) {\n      count = (count & POINT_RUN_COUNT_MASK) << 8 | stream.readUInt8();\n    }\n\n    let points = new Uint16Array(count);\n    let i = 0;\n    let point = 0;\n    while (i < count) {\n      let run = stream.readUInt8();\n      let runCount = (run & POINT_RUN_COUNT_MASK) + 1;\n      let fn = run & POINTS_ARE_WORDS ? stream.readUInt16 : stream.readUInt8;\n\n      for (let j = 0; j < runCount && i < count; j++) {\n        point += fn.call(stream);\n        points[i++] = point;\n      }\n    }\n\n    return points;\n  }\n\n  decodeDeltas(count) {\n    let stream = this.font.stream;\n    let i = 0;\n    let deltas = new Int16Array(count);\n\n    while (i < count) {\n      let run = stream.readUInt8();\n      let runCount = (run & DELTA_RUN_COUNT_MASK) + 1;\n\n      if (run & DELTAS_ARE_ZERO) {\n        i += runCount;\n\n      } else {\n        let fn = run & DELTAS_ARE_WORDS ? stream.readInt16BE : stream.readInt8;\n        for (let j = 0; j < runCount && i < count; j++) {\n          deltas[i++] = fn.call(stream);\n        }\n      }\n    }\n\n    return deltas;\n  }\n\n  tupleFactor(tupleIndex, tupleCoords, startCoords, endCoords) {\n    let normalized = this.normalizedCoords;\n    let { gvar } = this.font;\n    let factor = 1;\n\n    for (let i = 0; i < gvar.axisCount; i++) {\n      if (tupleCoords[i] === 0) {\n        continue;\n      }\n\n      if (normalized[i] === 0) {\n        return 0;\n      }\n\n      if ((tupleIndex & INTERMEDIATE_TUPLE) === 0) {\n        if ((normalized[i] < Math.min(0, tupleCoords[i])) ||\n            (normalized[i] > Math.max(0, tupleCoords[i]))) {\n          return 0;\n        }\n\n        factor = (factor * normalized[i] + Number.EPSILON) / (tupleCoords[i] + Number.EPSILON);\n      } else {\n        if ((normalized[i] < startCoords[i]) ||\n            (normalized[i] > endCoords[i])) {\n          return 0;\n\n        } else if (normalized[i] < tupleCoords[i]) {\n          factor = factor * (normalized[i] - startCoords[i] + Number.EPSILON) / (tupleCoords[i] - startCoords[i] + Number.EPSILON);\n\n        } else {\n          factor = factor * (endCoords[i] - normalized[i] + Number.EPSILON) / (endCoords[i] - tupleCoords[i] + Number.EPSILON);\n        }\n      }\n    }\n\n    return factor;\n  }\n\n  // Interpolates points without delta values.\n  // Needed for the  and Q glyphs in Skia.\n  // Algorithm from Freetype.\n  interpolateMissingDeltas(points, inPoints, hasDelta) {\n    if (points.length === 0) {\n      return;\n    }\n\n    let point = 0;\n    while (point < points.length) {\n      let firstPoint = point;\n\n      // find the end point of the contour\n      let endPoint = point;\n      let pt = points[endPoint];\n      while (!pt.endContour) {\n        pt = points[++endPoint];\n      }\n\n      // find the first point that has a delta\n      while (point <= endPoint && !hasDelta[point]) {\n        point++;\n      }\n\n      if (point > endPoint) {\n        continue;\n      }\n\n      let firstDelta = point;\n      let curDelta = point;\n      point++;\n\n      while (point <= endPoint) {\n        // find the next point with a delta, and interpolate intermediate points\n        if (hasDelta[point]) {\n          this.deltaInterpolate(curDelta + 1, point - 1, curDelta, point, inPoints, points);\n          curDelta = point;\n        }\n\n        point++;\n      }\n\n      // shift contour if we only have a single delta\n      if (curDelta === firstDelta) {\n        this.deltaShift(firstPoint, endPoint, curDelta, inPoints, points);\n      } else {\n        // otherwise, handle the remaining points at the end and beginning of the contour\n        this.deltaInterpolate(curDelta + 1, endPoint, curDelta, firstDelta, inPoints, points);\n\n        if (firstDelta > 0) {\n          this.deltaInterpolate(firstPoint, firstDelta - 1, curDelta, firstDelta, inPoints, points);\n        }\n      }\n\n      point = endPoint + 1;\n    }\n  }\n\n  deltaInterpolate(p1, p2, ref1, ref2, inPoints, outPoints) {\n    if (p1 > p2) {\n      return;\n    }\n\n    let iterable = ['x', 'y'];\n    for (let i = 0; i < iterable.length; i++) {\n      let k = iterable[i];\n      if (inPoints[ref1][k] > inPoints[ref2][k]) {\n        var p = ref1;\n        ref1 = ref2;\n        ref2 = p;\n      }\n\n      let in1 = inPoints[ref1][k];\n      let in2 = inPoints[ref2][k];\n      let out1 = outPoints[ref1][k];\n      let out2 = outPoints[ref2][k];\n\n      // If the reference points have the same coordinate but different\n      // delta, inferred delta is zero.  Otherwise interpolate.\n      if (in1 !== in2 || out1 === out2) {\n        let scale = in1 === in2 ? 0 : (out2 - out1) / (in2 - in1);\n\n        for (let p = p1; p <= p2; p++) {\n          let out = inPoints[p][k];\n\n          if (out <= in1) {\n            out += out1 - in1;\n          } else if (out >= in2) {\n            out += out2 - in2;\n          } else {\n            out = out1 + (out - in1) * scale;\n          }\n\n          outPoints[p][k] = out;\n        }\n      }\n    }\n  }\n\n  deltaShift(p1, p2, ref, inPoints, outPoints) {\n    let deltaX = outPoints[ref].x - inPoints[ref].x;\n    let deltaY = outPoints[ref].y - inPoints[ref].y;\n\n    if (deltaX === 0 && deltaY === 0) {\n      return;\n    }\n\n    for (let p = p1; p <= p2; p++) {\n      if (p !== ref) {\n        outPoints[p].x += deltaX;\n        outPoints[p].y += deltaY;\n      }\n    }\n  }\n\n  getAdvanceAdjustment(gid, table) {\n    let outerIndex, innerIndex;\n\n    if (table.advanceWidthMapping) {\n      let idx = gid;\n      if (idx >= table.advanceWidthMapping.mapCount) {\n        idx = table.advanceWidthMapping.mapCount - 1;\n      }\n\n      let entryFormat = table.advanceWidthMapping.entryFormat;\n      ({outerIndex, innerIndex} = table.advanceWidthMapping.mapData[idx]);\n    } else {\n      outerIndex = 0;\n      innerIndex = gid;\n    }\n\n    return this.getDelta(table.itemVariationStore, outerIndex, innerIndex);\n  }\n\n  // See pseudo code from `Font Variations Overview'\n  // in the OpenType specification.\n  getDelta(itemStore, outerIndex, innerIndex) {\n    if (outerIndex >= itemStore.itemVariationData.length) {\n      return 0;\n    }\n\n    let varData = itemStore.itemVariationData[outerIndex];\n    if (innerIndex >= varData.deltaSets.length) {\n      return 0;\n    }\n\n    let deltaSet = varData.deltaSets[innerIndex];\n    let blendVector = this.getBlendVector(itemStore, outerIndex);\n    let netAdjustment = 0;\n\n    for (let master = 0; master < varData.regionIndexCount; master++) {\n      netAdjustment += deltaSet.deltas[master] * blendVector[master];\n    }\n\n    return netAdjustment;\n  }\n\n  getBlendVector(itemStore, outerIndex) {\n    let varData = itemStore.itemVariationData[outerIndex];\n    if (this.blendVectors.has(varData)) {\n      return this.blendVectors.get(varData);\n    }\n\n    let normalizedCoords = this.normalizedCoords;\n    let blendVector = [];\n\n    // outer loop steps through master designs to be blended\n    for (let master = 0; master < varData.regionIndexCount; master++) {\n      let scalar = 1;\n      let regionIndex = varData.regionIndexes[master];\n      let axes = itemStore.variationRegionList.variationRegions[regionIndex];\n\n      // inner loop steps through axes in this region\n      for (let j = 0; j < axes.length; j++) {\n        let axis = axes[j];\n        let axisScalar;\n\n        // compute the scalar contribution of this axis\n        // ignore invalid ranges\n        if (axis.startCoord > axis.peakCoord || axis.peakCoord > axis.endCoord) {\n          axisScalar = 1;\n\n        } else if (axis.startCoord < 0 && axis.endCoord > 0 && axis.peakCoord !== 0) {\n          axisScalar = 1;\n\n        // peak of 0 means ignore this axis\n        } else if (axis.peakCoord === 0) {\n          axisScalar = 1;\n\n        // ignore this region if coords are out of range\n        } else if (normalizedCoords[j] < axis.startCoord || normalizedCoords[j] > axis.endCoord) {\n          axisScalar = 0;\n\n        // calculate a proportional factor\n        } else {\n          if (normalizedCoords[j] === axis.peakCoord) {\n            axisScalar = 1;\n          } else if (normalizedCoords[j] < axis.peakCoord) {\n            axisScalar = (normalizedCoords[j] - axis.startCoord + Number.EPSILON) /\n              (axis.peakCoord - axis.startCoord + Number.EPSILON);\n          } else {\n            axisScalar = (axis.endCoord - normalizedCoords[j] + Number.EPSILON) /\n              (axis.endCoord - axis.peakCoord + Number.EPSILON);\n          }\n        }\n\n        // take product of all the axis scalars\n        scalar *= axisScalar;\n      }\n\n      blendVector[master] = scalar;\n    }\n\n    this.blendVectors.set(varData, blendVector);\n    return blendVector;\n  }\n}\n","import cloneDeep from 'clone';\nimport Subset from './Subset';\nimport Directory from '../tables/directory';\nimport Tables from '../tables';\nimport TTFGlyphEncoder from '../glyph/TTFGlyphEncoder';\n\nexport default class TTFSubset extends Subset {\n  constructor(font) {\n    super(font);\n    this.glyphEncoder = new TTFGlyphEncoder;\n  }\n\n  _addGlyph(gid) {\n    let glyph = this.font.getGlyph(gid);\n    let glyf = glyph._decode();\n\n    // get the offset to the glyph from the loca table\n    let curOffset = this.font.loca.offsets[gid];\n    let nextOffset = this.font.loca.offsets[gid + 1];\n\n    let stream = this.font._getTableStream('glyf');\n    stream.pos += curOffset;\n\n    let buffer = stream.readBuffer(nextOffset - curOffset);\n\n    // if it is a compound glyph, include its components\n    if (glyf && glyf.numberOfContours < 0) {\n      buffer = new Uint8Array(buffer);\n      let view = new DataView(buffer.buffer);\n      for (let component of glyf.components) {\n        gid = this.includeGlyph(component.glyphID);\n        view.setUint16(component.pos, gid);\n      }\n    } else if (glyf && this.font._variationProcessor) {\n      // If this is a TrueType variation glyph, re-encode the path\n      buffer = this.glyphEncoder.encodeSimple(glyph.path, glyf.instructions);\n    }\n\n    this.glyf.push(buffer);\n    this.loca.offsets.push(this.offset);\n\n    this.hmtx.metrics.push({\n      advance: glyph.advanceWidth,\n      bearing: glyph._getMetrics().leftBearing\n    });\n\n    this.offset += buffer.length;\n    return this.glyf.length - 1;\n  }\n\n  encode() {\n    // tables required by PDF spec:\n    //   head, hhea, loca, maxp, cvt , prep, glyf, hmtx, fpgm\n    //\n    // additional tables required for standalone fonts:\n    //   name, cmap, OS/2, post\n\n    this.glyf = [];\n    this.offset = 0;\n    this.loca = {\n      offsets: [],\n      version: this.font.loca.version\n    };\n\n    this.hmtx = {\n      metrics: [],\n      bearings: []\n    };\n\n    // include all the glyphs\n    // not using a for loop because we need to support adding more\n    // glyphs to the array as we go, and CoffeeScript caches the length.\n    let i = 0;\n    while (i < this.glyphs.length) {\n      this._addGlyph(this.glyphs[i++]);\n    }\n\n    let maxp = cloneDeep(this.font.maxp);\n    maxp.numGlyphs = this.glyf.length;\n\n    this.loca.offsets.push(this.offset);\n\n    let head = cloneDeep(this.font.head);\n    head.indexToLocFormat = this.loca.version;\n\n    let hhea = cloneDeep(this.font.hhea);\n    hhea.numberOfMetrics = this.hmtx.metrics.length;\n\n    // map = []\n    // for index in [0...256]\n    //     if index < @numGlyphs\n    //         map[index] = index\n    //     else\n    //         map[index] = 0\n    //\n    // cmapTable =\n    //     version: 0\n    //     length: 262\n    //     language: 0\n    //     codeMap: map\n    //\n    // cmap =\n    //     version: 0\n    //     numSubtables: 1\n    //     tables: [\n    //         platformID: 1\n    //         encodingID: 0\n    //         table: cmapTable\n    //     ]\n\n    // TODO: subset prep, cvt, fpgm?\n    return Directory.toBuffer({\n      tables: {\n        head,\n        hhea,\n        loca: this.loca,\n        maxp,\n        'cvt ': this.font['cvt '],\n        prep: this.font.prep,\n        glyf: this.glyf,\n        hmtx: this.hmtx,\n        fpgm: this.font.fpgm\n\n        // name: clone @font.name\n        // 'OS/2': clone @font['OS/2']\n        // post: clone @font.post\n        // cmap: cmap\n      }\n    });\n  }\n}\n","import * as r from 'restructure';\n\nconst resolved = Promise.resolve();\n\nexport default class Subset {\n  constructor(font) {\n    this.font = font;\n    this.glyphs = [];\n    this.mapping = {};\n\n    // always include the missing glyph\n    this.includeGlyph(0);\n  }\n\n  includeGlyph(glyph) {\n    if (typeof glyph === 'object') {\n      glyph = glyph.id;\n    }\n\n    if (this.mapping[glyph] == null) {\n      this.glyphs.push(glyph);\n      this.mapping[glyph] = this.glyphs.length - 1;\n    }\n\n    return this.mapping[glyph];\n  }\n}\n","import * as r from 'restructure';\n\n// Flags for simple glyphs\nconst ON_CURVE        = 1 << 0;\nconst X_SHORT_VECTOR  = 1 << 1;\nconst Y_SHORT_VECTOR  = 1 << 2;\nconst REPEAT          = 1 << 3;\nconst SAME_X          = 1 << 4;\nconst SAME_Y          = 1 << 5;\n\nclass Point {\n  static size(val) {\n    return val >= 0 && val <= 255 ? 1 : 2;\n  }\n  \n  static encode(stream, value) {\n    if (value >= 0 && value <= 255) {\n      stream.writeUInt8(value);\n    } else {\n      stream.writeInt16BE(value);\n    }\n  }\n}\n\nlet Glyf = new r.Struct({\n  numberOfContours: r.int16, // if negative, this is a composite glyph\n  xMin: r.int16,\n  yMin: r.int16,\n  xMax: r.int16,\n  yMax: r.int16,\n  endPtsOfContours: new r.Array(r.uint16, 'numberOfContours'),\n  instructions: new r.Array(r.uint8, r.uint16),\n  flags: new r.Array(r.uint8, 0),\n  xPoints: new r.Array(Point, 0),\n  yPoints: new r.Array(Point, 0)\n});\n\n/**\n * Encodes TrueType glyph outlines\n */\nexport default class TTFGlyphEncoder {\n  encodeSimple(path, instructions = []) {\n    let endPtsOfContours = [];\n    let xPoints = [];\n    let yPoints = [];\n    let flags = [];\n    let same = 0;\n    let lastX = 0, lastY = 0, lastFlag = 0;\n    let pointCount = 0;\n    \n    for (let i = 0; i < path.commands.length; i++) {\n      let c = path.commands[i];\n      \n      for (let j = 0; j < c.args.length; j += 2) {\n        let x = c.args[j];\n        let y = c.args[j + 1];\n        let flag = 0;\n        \n        // If the ending point of a quadratic curve is the midpoint\n        // between the control point and the control point of the next\n        // quadratic curve, we can omit the ending point.\n        if (c.command === 'quadraticCurveTo' && j === 2) {\n          let next = path.commands[i + 1];\n          if (next && next.command === 'quadraticCurveTo') {\n            let midX = (lastX + next.args[0]) / 2;\n            let midY = (lastY + next.args[1]) / 2;\n            \n            if (x === midX && y === midY) {\n              continue;\n            }\n          }\n        }\n        \n        // All points except control points are on curve.\n        if (!(c.command === 'quadraticCurveTo' && j === 0)) {\n          flag |= ON_CURVE;\n        }\n        \n        flag = this._encodePoint(x, lastX, xPoints, flag, X_SHORT_VECTOR, SAME_X);\n        flag = this._encodePoint(y, lastY, yPoints, flag, Y_SHORT_VECTOR, SAME_Y);\n        \n        if (flag === lastFlag && same < 255) {\n          flags[flags.length - 1] |= REPEAT;\n          same++;\n        } else {\n          if (same > 0) {\n            flags.push(same);\n            same = 0;\n          }\n      \n          flags.push(flag);\n          lastFlag = flag;\n        }\n        \n        lastX = x;\n        lastY = y;\n        pointCount++;\n      }\n  \n      if (c.command === 'closePath') {\n        endPtsOfContours.push(pointCount - 1);\n      }\n    }\n\n    // Close the path if the last command didn't already\n    if (path.commands.length > 1 && path.commands[path.commands.length - 1].command !== 'closePath') {\n      endPtsOfContours.push(pointCount - 1);\n    }\n    \n    let bbox = path.bbox;\n    let glyf = {\n      numberOfContours: endPtsOfContours.length,\n      xMin: bbox.minX,\n      yMin: bbox.minY,\n      xMax: bbox.maxX,\n      yMax: bbox.maxY,\n      endPtsOfContours: endPtsOfContours,\n      instructions: instructions,\n      flags: flags,\n      xPoints: xPoints,\n      yPoints: yPoints\n    };\n    \n    let size = Glyf.size(glyf);\n    let tail = 4 - (size % 4);\n    \n    let stream = new r.EncodeStream(size + tail);\n    Glyf.encode(stream, glyf);\n    \n    // Align to 4-byte length\n    if (tail !== 0) {\n      stream.fill(0, tail);\n    }\n    \n    return stream.buffer;\n  }\n  \n  _encodePoint(value, last, points, flag, shortFlag, sameFlag) {\n    let diff = value - last;\n    \n    if (value === last) {\n      flag |= sameFlag;\n    } else {\n      if (-255 <= diff && diff <= 255) {\n        flag |= shortFlag;\n        if (diff < 0) {\n          diff = -diff;\n        } else {\n          flag |= sameFlag;\n        }\n      }\n      \n      points.push(diff);\n    }\n    \n    return flag;\n  }\n}\n","import Subset from './Subset';\nimport CFFTop from '../cff/CFFTop';\nimport CFFPrivateDict from '../cff/CFFPrivateDict';\nimport standardStrings from '../cff/CFFStandardStrings';\n\nexport default class CFFSubset extends Subset {\n  constructor(font) {\n    super(font);\n\n    this.cff = this.font['CFF '];\n    if (!this.cff) {\n      throw new Error('Not a CFF Font');\n    }\n  }\n\n  subsetCharstrings() {\n    this.charstrings = [];\n    let gsubrs = {};\n\n    for (let gid of this.glyphs) {\n      this.charstrings.push(this.cff.getCharString(gid));\n\n      let glyph = this.font.getGlyph(gid);\n      let path = glyph.path; // this causes the glyph to be parsed\n\n      for (let subr in glyph._usedGsubrs) {\n        gsubrs[subr] = true;\n      }\n    }\n\n    this.gsubrs = this.subsetSubrs(this.cff.globalSubrIndex, gsubrs);\n  }\n\n  subsetSubrs(subrs, used) {\n    let res = [];\n    for (let i = 0; i < subrs.length; i++) {\n      let subr = subrs[i];\n      if (used[i]) {\n        this.cff.stream.pos = subr.offset;\n        res.push(this.cff.stream.readBuffer(subr.length));\n      } else {\n        res.push(new Uint8Array([11])); // return\n      }\n    }\n\n    return res;\n  }\n\n  subsetFontdict(topDict) {\n    topDict.FDArray = [];\n    topDict.FDSelect = {\n      version: 0,\n      fds: []\n    };\n\n    let used_fds = {};\n    let used_subrs = [];\n    let fd_select = {};\n    for (let gid of this.glyphs) {\n      let fd = this.cff.fdForGlyph(gid);\n      if (fd == null) {\n        continue;\n      }\n\n      if (!used_fds[fd]) {\n        topDict.FDArray.push(Object.assign({}, this.cff.topDict.FDArray[fd]));\n        used_subrs.push({});\n        fd_select[fd] = topDict.FDArray.length - 1;\n      }\n\n      used_fds[fd] = true;\n      topDict.FDSelect.fds.push(fd_select[fd]);\n\n      let glyph = this.font.getGlyph(gid);\n      let path = glyph.path; // this causes the glyph to be parsed\n      for (let subr in glyph._usedSubrs) {\n        used_subrs[fd_select[fd]][subr] = true;\n      }\n    }\n\n    for (let i = 0; i < topDict.FDArray.length; i++) {\n      let dict = topDict.FDArray[i];\n      delete dict.FontName;\n      if (dict.Private && dict.Private.Subrs) {\n        dict.Private = Object.assign({}, dict.Private);\n        dict.Private.Subrs = this.subsetSubrs(dict.Private.Subrs, used_subrs[i]);\n      }\n    }\n\n    return;\n  }\n\n  createCIDFontdict(topDict) {\n    let used_subrs = {};\n    for (let gid of this.glyphs) {\n      let glyph = this.font.getGlyph(gid);\n      let path = glyph.path; // this causes the glyph to be parsed\n\n      for (let subr in glyph._usedSubrs) {\n        used_subrs[subr] = true;\n      }\n    }\n\n    let privateDict = Object.assign({}, this.cff.topDict.Private);\n    if (this.cff.topDict.Private && this.cff.topDict.Private.Subrs) {\n      privateDict.Subrs = this.subsetSubrs(this.cff.topDict.Private.Subrs, used_subrs);\n    }\n\n    topDict.FDArray = [{ Private: privateDict }];\n    return topDict.FDSelect = {\n      version: 3,\n      nRanges: 1,\n      ranges: [{ first: 0, fd: 0 }],\n      sentinel: this.charstrings.length\n    };\n  }\n\n  addString(string) {\n    if (!string) {\n      return null;\n    }\n\n    if (!this.strings) {\n      this.strings = [];\n    }\n\n    this.strings.push(string);\n    return standardStrings.length + this.strings.length - 1;\n  }\n\n  encode() {\n    this.subsetCharstrings();\n\n    let charset = {\n      version: this.charstrings.length > 255 ? 2 : 1,\n      ranges: [{ first: 1, nLeft: this.charstrings.length - 2 }]\n    };\n\n    let topDict = Object.assign({}, this.cff.topDict);\n    topDict.Private = null;\n    topDict.charset = charset;\n    topDict.Encoding = null;\n    topDict.CharStrings = this.charstrings;\n\n    for (let key of ['version', 'Notice', 'Copyright', 'FullName', 'FamilyName', 'Weight', 'PostScript', 'BaseFontName', 'FontName']) {\n      topDict[key] = this.addString(this.cff.string(topDict[key]));\n    }\n\n    topDict.ROS = [this.addString('Adobe'), this.addString('Identity'), 0];\n    topDict.CIDCount = this.charstrings.length;\n\n    if (this.cff.isCIDFont) {\n      this.subsetFontdict(topDict);\n    } else {\n      this.createCIDFontdict(topDict);\n    }\n\n    let top = {\n      version: 1,\n      hdrSize: this.cff.hdrSize,\n      offSize: 4,\n      header: this.cff.header,\n      nameIndex: [this.cff.postscriptName],\n      topDictIndex: [topDict],\n      stringIndex: this.strings,\n      globalSubrIndex: this.gsubrs\n    };\n\n    return CFFTop.toBuffer(top);\n  }\n}\n","import TTFFont from './TTFFont';\nimport WOFFDirectory from './tables/WOFFDirectory';\nimport tables from './tables';\nimport inflate from 'tiny-inflate';\nimport * as r from 'restructure';\nimport { asciiDecoder } from './utils';\n\nexport default class WOFFFont extends TTFFont {\n  type = 'WOFF';\n\n  static probe(buffer) {\n    return asciiDecoder.decode(buffer.slice(0, 4)) === 'wOFF';\n  }\n\n  _decodeDirectory() {\n    this.directory = WOFFDirectory.decode(this.stream, { _startOffset: 0 });\n  }\n\n  _getTableStream(tag) {\n    let table = this.directory.tables[tag];\n    if (table) {\n      this.stream.pos = table.offset;\n\n      if (table.compLength < table.length) {\n        this.stream.pos += 2; // skip deflate header\n        let outBuffer = new Uint8Array(table.length);\n        let buf = inflate(this.stream.readBuffer(table.compLength - 2), outBuffer);\n        return new r.DecodeStream(buf);\n      } else {\n        return this.stream;\n      }\n    }\n\n    return null;\n  }\n}\n","import * as r from 'restructure';\nimport tables from './';\n\nlet WOFFDirectoryEntry = new r.Struct({\n  tag:          new r.String(4),\n  offset:       new r.Pointer(r.uint32, 'void', {type: 'global'}),\n  compLength:   r.uint32,\n  length:       r.uint32,\n  origChecksum: r.uint32\n});\n\nlet WOFFDirectory = new r.Struct({\n  tag:            new r.String(4), // should be 'wOFF'\n  flavor:         r.uint32,\n  length:         r.uint32,\n  numTables:      r.uint16,\n  reserved:       new r.Reserved(r.uint16),\n  totalSfntSize:  r.uint32,\n  majorVersion:   r.uint16,\n  minorVersion:   r.uint16,\n  metaOffset:     r.uint32,\n  metaLength:     r.uint32,\n  metaOrigLength: r.uint32,\n  privOffset:     r.uint32,\n  privLength:     r.uint32,\n  tables:         new r.Array(WOFFDirectoryEntry, 'numTables')\n});\n\nWOFFDirectory.process = function() {\n  let tables = {};\n  for (let table of this.tables) {\n    tables[table.tag] = table;\n  }\n\n  this.tables = tables;\n};\n\nexport default WOFFDirectory;\n","import * as r from 'restructure';\nimport brotli from 'brotli/decompress.js';\nimport TTFFont from './TTFFont';\nimport TTFGlyph, { Point } from './glyph/TTFGlyph';\nimport WOFF2Glyph from './glyph/WOFF2Glyph';\nimport WOFF2Directory from './tables/WOFF2Directory';\nimport { asciiDecoder } from './utils';\n\n/**\n * Subclass of TTFFont that represents a TTF/OTF font compressed by WOFF2\n * See spec here: http://www.w3.org/TR/WOFF2/\n */\nexport default class WOFF2Font extends TTFFont {\n  type = 'WOFF2';\n\n  static probe(buffer) {\n    return asciiDecoder.decode(buffer.slice(0, 4)) === 'wOF2';\n  }\n\n  _decodeDirectory() {\n    this.directory = WOFF2Directory.decode(this.stream);\n    this._dataPos = this.stream.pos;\n  }\n\n  _decompress() {\n    // decompress data and setup table offsets if we haven't already\n    if (!this._decompressed) {\n      this.stream.pos = this._dataPos;\n      let buffer = this.stream.readBuffer(this.directory.totalCompressedSize);\n\n      let decompressedSize = 0;\n      for (let tag in this.directory.tables) {\n        let entry = this.directory.tables[tag];\n        entry.offset = decompressedSize;\n        decompressedSize += (entry.transformLength != null) ? entry.transformLength : entry.length;\n      }\n\n      let decompressed = brotli(buffer, decompressedSize);\n      if (!decompressed) {\n        throw new Error('Error decoding compressed data in WOFF2');\n      }\n\n      this.stream = new r.DecodeStream(decompressed);\n      this._decompressed = true;\n    }\n  }\n\n  _decodeTable(table) {\n    this._decompress();\n    return super._decodeTable(table);\n  }\n\n  // Override this method to get a glyph and return our\n  // custom subclass if there is a glyf table.\n  _getBaseGlyph(glyph, characters = []) {\n    if (!this._glyphs[glyph]) {\n      if (this.directory.tables.glyf && this.directory.tables.glyf.transformed) {\n        if (!this._transformedGlyphs) { this._transformGlyfTable(); }\n        return this._glyphs[glyph] = new WOFF2Glyph(glyph, characters, this);\n\n      } else {\n        return super._getBaseGlyph(glyph, characters);\n      }\n    }\n  }\n\n  _transformGlyfTable() {\n    this._decompress();\n    this.stream.pos = this.directory.tables.glyf.offset;\n    let table = GlyfTable.decode(this.stream);\n    let glyphs = [];\n\n    for (let index = 0; index < table.numGlyphs; index++) {\n      let glyph = {};\n      let nContours = table.nContours.readInt16BE();\n      glyph.numberOfContours = nContours;\n\n      if (nContours > 0) { // simple glyph\n        let nPoints = [];\n        let totalPoints = 0;\n\n        for (let i = 0; i < nContours; i++) {\n          let r = read255UInt16(table.nPoints);\n          totalPoints += r;\n          nPoints.push(totalPoints);\n        }\n\n        glyph.points = decodeTriplet(table.flags, table.glyphs, totalPoints);\n        for (let i = 0; i < nContours; i++) {\n          glyph.points[nPoints[i] - 1].endContour = true;\n        }\n\n        var instructionSize = read255UInt16(table.glyphs);\n\n      } else if (nContours < 0) { // composite glyph\n        let haveInstructions = TTFGlyph.prototype._decodeComposite.call({ _font: this }, glyph, table.composites);\n        if (haveInstructions) {\n          var instructionSize = read255UInt16(table.glyphs);\n        }\n      }\n\n      glyphs.push(glyph);\n    }\n\n    this._transformedGlyphs = glyphs;\n  }\n}\n\n// Special class that accepts a length and returns a sub-stream for that data\nclass Substream {\n  constructor(length) {\n    this.length = length;\n    this._buf = new r.Buffer(length);\n  }\n\n  decode(stream, parent) {\n    return new r.DecodeStream(this._buf.decode(stream, parent));\n  }\n}\n\n// This struct represents the entire glyf table\nlet GlyfTable = new r.Struct({\n  version: r.uint32,\n  numGlyphs: r.uint16,\n  indexFormat: r.uint16,\n  nContourStreamSize: r.uint32,\n  nPointsStreamSize: r.uint32,\n  flagStreamSize: r.uint32,\n  glyphStreamSize: r.uint32,\n  compositeStreamSize: r.uint32,\n  bboxStreamSize: r.uint32,\n  instructionStreamSize: r.uint32,\n  nContours: new Substream('nContourStreamSize'),\n  nPoints: new Substream('nPointsStreamSize'),\n  flags: new Substream('flagStreamSize'),\n  glyphs: new Substream('glyphStreamSize'),\n  composites: new Substream('compositeStreamSize'),\n  bboxes: new Substream('bboxStreamSize'),\n  instructions: new Substream('instructionStreamSize')\n});\n\nconst WORD_CODE = 253;\nconst ONE_MORE_BYTE_CODE2 = 254;\nconst ONE_MORE_BYTE_CODE1 = 255;\nconst LOWEST_U_CODE = 253;\n\nfunction read255UInt16(stream) {\n  let code = stream.readUInt8();\n\n  if (code === WORD_CODE) {\n    return stream.readUInt16BE();\n  }\n\n  if (code === ONE_MORE_BYTE_CODE1) {\n    return stream.readUInt8() + LOWEST_U_CODE;\n  }\n\n  if (code === ONE_MORE_BYTE_CODE2) {\n    return stream.readUInt8() + LOWEST_U_CODE * 2;\n  }\n\n  return code;\n}\n\nfunction withSign(flag, baseval) {\n  return flag & 1 ? baseval : -baseval;\n}\n\nfunction decodeTriplet(flags, glyphs, nPoints) {\n  let y;\n  let x = y = 0;\n  let res = [];\n\n  for (let i = 0; i < nPoints; i++) {\n    let dx = 0, dy = 0;\n    let flag = flags.readUInt8();\n    let onCurve = !(flag >> 7);\n    flag &= 0x7f;\n\n    if (flag < 10) {\n      dx = 0;\n      dy = withSign(flag, ((flag & 14) << 7) + glyphs.readUInt8());\n\n    } else if (flag < 20) {\n      dx = withSign(flag, (((flag - 10) & 14) << 7) + glyphs.readUInt8());\n      dy = 0;\n\n    } else if (flag < 84) {\n      var b0 = flag - 20;\n      var b1 = glyphs.readUInt8();\n      dx = withSign(flag, 1 + (b0 & 0x30) + (b1 >> 4));\n      dy = withSign(flag >> 1, 1 + ((b0 & 0x0c) << 2) + (b1 & 0x0f));\n\n    } else if (flag < 120) {\n      var b0 = flag - 84;\n      dx = withSign(flag, 1 + ((b0 / 12) << 8) + glyphs.readUInt8());\n      dy = withSign(flag >> 1, 1 + (((b0 % 12) >> 2) << 8) + glyphs.readUInt8());\n\n    } else if (flag < 124) {\n      var b1 = glyphs.readUInt8();\n      let b2 = glyphs.readUInt8();\n      dx = withSign(flag, (b1 << 4) + (b2 >> 4));\n      dy = withSign(flag >> 1, ((b2 & 0x0f) << 8) + glyphs.readUInt8());\n\n    } else {\n      dx = withSign(flag, glyphs.readUInt16BE());\n      dy = withSign(flag >> 1, glyphs.readUInt16BE());\n    }\n\n    x += dx;\n    y += dy;\n    res.push(new Point(onCurve, false, x, y));\n  }\n\n  return res;\n}\n","import TTFGlyph from './TTFGlyph';\n\n/**\n * Represents a TrueType glyph in the WOFF2 format, which compresses glyphs differently.\n */\nexport default class WOFF2Glyph extends TTFGlyph {\n  type = 'WOFF2';\n\n  _decode() {\n    // We have to decode in advance (in WOFF2Font), so just return the pre-decoded data.\n    return this._font._transformedGlyphs[this.id];\n  }\n\n  _getCBox() {\n    return this.path.bbox;\n  }\n}\n","import * as r from 'restructure';\n\nconst Base128 = {\n  decode(stream) {\n    let result = 0;\n    let iterable = [0, 1, 2, 3, 4];\n    for (let j = 0; j < iterable.length; j++) {\n      let i = iterable[j];\n      let code = stream.readUInt8();\n\n      // If any of the top seven bits are set then we're about to overflow.\n      if (result & 0xe0000000) {\n        throw new Error('Overflow');\n      }\n\n      result = (result << 7) | (code & 0x7f);\n      if ((code & 0x80) === 0) {\n        return result;\n      }\n    }\n\n    throw new Error('Bad base 128 number');\n  }\n};\n\nlet knownTags = [\n  'cmap', 'head', 'hhea', 'hmtx', 'maxp', 'name', 'OS/2', 'post', 'cvt ',\n  'fpgm', 'glyf', 'loca', 'prep', 'CFF ', 'VORG', 'EBDT', 'EBLC', 'gasp',\n  'hdmx', 'kern', 'LTSH', 'PCLT', 'VDMX', 'vhea', 'vmtx', 'BASE', 'GDEF',\n  'GPOS', 'GSUB', 'EBSC', 'JSTF', 'MATH', 'CBDT', 'CBLC', 'COLR', 'CPAL',\n  'SVG ', 'sbix', 'acnt', 'avar', 'bdat', 'bloc', 'bsln', 'cvar', 'fdsc',\n  'feat', 'fmtx', 'fvar', 'gvar', 'hsty', 'just', 'lcar', 'mort', 'morx',\n  'opbd', 'prop', 'trak', 'Zapf', 'Silf', 'Glat', 'Gloc', 'Feat', 'Sill'\n];\n\nlet WOFF2DirectoryEntry = new r.Struct({\n  flags: r.uint8,\n  customTag: new r.Optional(new r.String(4), t => (t.flags & 0x3f) === 0x3f),\n  tag: t => t.customTag || knownTags[t.flags & 0x3f],// || (() => { throw new Error(`Bad tag: ${flags & 0x3f}`); })(); },\n  length: Base128,\n  transformVersion: t => (t.flags >>> 6) & 0x03,\n  transformed: t => (t.tag === 'glyf' || t.tag === 'loca') ? t.transformVersion === 0 : t.transformVersion !== 0,\n  transformLength: new r.Optional(Base128, t => t.transformed)\n});\n\nlet WOFF2Directory = new r.Struct({\n  tag: new r.String(4), // should be 'wOF2'\n  flavor: r.uint32,\n  length: r.uint32,\n  numTables: r.uint16,\n  reserved: new r.Reserved(r.uint16),\n  totalSfntSize: r.uint32,\n  totalCompressedSize: r.uint32,\n  majorVersion: r.uint16,\n  minorVersion: r.uint16,\n  metaOffset: r.uint32,\n  metaLength: r.uint32,\n  metaOrigLength: r.uint32,\n  privOffset: r.uint32,\n  privLength: r.uint32,\n  tables: new r.Array(WOFF2DirectoryEntry, 'numTables')\n});\n\nWOFF2Directory.process = function() {\n  let tables = {};\n  for (let i = 0; i < this.tables.length; i++) {\n    let table = this.tables[i];\n    tables[table.tag] = table;\n  }\n\n  return this.tables = tables;\n};\n\nexport default WOFF2Directory;\n","import * as r from 'restructure';\nimport TTFFont from './TTFFont';\nimport Directory from './tables/directory';\nimport tables from './tables';\nimport { asciiDecoder } from './utils';\n\nlet TTCHeader = new r.VersionedStruct(r.uint32, {\n  0x00010000: {\n    numFonts:   r.uint32,\n    offsets:    new r.Array(r.uint32, 'numFonts')\n  },\n  0x00020000: {\n    numFonts:   r.uint32,\n    offsets:    new r.Array(r.uint32, 'numFonts'),\n    dsigTag:    r.uint32,\n    dsigLength: r.uint32,\n    dsigOffset: r.uint32\n  }\n});\n\nexport default class TrueTypeCollection {\n  type = 'TTC';\n\n  static probe(buffer) {\n    return asciiDecoder.decode(buffer.slice(0, 4)) === 'ttcf';\n  }\n\n  constructor(stream) {\n    this.stream = stream;\n    if (stream.readString(4) !== 'ttcf') {\n      throw new Error('Not a TrueType collection');\n    }\n\n    this.header = TTCHeader.decode(stream);\n  }\n\n  getFont(name) {\n    for (let offset of this.header.offsets) {\n      let stream = new r.DecodeStream(this.stream.buffer);\n      stream.pos = offset;\n      let font = new TTFFont(stream);\n      if (\n        font.postscriptName === name ||\n        (\n          font.postscriptName instanceof Uint8Array && \n          name instanceof Uint8Array && \n          font.postscriptName.every((v, i) => name[i] === v)\n        )\n      ) {\n        return font;\n      }\n    }\n\n    return null;\n  }\n\n  get fonts() {\n    let fonts = [];\n    for (let offset of this.header.offsets) {\n      let stream = new r.DecodeStream(this.stream.buffer);\n      stream.pos = offset;\n      fonts.push(new TTFFont(stream));\n    }\n\n    return fonts;\n  }\n}\n","import * as r from 'restructure';\nimport TTFFont from './TTFFont';\n\nlet DFontName = new r.String(r.uint8);\nlet DFontData = new r.Struct({\n  len: r.uint32,\n  buf: new r.Buffer('len')\n});\n\nlet Ref = new r.Struct({\n  id: r.uint16,\n  nameOffset: r.int16,\n  attr: r.uint8,\n  dataOffset: r.uint24,\n  handle: r.uint32\n});\n\nlet Type = new r.Struct({\n  name: new r.String(4),\n  maxTypeIndex: r.uint16,\n  refList: new r.Pointer(r.uint16, new r.Array(Ref, t => t.maxTypeIndex + 1), { type: 'parent' })\n});\n\nlet TypeList = new r.Struct({\n  length: r.uint16,\n  types: new r.Array(Type, t => t.length + 1)\n});\n\nlet DFontMap = new r.Struct({\n  reserved: new r.Reserved(r.uint8, 24),\n  typeList: new r.Pointer(r.uint16, TypeList),\n  nameListOffset: new r.Pointer(r.uint16, 'void')\n});\n\nlet DFontHeader = new r.Struct({\n  dataOffset: r.uint32,\n  map: new r.Pointer(r.uint32, DFontMap),\n  dataLength: r.uint32,\n  mapLength: r.uint32\n});\n\nexport default class DFont {\n  type = 'DFont';\n\n  static probe(buffer) {\n    let stream = new r.DecodeStream(buffer);\n\n    try {\n      var header = DFontHeader.decode(stream);\n    } catch (e) {\n      return false;\n    }\n\n    for (let type of header.map.typeList.types) {\n      if (type.name === 'sfnt') {\n        return true;\n      }\n    }\n\n    return false;\n  }\n\n  constructor(stream) {\n    this.stream = stream;\n    this.header = DFontHeader.decode(this.stream);\n\n    for (let type of this.header.map.typeList.types) {\n      for (let ref of type.refList) {\n        if (ref.nameOffset >= 0) {\n          this.stream.pos = ref.nameOffset + this.header.map.nameListOffset;\n          ref.name = DFontName.decode(this.stream);\n        } else {\n          ref.name = null;\n        }\n      }\n\n      if (type.name === 'sfnt') {\n        this.sfnt = type;\n      }\n    }\n  }\n\n  getFont(name) {\n    if (!this.sfnt) {\n      return null;\n    }\n\n    for (let ref of this.sfnt.refList) {\n      let pos = this.header.dataOffset + ref.dataOffset + 4;\n      let stream = new r.DecodeStream(this.stream.buffer.slice(pos));\n      let font = new TTFFont(stream);\n      if (\n        font.postscriptName === name ||\n        (\n          font.postscriptName instanceof Uint8Array && \n          name instanceof Uint8Array && \n          font.postscriptName.every((v, i) => name[i] === v)\n        )\n      ) {\n        return font;\n      }\n    }\n\n    return null;\n  }\n\n  get fonts() {\n    let fonts = [];\n    for (let ref of this.sfnt.refList) {\n      let pos = this.header.dataOffset + ref.dataOffset + 4;\n      let stream = new r.DecodeStream(this.stream.buffer.slice(pos));\n      fonts.push(new TTFFont(stream));\n    }\n\n    return fonts;\n  }\n}\n"],"mappings":"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AAQ;EAAe,QAAQ;EACvE,QAAQ;EAAY,QAAQ;EAAY,QAAQ;EAAe,QAAQ;EACvE,QAAQ;EAAY,QAAQ;EAAY,QAAQ;EAAe,QAAQ;EACvE,QAAQ;EAAY,QAAQ;EAAY,QAAQ;EAAe,QAAQ;EACvE,QAAQ;EAAY,QAAQ;EAAY,QAAQ;EAAe,QAAQ;EACvE,QAAQ;EAAY,QAAQ;EAAY,QAAQ;EAAe,QAAQ;EACvE,QAAQ;EAAY,QAAQ;EAAY,QAAQ;EAAe,QAAQ;EACvE,QAAQ;EAAY,QAAQ;EAAY,QAAQ;EAAe,QAAQ;EACvE,QAAQ;EAAY,QAAQ;EAAY,QAAQ;EAAe,QAAQ;EACvE,QAAQ;EAAY,QAAQ;EAAY,QAAQ;EAAe,QAAQ;EACvE,QAAQ;EAAY,QAAQ;EAAY,QAAQ;EAAe,QAAQ;EACvE,QAAQ;EAAY,QAAQ;EAAY,QAAQ;EAAe,QAAQ;EACvE,QAAQ;EAAY,QAAQ;EAAY,QAAQ;EAAe,QAAQ;EACvE,QAAQ;EAAY,QAAQ;EAAY,QAAQ;EAAe,QAAQ;EACvE,QAAQ;EAAY,QAAQ;EAAY,QAAQ;EAAe,QAAQ;EACvE,QAAQ;EAAY,QAAQ;EAAY,QAAQ;EAAe,QAAQ;EACvE,QAAQ;EAAY,QAAQ;EAAY,QAAQ;EAAe,QAAQ;EACvE,QAAQ;EAAY,QAAQ;EAAY,QAAQ;EAAe,QAAQ;EACvE,QAAQ;EAAY,QAAQ;EAAY,QAAQ;EAAe,QAAQ;EACvE,QAAQ;EAAY,QAAQ;EAAY,QAAQ;EAAe,QAAQ;EACvE,QAAQ;EAAY,QAAQ;EAAY,QAAQ;EAAe,QAAQ;EACvE,QAAQ;EAAY,QAAQ;EAAY,QAAQ;EAAe,QAAQ;EACvE,QAAQ;EAAY,QAAQ;EAAY,QAAQ;EAAe,QAAQ;EACvE,QAAQ;EAAY,QAAQ;EAAY,QAAQ;EAAe,QAAQ;EACvE,QAAQ;EAAY,QAAQ;EAAY,QAAQ;EAAe,QAAQ;EACvE,QAAQ;EAAY,QAAQ;EAAY,QAAQ;EAAe,QAAQ;EACvE,QAAQ;EAAY,QAAQ;EAAY,QAAQ;EAAe,QAAQ;EACvE,QAAQ;EAAY,QAAQ;EAAY,QAAQ;EAAe,QAAQ;EACvE,QAAQ;EAAY,QAAQ;EAAY,QAAQ;EAAe,QAAQ;EACvE,QAAQ;EAAY,QAAQ;EAAY,QAAQ;EAAe,QA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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}